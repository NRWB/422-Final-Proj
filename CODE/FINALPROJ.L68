00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/28/2014 10:03:31 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000                            51  
00000000                            52  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            53  
00001000                            54  START:  ORG    $1000            * first instruction of program
00001000                            55  
00001000                            56  * -----------------------------------
00001000                            57  * Starting and Ending Addresses
00001000                            58  * -----------------------------------
00001000                            59  
00001000                            60  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            61  
00001000                            62  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001854             63          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 64          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      65          TRAP    #15             * Perform #14
0000100C                            66          
0000100C                            67  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 68          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      69          TRAP    #15             * Perform #15
00001012                            70          
00001012                            71  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      72          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            73  
00001014                            74  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 0000186C             75          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 76          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      77          TRAP    #15             * Perform #14
00001020                            78          
00001020                            79  * GETS THE ENDING ADDRESS
00001020  103C 0004                 80          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      81          TRAP    #15             * Perform Trap #4
00001026  2A01                      82          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001882             83          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            84          
0000102E  3E3C 000F                 85          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 86          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0806                 87          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            88          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            89          
0000103A                            90  LOOP    
0000103A                            91          
0000103A                            92          * MOVE.W  #BITMASK,D2     * Load the bitmask into data register D2
0000103A  3F06                      93          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                      94          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                      95          AND.W   D2,D6           * Apply this bitmask
00001040                            96          
00001040  BC7C 1000                 97          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001044  6600 000A                 98          BNE     NOT0001            * No, check next case
00001048  6100 018E                 99          BSR     OP0001          * Branch to subroutine 0001
0000104C  6000 0016                100          BRA     ITERATION       * Move to next iteration of the loop
00001050                           101  NOT0001       
00001050  BC7C 4000                102          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001054  6600 000A                103          BNE     NEXT            * No, check next case
00001058  6100 01E6                104          BSR     OP0100          * Branch to subroutine 0100
0000105C  6000 0006                105          BRA     ITERATION       * Move to next iteration of the loop
00001060                           106          
00001060                           107  NEXT
00001060  6100 07B2                108          BSR     UNKNOWNOP
00001064                           109          
00001064                           110  ITERATION
00001064  3C1F                     111          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001066                           112  
00001066                           113          *MOVE.B  #14,D0          * Print a newline
00001066                           114          *TRAP    #15             * Perform Trap #14
00001066                           115  
00001066  BA4A                     116          CMP     A2,D5           * Compare the starting address to ending address
00001068  6700 2FB2                117          BEQ     END             * If they are equal, branch 
0000106C  60CC                     118          BRA     LOOP            * Otherwise, branch back to LOOP
0000106E                           119  
0000106E                           120  * --- OP 0000 ------------------------------------------
0000106E                           121  * FUNCTIONS     BCLR, ORI, CMPI
0000106E                           122  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask. 
0000106E                           123  * ADDR REG        
0000106E                           124  * POST COND     All registers return to their previous state.
0000106E                           125  * ------------------------------------------------------
0000106E                           126  OP0000
0000106E  48A7 C0C0                127          MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
00001072  3C3C 0006                128          MOVE.W  #6, D6              * Prep lower value for bitmask
00001076  3E3C 0008                129          MOVE.W  #8, D7              * Prep upper value for bitmask
0000107A  6100 07C2                130          BSR     BITMASK             * Finalize bitmask setup
0000107E  CC42                     131          AND     D2,D6               * Apply bitmask
00001080                           132          
00001080  0C46 0180                133          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001084  6600 0012                134          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
00001088                           135          
00001088  43F9 000018A5            136          LEA     BCLROP,A1           * We found BCLR
0000108E  103C 000E                137          MOVE.B  #14,D0              * Trap #14 prints out the data
00001092  4E4F                     138          TRAP    #15                 * Perform Trap #14
00001094  6000 013C                139          BRA     END0000              * Found the op, move to next iteration
00001098                           140  
00001098                           141  NOTBCLR * Possible options left are ORI or CMPI
00001098  3C3C 0009                142          MOVE.W  #9, D6              * Prep lower value for bitmask
0000109C  3E3C 000B                143          MOVE.W  #11, D7             * Prep upper value for bitmask
000010A0  6100 079C                144          BSR     BITMASK             * Finalize bitmask setup
000010A4  CC42                     145          AND     D2,D6               * Apply bitmask
000010A6                           146          
000010A6  0C46 0000                147          CMPI    #%0000000000000000, D6  * Are we ORI?
000010AA  6700 000E                148          BEQ     ISORI                   * If ORI, branch to ISORI
000010AE                           149          
000010AE  0C46 0C00                150          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
000010B2  6700 0006                151          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
000010B6                           152          
000010B6  6600 075C                153          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
000010BA                           154                                          * We don't deal too kindly with imposters.
000010BA                           155          
000010BA                           156  ISORI   * TODO
000010BA                           157          
000010BA                           158  
000010BA                           159  ISCMPI
000010BA  43F9 000018AE            160          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000010C0  103C 000E                161          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000010C4  4E4F                     162          TRAP    #15                 * Perform Trap #14
000010C6                           163          
000010C6                           164          * Determine the Size
000010C6  3C3C 0006                165          MOVE.W  #6, D6              * Prep lower value for bitmask
000010CA  3E3C 0007                166          MOVE.W  #7, D7              * Prep upper value for bitmask
000010CE  6100 076E                167          BSR     BITMASK             * Finalize bitmask setup
000010D2  CC42                     168          AND     D2,D6               * Apply bitmask
000010D4                           169          
000010D4  0C46 00C0                170          CMPI    #%0000000011000000, D6  * Imposter Op
000010D8  6700 073A                171          BEQ     UNKNOWNOP               * Deal with the imposter
000010DC                           172          
000010DC  0C46 0000                173          CMPI    #%0000000000000000, D6  * The size is a BYTE
000010E0  6700 0012                174          BEQ     CMPIBYTE                * Branch to CMPI.B
000010E4                           175          
000010E4  0C46 0040                176          CMPI    #%0000000001000000, D6  * The size is a WORD
000010E8  6700 0032                177          BEQ     CMPIWORD                * Branch to CMPI.W
000010EC                           178          
000010EC  0C46 0080                179          CMPI    #%0000000010000000, D6  * The size is a LONG
000010F0  6700 0050                180          BEQ     CMPILONG                * Branch to CMPI.L
000010F4                           181          
000010F4                           182  CMPIBYTE
000010F4  43F9 000018E3            183          LEA     __B, A1     * Load .B
000010FA  103C 000E                184          MOVE.B  #14, D0     * Print out data
000010FE  4E4F                     185          TRAP    #15         * Perform Trap #14
00001100                           186          
00001100  43F9 000018D7            187          LEA     IMD, A1     * Load #
00001106  103C 000E                188          MOVE.B  #14, D0     * Print out data
0000110A  4E4F                     189          TRAP    #15         * Perform Trap #14
0000110C                           190          
0000110C  361A                     191          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000110E  1203                     192          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
00001110  3622                     193          MOVE.W  -(A2),D3    * Now go back
00001112  103C 000E                194          MOVE.B  #14, D0     * Print out the data
00001116  4E4F                     195          TRAP    #15         * Perform Trap #14 
00001118                           196          
00001118  6000 004E                197          BRA     CMPIEA      * Branch to determine Effective Address
0000111C                           198          
0000111C                           199  CMPIWORD
0000111C  43F9 000018E7            200          LEA     __W, A1     * Load .W
00001122  103C 000E                201          MOVE.B  #14, D0     * Print out data
00001126  4E4F                     202          TRAP    #15         * Perform Trap #14
00001128                           203          
00001128  43F9 000018D7            204          LEA     IMD, A1     * Load #
0000112E  103C 000E                205          MOVE.B  #14, D0     * Print out data
00001132  4E4F                     206          TRAP    #15         * Perform Trap #14
00001134                           207          
00001134  361A                     208          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001136  3222                     209          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
00001138  103C 000E                210          MOVE.B  #14, D0     * Print out the data
0000113C  4E4F                     211          TRAP    #15         * Perform Trap #14
0000113E                           212          
0000113E                           213          
0000113E  6000 0028                214          BRA     CMPIEA      * Branch to determine Effective Address
00001142                           215          
00001142                           216  CMPILONG
00001142  43F9 000018EB            217          LEA     __L, A1     * Load .L
00001148  103C 000E                218          MOVE.B  #14, D0     * Print out data
0000114C  4E4F                     219          TRAP    #15         * Perform Trap #14
0000114E                           220          
0000114E  43F9 000018D7            221          LEA     IMD, A1     * Load #
00001154  103C 000E                222          MOVE.B  #14, D0     * Print out data
00001158  4E4F                     223          TRAP    #15         * Perform Trap #14
0000115A                           224          
0000115A  361A                     225          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000115C  2222                     226          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
0000115E  103C 000E                227          MOVE.B  #14, D0     * Print out the data
00001162  4E4F                     228          TRAP    #15         * Perform Trap #14
00001164                           229          
00001164  6000 0002                230          BRA     CMPIEA      * Branch to determine Effective Address
00001168                           231          
00001168                           232  CMPIEA
00001168                           233          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
00001168  43F9 000018D9            234          LEA     COMMA, A1   * Load ,
0000116E  103C 000E                235          MOVE.B  #14, D0     * Print out data
00001172  4E4F                     236          TRAP    #15         * Perform Trap #14
00001174                           237          
00001174  43F9 000018EB            238          LEA     __L, A1     * Load .L
0000117A  103C 000E                239          MOVE.B  #14, D0     * Print out data
0000117E  4E4F                     240          TRAP    #15         * Perform Trap #14
00001180                           241          
00001180                           242          * Determine the mode
00001180  3C3C 0003                243          MOVE.W  #3, D6              * Prep lower value for bitmask
00001184  3E3C 0005                244          MOVE.W  #5, D7              * Prep upper value for bitmask
00001188  6100 06B4                245          BSR     BITMASK             * Finalize bitmask setup
0000118C  CC42                     246          AND     D2,D6               * Apply bitmask
0000118E                           247          
0000118E  0C46 0008                248          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
00001192  6700 0680                249          BEQ     UNKNOWNOP               * Imposter op
00001196                           250          
00001196  0C46 0028                251          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
0000119A  6700 0678                252          BEQ     UNKNOWNOP               * Imposter op
0000119E                           253          
0000119E  0C46 0030                254          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
000011A2  6700 0670                255          BEQ     UNKNOWNOP               * Imposter op
000011A6                           256  
000011A6  0C46 0038                257          CMPI    #%0000000000111000, D6  * Is the Mode 111?
000011AA  6700 0008                258          BEQ     CMPIREG                 * Further investigation is needed
000011AE                           259          
000011AE                           260          * will need to call the EA helpers when they are complete
000011AE                           261          
000011AE                           262          * Mode is verified to be valid at this point
000011AE                           263          *CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
000011AE                           264          *BSR     MODE_DN
000011AE                           265          
000011AE                           266          *CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
000011AE                           267          *BSR     MODE_AN
000011AE                           268          
000011AE                           269          *CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
000011AE                           270          *BSR     MODE_IAN_POS
000011AE                           271          
000011AE                           272          *CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
000011AE                           273          *BSR     MODE_IAN_PRE
000011AE                           274          
000011AE                           275          * Reached End of CMPI. Everything has been printed out
000011AE  4C9F 0303                276          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000011B2  4E75                     277          RTS
000011B4                           278          
000011B4                           279  CMPIREG
000011B4  3C3C 0000                280          MOVE.W  #0, D6              * Prep lower value for bitmask
000011B8  3E3C 0002                281          MOVE.W  #2, D7              * Prep upper value for bitmask
000011BC  6100 0680                282          BSR     BITMASK             * Finalize bitmask setup
000011C0  CC42                     283          AND     D2,D6               * Apply bitmask
000011C2                           284          
000011C2  0C46 0000                285          CMPI    #%0000000000000000, D6  * Is the Register 000?
000011C6  6700 0010                286          BEQ     CMPIREG000
000011CA                           287          
000011CA  0C46 0001                288          CMPI    #%0000000000000001, D6  * Is the Register 001?
000011CE  6700 0008                289          BEQ     CMPIREG001
000011D2                           290  END0000          
000011D2                           291  
000011D2  4C9F 0303                292         MOVEM   (A7)+,D0-D1/A0-A1   * Push values to the stack to save
000011D6  4E75                     293         RTS
000011D8                           294  CMPIREG000  * TODO (xxx).W for CMPI
000011D8                           295  
000011D8                           296  CMPIREG001  * TODO (xxx).L for CMPI
000011D8                           297          
000011D8                           298  
000011D8                           299  
000011D8                           300  * --- OP 0001 ------------------------------------------
000011D8                           301  * FUNCTIONS     MOVE.B
000011D8                           302  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000011D8                           303  * ADDR REG        
000011D8                           304  * POST COND     All registers return to their previous state.
000011D8                           305  * ------------------------------------------------------
000011D8                           306  OP0001  
000011D8  48A7 FFC0                307          MOVEM   D0-D7/A0-A1,-(A7)  * Push vales onto stack
000011DC  3C3C 0006                308          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E0  3E3C 0008                309          MOVE.W  #8, D7              * Prep upper value for bitmask
000011E4  6100 0658                310          BSR     BITMASK             * Finalize bitmask setup
000011E8  CC42                     311          AND     D2,D6               * Apply bitmask
000011EA                           312          
000011EA                           313          * I may have fucked off this part, sorry - Caleb
000011EA                           314          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
000011EA                           315          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
000011EA                           316          
000011EA  43F9 0000188D            317          LEA     MOVEOP,A1   * Put 'MOVE' into the window
000011F0  103C 000E                318          MOVE.B  #14,D0      * Trap #14 to print out
000011F4  4E4F                     319          TRAP    #15         * Perform Trap #14
000011F6                           320          
000011F6  6100 0556                321          BSR     SIZE67
000011FA  6100 0254                322          BSR     EAHELPER05
000011FE                           323          
000011FE  43F9 000018D9            324          LEA     COMMA,A1
00001204  103C 000E                325          MOVE.B  #14,D0
00001208  4E4F                     326          TRAP    #15
0000120A                           327          
0000120A  6100 0210                328          BSR     EAHELPER611
0000120E                           329          
0000120E  43F9 00001882            330          LEA     NEWLINE,A1
00001214  103C 000E                331          MOVE.B  #14,D0
00001218  4E4F                     332          TRAP    #15
0000121A                           333          
0000121A  6000 0006                334          BRA     ENDOP0001
0000121E                           335          *LEA     __B,A1      * Put '.B' into the window
0000121E                           336          *MOVE.B  #14,D0      * Trap #14 to print out
0000121E                           337          *TRAP    #15         * Perform Trap #14
0000121E                           338          
0000121E                           339  UNKNOWNOP0001
0000121E                           340  
0000121E  6100 05F4                341          BSR     UNKNOWNOP
00001222                           342          
00001222                           343  ENDOP0001
00001222                           344  
00001222  4C9F 03FF                345          MOVEM (A7)+,D0-D7/A0-A1
00001226  4E75                     346          RTS        
00001228                           347          
00001228                           348          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
00001228                           349  
00001228                           350  * --- OP 0010 ------------------------------------------
00001228                           351  * FUNCTIONS     MOVE.L, MOVEA.L,
00001228                           352  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001228                           353  * ADDR REG        
00001228                           354  * POST COND     All registers return to their previous state.
00001228                           355  * ------------------------------------------------------
00001228                           356  OP0010  
00001228                           357  
00001228                           358  
00001228                           359  * --- OP 0011 ------------------------------------------
00001228                           360  * FUNCTIONS     MOVE.W, MOVEA.W
00001228                           361  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001228                           362  * ADDR REG        
00001228                           363  * POST COND     All registers return to their previous state.
00001228                           364  * ------------------------------------------------------
00001228                           365  OP0011
00001228  48A7 FFFE                366      MOVEM   D0-D7/A0-A6, -(A7)
0000122C                           367      
0000122C  3C3C 0006                368      MOVE.W  #6,D6
00001230  3E3C 0008                369      MOVE.W  #8,D7
00001234                           370      
00001234  6100 0608                371      BSR     BITMASK
00001238                           372      
00001238  CC42                     373      AND.W   D2,D6
0000123A                           374      
0000123A  BC7C 0040                375      CMP     #%0000000001000000,D6
0000123E                           376      *BNE     NEXT15
0000123E  61FE                     377      BSR     * for MOVEA.W
00001240                           378  
00001240                           379  
00001240                           380  * --- OP 0100 ------------------------------------------
00001240                           381  * FUNCTIONS     NO_OP, MOVEM, LEA, NEG, JSR, RTS
00001240                           382  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001240                           383  * ADDR REG        
00001240                           384  * POST COND     All registers return to their previous state.
00001240                           385  * ------------------------------------------------------
00001240                           386  OP0100  * TODO: lea, movem, neg?
00001240                           387  
00001240  48A7 C0C0                388          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001244                           389          
00001244                           390          *NOP
00001244  0C42 4E71                391          CMPI    #%0100111001110001,D2
00001248  6600 0012                392          BNE     NOTNOP
0000124C                           393          
0000124C  43F9 00001885            394          LEA     NOOPERATION,A1
00001252  103C 000D                395          MOVE.B  #13,D0          * Print a newline
00001256  4E4F                     396          TRAP    #15
00001258                           397          
00001258  6000 0108                398          BRA     DONE *we found it, move on to the next iteration
0000125C                           399  NOTNOP *NEG
0000125C                           400          
0000125C                           401          * prep values for BITMASK subroutine
0000125C  7C08                     402          MOVE.L  #8,D6
0000125E  7E0B                     403          MOVE.L  #11,D7
00001260                           404          
00001260  6100 05DC                405          BSR     BITMASK
00001264                           406          
00001264  CC42                     407          AND     D2,D6                   * apply bitmask
00001266                           408          
00001266  0C46 0400                409          CMPI    #%0000010000000000,D6   * are we NEG?
0000126A  6600 0046                410          BNE     NOTNEG                  * not neg
0000126E                           411          
0000126E  7C03                     412          MOVE.L  #3,D6
00001270  7E05                     413          MOVE.L  #5,D7
00001272                           414          
00001272  6100 05CA                415          BSR     BITMASK * generate a bitmask to be used to check mode
00001276                           416          
00001276  0C46 0008                417          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
0000127A  6700 00E2                418          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000127E                           419          
0000127E  0C46 0028                420          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001282  6700 00DA                421          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001286                           422          
00001286  0C46 0030                423          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000128A  6700 00D2                424          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000128E                           425        
0000128E                           426          * it is NEG, print
0000128E  43F9 00001889            427          LEA     NEGOP,A1
00001294  103C 000E                428          MOVE.B  #14,D0
00001298  4E4F                     429          TRAP    #15
0000129A                           430          
0000129A  6100 04B2                431          BSR     SIZE67
0000129E                           432          
0000129E  6100 01B0                433          BSR     EAHELPER05
000012A2                           434          
000012A2  43F9 00001882            435          LEA     NEWLINE,A1
000012A8  103C 000E                436          MOVE.B  #14,D0
000012AC  4E4F                     437          TRAP    #15
000012AE                           438          
000012AE  6000 00B2                439          BRA     DONE * we found the op, move to next iteration
000012B2                           440          
000012B2                           441  NOTNEG *MOVEM
000012B2                           442  
000012B2                           443          * prep values for BITMASK subroutine
000012B2  7C07                     444          MOVE.L  #7,D6
000012B4  7E09                     445          MOVE.L  #9,D7
000012B6                           446          
000012B6  6100 0586                447          BSR     BITMASK
000012BA                           448          
000012BA  CC42                     449          AND     D2,D6   * apply bitmask
000012BC                           450          
000012BC  0C46 0080                451          CMPI    #%0000000010000000,D6 * is it MOVEM?
000012C0  6600 0014                452          BNE     NOTMOVEM          * it is not MOVEM
000012C4                           453          
000012C4                           454          * make sure it is a valid size and mode for MOVEM
000012C4                           455          
000012C4                           456          * it is MOVEM
000012C4  43F9 00001892            457          LEA     MOVEMOP,A1
000012CA  103C 000D                458          MOVE.B  #13,D0          * Print a newline
000012CE  4E4F                     459          TRAP    #15
000012D0                           460          
000012D0                           461          * probably needs its own special code for printing the rest due to uniqueness of movem
000012D0                           462          
000012D0  341A                     463          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000012D2                           464          
000012D2  6000 008E                465          BRA     DONE          * we found and printed, move on to the next iteration
000012D6                           466          
000012D6                           467  NOTMOVEM *JSR
000012D6                           468          * prep values for BITMASK subroutine
000012D6  7C06                     469          MOVE.L  #6,D6
000012D8  7E08                     470          MOVE.L  #8,D7
000012DA                           471          
000012DA  6100 0562                472          BSR     BITMASK
000012DE                           473          
000012DE  CC42                     474          AND     D2,D6   * apply bitmask
000012E0                           475          
000012E0  0C46 0080                476          CMPI    #%0000000010000000,D6
000012E4  6600 0032                477          BNE     NOTJSR          * it's not JSR
000012E8                           478          
000012E8  43F9 00001898            479          LEA     JSROP,A1
000012EE  103C 000E                480          MOVE.B  #14,D0          * Print a newline and JSR
000012F2  4E4F                     481          TRAP    #15
000012F4                           482          
000012F4                           483          * print out where we are jumping to
000012F4                           484          
000012F4  341A                     485          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000012F6                           486          
000012F6  2202                     487          MOVE.L  D2,D1   * save the opcode to print
000012F8                           488          
000012F8  7410                     489          MOVE.L  #16,D2  * set the base to 16
000012FA                           490          
000012FA  700F                     491          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000012FC  4E4F                     492          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000012FE                           493          
000012FE  341A                     494          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001300                           495          
00001300  2202                     496          MOVE.L  D2,D1   * save the opcode to print
00001302                           497          
00001302  7410                     498          MOVE.L  #16,D2  * set the base to 16
00001304                           499          
00001304  700F                     500          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001306  4E4F                     501          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001308                           502          
00001308  43F9 00001882            503          LEA     NEWLINE,A1
0000130E  103C 000E                504          MOVE.B  #14,D0          * Print a newline
00001312  4E4F                     505          TRAP    #15
00001314                           506          
00001314  6000 004C                507          BRA     DONE          * we already found instruction, next iteration
00001318                           508  NOTJSR *RTS
00001318                           509  
00001318                           510          * prep values for BITMASK subroutine
00001318  7C06                     511          MOVE.L  #6,D6
0000131A  7E08                     512          MOVE.L  #8,D7
0000131C                           513          
0000131C  6100 0520                514          BSR     BITMASK
00001320                           515          
00001320  CC42                     516          AND     D2,D6   * apply bitmask
00001322                           517          
00001322  0C46 0040                518          CMPI    #%0000000001000000,D6
00001326  6600 0012                519          BNE     NOTRTS          * it's not RTS
0000132A                           520          
0000132A  43F9 0000189D            521          LEA     RTSOP,A1
00001330  103C 000D                522          MOVE.B  #13,D0          * Print a newline and RTS
00001334  4E4F                     523          TRAP    #15
00001336                           524          
00001336  6000 002A                525          BRA     DONE          * we already found instruction, next iteration
0000133A                           526  NOTRTS  *LEA
0000133A                           527         
0000133A                           528          * prep values for BITMASK subroutine
0000133A  7C06                     529          MOVE.L  #6,D6
0000133C  7E08                     530          MOVE.L  #8,D7
0000133E                           531          
0000133E  6100 04FE                532          BSR     BITMASK
00001342                           533          
00001342  CC42                     534          AND     D2,D6   * apply bitmask
00001344                           535          
00001344  0C46 01C0                536          CMPI    #%0000000111000000,D6
00001348  6600 0014                537          BNE     UNKNOWN          * it's not LEA, we dont know what it is
0000134C                           538          
0000134C                           539          * check to make sure it is a supported mode and size
0000134C                           540          
0000134C  43F9 000018A1            541          LEA     LEAOP,A1
00001352  103C 000D                542          MOVE.B  #13,D0          * Print LEA
00001356  4E4F                     543          TRAP    #15
00001358                           544          
00001358                           545          * call EA helper
00001358  341A                     546          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000135A                           547                  
0000135A  6000 0006                548          BRA     DONE          * we already found instruction, next iteration
0000135E                           549          
0000135E                           550  UNKNOWN *dont know what it is
0000135E  6100 04B4                551          BSR     UNKNOWNOP
00001362                           552          
00001362                           553  DONE
00001362  4C9F 0303                554          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001366  4E75                     555          RTS
00001368                           556          
00001368                           557          
00001368                           558          
00001368                           559  
00001368                           560  * --- OP 0101 ------------------------------------------
00001368                           561  * FUNCTIONS     SUBQ
00001368                           562  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001368                           563  * ADDR REG        
00001368                           564  * POST COND     All registers return to their previous state.
00001368                           565  * ------------------------------------------------------
00001368                           566  OP0101
00001368                           567  * testing branching
00001368                           568  * op op op
00001368                           569  
00001368                           570  
00001368                           571  
00001368                           572  * --- OP 0110 ------------------------------------------
00001368                           573  * FUNCTIONS     BCC, BCS, BGE, BLT, BVC, BRA
00001368                           574  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001368                           575  * ADDR REG        
00001368                           576  * POST COND     All registers return to their previous state.
00001368                           577  * ------------------------------------------------------
00001368                           578  * --- OP 0110 ------------------------------------------
00001368                           579  * FUNCTIONS     BCC, BCS, BGE, BLT, BVC, BRA
00001368                           580  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001368                           581  * ADDR REG      A1 - Printing
00001368                           582  * POST COND     All registers return to their previous state.
00001368                           583  * Description: Determine the opcode given 0110 from matching cases.
00001368                           584  *              Use additional word/long offset if specified to align memory evenly.
00001368                           585  *              Perform 2's compliment on label, then output result.
00001368                           586  *              - Conditions Table
00001368                           587  *                Condition Names  - Mnemonic - Condition Code
00001368                           588  *                --------------------------------------------
00001368                           589  *                True             -    T     - 0000
00001368                           590  *                False            -    F     - 0001
00001368                           591  *                Higher           -    HI    - 0010
00001368                           592  *                Lower or Same    -    LS    - 0011
00001368                           593  *                Carry Clear      -    CC    - 0100
00001368                           594  *                Carry Set        -    CS    - 0101
00001368                           595  *                Not Equal        -    NE    - 0110
00001368                           596  *                Equal            -    EQ    - 0111
00001368                           597  *                Overflow Clear   -    VC    - 1000
00001368                           598  *                Overflow Set     -    VS    - 1001
00001368                           599  *                Plus             -    PL    - 1010
00001368                           600  *                Minus            -    MI    - 1011
00001368                           601  *                Greater or Equal -    GE    - 1100
00001368                           602  *                Less Than        -    LT    - 1101
00001368                           603  *                Greater Than     -    GT    - 1110
00001368                           604  *                Less or Equal    -    LE    - 1111
00001368                           605  * ------------------------------------------------------
00001368                           606  OP0110
00001368  48A7 C0C0                607          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
0000136C                           608          
0000136C                           609          * Ready four bits to help distinguish op's with the 0110 prefix
0000136C  3C3C 0000                610          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
00001370                           611                                        * BITMASK sub-routine call)
00001370  3E3C 0007                612          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001374                           613                                        * BITMASK sub-routine call)
00001374                           614                                        
00001374                           615          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001374  6100 04C8                616          BSR     BITMASK               * Call BITMASK sub-routine
00001378                           617                                        * Returns a bitmask in D6
00001378                           618          
00001378  CC42                     619          AND     D2,D6                 * And the index op, which was pre-loaded
0000137A                           620                                        * in the main memory loop with the bitmask
0000137A                           621                                        * to use to determine what case we need.
0000137A                           622          
0000137A                           623          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
0000137A                           624          * $00 == word offset, $FF == long offset
0000137A                           625       ***CMPI    #%0000000000000000,D6
0000137A                           626       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
0000137A                           627       ***
0000137A                           628       ***CMPI    #%0000000011111111,D6
0000137A                           629       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
0000137A                           630          
0000137A                           631          * IF PASSED BOTH CMPI CHECKS (ABOVE),
0000137A                           632          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
0000137A                           633          
0000137A  3C3C 0009                634          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
0000137E  3E3C 000B                635          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
00001382                           636                                        
00001382                           637          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001382  6100 04BA                638          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
00001386  CC42                     639          AND     D2,D6   * apply the BITMASK
00001388                           640          
00001388                           641          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001388  0C46 0400                642          CMPI    #%0000010000000000,D6
0000138C  6700 002A                643          BEQ     OP_BCC
00001390                           644          
00001390                           645          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
00001390  0C46 0500                646          CMPI    #%0000010100000000,D6
00001394  6700 002C                647          BEQ     OP_BCS
00001398                           648          
00001398                           649          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001398  0C46 0C00                650          CMPI    #%0000110000000000,D6
0000139C  6700 002E                651          BEQ     OP_BGE
000013A0                           652          
000013A0                           653          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
000013A0  0C46 0D00                654          CMPI    #%0000110100000000,D6
000013A4  6700 0030                655          BEQ     OP_BLT
000013A8                           656          
000013A8                           657          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
000013A8  0C46 0800                658          CMPI    #%0000100000000000,D6
000013AC  6700 0032                659          BEQ     OP_BVC
000013B0                           660          
000013B0                           661          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
000013B0                           662          * NOTE: A branch to the immediately following instruction automatically
000013B0                           663          *       uses the 16-bit displacement format because the 8-bit displacement
000013B0                           664          *       field contains $00 zero offset
000013B0                           665          * http://68k.hax.com/BRA
000013B0                           666          * NOTE2 ---> Does this mean, there should be no checks when debugging
000013B0                           667          *            for word/long offsets?
000013B0  0C46 0000                668          CMPI    #%0000000000000000,D6
000013B4  6700 0034                669          BEQ     OP_BRA
000013B8                           670          
000013B8                           671          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
000013B8                           672          ; call raw data print out sub routine
000013B8                           673  
000013B8                           674  OP_BCC
000013B8  43F9 000018BB            675          LEA     OP_BCC_MSG,A1
000013BE  6000 0034                676          BRA     OP_BRANCHES_PRINT
000013C2                           677  OP_BCS
000013C2  43F9 000018BF            678          LEA     OP_BCS_MSG,A1
000013C8  6000 002A                679          BRA     OP_BRANCHES_PRINT
000013CC                           680  OP_BGE
000013CC  43F9 000018C3            681          LEA     OP_BGE_MSG,A1
000013D2  6000 0020                682          BRA     OP_BRANCHES_PRINT
000013D6                           683  OP_BLT
000013D6  43F9 000018C7            684          LEA     OP_BLT_MSG,A1
000013DC  6000 0016                685          BRA     OP_BRANCHES_PRINT
000013E0                           686  OP_BVC
000013E0  43F9 000018CB            687          LEA     OP_BVC_MSG,A1
000013E6  6000 000C                688          BRA     OP_BRANCHES_PRINT
000013EA                           689  OP_BRA
000013EA  43F9 000018CF            690          LEA     OP_BRA_MSG,A1
000013F0  6000 0002                691          BRA     OP_BRANCHES_PRINT
000013F4                           692  
000013F4                           693  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000013F4                           694          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000013F4                           695          * assemble output to console
000013F4                           696  OP_BRANCHES_PRINT
000013F4  103C 000E                697          MOVE.B  #14,D0 * print instruction op
000013F8  4E4F                     698          TRAP    #15
000013FA                           699          
000013FA  43F9 000018B3            700          LEA     DATA,A1
00001400  103C 000E                701          MOVE.B  #14,D0 * print raw data hex of the LABEL
00001404  4E4F                     702          TRAP    #15
00001406                           703          
00001406  1A1A                     704          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
00001408  2845                     705          MOVE.L  D5,A4 * ready the 8bits into a4
0000140A  43D4                     706          LEA     (A4),A1 * ready the a4 into a1 for print
0000140C  103C 000E                707          MOVE.B  #14,D0 * print the 8bit addr
00001410  4E4F                     708          TRAP    #15
00001412                           709  
00001412  6000 0002                710          BRA     BCC_END
00001416                           711  
00001416                           712  BCC_END * reload the memory, call RTS
00001416  4C9F 0303                713          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
0000141A  4E75                     714          RTS
0000141C                           715          
0000141C                           716  * --- OP 0111 ------------------------------------------
0000141C                           717  * FUNCTIONS     
0000141C                           718  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
0000141C                           719  * ADDR REG        
0000141C                           720  * POST COND     All registers return to their previous state.
0000141C                           721  * ------------------------------------------------------
0000141C                           722  OP0111
0000141C                           723  
0000141C                           724  
0000141C                           725  
0000141C                           726  * --- OP 1000 ------------------------------------------
0000141C                           727  * FUNCTIONS     DIVS, OR
0000141C                           728  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
0000141C                           729  * ADDR REG        
0000141C                           730  * POST COND     All registers return to their previous state.
0000141C                           731  * ------------------------------------------------------
0000141C                           732  OP1000
0000141C                           733  
0000141C                           734  
0000141C                           735  
0000141C                           736  * --- OP 1001 ------------------------------------------
0000141C                           737  * FUNCTIONS     SUB
0000141C                           738  * DATA REG      D0, D1 for output. D2 for entire instruction. D6 for bitmask.
0000141C                           739  * ADDR REG        
0000141C                           740  * POST COND     All registers return to their previous state.
0000141C                           741  * ------------------------------------------------------
0000141C                           742  OP1001
0000141C                           743  
0000141C                           744  
0000141C                           745  
0000141C                           746  * --- OP 1010 ------------------------------------------
0000141C                           747  * FUNCTIONS     
0000141C                           748  * DATA REG      D0, D1 for output. D2 for entire instruction. D6 for bitmask.
0000141C                           749  * ADDR REG        
0000141C                           750  * POST COND     All registers return to their previous state.
0000141C                           751  * ------------------------------------------------------
0000141C                           752  OP1010
0000141C                           753  
0000141C                           754  
0000141C                           755  * --- OP 1011 ------------------------------------------
0000141C                           756  * FUNCTIONS     EOR, CMP 
0000141C                           757  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
0000141C                           758  * ADDR REG        
0000141C                           759  * POST COND     All registers return to their previous state.
0000141C                           760  * ------------------------------------------------------
0000141C                           761  OP1011
0000141C                           762  
0000141C                           763  
0000141C                           764  * --- OP 1100 ------------------------------------------
0000141C                           765  * FUNCTIONS     MULS
0000141C                           766  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
0000141C                           767  * ADDR REG        
0000141C                           768  * POST COND     All registers return to their previous state.
0000141C                           769  * ------------------------------------------------------
0000141C                           770  OP1100
0000141C                           771  
0000141C                           772  
0000141C                           773  
0000141C                           774  * --- OP 1101 ------------------------------------------
0000141C                           775  * FUNCTIONS     ADD, ADDA,
0000141C                           776  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
0000141C                           777  * ADDR REG        
0000141C                           778  * POST COND     All registers return to their previous state.
0000141C                           779  * ------------------------------------------------------
0000141C                           780  OP1101
0000141C                           781  
0000141C                           782  
0000141C                           783  
0000141C                           784  * --- OP 1110 ------------------------------------------
0000141C                           785  * FUNCTIONS     LSL, LSR, ASL, ASR, ROL, ROR, 
0000141C                           786  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
0000141C                           787  * ADDR REG        
0000141C                           788  * POST COND     All registers return to their previous state.
0000141C                           789  * ------------------------------------------------------
0000141C                           790  OP1110
0000141C                           791  
0000141C                           792  
0000141C                           793  
0000141C                           794  
0000141C                           795  * --- OP 1111 ------------------------------------------
0000141C                           796  * FUNCTIONS     
0000141C                           797  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
0000141C                           798  * ADDR REG        
0000141C                           799  * POST COND     All registers return to their previous state.
0000141C                           800  * ------------------------------------------------------
0000141C                           801  OP1111
0000141C                           802  
0000141C                           803  
0000141C                           804  
0000141C                           805  * --- EAHELPER611 ----------------------------------------
0000141C                           806  * PRE  COND     D2 contains the instruction we wish to 
0000141C                           807  *               print the modes, registers for.
0000141C                           808  * POST COND     Determines mode, passes D2 to EAHELPER05 to print
0000141C                           809  * ------------------------------------------------------
0000141C                           810  EAHELPER611
0000141C  48A7 FFC0                811      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
00001420                           812      
00001420                           813      * to move the mode where EAHELPER50 can process it
00001420  7C06                     814      MOVE.L  #6,D6   *prep registers to create bitmask
00001422  7E08                     815      MOVE.L  #8,D7
00001424                           816      
00001424  6100 0418                817      BSR     BITMASK * create bitmask
00001428                           818      
00001428  CC42                     819      AND     D2,D6   * apply bitmask
0000142A                           820      
0000142A  4243                     821      CLR     D3      * prep D3 to store values
0000142C                           822      
0000142C  3606                     823      MOVE.W  D6,D3   * store bitmasked value in D3
0000142E                           824      
0000142E  E64B                     825      LSR     #3,D3   * move bits 6-8 to 3-5
00001430                           826      
00001430                           827      * to move the register where EAHELPER50 can process it
00001430  7C09                     828      MOVE.L  #9,D6   *prep registers to create bitmask
00001432  7E0B                     829      MOVE.L  #11,D7
00001434                           830      
00001434  6100 0408                831      BSR     BITMASK * create bitmask
00001438                           832      
00001438  CC42                     833      AND     D2,D6   * apply bitmask
0000143A                           834      
0000143A  4244                     835      CLR     D4      * prep D3 to store values
0000143C                           836      
0000143C  3806                     837      MOVE.W  D6,D4   * store bitmasked value in D3
0000143E                           838      
0000143E  E04C                     839      LSR     #8,D4   * move bits 9-11 to 0-2
00001440  E24C                     840      LSR     #1,D4   * move bits 9-11 to 0-2
00001442                           841      
00001442  8684                     842      OR.L    D4,D3   * combind the register and mode
00001444                           843      
00001444  2403                     844      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
00001446                           845      
00001446  6100 0008                846      BSR     EAHELPER05
0000144A                           847      
0000144A  4C9F 03FF                848      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
0000144E                           849      
0000144E  4E75                     850      RTS
00001450                           851      
00001450                           852  * --- EAHELPER05 ----------------------------------------
00001450                           853  * PRE  COND     D2 contains the instruction we wish to 
00001450                           854  *               print the modes, registers for.
00001450                           855  *               Only call this helper for operations that only
00001450                           856  *               have one mode, register.
00001450                           857  * POST COND     Determines mode, passes D2 to REGHELPER to print
00001450                           858  * ------------------------------------------------------
00001450                           859  *todo: add code for printing immediate values
00001450                           860  EAHELPER05
00001450                           861      
00001450  48A7 FFC0                862      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001454                           863      
00001454  7C03                     864      MOVE.L  #3,D6
00001456  7E05                     865      MOVE.L  #5,D7
00001458                           866      
00001458  6100 03E4                867      BSR     BITMASK * generate a bitmask to identify the mode
0000145C                           868      
0000145C  CC42                     869      AND     D2,D6   * mask off the parts of D2 we don't need
0000145E                           870      
0000145E  2A06                     871      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
00001460                           872      
00001460  0C46 0000                873      CMPI    #%0000000000000000,D6 * is it data register direct?
00001464  6600 000A                874      BNE     NOTDATAREG
00001468                           875      
00001468  6100 00E4                876      BSR     MODE_DN
0000146C                           877       
0000146C  6000 00DA                878      BRA     ENDEAHELPER05
00001470                           879      
00001470                           880  NOTDATAREG * address register direct
00001470                           881      
00001470  0C46 0008                882      CMPI    #%0000000000001000,D6 * is it address register direct?
00001474  6600 000A                883      BNE     NOTADRDIRECT
00001478                           884      
00001478  6100 01D4                885      BSR     MODE_AN * simply prints out the address register
0000147C                           886       
0000147C  6000 00CA                887      BRA     ENDEAHELPER05
00001480                           888      
00001480                           889  NOTADRDIRECT * address register indirect
00001480                           890          
00001480  0C46 0010                891      CMPI    #%0000000000010000,D6 * is it address register indirect?
00001484  6600 0022                892      BNE     NOTADRINDIRECT
00001488                           893      
00001488  43F9 000018DB            894      LEA     OBRACK,A1       * Load '('
0000148E  303C 000E                895      MOVE.W  #14,D0          * Trap #14 to display message
00001492  4E4F                     896      TRAP    #15             * Perform #14
00001494                           897          
00001494                           898  
00001494  6100 01B8                899      BSR     MODE_AN * print out an address register
00001498                           900      
00001498  43F9 000018DD            901      LEA     CBRACK,A1       * Load ')'
0000149E  303C 000E                902      MOVE.W  #14,D0          * Trap #14 to display message
000014A2  4E4F                     903      TRAP    #15             * Perform #14
000014A4                           904       
000014A4  6000 00A2                905      BRA     ENDEAHELPER05
000014A8                           906      
000014A8                           907  NOTADRINDIRECT * address register indirect, post increment
000014A8                           908      
000014A8  0C46 0018                909      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
000014AC  6600 002E                910      BNE     NOTADRINDIRECTPOST
000014B0                           911      
000014B0  43F9 000018DB            912      LEA     OBRACK,A1       * Load '('
000014B6  303C 000E                913      MOVE.W  #14,D0          * Trap #14 to display message
000014BA  4E4F                     914      TRAP    #15             * Perform #14
000014BC                           915          
000014BC                           916  
000014BC  6100 0190                917      BSR     MODE_AN * print out an address register
000014C0                           918      
000014C0  43F9 000018DD            919      LEA     CBRACK,A1       * Load ')'
000014C6  303C 000E                920      MOVE.W  #14,D0          * Trap #14 to display message
000014CA  4E4F                     921      TRAP    #15             * Perform #14
000014CC                           922      
000014CC  43F9 000018DF            923      LEA     PLUS,A1       * Load '+'
000014D2  303C 000E                924      MOVE.W  #14,D0          * Trap #14 to display message
000014D6  4E4F                     925      TRAP    #15             * Perform #14
000014D8                           926       
000014D8  6000 006E                927      BRA     ENDEAHELPER05
000014DC                           928      
000014DC                           929  NOTADRINDIRECTPOST * address register indirect, pre decrement
000014DC                           930      
000014DC  0C46 0020                931      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
000014E0  6600 002E                932      BNE     NOTADRINDIRECTPRE
000014E4                           933      
000014E4  43F9 000018E1            934      LEA     MINUS,A1       * Load '-'
000014EA  303C 000E                935      MOVE.W  #14,D0          * Trap #14 to display message
000014EE  4E4F                     936      TRAP    #15             * Perform #14
000014F0                           937      
000014F0  43F9 000018DB            938      LEA     OBRACK,A1       * Load '('
000014F6  303C 000E                939      MOVE.W  #14,D0          * Trap #14 to display message
000014FA  4E4F                     940      TRAP    #15             * Perform #14
000014FC                           941          
000014FC                           942  
000014FC  6100 0150                943      BSR     MODE_AN * print out an address register
00001500                           944      
00001500  43F9 000018DD            945      LEA     CBRACK,A1       * Load ')'
00001506  303C 000E                946      MOVE.W  #14,D0          * Trap #14 to display message
0000150A  4E4F                     947      TRAP    #15             * Perform #14
0000150C                           948       
0000150C  6000 003A                949      BRA     ENDEAHELPER05
00001510                           950      
00001510                           951  NOTADRINDIRECTPRE * immediate
00001510                           952      
00001510  0C46 0038                953      CMPI    #%0000000000111000,D6 * is it immediate?
00001514  6600 002E                954      BNE     NOTIMMEDIATE
00001518                           955  
00001518  3C3C 0006                956      MOVE.W  #6, D6              * Prep lower value for bitmask
0000151C  3E3C 0007                957      MOVE.W  #7, D7              * Prep upper value for bitmask
00001520  6100 031C                958      BSR     BITMASK             * Finalize bitmask setup
00001524  CC42                     959      AND     D2,D6               * Apply bitmask  
00001526                           960  
00001526  43F9 000018D7            961      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000152C  103C 000E                962      MOVE.B  #14,D0
00001530  4E4F                     963      TRAP    #15
00001532                           964          
00001532  341A                     965      MOVE.W  (A2)+,D2
00001534                           966      
00001534  3202                     967      MOVE.W  D2,D1
00001536                           968      
00001536  343C 0010                969      MOVE.W  #16,D2
0000153A                           970          
0000153A  103C 000F                971      MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000153E  4E4F                     972      TRAP    #15      * Perform Trap #3
00001540                           973      
00001540  6000 0006                974      BRA     ENDEAHELPER05
00001544                           975      
00001544                           976  NOTIMMEDIATE * if none of the previous cases are true, it is a mode not supported by our decompiler
00001544                           977  
00001544  6100 02CE                978      BSR     UNKNOWNOP
00001548                           979      
00001548                           980  ENDEAHELPER05
00001548  4C9F 03FF                981      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
0000154C  4E75                     982      RTS
0000154E                           983  
0000154E                           984  * --- Effective Address --------------------------------
0000154E                           985  * PURPOSE       To generalize the EA part of the project.
0000154E                           986  * PRE CON       The Mode must have been correctly identified. All Modes must be called by RTS
0000154E                           987  * POST CON      After the EA, the entire op will head back to the BSR that called it.
0000154E                           988  * ------------------------------------------------------    
0000154E                           989  
0000154E                           990  * --- Dn ---------------------------------------------------------    
0000154E                           991  MODE_DN
0000154E  48A7 FFC0                992          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001552                           993  
00001552  3C3C 0000                994          MOVE.W  #0, D6              * Prep lower value for bitmask
00001556  3E3C 0002                995          MOVE.W  #2, D7              * Prep upper value for bitmask
0000155A  6100 02E2                996          BSR     BITMASK             * Finalize bitmask setup
0000155E  CC42                     997          AND     D2,D6               * Apply bitmask
00001560                           998          
00001560  0C46 0000                999          CMPI    #%000000000000000, D6   * Data Register D0?
00001564  6600 000A               1000          BNE     NOTD0
00001568                          1001          
00001568  6100 0074               1002          BSR     PRINTD0
0000156C  6000 006A               1003          BRA     ENDMODE_DN
00001570                          1004  NOTD0      
00001570  0C46 0001               1005          CMPI    #%000000000000001, D6   * Data Register D1?
00001574  6600 000A               1006          BNE     NOTD1
00001578                          1007          
00001578  6100 0072               1008          BSR     PRINTD1
0000157C  6000 005A               1009          BRA     ENDMODE_DN
00001580                          1010  NOTD1
00001580  0C46 0002               1011          CMPI    #%000000000000010, D6   * Data Register D2?
00001584  6600 000A               1012          BNE     NOTD2
00001588                          1013          
00001588  6100 0070               1014          BSR     PRINTD2
0000158C  6000 004A               1015          BRA     ENDMODE_DN
00001590                          1016  NOTD2
00001590  0C46 0003               1017          CMPI    #%000000000000011, D6   * Data Register D3?
00001594  6600 000A               1018          BNE     NOTD3
00001598                          1019          
00001598  6100 006E               1020          BSR     PRINTD3
0000159C  6000 003A               1021          BRA     ENDMODE_DN
000015A0                          1022  NOTD3
000015A0  0C46 0004               1023          CMPI    #%000000000000100, D6   * Data Register D4?
000015A4  6600 000A               1024          BNE     NOTD4
000015A8                          1025          
000015A8  6100 006C               1026          BSR     PRINTD4
000015AC  6000 002A               1027          BRA     ENDMODE_DN
000015B0                          1028  NOTD4
000015B0  0C46 0005               1029          CMPI    #%000000000000101, D6   * Data Register D5?
000015B4  6600 000A               1030          BNE     NOTD5
000015B8                          1031          
000015B8  6100 006A               1032          BSR     PRINTD5
000015BC  6000 001A               1033          BRA     ENDMODE_DN
000015C0                          1034  NOTD5
000015C0  0C46 0006               1035          CMPI    #%000000000000110, D6   * Data Register D6?
000015C4  6600 000A               1036          BNE     NOTD6
000015C8                          1037          
000015C8  6100 0068               1038          BSR     PRINTD6
000015CC  6000 000A               1039          BRA     ENDMODE_DN
000015D0                          1040  NOTD6
000015D0  6100 006E               1041          BSR     PRINTD7
000015D4  6000 0002               1042          BRA     ENDMODE_DN
000015D8                          1043          
000015D8                          1044  ENDMODE_DN
000015D8  4C9F 03FF               1045          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
000015DC  4E75                    1046          RTS
000015DE                          1047  
000015DE                          1048  *--- PRINTD0 ---------------------------------------
000015DE                          1049  *   Simply prints D0|D1...|D7
000015DE                          1050  *---------------------------------------------------
000015DE                          1051  PRINTD0
000015DE  43F9 00001907           1052          LEA     __D0, A1        * Load 'D0'
000015E4  103C 000E               1053          MOVE.B  #14, D0         * Load Trap #14 to print out
000015E8  4E4F                    1054          TRAP    #15             * Perform Trap #14
000015EA  4E75                    1055          RTS
000015EC                          1056  PRINTD1
000015EC  43F9 0000190A           1057          LEA     __D1, A1        * Load 'D1'
000015F2  103C 000E               1058          MOVE.B  #14, D0         * Load Trap #14 to print out
000015F6  4E4F                    1059          TRAP    #15             * Perform Trap #14
000015F8  4E75                    1060          RTS      
000015FA                          1061  PRINTD2
000015FA  43F9 0000190D           1062          LEA     __D2, A1        * Load 'D2'
00001600  103C 000E               1063          MOVE.B  #14, D0         * Load Trap #14 to print out
00001604  4E4F                    1064          TRAP    #15             * Perform Trap #14
00001606  4E75                    1065          RTS      
00001608                          1066  PRINTD3
00001608  43F9 00001910           1067          LEA     __D3, A1        * Load 'D3'
0000160E  103C 000E               1068          MOVE.B  #14, D0         * Load Trap #14 to print out
00001612  4E4F                    1069          TRAP    #15             * Perform Trap #14
00001614  4E75                    1070          RTS      
00001616                          1071  PRINTD4
00001616  43F9 00001913           1072          LEA     __D4, A1        * Load 'D4'
0000161C  103C 000E               1073          MOVE.B  #14, D0         * Load Trap #14 to print out
00001620  4E4F                    1074          TRAP    #15             * Perform Trap #14
00001622  4E75                    1075          RTS       
00001624                          1076  PRINTD5
00001624  43F9 00001916           1077          LEA     __D5, A1        * Load 'D5'
0000162A  103C 000E               1078          MOVE.B  #14, D0         * Load Trap #14 to print out
0000162E  4E4F                    1079          TRAP    #15             * Perform Trap #14
00001630  4E75                    1080          RTS      
00001632                          1081  PRINTD6
00001632  43F9 00001919           1082          LEA     __D6, A1        * Load 'D6'
00001638  103C 000E               1083          MOVE.B  #14, D0         * Load Trap #14 to print out
0000163C  4E4F                    1084          TRAP    #15             * Perform Trap #14
0000163E  4E75                    1085          RTS
00001640                          1086  PRINTD7
00001640  43F9 0000191C           1087          LEA     __D7, A1        * Load 'D7'
00001646  103C 000E               1088          MOVE.B  #14, D0         * Load Trap #14 to print out
0000164A  4E4F                    1089          TRAP    #15             * Perform Trap #14
0000164C  4E75                    1090          RTS
0000164E                          1091  
0000164E                          1092  * --- MODE_AN ----------------------------------------------------
0000164E                          1093  *   Simply chooses to print A0-A7
0000164E                          1094  * ----------------------------------------------------------------
0000164E                          1095  MODE_AN
0000164E  48A7 FFC0               1096          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
00001652                          1097  
00001652  3C3C 0000               1098          MOVE.W  #0, D6              * Prep lower value for bitmask
00001656  3E3C 0002               1099          MOVE.W  #2, D7              * Prep upper value for bitmask
0000165A  6100 01E2               1100          BSR     BITMASK             * Finalize bitmask setup
0000165E  CC42                    1101          AND     D2,D6               * Apply bitmask
00001660                          1102          
00001660  0C46 0000               1103          CMPI    #%000000000000000, D6   * Address Register A0?
00001664  6600 000A               1104          BNE     NOTA0
00001668                          1105          
00001668  6100 0074               1106          BSR     PRINTA0
0000166C                          1107          
0000166C  6000 006A               1108          BRA     ENDMODE_AN
00001670                          1109  NOTA0      
00001670  0C46 0001               1110          CMPI    #%000000000000001, D6   * Address Register A1?
00001674  6600 000A               1111          BNE     NOTA1
00001678                          1112          
00001678  6100 0072               1113          BSR     PRINTA1
0000167C                          1114          
0000167C  6000 005A               1115          BRA     ENDMODE_AN
00001680                          1116  NOTA1
00001680  0C46 0002               1117          CMPI    #%000000000000010, D6   * Address Register A2?
00001684  6600 000A               1118          BNE     NOTA2
00001688                          1119          
00001688  6100 0070               1120          BSR     PRINTA2
0000168C                          1121          
0000168C  6000 004A               1122          BRA     ENDMODE_AN
00001690                          1123  NOTA2
00001690  0C46 0003               1124          CMPI    #%000000000000011, D6   * Address Register A3?
00001694  6600 000A               1125          BNE     NOTA3
00001698                          1126          
00001698  6100 006E               1127          BSR     PRINTA3
0000169C                          1128          
0000169C  6000 003A               1129          BRA     ENDMODE_AN
000016A0                          1130  NOTA3
000016A0  0C46 0004               1131          CMPI    #%000000000000100, D6   * Address Register A4?
000016A4  6600 000A               1132          BNE     NOTA4
000016A8                          1133          
000016A8  6100 006C               1134          BSR     PRINTA4
000016AC                          1135          
000016AC  6000 002A               1136          BRA     ENDMODE_AN
000016B0                          1137  NOTA4
000016B0  0C46 0005               1138          CMPI    #%000000000000101, D6   * Address Register A5?
000016B4  6600 000A               1139          BNE     NOTA5
000016B8                          1140          
000016B8  6100 006A               1141          BSR     PRINTA5
000016BC                          1142          
000016BC  6000 001A               1143          BRA     ENDMODE_AN
000016C0                          1144  NOTA5
000016C0  0C46 0006               1145          CMPI    #%000000000000110, D6   * Address Register A6?
000016C4  6600 000A               1146          BNE     NOTA6
000016C8                          1147          
000016C8  6100 0068               1148          BSR     PRINTA6
000016CC                          1149          
000016CC  6000 000A               1150          BRA     ENDMODE_AN
000016D0                          1151  NOTA6
000016D0  6100 006E               1152          BSR     PRINTA7
000016D4                          1153          
000016D4  6000 0002               1154          BRA     ENDMODE_AN
000016D8                          1155  ENDMODE_AN
000016D8  4C9F 03FF               1156          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
000016DC  4E75                    1157          RTS
000016DE                          1158          
000016DE                          1159  * --- Printing out Address Registers -------------------------
000016DE                          1160  *   Simply print out the address register
000016DE                          1161  * ------------------------------------------------------------
000016DE                          1162  PRINTA0
000016DE  43F9 000018EF           1163          LEA     __A0, A1        * Load 'A0'
000016E4  103C 000E               1164          MOVE.B  #14, D0         * Load Trap #14 to print out
000016E8  4E4F                    1165          TRAP    #15             * Perform Trap #14
000016EA  4E75                    1166          RTS
000016EC                          1167  
000016EC                          1168  PRINTA1
000016EC  43F9 000018F2           1169          LEA     __A1, A1        * Load 'A1'
000016F2  103C 000E               1170          MOVE.B  #14, D0         * Load Trap #14 to print out
000016F6  4E4F                    1171          TRAP    #15             * Perform Trap #14
000016F8  4E75                    1172          RTS
000016FA                          1173          
000016FA                          1174  PRINTA2
000016FA  43F9 000018F5           1175          LEA     __A2, A1        * Load 'A2'
00001700  103C 000E               1176          MOVE.B  #14, D0         * Load Trap #14 to print out
00001704  4E4F                    1177          TRAP    #15             * Perform Trap #14
00001706  4E75                    1178          RTS
00001708                          1179  
00001708                          1180  PRINTA3
00001708  43F9 000018F8           1181          LEA     __A3, A1        * Load 'A3'
0000170E  103C 000E               1182          MOVE.B  #14, D0         * Load Trap #14 to print out
00001712  4E4F                    1183          TRAP    #15             * Perform Trap #14
00001714  4E75                    1184          RTS
00001716                          1185  
00001716                          1186  PRINTA4
00001716  43F9 000018FB           1187          LEA     __A4, A1        * Load 'A4'
0000171C  103C 000E               1188          MOVE.B  #14, D0         * Load Trap #14 to print out
00001720  4E4F                    1189          TRAP    #15             * Perform Trap #14
00001722  4E75                    1190          RTS
00001724                          1191  
00001724                          1192  PRINTA5
00001724  43F9 000018FE           1193          LEA     __A5, A1        * Load 'A5'
0000172A  103C 000E               1194          MOVE.B  #14, D0         * Load Trap #14 to print out
0000172E  4E4F                    1195          TRAP    #15             * Perform Trap #14
00001730  4E75                    1196          RTS
00001732                          1197  
00001732                          1198  PRINTA6
00001732  43F9 00001901           1199          LEA     __A6, A1        * Load 'A6'
00001738  103C 000E               1200          MOVE.B  #14, D0         * Load Trap #14 to print out
0000173C  4E4F                    1201          TRAP    #15             * Perform Trap #14
0000173E  4E75                    1202          RTS
00001740                          1203  
00001740                          1204  PRINTA7
00001740  43F9 00001904           1205          LEA     __A7, A1        * Load 'A7'
00001746  103C 000E               1206          MOVE.B  #14, D0         * Load Trap #14 to print out
0000174A  4E4F                    1207          TRAP    #15             * Perform Trap #14
0000174C  4E75                    1208          RTS
0000174E                          1209  *--- SIZE67 ---------------------------------------
0000174E                          1210  *   Called if the size is stored in bits 6->7
0000174E                          1211  *---------------------------------------------------
0000174E                          1212          
0000174E                          1213  SIZE67  * If the size is stored in bits 6->7
0000174E  48A7 FFFE               1214          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001752  3C3C 0006               1215          MOVE.W  #6, D6              * Prep lower value for bitmask
00001756  3E3C 0007               1216          MOVE.W  #7, D7              * Prep upper value for bitmask
0000175A  6100 00E2               1217          BSR     BITMASK             * Finalize bitmask setup
0000175E  CC42                    1218          AND     D2,D6               * Apply bitmask     
00001760                          1219  
00001760  0C46 0000               1220          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001764  6600 000A               1221          BNE     NOT67BYTE
00001768                          1222          
00001768  6100 0080               1223          BSR     PRINTBYTE               * Branch to handle BYTE sizes
0000176C  6000 001E               1224          BRA     END67
00001770                          1225  NOT67BYTE        
00001770  0C46 0040               1226          CMPI    #%0000000001000000, D6   * is it a WORD?
00001774  6600 000A               1227          BNE     NOT67WORD
00001778                          1228          
00001778  6100 007E               1229          BSR     PRINTWORD               * Branch to handle WORD sizes
0000177C  6000 000E               1230          BRA     END67
00001780                          1231  NOT67WORD
00001780  0C46 0080               1232          CMPI    #%0000000010000000, D6   * is it a LONG?
00001784  6600 0006               1233          BNE     END67
00001788                          1234          
00001788  6100 007C               1235          BSR     PRINTLONG               * Branch to handle LONG sizes
0000178C                          1236  END67
0000178C  4C9F 7FFF               1237          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001790  4E75                    1238          RTS                             * Return. Size handling is finished.
00001792                          1239  
00001792                          1240  * finish later, need to follow the same format as SIZE67        
00001792                          1241  SIZE68  * If the size is stored in bits 6->8 
00001792  48A7 FFFE               1242          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001796  3C3C 0006               1243          MOVE.W  #6, D6              * Prep lower value for bitmask
0000179A  3E3C 0008               1244          MOVE.W  #8, D7              * Prep upper value for bitmask
0000179E  6100 009E               1245          BSR     BITMASK             * Finalize bitmask setup
000017A2  CC42                    1246          AND     D2,D6               * Apply bitmask          
000017A4                          1247          
000017A4  0C46 0000               1248          CMPI    #%0000000000000000, D6   * is it a BYTE?
000017A8  6100 0040               1249          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000017AC  0C46 0100               1250          CMPI    #%0000000100000000, D6   * is it a BYTE?
000017B0  6100 0038               1251          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
000017B4                          1252        
000017B4  0C46 0040               1253          CMPI    #%0000000001000000, D6   * is it a WORD?
000017B8  6100 003E               1254          BSR     PRINTWORD               * Branch to handle BYTE sizes
000017BC  0C46 0140               1255          CMPI    #%0000000101000000, D6   * is it a WORD?
000017C0  6100 0036               1256          BSR     PRINTWORD               * Branch to handle BYTE sizes
000017C4  0C46 00C0               1257          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
000017C8  6100 002E               1258          BSR     PRINTWORD               * Branch to handle BYTE sizes
000017CC                          1259  
000017CC  0C46 0080               1260          CMPI    #%0000000010000000, D6   * is it a LONG?
000017D0  6100 0034               1261          BSR     PRINTLONG               * Branch to handle BYTE sizes
000017D4  0C46 0180               1262          CMPI    #%0000000110000000, D6   * is it a LONG?
000017D8  6100 002C               1263          BSR     PRINTLONG               * Branch to handle BYTE sizes
000017DC  0C46 01C0               1264          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
000017E0  6100 0024               1265          BSR     PRINTLONG               * Branch to handle BYTE sizes
000017E4                          1266  
000017E4  4C9F 7FFF               1267          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
000017E8  4E75                    1268          RTS                             * Return. Size handling is finished.              
000017EA                          1269          
000017EA                          1270  PRINTBYTE
000017EA  43F9 000018E3           1271          LEA     __B,A1      * Load '.B ' into A1
000017F0  103C 000E               1272          MOVE.B  #14,D0      * Trap #14 setup to print
000017F4  4E4F                    1273          TRAP    #15         * Perform Trap #14
000017F6  4E75                    1274          RTS                 * Return to SIZE67/SIZE68
000017F8                          1275          
000017F8                          1276  PRINTWORD
000017F8  43F9 000018E7           1277          LEA     __W,A1      * Load '.W ' into A1
000017FE  103C 000E               1278          MOVE.B  #14,D0      * Trap #14 setup to print
00001802  4E4F                    1279          TRAP    #15         * Perform Trap #14
00001804  4E75                    1280          RTS                 * Return to SIZE67/SIZE68
00001806                          1281  
00001806                          1282  PRINTLONG
00001806  43F9 000018EB           1283          LEA     __L,A1      * Load '.L ' into A1
0000180C  103C 000E               1284          MOVE.B  #14,D0      * Trap #14 setup to print
00001810  4E4F                    1285          TRAP    #15         * Perform Trap #14
00001812  4E75                    1286          RTS                 * Return to SIZE67/SIZE68
00001814                          1287  
00001814                          1288  * --- UNKNOWNOP ----------------------------------------
00001814                          1289  * PRE  COND     D2 contains the instruction we wish to print.
00001814                          1290  *               D2 has already been identified as an unknown operation
00001814                          1291  * 
00001814                          1292  * POST COND     D2 is no longer the opcode
00001814                          1293  * ------------------------------------------------------
00001814                          1294     
00001814                          1295  UNKNOWNOP
00001814  220A                    1296          MOVE.L  A2,D1   * prep the add to print
00001816                          1297          
00001816  5581                    1298          SUB.L   #2,D1   * off by two error due to post increment correct
00001818                          1299          
00001818  2602                    1300          MOVE.L  D2,D3   * save the opcode to print
0000181A                          1301          
0000181A  7410                    1302          MOVE.L  #16,D2  * set the base to 16
0000181C                          1303          
0000181C  700F                    1304          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
0000181E  4E4F                    1305          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001820                          1306          
00001820  43F9 000018B3           1307          LEA     DATA,A1 * load " DATA $" into register A1
00001826  700E                    1308          MOVE.L  #14,D0  * print the string stored in A1
00001828  4E4F                    1309          TRAP    #15
0000182A                          1310          
0000182A  2203                    1311          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
0000182C                          1312          
0000182C  103C 000F               1313          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001830  4E4F                    1314          TRAP    #15      * Perform Trap #3
00001832                          1315          
00001832  43F9 00001882           1316          LEA     NEWLINE,A1 * load newline into register A1
00001838  700E                    1317          MOVE.L  #14,D0  * print the string stored in A1
0000183A  4E4F                    1318          TRAP    #15
0000183C                          1319          
0000183C  4E75                    1320          RTS
0000183E                          1321          *BRA     ITERATION * done with this op, move on to the next iteration
0000183E                          1322  
0000183E                          1323   * --- BITMASK ----------------------------------------------------------------
0000183E                          1324   *@pre      D6 contains the starting bit you want masked, D7 the ending bit
0000183E                          1325   *
0000183E                          1326   *@post     D6 contains the bitmask, ready for use
0000183E                          1327   
0000183E                          1328  BITMASK
0000183E  3F05                    1329          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001840  4245                    1330          CLR     D5          * clear D5 so we can use it
00001842                          1331  LOOPBIT 
00001842  0DC5                    1332          BSET    D6,D5       * set the D6th bit in D5 to 1
00001844  5246                    1333          ADD     #1,D6       * increment D6
00001846                          1334          
00001846  BC47                    1335          CMP     D7,D6       * have we finished?
00001848  6E00 0004               1336          BGT     BITMASKDONE * yes
0000184C  60F4                    1337          BRA     LOOPBIT     * no, iterate again
0000184E                          1338          
0000184E                          1339  BITMASKDONE
0000184E                          1340  
0000184E  2C05                    1341          MOVE.L  D5,D6
00001850  3A1F                    1342          MOVE    (A7)+,D5    * restore D5
00001852  4E75                    1343          RTS
00001854                          1344          
00001854                          1345   * --- OP0100 -----------------------------------------------------------------
00001854                          1346   * @pre      D2 contains the opcode
00001854                          1347   *
00001854                          1348   * @post     all registers are returned to their previous state
00001854                          1349  
00001854                          1350  
00001854                          1351  
00001854                          1352   * ----------------------------------------------------------------------------
00001854                          1353   * ----------------------------------------------------------------------------
00001854                          1354   * Constants for printing information to the console
00001854                          1355  
00001854  =0000000D               1356  CR      EQU     $0D
00001854  =0000000A               1357  LF      EQU     $0A
00001854= 45 4E 54 45 52 20 ...   1358  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
0000186C= 45 4E 54 45 52 20 ...   1359  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001882= 0D 0A 00                1360  NEWLINE     DC.B    CR,LF,0
00001885= 4E 4F 50 00             1361  NOOPERATION DC.B    'NOP',0
00001889= 4E 45 47 00             1362  NEGOP       DC.B    'NEG',0
0000188D= 4D 4F 56 45 00          1363  MOVEOP      DC.B    'MOVE',0
00001892= 4D 4F 56 45 4D 00       1364  MOVEMOP     DC.B    'MOVEM',0
00001898= 4A 53 52 20 00          1365  JSROP       DC.B    'JSR ',0
0000189D= 52 54 53 00             1366  RTSOP       DC.B    'RTS',0
000018A1= 4C 45 41 00             1367  LEAOP       DC.B    'LEA',0
000018A5= 42 43 4C 52 00          1368  BCLROP      DC.B    'BCLR',0
000018AA= 4F 52 49 00             1369  ORIOP       DC.B    'ORI',0
000018AE= 43 4D 50 49 00          1370  CMPIOP      DC.B    'CMPI',0
000018B3= 20 44 41 54 41 20 ...   1371  DATA        DC.B    ' DATA $',0
000018BB= 42 43 43 00             1372  OP_BCC_MSG  DC.B    'BCC',0
000018BF= 42 43 53 00             1373  OP_BCS_MSG  DC.B    'BCS',0
000018C3= 42 47 45 00             1374  OP_BGE_MSG  DC.B    'BGE',0
000018C7= 42 4C 54 00             1375  OP_BLT_MSG  DC.B    'BLT',0
000018CB= 42 56 43 00             1376  OP_BVC_MSG  DC.B    'BVC',0
000018CF= 42 52 41 00             1377  OP_BRA_MSG  DC.B    'BRA',0
000018D3                          1378  
000018D3                          1379   * ----------------------------------------------------------------------------
000018D3                          1380   * ----------------------------------------------------------------------------
000018D3                          1381   * Data defined constants
000018D3                          1382   *   - B/W/L (representing Byte, Word, Long)
000018D3                          1383   *   - A0-A7 (representing the 8 address registers)
000018D3                          1384   *   - D0-D7 (representing the 8 data registers)
000018D3                          1385   * ----------------------------------------------------------------------------
000018D3                          1386  
000018D3= 20 00                   1387  SPACE       DC.B    ' ',0
000018D5= 24 00                   1388  DOLLAR      DC.B    '$',0
000018D7= 23 00                   1389  IMD         DC.B    '#',0
000018D9= 2C 00                   1390  COMMA       DC.B    ',',0
000018DB= 28 00                   1391  OBRACK      DC.B    '(',0
000018DD= 29 00                   1392  CBRACK      DC.B    ')',0
000018DF= 2B 00                   1393  PLUS        DC.B    '+',0
000018E1= 2D 00                   1394  MINUS       DC.B    '-',0
000018E3= 2E 42 20 00             1395  __B         DC.B    '.B ',0
000018E7= 2E 57 20 00             1396  __W         DC.B    '.W ',0
000018EB= 2E 4C 20 00             1397  __L         DC.B    '.L ',0
000018EF                          1398  
000018EF= 41 30 00                1399  __A0        DC.B   'A0',0
000018F2= 41 31 00                1400  __A1        DC.B   'A1',0    
000018F5= 41 32 00                1401  __A2        DC.B   'A2',0
000018F8= 41 33 00                1402  __A3        DC.B   'A3',0
000018FB= 41 34 00                1403  __A4        DC.B   'A4',0
000018FE= 41 35 00                1404  __A5        DC.B   'A5',0
00001901= 41 36 00                1405  __A6        DC.B   'A6',0
00001904= 41 37 00                1406  __A7        DC.B   'A7',0
00001907                          1407  
00001907= 44 30 00                1408  __D0        DC.B   'D0',0
0000190A= 44 31 00                1409  __D1        DC.B   'D1',0
0000190D= 44 32 00                1410  __D2        DC.B   'D2',0
00001910= 44 33 00                1411  __D3        DC.B   'D3',0
00001913= 44 34 00                1412  __D4        DC.B   'D4',0
00001916= 44 35 00                1413  __D5        DC.B   'D5',0
00001919= 44 36 00                1414  __D6        DC.B   'D6',0
0000191C= 44 37 00                1415  __D7        DC.B   'D7',0
0000191F                          1416   * ---------------------------------------------------------------------------
0000191F                          1417   * End of definition segment
0000191F                          1418   * ---------------------------------------------------------------------------
0000191F                          1419   * ---------------------------------------------------------------------------
0000191F                          1420  
0000191F                          1421  * Put variables and constants here
0000191F                          1422  
00004000                          1423      ORG $4000
00004000                          1424  
00004000  4E71                    1425      NOP
00004002  103C 009A               1426      MOVE.B   #%10011010, D0
00004006  123C 00A9               1427      MOVE.B   #%10101001, D1
0000400A  D200                    1428      ADD.B    D0,D1
0000400C  48A7 4000               1429      MOVEM    D1,-(A7)
00004010  43F8 1898               1430      LEA      JSROP,A1
00004014  4467                    1431      NEG.W    -(A7)
00004016  4EB9 0000401C           1432      JSR      END
0000401C                          1433  
0000401C                          1434  END
0000401C  4E75                    1435      RTS
0000401E                          1436  RLLYEND
0000401E                          1437      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BCC_END             1416
BCLROP              18A5
BITMASK             183E
BITMASKDONE         184E
CBRACK              18DD
CMPIBYTE            10F4
CMPIEA              1168
CMPILONG            1142
CMPIOP              18AE
CMPIREG             11B4
CMPIREG000          11D8
CMPIREG001          11D8
CMPIWORD            111C
COMMA               18D9
CR                  D
DATA                18B3
DOLLAR              18D5
DONE                1362
EAHELPER05          1450
EAHELPER611         141C
END                 401C
END0000             11D2
END67               178C
ENDEAHELPER05       1548
ENDMODE_AN          16D8
ENDMODE_DN          15D8
ENDOP0001           1222
IMD                 18D7
ISCMPI              10BA
ISORI               10BA
ITERATION           1064
JSROP               1898
LEAOP               18A1
LF                  A
LOOP                103A
LOOPBIT             1842
MINUS               18E1
MODE_AN             164E
MODE_DN             154E
MOVEMOP             1892
MOVEOP              188D
MSGEND              186C
MSGSTART            1854
NEGOP               1889
NEWLINE             1882
NEXT                1060
NOOPERATION         1885
NOT0001             1050
NOT67BYTE           1770
NOT67WORD           1780
NOTA0               1670
NOTA1               1680
NOTA2               1690
NOTA3               16A0
NOTA4               16B0
NOTA5               16C0
NOTA6               16D0
NOTADRDIRECT        1480
NOTADRINDIRECT      14A8
NOTADRINDIRECTPOST  14DC
NOTADRINDIRECTPRE   1510
NOTBCLR             1098
NOTD0               1570
NOTD1               1580
NOTD2               1590
NOTD3               15A0
NOTD4               15B0
NOTD5               15C0
NOTD6               15D0
NOTDATAREG          1470
NOTIMMEDIATE        1544
NOTJSR              1318
NOTMOVEM            12D6
NOTNEG              12B2
NOTNOP              125C
NOTRTS              133A
OBRACK              18DB
OP0000              106E
OP0001              11D8
OP0010              1228
OP0011              1228
OP0100              1240
OP0101              1368
OP0110              1368
OP0111              141C
OP1000              141C
OP1001              141C
OP1010              141C
OP1011              141C
OP1100              141C
OP1101              141C
OP1110              141C
OP1111              141C
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              13B8
OP_BCC_MSG          18BB
OP_BCS              13C2
OP_BCS_MSG          18BF
OP_BGE              13CC
OP_BGE_MSG          18C3
OP_BLT              13D6
OP_BLT_MSG          18C7
OP_BRA              13EA
OP_BRANCHES_PRINT   13F4
OP_BRA_MSG          18CF
OP_BVC              13E0
OP_BVC_MSG          18CB
ORIOP               18AA
PLUS                18DF
PRINTA0             16DE
PRINTA1             16EC
PRINTA2             16FA
PRINTA3             1708
PRINTA4             1716
PRINTA5             1724
PRINTA6             1732
PRINTA7             1740
PRINTBYTE           17EA
PRINTD0             15DE
PRINTD1             15EC
PRINTD2             15FA
PRINTD3             1608
PRINTD4             1616
PRINTD5             1624
PRINTD6             1632
PRINTD7             1640
PRINTLONG           1806
PRINTWORD           17F8
RLLYEND             401E
RTSOP               189D
SIZE67              174E
SIZE68              1792
SPACE               18D3
START               1000
UNKNOWN             135E
UNKNOWNOP           1814
UNKNOWNOP0001       121E
__A0                18EF
__A1                18F2
__A2                18F5
__A3                18F8
__A4                18FB
__A5                18FE
__A6                1901
__A7                1904
__B                 18E3
__D0                1907
__D1                190A
__D2                190D
__D3                1910
__D4                1913
__D5                1916
__D6                1919
__D7                191C
__L                 18EB
__W                 18E7
