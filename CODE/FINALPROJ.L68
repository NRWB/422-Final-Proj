00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/6/2014 9:49:59 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001C60             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001C78             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001C8E             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0C12                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 01EC                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 0242                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 0238                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 0236                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 041C                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 0412                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 04B6                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 04AC                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 0530                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 0526                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 051C                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 0512                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 0508                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 04FE                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 04F4                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 0950                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2EE4                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 FFC0                212          MOVEM   D0-D7/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0AEC                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162                           218          * TODO: Consider static  AND dynamic BCLR.
00001162                           219          * Only works for Dynamic right now
00001162  0C46 0180                220          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0066                221          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           222          
0000116A  3C3C 0003                223          MOVE.W  #3, D6              * Prep lower value for bitmask
0000116E  3E3C 0005                224          MOVE.W  #5, D7              * Prep upper value for bitmask
00001172  6100 0AD6                225          BSR     BITMASK             * Finalize bitmask setup
00001176  CC42                     226          AND     D2,D6               * Apply bitmask
00001178                           227          
00001178                           228          * Checking for unsupported mode
00001178  0C46 0008                229          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000117C  6700 00BE                230          BEQ     UNKNOWN0000             * If so, branch to other OP0000 functions
00001180                           231          
00001180                           232          * Confirmed BCLR at this point
00001180  43F9 00001CB5            233          LEA     BCLROP,A1           * We found BCLR
00001186  103C 000E                234          MOVE.B  #14,D0              * Trap #14 prints out the data
0000118A  4E4F                     235          TRAP    #15                 * Perform Trap #14
0000118C                           236  
0000118C  43F9 00001D0D            237          LEA     SPACE,A1            * Formatting
00001192  103C 000E                238          MOVE.B  #14,D0              * Trap #14 prints out space
00001196  4E4F                     239          TRAP    #15                 * Perform Trap #14
00001198                           240          
00001198                           241          * Set up for printing out the Register
00001198  0882 0006                242          BCLR    #6,D2               * Clear bit 6
0000119C  0882 0007                243          BCLR    #7,D2               * Clear bit 7
000011A0  0882 0008                244          BCLR    #8,D2               * Clear bit 8
000011A4                           245          
000011A4  6100 048E                246          BSR     EAHELPER611         * Print out Register
000011A8                           247  
000011A8  43F9 00001D13            248          LEA     COMMA,A1            * formatting
000011AE  103C 000E                249          MOVE.B  #14,D0              * Trap #14 prints out a comma
000011B2  4E4F                     250          TRAP    #15                 * Perform Trap #14
000011B4                           251          
000011B4  4243                     252          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000011B6  08C3 0000                253          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000011BA                           254      
000011BA  6100 04BA                255          BSR     EAHELPER05          * Print out data.
000011BE                           256          
000011BE  43F9 00001C8E            257          LEA     NEWLINE,A1          * Formatting
000011C4  103C 000E                258          MOVE.B  #14,D0              * Trap #14 prints out the data
000011C8  4E4F                     259          TRAP    #15                 * Perform Trap #14
000011CA                           260          
000011CA  6000 0074                261          BRA     END0000             * Found the op, move to next iteration
000011CE                           262          
000011CE                           263  NOTBCLR * Possible options left are ORI or CMPI
000011CE  3C3C 0009                264          MOVE.W  #9, D6              * Prep lower value for bitmask
000011D2  3E3C 000B                265          MOVE.W  #11, D7             * Prep upper value for bitmask
000011D6  6100 0A72                266          BSR     BITMASK             * Finalize bitmask setup
000011DA  CC42                     267          AND     D2,D6               * Apply bitmask
000011DC                           268          
000011DC  0C46 0000                269          CMPI    #%0000000000000000, D6   * Are we possibly ORI?
000011E0  6600 0052                270          BNE     NOTORI                   * If not, branch to NOTORI
000011E4                           271          
000011E4                           272          * Size check to see if unsupported ORI mode
000011E4  3C3C 0006                273          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E8  3E3C 0007                274          MOVE.W  #7, D7              * Prep upper value for bitmask
000011EC  6100 0A5C                275          BSR     BITMASK             * Finalize bitmask setup
000011F0  CC42                     276          AND     D2,D6               * Apply bitmask
000011F2                           277          
000011F2  0C46 00C0                278          CMPI    #%0000000011000000, D6  * Are bits 6,7 == 1,1?
000011F6  6700 0044                279          BEQ     UNKNOWN0000             * If so, unknown op. 
000011FA                           280          
000011FA                           281          * Mode check to see if unsupported ORI mode
000011FA  3C3C 0003                282          MOVE.W  #3, D6              * Prep lower value for bitmask
000011FE  3E3C 0005                283          MOVE.W  #5, D7              * Prep upper value for bitmask
00001202  6100 0A46                284          BSR     BITMASK             * Finalize bitmask setup
00001206  CC42                     285          AND     D2,D6               * Apply bitmask
00001208                           286          
00001208  0C46 0008                287          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000120C  6700 002E                288          BEQ     UNKNOWN0000             * If so, unknown op. 
00001210                           289          
00001210                           290          * Confirmed ORI at this point
00001210                           291          * TODO: Get the immediate data following the instruction and print it out
00001210  43F9 00001CBE            292          LEA     ORIOP, A1           * Load 'ORI' into the output window
00001216  103C 000E                293          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
0000121A  4E4F                     294          TRAP    #15                 * Perform Trap #14
0000121C                           295          
0000121C  6100 07AE                296          BSR     SIZE67              * Print the size
00001220  6100 0454                297          BSR     EAHELPER05          * Print out the EA
00001224                           298          
00001224  43F9 00001C8E            299          LEA     NEWLINE,A1          * Formatting
0000122A  103C 000E                300          MOVE.B  #14,D0              * Trap #14 prints out the data
0000122E  4E4F                     301          TRAP    #15                 * Perform Trap #14
00001230                           302          
00001230  6000 000E                303          BRA     END0000             * Done with op. Move to next iteration
00001234                           304          
00001234                           305  NOTORI  * Possible option left is CMPI
00001234  0C46 0C00                306          CMPI    #%0000110000000000, D6  * Are we CMPI?
00001238  6600 0002                307          BNE     UNKNOWN0000             * If not, unknown op
0000123C                           308          
0000123C                           309          * TODO: Continue checking for CMPI validity
0000123C                           310          
0000123C                           311  UNKNOWN0000
0000123C  6100 0854                312          BSR     UNKNOWNOP       * Unknown op
00001240                           313          
00001240                           314  END0000          
00001240  4C9F 03FF                315         MOVEM   (A7)+,D0-D7/A0-A1   * Push values to the stack to save
00001244  4E75                     316         RTS
00001246                           317  
00001246                           318  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001246                           319  *-----------------------------------------------------------------------------
00001246                           320  
00001246                           321  
00001246                           322  
00001246                           323  *-----------------------------------------------------------------------------
00001246                           324  *-----------------------------------------------------------------------------
00001246                           325  * NAME: OP_0001   (MOVE.B)
00001246                           326  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001246                           327  * PRE-CONDITION:  xyz
00001246                           328  * POST-CONDITION: All registers return to their previous state, and the output
00001246                           329  *                 goes to the output console for reading the raw data or the
00001246                           330  *                 actual instruction.
00001246                           331  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001246                           332  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001246                           333  OP0001  
00001246  48A7 FFC0                334          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
0000124A  3C3C 0006                335          MOVE.W  #6, D6              * Prep lower value for bitmask
0000124E  3E3C 0008                336          MOVE.W  #8, D7              * Prep upper value for bitmask
00001252  6100 09F6                337          BSR     BITMASK             * Finalize bitmask setup
00001256  CC42                     338          AND     D2,D6               * Apply bitmask
00001258                           339          
00001258                           340          * I may have fucked off this part, sorry - Caleb
00001258                           341          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
00001258                           342          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
00001258                           343          
00001258  43F9 00001C9E            344          LEA     MOVEOP,A1   * Put 'MOVE' into the window
0000125E  103C 000E                345          MOVE.B  #14,D0      * Trap #14 to print out
00001262  4E4F                     346          TRAP    #15         * Perform Trap #14
00001264                           347          
00001264                           348          *-----------------------------------------------------------
00001264                           349          * the following code is to move the size bits into the
00001264                           350          * 0-1 positions of D3 so that eahelper05 case use that as a "parameter"
00001264                           351          * for eahelper05
00001264                           352          
00001264  3C3C 000C                353          MOVE.W  #12, D6              * Prep lower value for bitmask
00001268  3E3C 000D                354          MOVE.W  #13, D7              * Prep upper value for bitmask
0000126C  6100 09DC                355          BSR     BITMASK             * Finalize bitmask setup
00001270                           356          
00001270  CC42                     357          AND     D2,D6
00001272                           358          
00001272  E04E                     359          LSR     #8,D6
00001274  E84E                     360          LSR     #4,D6
00001276                           361          
00001276  4243                     362          CLR     D3
00001278                           363          
00001278  1606                     364          MOVE.B  D6,D3
0000127A                           365          
0000127A                           366          *---------------------------------------------------------------
0000127A                           367          
0000127A                           368          
0000127A  6100 0750                369          BSR     SIZE67
0000127E  6100 03F6                370          BSR     EAHELPER05
00001282                           371          
00001282  43F9 00001D13            372          LEA     COMMA,A1
00001288  103C 000E                373          MOVE.B  #14,D0
0000128C  4E4F                     374          TRAP    #15
0000128E                           375          
0000128E  6100 03A4                376          BSR     EAHELPER611
00001292                           377          
00001292  43F9 00001C8E            378          LEA     NEWLINE,A1
00001298  103C 000E                379          MOVE.B  #14,D0
0000129C  4E4F                     380          TRAP    #15
0000129E                           381          
0000129E  6000 0006                382          BRA     ENDOP0001
000012A2                           383          *LEA     __B,A1      * Put '.B' into the window
000012A2                           384          *MOVE.B  #14,D0      * Trap #14 to print out
000012A2                           385          *TRAP    #15         * Perform Trap #14
000012A2                           386          
000012A2                           387  UNKNOWNOP0001
000012A2                           388  
000012A2  6100 07EE                389          BSR     UNKNOWNOP
000012A6                           390          
000012A6                           391  ENDOP0001
000012A6                           392  
000012A6  4C9F 03FF                393          MOVEM (A7)+,D0-D7/A0-A1
000012AA  4E75                     394          RTS        
000012AC                           395          
000012AC                           396          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
000012AC                           397  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012AC                           398  *-----------------------------------------------------------------------------
000012AC                           399  
000012AC                           400  
000012AC                           401  
000012AC                           402  *-----------------------------------------------------------------------------
000012AC                           403  *-----------------------------------------------------------------------------
000012AC                           404  * NAME: OP_0010   (MOVE.L, MOVEA.L)
000012AC                           405  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012AC                           406  * PRE-CONDITION:  xyz
000012AC                           407  * POST-CONDITION: All registers return to their previous state, and the output
000012AC                           408  *                 goes to the output console for reading the raw data or the
000012AC                           409  *                 actual instruction.
000012AC                           410  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012AC                           411  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012AC                           412  OP0010
000012AC                           413  
000012AC  6100 07E4                414      BSR     UNKNOWNOP
000012B0  4E75                     415      RTS
000012B2                           416  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012B2                           417  *-----------------------------------------------------------------------------
000012B2                           418  
000012B2                           419  
000012B2                           420  
000012B2                           421  *-----------------------------------------------------------------------------
000012B2                           422  *-----------------------------------------------------------------------------
000012B2                           423  * NAME: OP_0011   (MOVE.W, MOVEA.W)
000012B2                           424  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012B2                           425  * PRE-CONDITION:  xyz
000012B2                           426  * POST-CONDITION: All registers return to their previous state, and the output
000012B2                           427  *                 goes to the output console for reading the raw data or the
000012B2                           428  *                 actual instruction.
000012B2                           429  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012B2                           430  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012B2                           431  OP0011
000012B2  48A7 FFFE                432      MOVEM   D0-D7/A0-A6, -(A7)
000012B6                           433      
000012B6                           434      *MOVE.W  #6,D6
000012B6                           435      *MOVE.W  #8,D7
000012B6                           436      
000012B6                           437      *BSR     BITMASK
000012B6                           438      
000012B6                           439      *AND.W   D2,D6
000012B6                           440      
000012B6                           441      *CMP     #%0000000001000000,D6
000012B6                           442      *BNE     NEXT15
000012B6                           443      *BSR     * for MOVEA.W
000012B6                           444      
000012B6  4C9F 7FFF                445      MOVEM   (A7)+,D0-D7/A0-A6
000012BA                           446      
000012BA  6100 07D6                447      BSR     UNKNOWNOP
000012BE  4E75                     448      RTS
000012C0                           449  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012C0                           450  *-----------------------------------------------------------------------------
000012C0                           451  
000012C0                           452  
000012C0                           453  
000012C0                           454  *-----------------------------------------------------------------------------
000012C0                           455  *-----------------------------------------------------------------------------
000012C0                           456  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
000012C0                           457  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012C0                           458  * PRE-CONDITION:  xyz
000012C0                           459  * POST-CONDITION: All registers return to their previous state, and the output
000012C0                           460  *                 goes to the output console for reading the raw data or the
000012C0                           461  *                 actual instruction.
000012C0                           462  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012C0                           463  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012C0                           464  OP0100  
000012C0                           465          * TODO: lea, movem
000012C0                           466  
000012C0  48A7 C0C0                467          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000012C4                           468          
000012C4                           469          *NOP
000012C4  0C42 4E71                470          CMPI    #%0100111001110001,D2
000012C8  6600 0012                471          BNE     NOTNOP
000012CC                           472          
000012CC  43F9 00001C96            473          LEA     NOOPERATION,A1
000012D2  103C 000D                474          MOVE.B  #13,D0          * Print a newline
000012D6  4E4F                     475          TRAP    #15
000012D8                           476          
000012D8  6000 01D2                477          BRA     DONE0100 *we found it, move on to the next iteration
000012DC                           478  NOTNOP *NEG
000012DC                           479          
000012DC                           480          * prep values for BITMASK subroutine
000012DC  7C08                     481          MOVE.L  #8,D6
000012DE  7E0B                     482          MOVE.L  #11,D7
000012E0                           483          
000012E0  6100 0968                484          BSR     BITMASK
000012E4                           485          
000012E4  CC42                     486          AND     D2,D6                   * apply bitmask
000012E6                           487          
000012E6  0C46 0400                488          CMPI    #%0000010000000000,D6   * are we NEG?
000012EA  6600 0046                489          BNE     NOTNEG                  * not neg
000012EE                           490          
000012EE  7C03                     491          MOVE.L  #3,D6
000012F0  7E05                     492          MOVE.L  #5,D7
000012F2                           493          
000012F2  6100 0956                494          BSR     BITMASK * generate a bitmask to be used to check mode
000012F6                           495          
000012F6  0C46 0008                496          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
000012FA  6700 01AC                497          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
000012FE                           498          
000012FE  0C46 0028                499          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001302  6700 01A4                500          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
00001306                           501          
00001306  0C46 0030                502          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000130A  6700 019C                503          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
0000130E                           504        
0000130E                           505          * it is NEG, print
0000130E  43F9 00001C9A            506          LEA     NEGOP,A1
00001314  103C 000E                507          MOVE.B  #14,D0
00001318  4E4F                     508          TRAP    #15
0000131A                           509          
0000131A  6100 06B0                510          BSR     SIZE67
0000131E                           511          
0000131E  6100 0356                512          BSR     EAHELPER05
00001322                           513          
00001322  43F9 00001C8E            514          LEA     NEWLINE,A1
00001328  103C 000E                515          MOVE.B  #14,D0
0000132C  4E4F                     516          TRAP    #15
0000132E                           517          
0000132E  6000 017C                518          BRA     DONE0100 * we found the op, move to next iteration
00001332                           519          
00001332                           520  NOTNEG *MOVEM
00001332                           521  
00001332                           522          * prep values for BITMASK subroutine
00001332  7C07                     523          MOVE.L  #7,D6
00001334  7E09                     524          MOVE.L  #9,D7
00001336                           525          
00001336  6100 0912                526          BSR     BITMASK
0000133A                           527          
0000133A  CC42                     528          AND     D2,D6   * apply bitmask
0000133C                           529          
0000133C  0C46 0080                530          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001340  6600 0014                531          BNE     NOTMOVEM          * it is not MOVEM
00001344                           532          
00001344                           533          * make sure it is a valid size and mode for MOVEM
00001344                           534          
00001344                           535          * it is MOVEM
00001344  43F9 00001CA3            536          LEA     MOVEMOP,A1
0000134A  103C 000D                537          MOVE.B  #13,D0          * Print a newline
0000134E  4E4F                     538          TRAP    #15
00001350                           539          
00001350                           540          * probably needs its own special code for printing the rest due to uniqueness of movem
00001350                           541          
00001350  341A                     542          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001352                           543          
00001352  6000 0158                544          BRA     DONE0100          * we found and printed, move on to the next iteration
00001356                           545          
00001356                           546  NOTMOVEM *JSR
00001356                           547          * prep values for BITMASK subroutine
00001356  7C06                     548          MOVE.L  #6,D6
00001358  7E08                     549          MOVE.L  #8,D7
0000135A                           550          
0000135A  6100 08EE                551          BSR     BITMASK
0000135E                           552          
0000135E  CC42                     553          AND     D2,D6   * apply bitmask
00001360                           554          
00001360  0C46 0080                555          CMPI    #%0000000010000000,D6
00001364  6600 003E                556          BNE     NOTJSR          * it's not JSR
00001368                           557          
00001368  43F9 00001CA9            558          LEA     JSROP,A1
0000136E  103C 000E                559          MOVE.B  #14,D0          * Print a newline and JSR
00001372  4E4F                     560          TRAP    #15
00001374                           561          
00001374  43F9 00001D0D            562          LEA     SPACE,A1
0000137A  103C 000E                563          MOVE.B  #14,D0          * Print a newline and JSR
0000137E  4E4F                     564          TRAP    #15
00001380                           565          
00001380                           566          * print out where we are jumping to
00001380                           567          
00001380  341A                     568          MOVE.W  (A2)+,D2 * read in the next word of the instruction 
00001382                           569          
00001382  2202                     570          MOVE.L  D2,D1   * save the opcode to print
00001384                           571          
00001384  7410                     572          MOVE.L  #16,D2  * set the base to 16
00001386                           573          
00001386  700F                     574          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001388  4E4F                     575          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000138A                           576          
0000138A  341A                     577          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000138C                           578          
0000138C  2202                     579          MOVE.L  D2,D1   * save the opcode to print
0000138E                           580          
0000138E  7410                     581          MOVE.L  #16,D2  * set the base to 16
00001390                           582          
00001390  700F                     583          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001392  4E4F                     584          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001394                           585          
00001394  43F9 00001C8E            586          LEA     NEWLINE,A1
0000139A  103C 000E                587          MOVE.B  #14,D0          * Print a newline
0000139E  4E4F                     588          TRAP    #15
000013A0                           589          
000013A0  6000 010A                590          BRA     DONE0100          * we already found instruction, next iteration
000013A4                           591  NOTJSR *RTS
000013A4                           592  
000013A4                           593          * prep values for BITMASK subroutine
000013A4  7C06                     594          MOVE.L  #6,D6
000013A6  7E08                     595          MOVE.L  #8,D7
000013A8                           596          
000013A8  6100 08A0                597          BSR     BITMASK
000013AC                           598          
000013AC  CC42                     599          AND     D2,D6   * apply bitmask
000013AE                           600          
000013AE  0C46 0040                601          CMPI    #%0000000001000000,D6
000013B2  6600 0012                602          BNE     NOTRTS          * it's not RTS
000013B6                           603          
000013B6  43F9 00001CAD            604          LEA     RTSOP,A1
000013BC  103C 000D                605          MOVE.B  #13,D0          * Print a newline and RTS
000013C0  4E4F                     606          TRAP    #15
000013C2                           607          
000013C2  6000 00E8                608          BRA     DONE0100          * we already found instruction, next iteration
000013C6                           609  NOTRTS  *LEA
000013C6                           610         
000013C6                           611          * prep values for BITMASK subroutine
000013C6  7C06                     612          MOVE.L  #6,D6
000013C8  7E08                     613          MOVE.L  #8,D7
000013CA                           614          
000013CA  6100 087E                615          BSR     BITMASK
000013CE                           616          
000013CE  CC42                     617          AND     D2,D6   * apply bitmask
000013D0                           618          
000013D0  0C46 01C0                619          CMPI    #%0000000111000000,D6
000013D4  6600 00D2                620          BNE     UNKNOWN0100          * it's not LEA, we dont know what it is
000013D8                           621          
000013D8                           622          * prep values for BITMASK subroutine
000013D8  7C03                     623          MOVE.L  #3,D6
000013DA  7E05                     624          MOVE.L  #5,D7
000013DC                           625          
000013DC  6100 086C                626          BSR     BITMASK
000013E0                           627          
000013E0  CC42                     628          AND     D2,D6   * apply bitmask
000013E2                           629          
000013E2  0C46 0008                630          CMPI    #%0000000000001000,D6
000013E6  6700 00C0                631          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013EA                           632          
000013EA  0C46 0018                633          CMPI    #%0000000000011000,D6
000013EE  6700 00B8                634          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013F2                           635          
000013F2  0C46 0020                636          CMPI    #%0000000000100000,D6
000013F6  6700 00B0                637          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013FA                           638          
000013FA  0C46 0028                639          CMPI    #%0000000000101000,D6
000013FE  6700 00A8                640          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001402                           641          
00001402  0C46 0030                642          CMPI    #%0000000000110000,D6
00001406  6700 00A0                643          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
0000140A                           644          
0000140A  0C46 0038                645          CMPI    #%0000000000111000,D6
0000140E  6700 0046                646          BEQ     TWOWORDLEA          * it's not LEA, we dont know what it is
00001412                           647          
00001412                           648          * check to make sure it is a supported mode and size
00001412                           649          
00001412  43F9 00001CB1            650          LEA     LEAOP,A1
00001418  103C 000E                651          MOVE.B  #14,D0          * Print LEA
0000141C  4E4F                     652          TRAP    #15
0000141E                           653          
0000141E  0882 0007                654          BCLR    #7,D2
00001422  0882 0008                655          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001426                           656          
00001426  43F9 00001D0D            657          LEA     SPACE,A1
0000142C  103C 000E                658          MOVE.B  #14,D0          * Print SPACE
00001430  4E4F                     659          TRAP    #15
00001432                           660          
00001432  6100 0242                661          BSR     EAHELPER05
00001436                           662          
00001436  43F9 00001D13            663          LEA     COMMA,A1
0000143C  103C 000E                664          MOVE.B  #14,D0          * Print COMMA
00001440  4E4F                     665          TRAP    #15
00001442                           666          
00001442  6100 01F0                667          BSR     EAHELPER611
00001446                           668          
00001446  43F9 00001C8E            669          LEA     NEWLINE,A1
0000144C  103C 000E                670          MOVE.B  #14,D0          * Start a new line
00001450  4E4F                     671          TRAP    #15
00001452                           672          
00001452                           673          
00001452                           674          * call EA helper
00001452                           675          * MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001452                           676                  
00001452  6000 0058                677          BRA     DONE0100          * we already found instruction, next iteration
00001456                           678          
00001456                           679  TWOWORDLEA
00001456                           680  
00001456  43F9 00001CB1            681          LEA     LEAOP,A1
0000145C  103C 000E                682          MOVE.B  #14,D0   * Print LEA
00001460  4E4F                     683          TRAP    #15
00001462                           684          
00001462  43F9 00001D0D            685          LEA     SPACE,A1
00001468  103C 000E                686          MOVE.B  #14,D0   * Print SPACE
0000146C  4E4F                     687          TRAP    #15
0000146E                           688  
0000146E  321A                     689          MOVE.W  (A2)+,D1
00001470                           690          
00001470  7C00                     691          MOVE.L  #0,D6
00001472  7E0F                     692          MOVE.L  #15,D7
00001474                           693          
00001474  6100 07D4                694          BSR     BITMASK
00001478                           695          
00001478  C286                     696          AND.L   D6,D1   * shave off bad info
0000147A                           697          
0000147A  103C 0003                698          MOVE.B  #3,D0   * Print the address which was the source
0000147E  4E4F                     699          TRAP    #15
00001480                           700          
00001480  43F9 00001D13            701          LEA     COMMA,A1
00001486  103C 000E                702          MOVE.B  #14,D0  * Print COMMA
0000148A  4E4F                     703          TRAP    #15
0000148C                           704          
0000148C  0882 0007                705          BCLR    #7,D2
00001490  0882 0008                706          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001494                           707          
00001494  6100 019E                708          BSR     EAHELPER611
00001498                           709          
00001498  43F9 00001C8E            710          LEA     NEWLINE,A1
0000149E  103C 000E                711          MOVE.B  #14,D0          * Start a new line
000014A2  4E4F                     712          TRAP    #15
000014A4                           713          
000014A4  6000 0006                714          BRA     DONE0100
000014A8                           715          
000014A8                           716  UNKNOWN0100 *dont know what it is
000014A8  6100 05E8                717          BSR     UNKNOWNOP
000014AC                           718          
000014AC                           719  DONE0100
000014AC  4C9F 0303                720          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000014B0  4E75                     721          RTS
000014B2                           722          
000014B2  6000 FC90                723          BRA     ITERATION
000014B6                           724  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014B6                           725  *-----------------------------------------------------------------------------        
000014B6                           726          
000014B6                           727          
000014B6                           728  
000014B6                           729  *-----------------------------------------------------------------------------
000014B6                           730  *-----------------------------------------------------------------------------
000014B6                           731  * NAME: OP_0101   (SUBQ)
000014B6                           732  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000014B6                           733  * PRE-CONDITION:  xyz
000014B6                           734  * POST-CONDITION: All registers return to their previous state, and the output
000014B6                           735  *                 goes to the output console for reading the raw data or the
000014B6                           736  *                 actual instruction.
000014B6                           737  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000014B6                           738  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014B6                           739  OP0101
000014B6                           740  
000014B6  6100 05DA                741      BSR     UNKNOWNOP
000014BA  4E75                     742      RTS
000014BC                           743  
000014BC                           744  * testing branching
000014BC                           745  * op op op
000014BC                           746  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014BC                           747  *-----------------------------------------------------------------------------
000014BC                           748  
000014BC                           749  
000014BC                           750  
000014BC                           751  *-----------------------------------------------------------------------------
000014BC                           752  *-----------------------------------------------------------------------------
000014BC                           753  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
000014BC                           754  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000014BC                           755  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
000014BC                           756  *                 in the instruction and determines what the bits match to a
000014BC                           757  *                 given condition code. If the 8 bit offset is $00, or $FF,
000014BC                           758  *                 this signifies a word or long offset (for $00 and $FF
000014BC                           759  *                 respectively). The 8 bit offset is in 2's comp. form, and
000014BC                           760  *                 should be un-done, then plus or minus to the current
000014BC                           761  *                 program counter (PC) to get the actual memory label to
000014BC                           762  *                 output to console. The word offset signal eats an
000014BC                           763  *                 additional 16 bits and the long offset eats an additional
000014BC                           764  *                 32 bits. The word/long offset are for memory alignment.
000014BC                           765  * POST-CONDITION: All registers return to their previous state, and the output
000014BC                           766  *                 goes to the output console for reading the raw data or the
000014BC                           767  *                 actual instruction.
000014BC                           768  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000014BC                           769  *                 A1 (output)
000014BC                           770  * CONDITIONS TABLE:
000014BC                           771  *                Condition Names  - Mnemonic - Condition Code
000014BC                           772  *                --------------------------------------------
000014BC                           773  *                True             -    T     - 0000
000014BC                           774  *                False            -    F     - 0001
000014BC                           775  *                Higher           -    HI    - 0010
000014BC                           776  *                Lower or Same    -    LS    - 0011
000014BC                           777  *                Carry Clear      -    CC    - 0100
000014BC                           778  *                Carry Set        -    CS    - 0101
000014BC                           779  *                Not Equal        -    NE    - 0110
000014BC                           780  *                Equal            -    EQ    - 0111
000014BC                           781  *                Overflow Clear   -    VC    - 1000
000014BC                           782  *                Overflow Set     -    VS    - 1001
000014BC                           783  *                Plus             -    PL    - 1010
000014BC                           784  *                Minus            -    MI    - 1011
000014BC                           785  *                Greater or Equal -    GE    - 1100
000014BC                           786  *                Less Than        -    LT    - 1101
000014BC                           787  *                Greater Than     -    GT    - 1110
000014BC                           788  *                Less or Equal    -    LE    - 1111
000014BC                           789  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014BC                           790  OP0110
000014BC  48A7 C0C0                791          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
000014C0                           792          
000014C0                           793          * Ready four bits to help distinguish op's with the 0110 prefix
000014C0  3C3C 0000                794          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
000014C4                           795                                        * BITMASK sub-routine call)
000014C4  3E3C 0007                796          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
000014C8                           797                                        * BITMASK sub-routine call)
000014C8                           798                                        
000014C8                           799          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
000014C8  6100 0780                800          BSR     BITMASK               * Call BITMASK sub-routine
000014CC                           801                                        * Returns a bitmask in D6
000014CC                           802          
000014CC  CC42                     803          AND     D2,D6                 * And the index op, which was pre-loaded
000014CE                           804                                        * in the main memory loop with the bitmask
000014CE                           805                                        * to use to determine what case we need.
000014CE                           806          
000014CE                           807          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
000014CE                           808          * $00 == word offset, $FF == long offset
000014CE                           809       ***CMPI    #%0000000000000000,D6
000014CE                           810       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
000014CE                           811       ***
000014CE                           812       ***CMPI    #%0000000011111111,D6
000014CE                           813       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
000014CE                           814          
000014CE                           815          * IF PASSED BOTH CMPI CHECKS (ABOVE),
000014CE                           816          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
000014CE                           817          
000014CE  3C3C 0009                818          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
000014D2  3E3C 000B                819          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
000014D6                           820                                        
000014D6                           821          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
000014D6  6100 0772                822          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
000014DA  CC42                     823          AND     D2,D6   * apply the BITMASK
000014DC                           824          
000014DC                           825          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
000014DC  0C46 0400                826          CMPI    #%0000010000000000,D6
000014E0  6700 002A                827          BEQ     OP_BCC
000014E4                           828          
000014E4                           829          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
000014E4  0C46 0500                830          CMPI    #%0000010100000000,D6
000014E8  6700 002C                831          BEQ     OP_BCS
000014EC                           832          
000014EC                           833          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
000014EC  0C46 0C00                834          CMPI    #%0000110000000000,D6
000014F0  6700 002E                835          BEQ     OP_BGE
000014F4                           836          
000014F4                           837          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
000014F4  0C46 0D00                838          CMPI    #%0000110100000000,D6
000014F8  6700 0030                839          BEQ     OP_BLT
000014FC                           840          
000014FC                           841          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
000014FC  0C46 0800                842          CMPI    #%0000100000000000,D6
00001500  6700 0032                843          BEQ     OP_BVC
00001504                           844          
00001504                           845          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
00001504                           846          * NOTE: A branch to the immediately following instruction automatically
00001504                           847          *       uses the 16-bit displacement format because the 8-bit displacement
00001504                           848          *       field contains $00 zero offset
00001504                           849          * http://68k.hax.com/BRA
00001504                           850          * NOTE2 ---> Does this mean, there should be no checks when debugging
00001504                           851          *            for word/long offsets?
00001504  0C46 0000                852          CMPI    #%0000000000000000,D6
00001508  6700 0034                853          BEQ     OP_BRA
0000150C                           854          
0000150C                           855          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
0000150C                           856          ; call raw data print out sub routine
0000150C                           857  
0000150C                           858  OP_BCC
0000150C  43F9 00001CCF            859          LEA     OP_BCC_MSG,A1
00001512  6000 0034                860          BRA     OP_BRANCHES_PRINT
00001516                           861  OP_BCS
00001516  43F9 00001CD4            862          LEA     OP_BCS_MSG,A1
0000151C  6000 002A                863          BRA     OP_BRANCHES_PRINT
00001520                           864  OP_BGE
00001520  43F9 00001CD9            865          LEA     OP_BGE_MSG,A1
00001526  6000 0020                866          BRA     OP_BRANCHES_PRINT
0000152A                           867  OP_BLT
0000152A  43F9 00001CDE            868          LEA     OP_BLT_MSG,A1
00001530  6000 0016                869          BRA     OP_BRANCHES_PRINT
00001534                           870  OP_BVC
00001534  43F9 00001CE3            871          LEA     OP_BVC_MSG,A1
0000153A  6000 000C                872          BRA     OP_BRANCHES_PRINT
0000153E                           873  OP_BRA
0000153E  43F9 00001CE8            874          LEA     OP_BRA_MSG,A1
00001544  6000 0002                875          BRA     OP_BRANCHES_PRINT
00001548                           876  
00001548                           877  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
00001548                           878          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
00001548                           879          * assemble output to console
00001548                           880  OP_BRANCHES_PRINT
00001548  103C 000E                881          MOVE.B  #14,D0 * print instruction op
0000154C  4E4F                     882          TRAP    #15
0000154E                           883          
0000154E  43F9 00001CC7            884          LEA     DATA,A1
00001554  103C 000E                885          MOVE.B  #14,D0 * print raw data hex of the LABEL
00001558  4E4F                     886          TRAP    #15
0000155A                           887          
0000155A  1A1A                     888          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
0000155C  2845                     889          MOVE.L  D5,A4 * ready the 8bits into a4
0000155E  43D4                     890          LEA     (A4),A1 * ready the a4 into a1 for print
00001560  103C 000E                891          MOVE.B  #14,D0 * print the 8bit addr
00001564  4E4F                     892          TRAP    #15
00001566                           893  
00001566  6000 0002                894          BRA     BCC_END
0000156A                           895  
0000156A                           896  BCC_END * reload the memory, call RTS
0000156A  4C9F 0303                897          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
0000156E  4E75                     898          RTS
00001570                           899  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001570                           900  *-----------------------------------------------------------------------------
00001570                           901  
00001570                           902  
00001570                           903  
00001570                           904  *-----------------------------------------------------------------------------
00001570                           905  *-----------------------------------------------------------------------------
00001570                           906  * NAME: OP_0111   ()
00001570                           907  * DESCRIPTION:    OP code 0111 is not supported. 
00001570                           908  * PRE-CONDITION:  
00001570                           909  * POST-CONDITION: 
00001570                           910  * REGISTERS:
00001570                           911  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001570                           912  OP0111
00001570  6100 0520                913      BSR     UNKNOWNOP
00001574  4E75                     914      RTS
00001576                           915  
00001576                           916  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001576                           917  *-----------------------------------------------------------------------------
00001576                           918  
00001576                           919  
00001576                           920  
00001576                           921  *-----------------------------------------------------------------------------
00001576                           922  *-----------------------------------------------------------------------------
00001576                           923  * NAME: OP_1000   (DIVS, OR)
00001576                           924  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001576                           925  * PRE-CONDITION:  xyz
00001576                           926  * POST-CONDITION: All registers return to their previous state, and the output
00001576                           927  *                 goes to the output console for reading the raw data or the
00001576                           928  *                 actual instruction.
00001576                           929  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001576                           930  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001576                           931  OP1000
00001576                           932          * Saving values to the stack
00001576  48A7 FFC0                933          MOVEM   D0-D7/A0-A1,-(A7)
0000157A                           934  
0000157A                           935          * Check if the EA Mode is 001 since both DIVS and OR do not support it
0000157A  3C3C 0003                936          MOVE.W  #3, D6              * Prep lower value for bitmask
0000157E  3E3C 0005                937          MOVE.W  #5, D7              * Prep upper value for bitmask
00001582  6100 06C6                938          BSR     BITMASK             * Finalize bitmask setup
00001586  CC42                     939          AND     D2,D6               * Apply bitmask
00001588                           940          
00001588  0C46 0008                941          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
0000158C  6700 0504                942          BEQ     UNKNOWNOP                 * If so, the op is not supported
00001590                           943          
00001590                           944          * Checking for DIVS
00001590  3C3C 0006                945          MOVE.W  #6, D6              * Prep lower value for bitmask
00001594  3E3C 0008                946          MOVE.W  #8, D7              * Prep upper value for bitmask
00001598  6100 06B0                947          BSR     BITMASK             * Finalize bitmask setup
0000159C  CC42                     948          AND     D2,D6               * Apply bitmask
0000159E                           949          
0000159E  0C46 01C0                950          CMPI    #%0000000111000000, D6  * Are we DIVS?
000015A2  6600 0050                951          BNE     NOTDIVS                 * If not, branch to see if it's OR
000015A6                           952          
000015A6  43F9 00001C91            953          LEA     DIVSOP,A1           * We found DIVS
000015AC  103C 000E                954          MOVE.B  #14,D0              * Trap #14 prints out the data
000015B0  4E4F                     955          TRAP    #15                 * Perform Trap #14
000015B2                           956          
000015B2  43F9 00001D0D            957          LEA     SPACE,A1            * formatting
000015B8  103C 000E                958          MOVE.B  #14,D0              * Trap #14 prints out space
000015BC  4E4F                     959          TRAP    #15                 * Perform Trap #14
000015BE                           960          
000015BE  4243                     961          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000015C0  08C3 0000                962          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000015C4                           963                                      * to indicate a potential immediate of size word
000015C4                           964          
000015C4  6100 00B0                965          BSR     EAHELPER05          * Print out data. TODO: DOESN'T WORK.
000015C8                           966  
000015C8  43F9 00001D13            967          LEA     COMMA,A1            * formatting
000015CE  103C 000E                968          MOVE.B  #14,D0              * Trap #14 prints out a comma
000015D2  4E4F                     969          TRAP    #15                 * Perform Trap #14
000015D4                           970          
000015D4                           971          * bit manipulation is needed to make the outlier DIVS work
000015D4                           972          * with the generic EAHELPER611
000015D4  0882 0006                973          BCLR    #6,D2
000015D8  0882 0007                974          BCLR    #7,D2
000015DC  0882 0008                975          BCLR    #8,D2
000015E0                           976          
000015E0                           977          * the above bits were cleared so that eahelper05 knows the destination
000015E0                           978          * is a data register.
000015E0                           979          
000015E0  6100 0052                980          BSR     EAHELPER611 
000015E4                           981  
000015E4  43F9 00001C8E            982          LEA     NEWLINE,A1          * We found DIVS
000015EA  103C 000E                983          MOVE.B  #14,D0              * Trap #14 prints out the data
000015EE  4E4F                     984          TRAP    #15                 * Perform Trap #14
000015F0                           985          
000015F0  6000 0012                986          BRA     OP1000END
000015F4                           987          
000015F4                           988  NOTDIVS * It is confirmed OR at this point
000015F4  43F9 00001CBB            989          LEA     OROP,A1         * We found OR
000015FA  103C 000E                990          MOVE.B  #14,D0          * Trap #14 prints out the data
000015FE  4E4F                     991          TRAP    #15             * Perform Trap #14
00001600                           992          *================================================================
00001600                           993          * todo, move the size of the operation into the leading bits of D5
00001600                           994          * before subroutine call
00001600  6100 0032                995          BSR     EAHELPER611
00001604                           996  
00001604                           997  OP1000END
00001604  4C9F 03FF                998          MOVEM   (A7)+,D0-D7/A0-A1
00001608  4E75                     999          RTS
0000160A                          1000  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000160A                          1001  *-----------------------------------------------------------------------------
0000160A                          1002  
0000160A                          1003  
0000160A                          1004  
0000160A                          1005  *-----------------------------------------------------------------------------
0000160A                          1006  *-----------------------------------------------------------------------------
0000160A                          1007  * NAME: OP_1001   (SUB)
0000160A                          1008  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000160A                          1009  * PRE-CONDITION:  xyz
0000160A                          1010  * POST-CONDITION: All registers return to their previous state, and the output
0000160A                          1011  *                 goes to the output console for reading the raw data or the
0000160A                          1012  *                 actual instruction.
0000160A                          1013  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000160A                          1014  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000160A                          1015  OP1001
0000160A                          1016  
0000160A  6100 0486               1017      BSR     UNKNOWNOP
0000160E  4E75                    1018      RTS
00001610                          1019  
00001610                          1020  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001610                          1021  *-----------------------------------------------------------------------------
00001610                          1022  
00001610                          1023  
00001610                          1024  
00001610                          1025  *-----------------------------------------------------------------------------
00001610                          1026  *-----------------------------------------------------------------------------
00001610                          1027  * NAME: OP_1010   ()
00001610                          1028  * DESCRIPTION:    a
00001610                          1029  * PRE-CONDITION:  b
00001610                          1030  * POST-CONDITION: c
00001610                          1031  * REGISTERS:      d
00001610                          1032  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001610                          1033  OP1010
00001610                          1034  
00001610  6100 0480               1035      BSR     UNKNOWNOP
00001614  4E75                    1036      RTS
00001616                          1037  
00001616                          1038  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001616                          1039  *-----------------------------------------------------------------------------
00001616                          1040  
00001616                          1041  
00001616                          1042  
00001616                          1043  *-----------------------------------------------------------------------------
00001616                          1044  *-----------------------------------------------------------------------------
00001616                          1045  * NAME: OP_1011   (EOR, CMP)
00001616                          1046  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001616                          1047  * PRE-CONDITION:  xyz
00001616                          1048  * POST-CONDITION: All registers return to their previous state, and the output
00001616                          1049  *                 goes to the output console for reading the raw data or the
00001616                          1050  *                 actual instruction.
00001616                          1051  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001616                          1052  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001616                          1053  OP1011
00001616                          1054  
00001616  6100 047A               1055      BSR     UNKNOWNOP
0000161A  4E75                    1056      RTS
0000161C                          1057  
0000161C                          1058  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000161C                          1059  *-----------------------------------------------------------------------------
0000161C                          1060  
0000161C                          1061  
0000161C                          1062  
0000161C                          1063  *-----------------------------------------------------------------------------
0000161C                          1064  *-----------------------------------------------------------------------------
0000161C                          1065  * NAME: OP_1100   (MULS)
0000161C                          1066  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000161C                          1067  * PRE-CONDITION:  xyz
0000161C                          1068  * POST-CONDITION: All registers return to their previous state, and the output
0000161C                          1069  *                 goes to the output console for reading the raw data or the
0000161C                          1070  *                 actual instruction.
0000161C                          1071  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000161C                          1072  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000161C                          1073  OP1100
0000161C                          1074  
0000161C  6100 0474               1075      BSR     UNKNOWNOP
00001620  4E75                    1076      RTS
00001622                          1077  
00001622                          1078  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001622                          1079  *-----------------------------------------------------------------------------
00001622                          1080  
00001622                          1081  
00001622                          1082  
00001622                          1083  *-----------------------------------------------------------------------------
00001622                          1084  *-----------------------------------------------------------------------------
00001622                          1085  * NAME: OP_1101   (ADD, ADDA)
00001622                          1086  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001622                          1087  * PRE-CONDITION:  xyz
00001622                          1088  * POST-CONDITION: All registers return to their previous state, and the output
00001622                          1089  *                 goes to the output console for reading the raw data or the
00001622                          1090  *                 actual instruction.
00001622                          1091  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001622                          1092  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001622                          1093  OP1101
00001622                          1094  
00001622  6100 046E               1095      BSR     UNKNOWNOP
00001626  4E75                    1096      RTS
00001628                          1097  
00001628                          1098  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001628                          1099  *-----------------------------------------------------------------------------
00001628                          1100  
00001628                          1101  
00001628                          1102  
00001628                          1103  *-----------------------------------------------------------------------------
00001628                          1104  *-----------------------------------------------------------------------------
00001628                          1105  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
00001628                          1106  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001628                          1107  * PRE-CONDITION:  xyz
00001628                          1108  * POST-CONDITION: All registers return to their previous state, and the output
00001628                          1109  *                 goes to the output console for reading the raw data or the
00001628                          1110  *                 actual instruction.
00001628                          1111  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001628                          1112  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001628                          1113  OP1110
00001628                          1114  
00001628  6100 0468               1115      BSR     UNKNOWNOP
0000162C  4E75                    1116      RTS
0000162E                          1117  
0000162E                          1118  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000162E                          1119  *-----------------------------------------------------------------------------
0000162E                          1120  
0000162E                          1121  
0000162E                          1122  
0000162E                          1123  *-----------------------------------------------------------------------------
0000162E                          1124  *-----------------------------------------------------------------------------
0000162E                          1125  * NAME: OP_1111   ()
0000162E                          1126  * DESCRIPTION:    a
0000162E                          1127  * PRE-CONDITION:  b
0000162E                          1128  * POST-CONDITION: c
0000162E                          1129  * REGISTERS:      d
0000162E                          1130  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000162E                          1131  OP1111
0000162E                          1132  
0000162E  6100 0462               1133      BSR     UNKNOWNOP
00001632  4E75                    1134      RTS
00001634                          1135  
00001634                          1136  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001634                          1137  *-----------------------------------------------------------------------------
00001634                          1138  
00001634                          1139  
00001634                          1140  
00001634                          1141  *-----------------------------------------------------------------------------
00001634                          1142  *-----------------------------------------------------------------------------
00001634                          1143  * NAME:           EAHELPER611
00001634                          1144  * DESCRIPTION:    a
00001634                          1145  * PRE-CONDITION:  D2 contains the instruction to print modes for.
00001634                          1146  *                 D5 contains the size of the data to be printed
00001634                          1147  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
00001634                          1148  *                 EAHELPER05 to print.
00001634                          1149  * REGISTERS:      a
00001634                          1150  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001634                          1151  EAHELPER611
00001634  48A7 FFC0               1152      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
00001638                          1153      
00001638  3C3C 0006               1154      MOVE.W  #6, D6              * Prep lower value for bitmask
0000163C  3E3C 0008               1155      MOVE.W  #8, D7              * Prep upper value for bitmask
00001640  6100 0608               1156      BSR     BITMASK             * Finalize bitmask setup
00001644  CC42                    1157      AND     D2,D6               * Apply bitmask
00001646                          1158      
00001646                          1159      * to move the mode where EAHELPER50 can process it
00001646  7C06                    1160      MOVE.L  #6,D6
00001648  7E08                    1161      MOVE.L  #8,D7
0000164A                          1162      
0000164A  6100 05FE               1163      BSR     BITMASK * create bitmask
0000164E                          1164      
0000164E  CC42                    1165      AND     D2,D6   * apply bitmask
00001650                          1166      
00001650  4243                    1167      CLR     D3      * prep D3 to store values
00001652                          1168      
00001652  3606                    1169      MOVE.W  D6,D3   * store bitmasked value in D3
00001654                          1170      
00001654  E64B                    1171      LSR     #3,D3   * move bits 6-8 to 3-5
00001656                          1172      
00001656                          1173      * to move the register where EAHELPER50 can process it
00001656  7C09                    1174      MOVE.L  #9,D6   *prep registers to create bitmask
00001658  7E0B                    1175      MOVE.L  #11,D7
0000165A                          1176      
0000165A  6100 05EE               1177      BSR     BITMASK * create bitmask
0000165E                          1178      
0000165E  CC42                    1179      AND     D2,D6   * apply bitmask
00001660                          1180      
00001660  4244                    1181      CLR     D4      * prep D3 to store values
00001662                          1182      
00001662  3806                    1183      MOVE.W  D6,D4   * store bitmasked value in D3
00001664                          1184      
00001664  E04C                    1185      LSR     #8,D4   * move bits 9-11 to 0-2
00001666  E24C                    1186      LSR     #1,D4   * move bits 9-11 to 0-2
00001668                          1187      
00001668  8684                    1188      OR.L    D4,D3   * combind the register and mode
0000166A                          1189      
0000166A  2403                    1190      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
0000166C                          1191      
0000166C  6100 0008               1192      BSR     EAHELPER05
00001670                          1193      
00001670                          1194  ENDEAHELPER611
00001670                          1195      
00001670  4C9F 03FF               1196      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
00001674                          1197      
00001674  4E75                    1198      RTS
00001676                          1199  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001676                          1200  *-----------------------------------------------------------------------------
00001676                          1201  
00001676                          1202  
00001676                          1203  
00001676                          1204  *-----------------------------------------------------------------------------
00001676                          1205  *-----------------------------------------------------------------------------
00001676                          1206  * NAME:           EAHELPER05
00001676                          1207  * DESCRIPTION:    a
00001676                          1208  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
00001676                          1209  *                 this sub-routine helper for operations that only have one
00001676                          1210  *                 mode register.
00001676                          1211  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
00001676                          1212  * REGISTERS:      a
00001676                          1213  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001676                          1214  EAHELPER05
00001676                          1215      * todo: add code for printing immediate values
00001676                          1216      
00001676  48A7 FFC0               1217      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
0000167A                          1218      
0000167A  7C03                    1219      MOVE.L  #3,D6
0000167C  7E05                    1220      MOVE.L  #5,D7
0000167E                          1221      
0000167E  6100 05CA               1222      BSR     BITMASK * generate a bitmask to identify the mode
00001682                          1223      
00001682  CC42                    1224      AND     D2,D6   * mask off the parts of D2 we don't need
00001684                          1225      
00001684  2A06                    1226      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
00001686                          1227      
00001686  0C46 0000               1228      CMPI    #%0000000000000000,D6 * is it data register direct?
0000168A  6600 000A               1229      BNE     NOTDATAREG
0000168E                          1230      
0000168E  6100 013C               1231      BSR     MODE_DN
00001692                          1232       
00001692  6000 0132               1233      BRA     ENDEAHELPER05
00001696                          1234      
00001696                          1235  NOTDATAREG * address register direct
00001696                          1236      
00001696  0C46 0008               1237      CMPI    #%0000000000001000,D6 * is it address register direct?
0000169A  6600 000A               1238      BNE     NOTADRDIRECT
0000169E                          1239      
0000169E  6100 022C               1240      BSR     MODE_AN * simply prints out the address register
000016A2                          1241       
000016A2  6000 0122               1242      BRA     ENDEAHELPER05
000016A6                          1243      
000016A6                          1244  NOTADRDIRECT * address register indirect
000016A6                          1245          
000016A6  0C46 0010               1246      CMPI    #%0000000000010000,D6 * is it address register indirect?
000016AA  6600 0022               1247      BNE     NOTADRINDIRECT
000016AE                          1248      
000016AE  43F9 00001D15           1249      LEA     OBRACK,A1       * Load '('
000016B4  303C 000E               1250      MOVE.W  #14,D0          * Trap #14 to display message
000016B8  4E4F                    1251      TRAP    #15             * Perform #14
000016BA                          1252          
000016BA                          1253  
000016BA  6100 0210               1254      BSR     MODE_AN * print out an address register
000016BE                          1255      
000016BE  43F9 00001D17           1256      LEA     CBRACK,A1       * Load ')'
000016C4  303C 000E               1257      MOVE.W  #14,D0          * Trap #14 to display message
000016C8  4E4F                    1258      TRAP    #15             * Perform #14
000016CA                          1259       
000016CA  6000 00FA               1260      BRA     ENDEAHELPER05
000016CE                          1261      
000016CE                          1262  NOTADRINDIRECT * address register indirect, post increment
000016CE                          1263      
000016CE  0C46 0018               1264      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
000016D2  6600 002E               1265      BNE     NOTADRINDIRECTPOST
000016D6                          1266      
000016D6  43F9 00001D15           1267      LEA     OBRACK,A1       * Load '('
000016DC  303C 000E               1268      MOVE.W  #14,D0          * Trap #14 to display message
000016E0  4E4F                    1269      TRAP    #15             * Perform #14
000016E2                          1270          
000016E2                          1271  
000016E2  6100 01E8               1272      BSR     MODE_AN * print out an address register
000016E6                          1273      
000016E6  43F9 00001D17           1274      LEA     CBRACK,A1       * Load ')'
000016EC  303C 000E               1275      MOVE.W  #14,D0          * Trap #14 to display message
000016F0  4E4F                    1276      TRAP    #15             * Perform #14
000016F2                          1277      
000016F2  43F9 00001D19           1278      LEA     PLUS,A1       * Load '+'
000016F8  303C 000E               1279      MOVE.W  #14,D0          * Trap #14 to display message
000016FC  4E4F                    1280      TRAP    #15             * Perform #14
000016FE                          1281       
000016FE  6000 00C6               1282      BRA     ENDEAHELPER05
00001702                          1283      
00001702                          1284  NOTADRINDIRECTPOST * address register indirect, pre decrement
00001702                          1285      
00001702  0C46 0020               1286      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
00001706  6600 002E               1287      BNE     NOTADRINDIRECTPRE
0000170A                          1288      
0000170A  43F9 00001D1B           1289      LEA     MINUS,A1       * Load '-'
00001710  303C 000E               1290      MOVE.W  #14,D0          * Trap #14 to display message
00001714  4E4F                    1291      TRAP    #15             * Perform #14
00001716                          1292      
00001716  43F9 00001D15           1293      LEA     OBRACK,A1       * Load '('
0000171C  303C 000E               1294      MOVE.W  #14,D0          * Trap #14 to display message
00001720  4E4F                    1295      TRAP    #15             * Perform #14
00001722                          1296          
00001722                          1297  
00001722  6100 01A8               1298      BSR     MODE_AN * print out an address register
00001726                          1299      
00001726  43F9 00001D17           1300      LEA     CBRACK,A1       * Load ')'
0000172C  303C 000E               1301      MOVE.W  #14,D0          * Trap #14 to display message
00001730  4E4F                    1302      TRAP    #15             * Perform #14
00001732                          1303       
00001732  6000 0092               1304      BRA     ENDEAHELPER05
00001736                          1305  
00001736                          1306  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
00001736                          1307  
00001736  0C46 0038               1308      CMPI    #%0000000000111000,D6 * is it immediate?
0000173A  6600 0086               1309      BNE     NOTIMMEDIATE
0000173E                          1310  
0000173E  0C43 0001               1311      CMPI    #1,D3 * is it a byte?
00001742  6600 0028               1312      BNE     NOTIMMBYTE
00001746                          1313      
00001746  43F9 00001D11           1314      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000174C  103C 000E               1315      MOVE.B  #14,D0
00001750  4E4F                    1316      TRAP    #15
00001752                          1317      
00001752  3C3C 0000               1318      MOVE.W  #0, D6              * Prep lower value for bitmask
00001756  3E3C 0007               1319      MOVE.W  #7, D7              * Prep upper value for bitmask
0000175A  6100 04EE               1320      BSR     BITMASK             * Finalize bitmask setup
0000175E                          1321          
0000175E  321A                    1322      MOVE.W  (A2)+,D1
00001760                          1323      
00001760  C286                    1324      AND.L     D6,D1
00001762                          1325          
00001762  103C 0003               1326      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001766  4E4F                    1327      TRAP    #15      * Perform Trap #3
00001768                          1328      
00001768  6000 005C               1329      BRA     ENDEAHELPER05
0000176C                          1330  
0000176C                          1331  NOTIMMBYTE
0000176C                          1332      
0000176C  0C43 0002               1333      CMPI    #2,D3 * is it a word?
00001770  6600 0028               1334      BNE     NOTIMMWORD
00001774                          1335      
00001774  43F9 00001D11           1336      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000177A  103C 000E               1337      MOVE.B  #14,D0
0000177E  4E4F                    1338      TRAP    #15
00001780                          1339      
00001780  3C3C 0000               1340      MOVE.W  #0, D6              * Prep lower value for bitmask
00001784  3E3C 000F               1341      MOVE.W  #15, D7             * Prep upper value for bitmask
00001788  6100 04C0               1342      BSR     BITMASK             * Finalize bitmask setup
0000178C                          1343          
0000178C  321A                    1344      MOVE.W  (A2)+,D1
0000178E                          1345      
0000178E  C286                    1346      AND.L     D6,D1               * Apply bitmask
00001790                          1347          
00001790  103C 0003               1348      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001794  4E4F                    1349      TRAP    #15      * Perform Trap #3
00001796                          1350      
00001796  6000 002E               1351      BRA     ENDEAHELPER05
0000179A                          1352      
0000179A                          1353  NOTIMMWORD
0000179A  0C43 0003               1354      CMPI    #3,D3 * is it a long?
0000179E  6600 0022               1355      BNE     NOTIMMEDIATE
000017A2                          1356      
000017A2  43F9 00001D11           1357      LEA     IMD,A1 *print out the '#' indicating an immediate value
000017A8  103C 000E               1358      MOVE.B  #14,D0
000017AC  4E4F                    1359      TRAP    #15
000017AE                          1360          
000017AE  221A                    1361      MOVE.L  (A2)+,D1
000017B0                          1362          
000017B0  103C 0003               1363      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000017B4  4E4F                    1364      TRAP    #15      * Perform Trap #3
000017B6                          1365      
000017B6  321A                    1366      MOVE.W  (A2)+,D1
000017B8                          1367          
000017B8  103C 0003               1368      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000017BC  4E4F                    1369      TRAP    #15      * Perform Trap #3
000017BE                          1370      
000017BE  6000 0006               1371      BRA     ENDEAHELPER05
000017C2                          1372  
000017C2                          1373  NOTIMMEDIATE    
000017C2                          1374  
000017C2                          1375  
000017C2  6100 02CE               1376      BSR     UNKNOWNOP
000017C6                          1377      
000017C6                          1378  ENDEAHELPER05
000017C6  4C9F 03FF               1379      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
000017CA  4E75                    1380      RTS
000017CC                          1381  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000017CC                          1382  *-----------------------------------------------------------------------------
000017CC                          1383  
000017CC                          1384  
000017CC                          1385  
000017CC                          1386  *-----------------------------------------------------------------------------
000017CC                          1387  *-----------------------------------------------------------------------------
000017CC                          1388  * NAME:           MODE_DN
000017CC                          1389  * DESCRIPTION:    Generalize the EA part of the project.
000017CC                          1390  * PRE-CONDITION:  The mode must have been correctly identified. All modes
000017CC                          1391  *                 must be called by RTS.
000017CC                          1392  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
000017CC                          1393  *                 called it.
000017CC                          1394  * REGISTERS:      a
000017CC                          1395  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000017CC                          1396  * ---> Dn
000017CC                          1397  MODE_DN
000017CC  48A7 FFC0               1398          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000017D0                          1399  
000017D0  3C3C 0000               1400          MOVE.W  #0, D6              * Prep lower value for bitmask
000017D4  3E3C 0002               1401          MOVE.W  #2, D7              * Prep upper value for bitmask
000017D8  6100 0470               1402          BSR     BITMASK             * Finalize bitmask setup
000017DC  CC42                    1403          AND     D2,D6               * Apply bitmask
000017DE                          1404          
000017DE  0C46 0000               1405          CMPI    #%000000000000000, D6   * Data Register D0?
000017E2  6600 000A               1406          BNE     NOTD0
000017E6                          1407          
000017E6  6100 0074               1408          BSR     PRINTD0
000017EA  6000 006A               1409          BRA     ENDMODE_DN
000017EE                          1410  NOTD0      
000017EE  0C46 0001               1411          CMPI    #%000000000000001, D6   * Data Register D1?
000017F2  6600 000A               1412          BNE     NOTD1
000017F6                          1413          
000017F6  6100 0072               1414          BSR     PRINTD1
000017FA  6000 005A               1415          BRA     ENDMODE_DN
000017FE                          1416  NOTD1
000017FE  0C46 0002               1417          CMPI    #%000000000000010, D6   * Data Register D2?
00001802  6600 000A               1418          BNE     NOTD2
00001806                          1419          
00001806  6100 0070               1420          BSR     PRINTD2
0000180A  6000 004A               1421          BRA     ENDMODE_DN
0000180E                          1422  NOTD2
0000180E  0C46 0003               1423          CMPI    #%000000000000011, D6   * Data Register D3?
00001812  6600 000A               1424          BNE     NOTD3
00001816                          1425          
00001816  6100 006E               1426          BSR     PRINTD3
0000181A  6000 003A               1427          BRA     ENDMODE_DN
0000181E                          1428  NOTD3
0000181E  0C46 0004               1429          CMPI    #%000000000000100, D6   * Data Register D4?
00001822  6600 000A               1430          BNE     NOTD4
00001826                          1431          
00001826  6100 006C               1432          BSR     PRINTD4
0000182A  6000 002A               1433          BRA     ENDMODE_DN
0000182E                          1434  NOTD4
0000182E  0C46 0005               1435          CMPI    #%000000000000101, D6   * Data Register D5?
00001832  6600 000A               1436          BNE     NOTD5
00001836                          1437          
00001836  6100 006A               1438          BSR     PRINTD5
0000183A  6000 001A               1439          BRA     ENDMODE_DN
0000183E                          1440  NOTD5
0000183E  0C46 0006               1441          CMPI    #%000000000000110, D6   * Data Register D6?
00001842  6600 000A               1442          BNE     NOTD6
00001846                          1443          
00001846  6100 0068               1444          BSR     PRINTD6
0000184A  6000 000A               1445          BRA     ENDMODE_DN
0000184E                          1446  NOTD6
0000184E  6100 006E               1447          BSR     PRINTD7
00001852  6000 0002               1448          BRA     ENDMODE_DN
00001856                          1449          
00001856                          1450  ENDMODE_DN
00001856  4C9F 03FF               1451          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
0000185A  4E75                    1452          RTS
0000185C                          1453  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000185C                          1454  *-----------------------------------------------------------------------------
0000185C                          1455  
0000185C                          1456  
0000185C                          1457  
0000185C                          1458  *-----------------------------------------------------------------------------
0000185C                          1459  *-----------------------------------------------------------------------------
0000185C                          1460  * NAME:           PRINTD0
0000185C                          1461  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
0000185C                          1462  * PRE-CONDITION:  a
0000185C                          1463  * POST-CONDITION: a
0000185C                          1464  * REGISTERS:      a
0000185C                          1465  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000185C                          1466  PRINTD0
0000185C  43F9 00001D41           1467          LEA     __D0, A1        * Load 'D0'
00001862  103C 000E               1468          MOVE.B  #14, D0         * Load Trap #14 to print out
00001866  4E4F                    1469          TRAP    #15             * Perform Trap #14
00001868  4E75                    1470          RTS
0000186A                          1471  PRINTD1
0000186A  43F9 00001D44           1472          LEA     __D1, A1        * Load 'D1'
00001870  103C 000E               1473          MOVE.B  #14, D0         * Load Trap #14 to print out
00001874  4E4F                    1474          TRAP    #15             * Perform Trap #14
00001876  4E75                    1475          RTS      
00001878                          1476  PRINTD2
00001878  43F9 00001D47           1477          LEA     __D2, A1        * Load 'D2'
0000187E  103C 000E               1478          MOVE.B  #14, D0         * Load Trap #14 to print out
00001882  4E4F                    1479          TRAP    #15             * Perform Trap #14
00001884  4E75                    1480          RTS      
00001886                          1481  PRINTD3
00001886  43F9 00001D4A           1482          LEA     __D3, A1        * Load 'D3'
0000188C  103C 000E               1483          MOVE.B  #14, D0         * Load Trap #14 to print out
00001890  4E4F                    1484          TRAP    #15             * Perform Trap #14
00001892  4E75                    1485          RTS      
00001894                          1486  PRINTD4
00001894  43F9 00001D4D           1487          LEA     __D4, A1        * Load 'D4'
0000189A  103C 000E               1488          MOVE.B  #14, D0         * Load Trap #14 to print out
0000189E  4E4F                    1489          TRAP    #15             * Perform Trap #14
000018A0  4E75                    1490          RTS       
000018A2                          1491  PRINTD5
000018A2  43F9 00001D50           1492          LEA     __D5, A1        * Load 'D5'
000018A8  103C 000E               1493          MOVE.B  #14, D0         * Load Trap #14 to print out
000018AC  4E4F                    1494          TRAP    #15             * Perform Trap #14
000018AE  4E75                    1495          RTS      
000018B0                          1496  PRINTD6
000018B0  43F9 00001D53           1497          LEA     __D6, A1        * Load 'D6'
000018B6  103C 000E               1498          MOVE.B  #14, D0         * Load Trap #14 to print out
000018BA  4E4F                    1499          TRAP    #15             * Perform Trap #14
000018BC  4E75                    1500          RTS
000018BE                          1501  PRINTD7
000018BE  43F9 00001D56           1502          LEA     __D7, A1        * Load 'D7'
000018C4  103C 000E               1503          MOVE.B  #14, D0         * Load Trap #14 to print out
000018C8  4E4F                    1504          TRAP    #15             * Perform Trap #14
000018CA  4E75                    1505          RTS
000018CC                          1506  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018CC                          1507  *-----------------------------------------------------------------------------
000018CC                          1508  
000018CC                          1509  
000018CC                          1510  
000018CC                          1511  *-----------------------------------------------------------------------------
000018CC                          1512  *-----------------------------------------------------------------------------
000018CC                          1513  * NAME:           MODE_AN
000018CC                          1514  * DESCRIPTION:    Simply chooses to print A0-A7.
000018CC                          1515  * PRE-CONDITION:  a
000018CC                          1516  * POST-CONDITION: a
000018CC                          1517  * REGISTERS:      a
000018CC                          1518  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018CC                          1519  MODE_AN
000018CC  48A7 FFC0               1520          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
000018D0                          1521  
000018D0  3C3C 0000               1522          MOVE.W  #0, D6              * Prep lower value for bitmask
000018D4  3E3C 0002               1523          MOVE.W  #2, D7              * Prep upper value for bitmask
000018D8  6100 0370               1524          BSR     BITMASK             * Finalize bitmask setup
000018DC  CC42                    1525          AND     D2,D6               * Apply bitmask
000018DE                          1526          
000018DE  0C46 0000               1527          CMPI    #%000000000000000, D6   * Address Register A0?
000018E2  6600 000A               1528          BNE     NOTA0
000018E6                          1529          
000018E6  6100 0074               1530          BSR     PRINTA0
000018EA                          1531          
000018EA  6000 006A               1532          BRA     ENDMODE_AN
000018EE                          1533  NOTA0      
000018EE  0C46 0001               1534          CMPI    #%000000000000001, D6   * Address Register A1?
000018F2  6600 000A               1535          BNE     NOTA1
000018F6                          1536          
000018F6  6100 0072               1537          BSR     PRINTA1
000018FA                          1538          
000018FA  6000 005A               1539          BRA     ENDMODE_AN
000018FE                          1540  NOTA1
000018FE  0C46 0002               1541          CMPI    #%000000000000010, D6   * Address Register A2?
00001902  6600 000A               1542          BNE     NOTA2
00001906                          1543          
00001906  6100 0070               1544          BSR     PRINTA2
0000190A                          1545          
0000190A  6000 004A               1546          BRA     ENDMODE_AN
0000190E                          1547  NOTA2
0000190E  0C46 0003               1548          CMPI    #%000000000000011, D6   * Address Register A3?
00001912  6600 000A               1549          BNE     NOTA3
00001916                          1550          
00001916  6100 006E               1551          BSR     PRINTA3
0000191A                          1552          
0000191A  6000 003A               1553          BRA     ENDMODE_AN
0000191E                          1554  NOTA3
0000191E  0C46 0004               1555          CMPI    #%000000000000100, D6   * Address Register A4?
00001922  6600 000A               1556          BNE     NOTA4
00001926                          1557          
00001926  6100 006C               1558          BSR     PRINTA4
0000192A                          1559          
0000192A  6000 002A               1560          BRA     ENDMODE_AN
0000192E                          1561  NOTA4
0000192E  0C46 0005               1562          CMPI    #%000000000000101, D6   * Address Register A5?
00001932  6600 000A               1563          BNE     NOTA5
00001936                          1564          
00001936  6100 006A               1565          BSR     PRINTA5
0000193A                          1566          
0000193A  6000 001A               1567          BRA     ENDMODE_AN
0000193E                          1568  NOTA5
0000193E  0C46 0006               1569          CMPI    #%000000000000110, D6   * Address Register A6?
00001942  6600 000A               1570          BNE     NOTA6
00001946                          1571          
00001946  6100 0068               1572          BSR     PRINTA6
0000194A                          1573          
0000194A  6000 000A               1574          BRA     ENDMODE_AN
0000194E                          1575  NOTA6
0000194E  6100 006E               1576          BSR     PRINTA7
00001952                          1577          
00001952  6000 0002               1578          BRA     ENDMODE_AN
00001956                          1579  ENDMODE_AN
00001956  4C9F 03FF               1580          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
0000195A  4E75                    1581          RTS
0000195C                          1582  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000195C                          1583  *-----------------------------------------------------------------------------
0000195C                          1584  
0000195C                          1585  
0000195C                          1586  
0000195C                          1587  *-----------------------------------------------------------------------------
0000195C                          1588  *-----------------------------------------------------------------------------
0000195C                          1589  * NAME:           PRINTA0
0000195C                          1590  * DESCRIPTION:    Simply print out the address register.
0000195C                          1591  * PRE-CONDITION:  a
0000195C                          1592  * POST-CONDITION: a
0000195C                          1593  * REGISTERS:      a
0000195C                          1594  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000195C                          1595  PRINTA0
0000195C  43F9 00001D29           1596          LEA     __A0, A1        * Load 'A0'
00001962  103C 000E               1597          MOVE.B  #14, D0         * Load Trap #14 to print out
00001966  4E4F                    1598          TRAP    #15             * Perform Trap #14
00001968  4E75                    1599          RTS
0000196A                          1600  
0000196A                          1601  PRINTA1
0000196A  43F9 00001D2C           1602          LEA     __A1, A1        * Load 'A1'
00001970  103C 000E               1603          MOVE.B  #14, D0         * Load Trap #14 to print out
00001974  4E4F                    1604          TRAP    #15             * Perform Trap #14
00001976  4E75                    1605          RTS
00001978                          1606          
00001978                          1607  PRINTA2
00001978  43F9 00001D2F           1608          LEA     __A2, A1        * Load 'A2'
0000197E  103C 000E               1609          MOVE.B  #14, D0         * Load Trap #14 to print out
00001982  4E4F                    1610          TRAP    #15             * Perform Trap #14
00001984  4E75                    1611          RTS
00001986                          1612  
00001986                          1613  PRINTA3
00001986  43F9 00001D32           1614          LEA     __A3, A1        * Load 'A3'
0000198C  103C 000E               1615          MOVE.B  #14, D0         * Load Trap #14 to print out
00001990  4E4F                    1616          TRAP    #15             * Perform Trap #14
00001992  4E75                    1617          RTS
00001994                          1618  
00001994                          1619  PRINTA4
00001994  43F9 00001D35           1620          LEA     __A4, A1        * Load 'A4'
0000199A  103C 000E               1621          MOVE.B  #14, D0         * Load Trap #14 to print out
0000199E  4E4F                    1622          TRAP    #15             * Perform Trap #14
000019A0  4E75                    1623          RTS
000019A2                          1624  
000019A2                          1625  PRINTA5
000019A2  43F9 00001D38           1626          LEA     __A5, A1        * Load 'A5'
000019A8  103C 000E               1627          MOVE.B  #14, D0         * Load Trap #14 to print out
000019AC  4E4F                    1628          TRAP    #15             * Perform Trap #14
000019AE  4E75                    1629          RTS
000019B0                          1630  
000019B0                          1631  PRINTA6
000019B0  43F9 00001D3B           1632          LEA     __A6, A1        * Load 'A6'
000019B6  103C 000E               1633          MOVE.B  #14, D0         * Load Trap #14 to print out
000019BA  4E4F                    1634          TRAP    #15             * Perform Trap #14
000019BC  4E75                    1635          RTS
000019BE                          1636  
000019BE                          1637  PRINTA7
000019BE  43F9 00001D3E           1638          LEA     __A7, A1        * Load 'A7'
000019C4  103C 000E               1639          MOVE.B  #14, D0         * Load Trap #14 to print out
000019C8  4E4F                    1640          TRAP    #15             * Perform Trap #14
000019CA  4E75                    1641          RTS
000019CC                          1642  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019CC                          1643  *-----------------------------------------------------------------------------
000019CC                          1644  
000019CC                          1645  
000019CC                          1646  
000019CC                          1647  *-----------------------------------------------------------------------------
000019CC                          1648  *-----------------------------------------------------------------------------
000019CC                          1649  * NAME:           SIZE67
000019CC                          1650  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
000019CC                          1651  * PRE-CONDITION:  a
000019CC                          1652  * POST-CONDITION: a
000019CC                          1653  * REGISTERS:      a
000019CC                          1654  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019CC                          1655  SIZE67
000019CC  48A7 FFFE               1656          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
000019D0  3C3C 0006               1657          MOVE.W  #6, D6              * Prep lower value for bitmask
000019D4  3E3C 0007               1658          MOVE.W  #7, D7              * Prep upper value for bitmask
000019D8  6100 0270               1659          BSR     BITMASK             * Finalize bitmask setup
000019DC  CC42                    1660          AND     D2,D6               * Apply bitmask     
000019DE                          1661  
000019DE  0C46 0000               1662          CMPI    #%0000000000000000, D6   * is it a BYTE?
000019E2  6600 000A               1663          BNE     NOT67BYTE
000019E6                          1664          
000019E6  6100 0080               1665          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000019EA  6000 001E               1666          BRA     END67
000019EE                          1667  NOT67BYTE        
000019EE  0C46 0040               1668          CMPI    #%0000000001000000, D6   * is it a WORD?
000019F2  6600 000A               1669          BNE     NOT67WORD
000019F6                          1670          
000019F6  6100 007E               1671          BSR     PRINTWORD               * Branch to handle WORD sizes
000019FA  6000 000E               1672          BRA     END67
000019FE                          1673  NOT67WORD
000019FE  0C46 0080               1674          CMPI    #%0000000010000000, D6   * is it a LONG?
00001A02  6600 0006               1675          BNE     END67
00001A06                          1676          
00001A06  6100 007C               1677          BSR     PRINTLONG               * Branch to handle LONG sizes
00001A0A                          1678  END67
00001A0A  4C9F 7FFF               1679          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001A0E  4E75                    1680          RTS                             * Return. Size handling is finished.
00001A10                          1681  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A10                          1682  *-----------------------------------------------------------------------------
00001A10                          1683  
00001A10                          1684  
00001A10                          1685  
00001A10                          1686  *-----------------------------------------------------------------------------
00001A10                          1687  *-----------------------------------------------------------------------------
00001A10                          1688  * NAME:           SIZE68
00001A10                          1689  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
00001A10                          1690  * PRE-CONDITION:  a
00001A10                          1691  * POST-CONDITION: a
00001A10                          1692  * REGISTERS:      a
00001A10                          1693  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A10                          1694  SIZE68
00001A10                          1695          * finish later, need to follow the same format as SIZE67
00001A10                          1696          
00001A10                          1697          
00001A10  48A7 FFFE               1698          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001A14  3C3C 0006               1699          MOVE.W  #6, D6              * Prep lower value for bitmask
00001A18  3E3C 0008               1700          MOVE.W  #8, D7              * Prep upper value for bitmask
00001A1C  6100 022C               1701          BSR     BITMASK             * Finalize bitmask setup
00001A20  CC42                    1702          AND     D2,D6               * Apply bitmask          
00001A22                          1703          
00001A22  0C46 0000               1704          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001A26  6100 0040               1705          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001A2A  0C46 0100               1706          CMPI    #%0000000100000000, D6   * is it a BYTE?
00001A2E  6100 0038               1707          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001A32                          1708        
00001A32  0C46 0040               1709          CMPI    #%0000000001000000, D6   * is it a WORD?
00001A36  6100 003E               1710          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001A3A  0C46 0140               1711          CMPI    #%0000000101000000, D6   * is it a WORD?
00001A3E  6100 0036               1712          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001A42  0C46 00C0               1713          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
00001A46  6100 002E               1714          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001A4A                          1715  
00001A4A  0C46 0080               1716          CMPI    #%0000000010000000, D6   * is it a LONG?
00001A4E  6100 0034               1717          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001A52  0C46 0180               1718          CMPI    #%0000000110000000, D6   * is it a LONG?
00001A56  6100 002C               1719          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001A5A  0C46 01C0               1720          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001A5E  6100 0024               1721          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001A62                          1722  
00001A62  4C9F 7FFF               1723          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001A66  4E75                    1724          RTS                             * Return. Size handling is finished.
00001A68                          1725  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A68                          1726  *-----------------------------------------------------------------------------
00001A68                          1727  
00001A68                          1728  
00001A68                          1729  
00001A68                          1730  *-----------------------------------------------------------------------------
00001A68                          1731  *-----------------------------------------------------------------------------
00001A68                          1732  * NAME:           PRINTBYTE
00001A68                          1733  * DESCRIPTION:    a
00001A68                          1734  * PRE-CONDITION:  a
00001A68                          1735  * POST-CONDITION: a
00001A68                          1736  * REGISTERS:      a
00001A68                          1737  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A68                          1738  PRINTBYTE
00001A68  43F9 00001D1D           1739          LEA     __B,A1      * Load '.B ' into A1
00001A6E  103C 000E               1740          MOVE.B  #14,D0      * Trap #14 setup to print
00001A72  4E4F                    1741          TRAP    #15         * Perform Trap #14
00001A74  4E75                    1742          RTS                 * Return to SIZE67/SIZE68
00001A76                          1743          
00001A76                          1744  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A76                          1745  *-----------------------------------------------------------------------------
00001A76                          1746  
00001A76                          1747  
00001A76                          1748  
00001A76                          1749  *-----------------------------------------------------------------------------
00001A76                          1750  *-----------------------------------------------------------------------------
00001A76                          1751  * NAME:           PRINTWORD
00001A76                          1752  * DESCRIPTION:    a
00001A76                          1753  * PRE-CONDITION:  a
00001A76                          1754  * POST-CONDITION: a
00001A76                          1755  * REGISTERS:      a
00001A76                          1756  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A76                          1757  PRINTWORD
00001A76  43F9 00001D21           1758          LEA     __W,A1      * Load '.W ' into A1
00001A7C  103C 000E               1759          MOVE.B  #14,D0      * Trap #14 setup to print
00001A80  4E4F                    1760          TRAP    #15         * Perform Trap #14
00001A82  4E75                    1761          RTS                 * Return to SIZE67/SIZE68
00001A84                          1762          
00001A84                          1763  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A84                          1764  *-----------------------------------------------------------------------------
00001A84                          1765  
00001A84                          1766  
00001A84                          1767  
00001A84                          1768  *-----------------------------------------------------------------------------
00001A84                          1769  *-----------------------------------------------------------------------------
00001A84                          1770  * NAME:           PRINTLONG
00001A84                          1771  * DESCRIPTION:    a
00001A84                          1772  * PRE-CONDITION:  a
00001A84                          1773  * POST-CONDITION: a
00001A84                          1774  * REGISTERS:      a
00001A84                          1775  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A84                          1776  PRINTLONG
00001A84  43F9 00001D25           1777          LEA     __L,A1      * Load '.L ' into A1
00001A8A  103C 000E               1778          MOVE.B  #14,D0      * Trap #14 setup to print
00001A8E  4E4F                    1779          TRAP    #15         * Perform Trap #14
00001A90  4E75                    1780          RTS                 * Return to SIZE67/SIZE68
00001A92                          1781          
00001A92                          1782  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A92                          1783  *-----------------------------------------------------------------------------
00001A92                          1784  
00001A92                          1785  
00001A92                          1786  
00001A92                          1787  *-----------------------------------------------------------------------------
00001A92                          1788  *-----------------------------------------------------------------------------
00001A92                          1789  * NAME:           UNKNOWNOP
00001A92                          1790  * DESCRIPTION:    a
00001A92                          1791  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001A92                          1792  *                 identified as an unknown operation.
00001A92                          1793  * POST-CONDITION: D2 is no longer the opcode.
00001A92                          1794  * REGISTERS:      a
00001A92                          1795  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A92                          1796  UNKNOWNOP
00001A92  220A                    1797          MOVE.L  A2,D1   * prep the add to print
00001A94                          1798          
00001A94  5581                    1799          SUB.L   #2,D1   * off by two error due to post increment correct
00001A96                          1800          
00001A96  2602                    1801          MOVE.L  D2,D3   * save the opcode to print
00001A98                          1802          
00001A98  7410                    1803          MOVE.L  #16,D2  * set the base to 16
00001A9A                          1804          
00001A9A  700F                    1805          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001A9C  4E4F                    1806          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001A9E                          1807          
00001A9E  43F9 00001CC7           1808          LEA     DATA,A1 * load " DATA $" into register A1
00001AA4  700E                    1809          MOVE.L  #14,D0  * print the string stored in A1
00001AA6  4E4F                    1810          TRAP    #15
00001AA8                          1811          
00001AA8  2203                    1812          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001AAA                          1813          
00001AAA  103C 000F               1814          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001AAE  4E4F                    1815          TRAP    #15      * Perform Trap #3
00001AB0                          1816  
00001AB0  43F9 00001C8E           1817          LEA     NEWLINE,A1 * load newline into register A1
00001AB6  700E                    1818          MOVE.L  #14,D0  * print the string stored in A1
00001AB8  4E4F                    1819          TRAP    #15
00001ABA                          1820  
00001ABA  4E75                    1821          RTS
00001ABC                          1822  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001ABC                          1823  *-----------------------------------------------------------------------------
00001ABC                          1824  
00001ABC                          1825  
00001ABC                          1826  
00001ABC                          1827  *-----------------------------------------------------------------------------
00001ABC                          1828  *-----------------------------------------------------------------------------
00001ABC                          1829  * NAME: Print ASCII hex char
00001ABC                          1830  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
00001ABC                          1831  * PRE-CONDITION:  A6 contains the register for memory to print.
00001ABC                          1832  *                 This parameter would be pre-loaded by, for example:
00001ABC                          1833  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001ABC                          1834  *                 D6 contains the loops to do (number of bytes).
00001ABC                          1835  * POST-CONDITION: 
00001ABC                          1836  * REGISTERS:      
00001ABC                          1837  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001ABC                          1838  PRINT_ASCII_HEX_CHAR
00001ABC  48E7 FFFC               1839      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001AC0  4285                    1840      CLR.L       D5
00001AC2                          1841      
00001AC2                          1842      * fence post check (if-statement, check if 0 > chars)
00001AC2  0C06 0000               1843      CMPI.B      #0,D6
00001AC6  6700 017C               1844      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001ACA                          1845      
00001ACA                          1846  *    MOVE.L      A6,D4
00001ACA  2E0E                    1847      MOVE.L      A6,D7
00001ACC                          1848  PRINT_ASCII_LOOP
00001ACC                          1849  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001ACC                          1850  *    MOVE.L      D4,D7 * make a mutable copy
00001ACC  E99F                    1851      ROL.L       #4,D7 * roll to next spot
00001ACE  48E7 0100               1852      MOVEM.L     D7,-(A7) * save D7
00001AD2                          1853  
00001AD2  0287 0000000F           1854      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001AD8                          1855      
00001AD8  0C87 00000000           1856      CMPI.L      #0,D7
00001ADE  6D00 0164               1857      BLT         INVALID_ASCII_INPUT
00001AE2                          1858  
00001AE2  0C87 0000000F           1859      CMPI.L      #15,D7
00001AE8  6E00 015A               1860      BGT         INVALID_ASCII_INPUT
00001AEC                          1861  
00001AEC                          1862      * this might be faster... to do later, after entire assignment done
00001AEC                          1863       * CMPI.L      #9,D7
00001AEC                          1864       * BLE         PRINT_ASCII_0_TO_9
00001AEC                          1865  
00001AEC  0C87 00000000           1866      CMPI.L      #0,D7
00001AF2  6700 0098               1867      BEQ         PRINT_ASCII_0
00001AF6  0C87 00000001           1868      CMPI.L      #1,D7
00001AFC  6700 0098               1869      BEQ         PRINT_ASCII_1
00001B00  0C87 00000002           1870      CMPI.L      #2,D7
00001B06  6700 0098               1871      BEQ         PRINT_ASCII_2
00001B0A  0C87 00000003           1872      CMPI.L      #3,D7
00001B10  6700 0098               1873      BEQ         PRINT_ASCII_3
00001B14  0C87 00000004           1874      CMPI.L      #4,D7
00001B1A  6700 0098               1875      BEQ         PRINT_ASCII_4
00001B1E  0C87 00000005           1876      CMPI.L      #5,D7
00001B24  6700 0098               1877      BEQ         PRINT_ASCII_5
00001B28  0C87 00000006           1878      CMPI.L      #6,D7
00001B2E  6700 0098               1879      BEQ         PRINT_ASCII_6
00001B32  0C87 00000007           1880      CMPI.L      #7,D7
00001B38  6700 0098               1881      BEQ         PRINT_ASCII_7
00001B3C  0C87 00000008           1882      CMPI.L      #8,D7
00001B42  6700 0098               1883      BEQ         PRINT_ASCII_8
00001B46  0C87 00000009           1884      CMPI.L      #9,D7
00001B4C  6700 0098               1885      BEQ         PRINT_ASCII_9
00001B50  0C87 0000000A           1886      CMPI.L      #10,D7
00001B56  6700 0098               1887      BEQ         PRINT_ASCII_A
00001B5A  0C87 0000000B           1888      CMPI.L      #11,D7
00001B60  6700 0098               1889      BEQ         PRINT_ASCII_B
00001B64  0C87 0000000C           1890      CMPI.L      #12,D7
00001B6A  6700 0098               1891      BEQ         PRINT_ASCII_C
00001B6E  0C87 0000000D           1892      CMPI.L      #13,D7
00001B74  6700 0098               1893      BEQ         PRINT_ASCII_D
00001B78  0C87 0000000E           1894      CMPI.L      #14,D7
00001B7E  6700 0098               1895      BEQ         PRINT_ASCII_E
00001B82  0C87 0000000F           1896      CMPI.L      #15,D7
00001B88  6700 0098               1897      BEQ         PRINT_ASCII_F
00001B8C                          1898  PRINT_ASCII_0
00001B8C  43F9 00001CED           1899      LEA         ASCII_0,A1
00001B92  6000 0098               1900      BRA         PRINT_ASCII_CHAR
00001B96                          1901  PRINT_ASCII_1
00001B96  43F9 00001CEF           1902      LEA         ASCII_1,A1
00001B9C  6000 008E               1903      BRA         PRINT_ASCII_CHAR
00001BA0                          1904  PRINT_ASCII_2
00001BA0  43F9 00001CF1           1905      LEA         ASCII_2,A1
00001BA6  6000 0084               1906      BRA         PRINT_ASCII_CHAR
00001BAA                          1907  PRINT_ASCII_3
00001BAA  43F9 00001CF3           1908      LEA         ASCII_3,A1
00001BB0  6000 007A               1909      BRA         PRINT_ASCII_CHAR
00001BB4                          1910  PRINT_ASCII_4
00001BB4  43F9 00001CF5           1911      LEA         ASCII_4,A1
00001BBA  6000 0070               1912      BRA         PRINT_ASCII_CHAR
00001BBE                          1913  PRINT_ASCII_5
00001BBE  43F9 00001CF7           1914      LEA         ASCII_5,A1
00001BC4  6000 0066               1915      BRA         PRINT_ASCII_CHAR
00001BC8                          1916  PRINT_ASCII_6
00001BC8  43F9 00001CF9           1917      LEA         ASCII_6,A1
00001BCE  6000 005C               1918      BRA         PRINT_ASCII_CHAR
00001BD2                          1919  PRINT_ASCII_7
00001BD2  43F9 00001CFB           1920      LEA         ASCII_7,A1
00001BD8  6000 0052               1921      BRA         PRINT_ASCII_CHAR
00001BDC                          1922  PRINT_ASCII_8
00001BDC  43F9 00001CFD           1923      LEA         ASCII_8,A1
00001BE2  6000 0048               1924      BRA         PRINT_ASCII_CHAR
00001BE6                          1925  PRINT_ASCII_9
00001BE6  43F9 00001CFF           1926      LEA         ASCII_9,A1
00001BEC  6000 003E               1927      BRA         PRINT_ASCII_CHAR
00001BF0                          1928  PRINT_ASCII_A
00001BF0  43F9 00001D01           1929      LEA         ASCII_A,A1
00001BF6  6000 0034               1930      BRA         PRINT_ASCII_CHAR
00001BFA                          1931  PRINT_ASCII_B
00001BFA  43F9 00001D03           1932      LEA         ASCII_B,A1
00001C00  6000 002A               1933      BRA         PRINT_ASCII_CHAR
00001C04                          1934  PRINT_ASCII_C
00001C04  43F9 00001D05           1935      LEA         ASCII_C,A1
00001C0A  6000 0020               1936      BRA         PRINT_ASCII_CHAR
00001C0E                          1937  PRINT_ASCII_D
00001C0E  43F9 00001D07           1938      LEA         ASCII_D,A1
00001C14  6000 0016               1939      BRA         PRINT_ASCII_CHAR
00001C18                          1940  PRINT_ASCII_E
00001C18  43F9 00001D09           1941      LEA         ASCII_E,A1
00001C1E  6000 000C               1942      BRA         PRINT_ASCII_CHAR
00001C22                          1943  PRINT_ASCII_F
00001C22  43F9 00001D0B           1944      LEA         ASCII_F,A1
00001C28  6000 0002               1945      BRA         PRINT_ASCII_CHAR
00001C2C                          1946  PRINT_ASCII_CHAR
00001C2C  103C 000E               1947      MOVE.B      #14,D0
00001C30  4E4F                    1948      TRAP        #15
00001C32                          1949      
00001C32  5205                    1950      ADD.B       #1,D5 * loop until counter stops
00001C34  BA06                    1951      CMP.B       D6,D5
00001C36  6C00 000C               1952      BGE         PRINT_ASCII_FINISH
00001C3A                          1953      
00001C3A  4287                    1954      CLR.L       D7
00001C3C  4CDF 0080               1955      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001C40                          1956      
00001C40  6000 FE8A               1957      BRA         PRINT_ASCII_LOOP
00001C44                          1958  INVALID_ASCII_INPUT
00001C44                          1959  PRINT_ASCII_FINISH
00001C44  4CDF 3FFF               1960      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001C48  4E75                    1961      RTS
00001C4A                          1962  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C4A                          1963  *-----------------------------------------------------------------------------
00001C4A                          1964  
00001C4A                          1965  
00001C4A                          1966  
00001C4A                          1967  *-----------------------------------------------------------------------------
00001C4A                          1968  *-----------------------------------------------------------------------------
00001C4A                          1969  * NAME: Bitmask
00001C4A                          1970  * DESCRIPTION:    Masks bits in a data register.
00001C4A                          1971  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001C4A                          1972  *                 the ending bit.  For example, a starting bit of decimal
00001C4A                          1973  *                 value 0 and an ending bit of decimal value 3 will mask the
00001C4A                          1974  *                 bits 0, 1, 2, and 3.
00001C4A                          1975  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001C4A                          1976  * REGISTERS:      D5,D6,D7
00001C4A                          1977  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C4A                          1978  BITMASK
00001C4A  3F05                    1979          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001C4C  4245                    1980          CLR     D5          * clear D5 so we can use it
00001C4E                          1981  LOOPBIT 
00001C4E  0DC5                    1982          BSET    D6,D5       * set the D6th bit in D5 to 1
00001C50  5246                    1983          ADD     #1,D6       * increment D6
00001C52                          1984  
00001C52  BC47                    1985          CMP     D7,D6       * have we finished?
00001C54  6E00 0004               1986          BGT     BITMASKDONE * yes
00001C58  60F4                    1987          BRA     LOOPBIT     * no, iterate again
00001C5A                          1988  
00001C5A                          1989  BITMASKDONE
00001C5A  2C05                    1990          MOVE.L  D5,D6
00001C5C  3A1F                    1991          MOVE    (A7)+,D5    * restore D5
00001C5E  4E75                    1992          RTS
00001C60                          1993  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C60                          1994  *-----------------------------------------------------------------------------
00001C60                          1995  
00001C60                          1996  
00001C60                          1997  
00001C60                          1998  *-----------------------------------------------------------------------------
00001C60                          1999  *-----------------------------------------------------------------------------
00001C60                          2000  * SECTION: Constants/variables used throughout the program.
00001C60                          2001  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C60                          2002  * ---> GENERAL
00001C60  =0000000D               2003  CR          EQU     $0D
00001C60  =0000000A               2004  LF          EQU     $0A
00001C60= 45 4E 54 45 52 20 ...   2005  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001C78= 45 4E 54 45 52 20 ...   2006  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001C8E= 0D 0A 00                2007  NEWLINE     DC.B    CR,LF,0
00001C91                          2008  * ---> OPS
00001C91= 44 49 56 53 00          2009  DIVSOP      DC.B    'DIVS',0
00001C96= 4E 4F 50 00             2010  NOOPERATION DC.B    'NOP',0
00001C9A= 4E 45 47 00             2011  NEGOP       DC.B    'NEG',0
00001C9E= 4D 4F 56 45 00          2012  MOVEOP      DC.B    'MOVE',0
00001CA3= 4D 4F 56 45 4D 00       2013  MOVEMOP     DC.B    'MOVEM',0
00001CA9= 4A 53 52 00             2014  JSROP       DC.B    'JSR',0
00001CAD= 52 54 53 00             2015  RTSOP       DC.B    'RTS',0
00001CB1= 4C 45 41 00             2016  LEAOP       DC.B    'LEA',0
00001CB5= 42 43 4C 52 20 00       2017  BCLROP      DC.B    'BCLR ',0
00001CBB= 4F 52 00                2018  OROP        DC.B    'OR',0
00001CBE= 4F 52 49 00             2019  ORIOP       DC.B    'ORI',0
00001CC2= 43 4D 50 49 00          2020  CMPIOP      DC.B    'CMPI',0
00001CC7= 20 44 41 54 41 20 ...   2021  DATA        DC.B    ' DATA $',0
00001CCF= 42 43 43 20 00          2022  OP_BCC_MSG  DC.B    'BCC ',0
00001CD4= 42 43 53 20 00          2023  OP_BCS_MSG  DC.B    'BCS ',0
00001CD9= 42 47 45 20 00          2024  OP_BGE_MSG  DC.B    'BGE ',0
00001CDE= 42 4C 54 20 00          2025  OP_BLT_MSG  DC.B    'BLT ',0
00001CE3= 42 56 43 20 00          2026  OP_BVC_MSG  DC.B    'BVC ',0
00001CE8= 42 52 41 20 00          2027  OP_BRA_MSG  DC.B    'BRA ',0
00001CED                          2028  * ---> HEX CHARS
00001CED= 30 00                   2029  ASCII_0     DC.B    '0',0
00001CEF= 31 00                   2030  ASCII_1     DC.B    '1',0
00001CF1= 32 00                   2031  ASCII_2     DC.B    '2',0
00001CF3= 33 00                   2032  ASCII_3     DC.B    '3',0
00001CF5= 34 00                   2033  ASCII_4     DC.B    '4',0
00001CF7= 35 00                   2034  ASCII_5     DC.B    '5',0
00001CF9= 36 00                   2035  ASCII_6     DC.B    '6',0
00001CFB= 37 00                   2036  ASCII_7     DC.B    '7',0
00001CFD= 38 00                   2037  ASCII_8     DC.B    '8',0
00001CFF= 39 00                   2038  ASCII_9     DC.B    '9',0
00001D01= 41 00                   2039  ASCII_A     DC.B    'A',0
00001D03= 42 00                   2040  ASCII_B     DC.B    'B',0
00001D05= 43 00                   2041  ASCII_C     DC.B    'C',0
00001D07= 44 00                   2042  ASCII_D     DC.B    'D',0
00001D09= 45 00                   2043  ASCII_E     DC.B    'E',0
00001D0B= 46 00                   2044  ASCII_F     DC.B    'F',0
00001D0D                          2045  * ---> SPECIAL CHARACTERS
00001D0D= 20 00                   2046  SPACE       DC.B    ' ',0
00001D0F= 24 00                   2047  DOLLAR      DC.B    '$',0
00001D11= 23 00                   2048  IMD         DC.B    '#',0
00001D13= 2C 00                   2049  COMMA       DC.B    ',',0
00001D15= 28 00                   2050  OBRACK      DC.B    '(',0
00001D17= 29 00                   2051  CBRACK      DC.B    ')',0
00001D19= 2B 00                   2052  PLUS        DC.B    '+',0
00001D1B= 2D 00                   2053  MINUS       DC.B    '-',0
00001D1D                          2054  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001D1D= 2E 42 20 00             2055  __B         DC.B    '.B ',0
00001D21= 2E 57 20 00             2056  __W         DC.B    '.W ',0
00001D25= 2E 4C 20 00             2057  __L         DC.B    '.L ',0
00001D29                          2058  * ---> ADDRESS REGISTERS A0-A7
00001D29= 41 30 00                2059  __A0        DC.B   'A0',0
00001D2C= 41 31 00                2060  __A1        DC.B   'A1',0    
00001D2F= 41 32 00                2061  __A2        DC.B   'A2',0
00001D32= 41 33 00                2062  __A3        DC.B   'A3',0
00001D35= 41 34 00                2063  __A4        DC.B   'A4',0
00001D38= 41 35 00                2064  __A5        DC.B   'A5',0
00001D3B= 41 36 00                2065  __A6        DC.B   'A6',0
00001D3E= 41 37 00                2066  __A7        DC.B   'A7',0
00001D41                          2067  * ---> DATA REGISTERS D0-D7
00001D41= 44 30 00                2068  __D0        DC.B   'D0',0
00001D44= 44 31 00                2069  __D1        DC.B   'D1',0
00001D47= 44 32 00                2070  __D2        DC.B   'D2',0
00001D4A= 44 33 00                2071  __D3        DC.B   'D3',0
00001D4D= 44 34 00                2072  __D4        DC.B   'D4',0
00001D50= 44 35 00                2073  __D5        DC.B   'D5',0
00001D53= 44 36 00                2074  __D6        DC.B   'D6',0
00001D56= 44 37 00                2075  __D7        DC.B   'D7',0
00001D59                          2076  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D59                          2077  *-----------------------------------------------------------------------------
00001D59                          2078  
00001D59                          2079  
00001D59                          2080  
00001D59                          2081  *-----------------------------------------------------------------------------
00001D59                          2082  *-----------------------------------------------------------------------------
00001D59                          2083  * SECTION: Sample program to run, then attempt testing disassembly on.
00001D59                          2084  * STARTING: 16384
00001D59                          2085  * ENDING:   16420
00001D59                          2086  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2087      ORG $4000
00004000                          2088      
00004000  4E71                    2089      NOP
00004002  103C 009A               2090      MOVE.B   #%10011010, D0
00004006  123C 00A9               2091      MOVE.B   #%10101001, D1
0000400A  D200                    2092      ADD.B    D0,D1
0000400C  48A7 4000               2093      MOVEM    D1,-(A7)
00004010  43F8 1CA9               2094      LEA      JSROP,A1
00004014  4467                    2095      NEG.W    -(A7)
00004016  4EB9 0000402E           2096      JSR      END
0000401C  81FC 0001               2097      DIVS    #1, D0
00004020  0181                    2098      BCLR    D0, D1
00004022  0041 0004               2099      ORI     #4, D1
00004026  6000 0006               2100      BRA     END
0000402A  6700 0002               2101      BEQ     END
0000402E                          2102  
0000402E                          2103  END
0000402E  4E75                    2104      RTS
00004030                          2105      
00004030                          2106  RLLYEND
00004030                          2107      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1CED
ASCII_1             1CEF
ASCII_2             1CF1
ASCII_3             1CF3
ASCII_4             1CF5
ASCII_5             1CF7
ASCII_6             1CF9
ASCII_7             1CFB
ASCII_8             1CFD
ASCII_9             1CFF
ASCII_A             1D01
ASCII_B             1D03
ASCII_C             1D05
ASCII_D             1D07
ASCII_E             1D09
ASCII_F             1D0B
BCC_END             156A
BCLROP              1CB5
BITMASK             1C4A
BITMASKDONE         1C5A
CBRACK              1D17
CMPIOP              1CC2
COMMA               1D13
CR                  D
DATA                1CC7
DIVSOP              1C91
DOLLAR              1D0F
DONE0100            14AC
EAHELPER05          1676
EAHELPER611         1634
END                 402E
END0000             1240
END67               1A0A
ENDEAHELPER05       17C6
ENDEAHELPER611      1670
ENDMODE_AN          1956
ENDMODE_DN          1856
ENDOP0001           12A6
HEX_VALUE_MASK_LONG  F
IMD                 1D11
INVALID_ASCII_INPUT  1C44
ITERATION           1144
JSROP               1CA9
LEAOP               1CB1
LF                  A
LOOP                103A
LOOPBIT             1C4E
LOOPUNKNOWNOP       1140
MINUS               1D1B
MODE_AN             18CC
MODE_DN             17CC
MOVEMOP             1CA3
MOVEOP              1C9E
MSGEND              1C78
MSGSTART            1C60
NEGOP               1C9A
NEWLINE             1C8E
NOOPERATION         1C96
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           19EE
NOT67WORD           19FE
NOTA0               18EE
NOTA1               18FE
NOTA2               190E
NOTA3               191E
NOTA4               192E
NOTA5               193E
NOTA6               194E
NOTADRDIRECT        16A6
NOTADRINDIRECT      16CE
NOTADRINDIRECTPOST  1702
NOTADRINDIRECTPRE   1736
NOTBCLR             11CE
NOTD0               17EE
NOTD1               17FE
NOTD2               180E
NOTD3               181E
NOTD4               182E
NOTD5               183E
NOTD6               184E
NOTDATAREG          1696
NOTDIVS             15F4
NOTIMMBYTE          176C
NOTIMMEDIATE        17C2
NOTIMMWORD          179A
NOTJSR              13A4
NOTMOVEM            1356
NOTNEG              1332
NOTNOP              12DC
NOTORI              1234
NOTRTS              13C6
OBRACK              1D15
OP0000              1150
OP0001              1246
OP0010              12AC
OP0011              12B2
OP0100              12C0
OP0101              14B6
OP0110              14BC
OP0111              1570
OP1000              1576
OP1000END           1604
OP1001              160A
OP1010              1610
OP1011              1616
OP1100              161C
OP1101              1622
OP1110              1628
OP1111              162E
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              150C
OP_BCC_MSG          1CCF
OP_BCS              1516
OP_BCS_MSG          1CD4
OP_BGE              1520
OP_BGE_MSG          1CD9
OP_BLT              152A
OP_BLT_MSG          1CDE
OP_BRA              153E
OP_BRANCHES_PRINT   1548
OP_BRA_MSG          1CE8
OP_BVC              1534
OP_BVC_MSG          1CE3
ORIOP               1CBE
OROP                1CBB
PLUS                1D19
PRINTA0             195C
PRINTA1             196A
PRINTA2             1978
PRINTA3             1986
PRINTA4             1994
PRINTA5             19A2
PRINTA6             19B0
PRINTA7             19BE
PRINTBYTE           1A68
PRINTD0             185C
PRINTD1             186A
PRINTD2             1878
PRINTD3             1886
PRINTD4             1894
PRINTD5             18A2
PRINTD6             18B0
PRINTD7             18BE
PRINTLONG           1A84
PRINTWORD           1A76
PRINT_ASCII_0       1B8C
PRINT_ASCII_1       1B96
PRINT_ASCII_2       1BA0
PRINT_ASCII_3       1BAA
PRINT_ASCII_4       1BB4
PRINT_ASCII_5       1BBE
PRINT_ASCII_6       1BC8
PRINT_ASCII_7       1BD2
PRINT_ASCII_8       1BDC
PRINT_ASCII_9       1BE6
PRINT_ASCII_A       1BF0
PRINT_ASCII_B       1BFA
PRINT_ASCII_C       1C04
PRINT_ASCII_CHAR    1C2C
PRINT_ASCII_D       1C0E
PRINT_ASCII_E       1C18
PRINT_ASCII_F       1C22
PRINT_ASCII_FINISH  1C44
PRINT_ASCII_HEX_CHAR  1ABC
PRINT_ASCII_LOOP    1ACC
RLLYEND             4030
RTSOP               1CAD
SIZE67              19CC
SIZE68              1A10
SPACE               1D0D
START               1000
TWOWORDLEA          1456
UNKNOWN0000         123C
UNKNOWN0100         14A8
UNKNOWNOP           1A92
UNKNOWNOP0001       12A2
__A0                1D29
__A1                1D2C
__A2                1D2F
__A3                1D32
__A4                1D35
__A5                1D38
__A6                1D3B
__A7                1D3E
__B                 1D1D
__D0                1D41
__D1                1D44
__D2                1D47
__D3                1D4A
__D4                1D4D
__D5                1D50
__D6                1D53
__D7                1D56
__L                 1D25
__W                 1D21
