00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/26/2014 2:47:32 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000                            51  
00000000                            52  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            53  
00001000                            54  START:  ORG    $1000            * first instruction of program
00001000                            55  
00001000                            56  * -----------------------------------
00001000                            57  * Starting and Ending Addresses
00001000                            58  * -----------------------------------
00001000                            59  
00001000                            60  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            61  
00001000                            62  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001508             63          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 64          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      65          TRAP    #15             * Perform #14
0000100C                            66          
0000100C                            67  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 68          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      69          TRAP    #15             * Perform #15
00001012                            70          
00001012                            71  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      72          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            73  
00001014                            74  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001520             75          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 76          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      77          TRAP    #15             * Perform #14
00001020                            78          
00001020                            79  * GETS THE ENDING ADDRESS
00001020  103C 0004                 80          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      81          TRAP    #15             * Perform Trap #4
00001026  2A01                      82          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001536             83          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            84          
0000102E  3E3C 000F                 85          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 86          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 04BA                 87          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            88          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            89          
0000103A                            90  LOOP    
0000103A                            91          
0000103A                            92          * MOVE.W  #BITMASK,D2     * Load the bitmask into data register D2
0000103A  3F06                      93          MOVE    D6,-(A7)        * save the bitmask
0000103C  341A                      94          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                      95          AND.W   D2,D6           * Apply this bitmask
00001040                            96          
00001040  BC7C 4000                 97          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001044  6600 0006                 98          BNE     NEXT            * No, check next case
00001048  6000 01AC                 99          BRA     OP0100          * Branch to subroutine 0100
0000104C                           100          *BRA     ITERATION       * Move to next iteration of the loop
0000104C                           101          
0000104C                           102  NEXT
0000104C  6100 047A                103          BSR     UNKNOWNOP
00001050                           104          
00001050                           105  ITERATION
00001050  3C1F                     106          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001052                           107  
00001052                           108          *MOVE.B  #14,D0          * Print a newline
00001052                           109          *TRAP    #15             * Perform Trap #14
00001052                           110  
00001052  BA4A                     111          CMP     A2,D5           * Compare the starting address to ending address
00001054  6700 2FC6                112          BEQ     END             * If they are equal, branch 
00001058  60E0                     113          BRA     LOOP            * Otherwise, branch back to LOOP
0000105A                           114  
0000105A                           115  * --- OP 0000 ------------------------------------------
0000105A                           116  * FUNCTIONS     BCLR, ORI, CMPI
0000105A                           117  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask. 
0000105A                           118  * ADDR REG        
0000105A                           119  * POST COND     All registers return to their previous state.
0000105A                           120  * ------------------------------------------------------
0000105A                           121  OP0000
0000105A  48A7 C0C0                122   MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
0000105E  3C3C 0006                123          MOVE.W  #6, D6              * Prep lower value for bitmask
00001062  3E3C 0008                124          MOVE.W  #8, D7              * Prep upper value for bitmask
00001066  6100 048A                125          BSR     BITMASK             * Finalize bitmask setup
0000106A  CC42                     126          AND     D2,D6               * Apply bitmask
0000106C                           127          
0000106C  0C46 0180                128          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001070  6600 0012                129          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
00001074                           130          
00001074  43F9 00001553            131          LEA     BCLROP,A1           * We found BCLR
0000107A  103C 000E                132          MOVE.B  #14,D0              * Trap #14 prints out the data
0000107E  4E4F                     133          TRAP    #15                 * Perform Trap #14
00001080  6000 026A                134          BRA     DONE              * Found the op, move to next iteration
00001084                           135  
00001084                           136  NOTBCLR * Possible options left are ORI or CMPI
00001084  3C3C 0009                137          MOVE.W  #9, D6              * Prep lower value for bitmask
00001088  3E3C 000B                138          MOVE.W  #11, D7             * Prep upper value for bitmask
0000108C  6100 0464                139          BSR     BITMASK             * Finalize bitmask setup
00001090  CC42                     140          AND     D2,D6               * Apply bitmask
00001092                           141          
00001092  0C46 0000                142          CMPI    #%0000000000000000, D6  * Are we ORI?
00001096  6700 000E                143          BEQ     ISORI                   * If ORI, branch to ISORI
0000109A                           144          
0000109A  0C46 0C00                145          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
0000109E  6700 0006                146          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
000010A2                           147          
000010A2  6600 0424                148          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
000010A6                           149                                          * We don't deal too kindly with imposters.
000010A6                           150          
000010A6                           151  ISORI   * TODO
000010A6                           152          
000010A6                           153  
000010A6                           154  ISCMPI
000010A6  43F9 0000155C            155          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000010AC  103C 000E                156          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000010B0  4E4F                     157          TRAP    #15                 * Perform Trap #14
000010B2                           158          
000010B2                           159          * Determine the Size
000010B2  3C3C 0006                160          MOVE.W  #6, D6              * Prep lower value for bitmask
000010B6  3E3C 0007                161          MOVE.W  #7, D7              * Prep upper value for bitmask
000010BA  6100 0436                162          BSR     BITMASK             * Finalize bitmask setup
000010BE  CC42                     163          AND     D2,D6               * Apply bitmask
000010C0                           164          
000010C0  0C46 00C0                165          CMPI    #%0000000011000000, D6  * Imposter Op
000010C4  6700 0402                166          BEQ     UNKNOWNOP               * Deal with the imposter
000010C8                           167          
000010C8  0C46 0000                168          CMPI    #%0000000000000000, D6  * The size is a BYTE
000010CC  6700 0012                169          BEQ     CMPIBYTE                * Branch to CMPI.B
000010D0                           170          
000010D0  0C46 0040                171          CMPI    #%0000000001000000, D6  * The size is a WORD
000010D4  6700 0032                172          BEQ     CMPIWORD                * Branch to CMPI.W
000010D8                           173          
000010D8  0C46 0080                174          CMPI    #%0000000010000000, D6  * The size is a LONG
000010DC  6700 0050                175          BEQ     CMPILONG                * Branch to CMPI.L
000010E0                           176          
000010E0                           177  CMPIBYTE
000010E0  43F9 0000156F            178          LEA     __B, A1     * Load .B
000010E6  103C 000E                179          MOVE.B  #14, D0     * Print out data
000010EA  4E4F                     180          TRAP    #15         * Perform Trap #14
000010EC                           181          
000010EC  43F9 0000156B            182          LEA     IMD, A1     * Load #
000010F2  103C 000E                183          MOVE.B  #14, D0     * Print out data
000010F6  4E4F                     184          TRAP    #15         * Perform Trap #14
000010F8                           185          
000010F8  361A                     186          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
000010FA  1203                     187          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
000010FC  3622                     188          MOVE.W  -(A2),D3    * Now go back
000010FE  103C 000E                189          MOVE.B  #14, D0     * Print out the data
00001102  4E4F                     190          TRAP    #15         * Perform Trap #14 
00001104                           191          
00001104  6000 004E                192          BRA     CMPIEA      * Branch to determine Effective Address
00001108                           193          
00001108                           194  CMPIWORD
00001108  43F9 00001573            195          LEA     __W, A1     * Load .W
0000110E  103C 000E                196          MOVE.B  #14, D0     * Print out data
00001112  4E4F                     197          TRAP    #15         * Perform Trap #14
00001114                           198          
00001114  43F9 0000156B            199          LEA     IMD, A1     * Load #
0000111A  103C 000E                200          MOVE.B  #14, D0     * Print out data
0000111E  4E4F                     201          TRAP    #15         * Perform Trap #14
00001120                           202          
00001120  361A                     203          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001122  3222                     204          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
00001124  103C 000E                205          MOVE.B  #14, D0     * Print out the data
00001128  4E4F                     206          TRAP    #15         * Perform Trap #14
0000112A                           207          
0000112A                           208          
0000112A  6000 0028                209          BRA     CMPIEA      * Branch to determine Effective Address
0000112E                           210          
0000112E                           211  CMPILONG
0000112E  43F9 00001577            212          LEA     __L, A1     * Load .L
00001134  103C 000E                213          MOVE.B  #14, D0     * Print out data
00001138  4E4F                     214          TRAP    #15         * Perform Trap #14
0000113A                           215          
0000113A  43F9 0000156B            216          LEA     IMD, A1     * Load #
00001140  103C 000E                217          MOVE.B  #14, D0     * Print out data
00001144  4E4F                     218          TRAP    #15         * Perform Trap #14
00001146                           219          
00001146  361A                     220          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001148  2222                     221          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
0000114A  103C 000E                222          MOVE.B  #14, D0     * Print out the data
0000114E  4E4F                     223          TRAP    #15         * Perform Trap #14
00001150                           224          
00001150  6000 0002                225          BRA     CMPIEA      * Branch to determine Effective Address
00001154                           226          
00001154                           227  CMPIEA
00001154                           228          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
00001154  43F9 0000156D            229          LEA     COMMA, A1   * Load ,
0000115A  103C 000E                230          MOVE.B  #14, D0     * Print out data
0000115E  4E4F                     231          TRAP    #15         * Perform Trap #14
00001160                           232          
00001160  43F9 00001577            233          LEA     __L, A1     * Load .L
00001166  103C 000E                234          MOVE.B  #14, D0     * Print out data
0000116A  4E4F                     235          TRAP    #15         * Perform Trap #14
0000116C                           236          
0000116C                           237          * Determine the mode
0000116C  3C3C 0003                238          MOVE.W  #3, D6              * Prep lower value for bitmask
00001170  3E3C 0005                239          MOVE.W  #5, D7              * Prep upper value for bitmask
00001174  6100 037C                240          BSR     BITMASK             * Finalize bitmask setup
00001178  CC42                     241          AND     D2,D6               * Apply bitmask
0000117A                           242          
0000117A  0C46 0008                243          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
0000117E  6700 0348                244          BEQ     UNKNOWNOP               * Imposter op
00001182                           245          
00001182  0C46 0028                246          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
00001186  6700 0340                247          BEQ     UNKNOWNOP               * Imposter op
0000118A                           248          
0000118A  0C46 0030                249          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
0000118E  6700 0338                250          BEQ     UNKNOWNOP               * Imposter op
00001192                           251  
00001192  0C46 0038                252          CMPI    #%0000000000111000, D6  * Is the Mode 111?
00001196  6700 0028                253          BEQ     CMPIREG                 * Further investigation is needed
0000119A                           254          
0000119A                           255          * Mode is verified to be valid at this point
0000119A  0C46 0000                256          CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
0000119E  6100 017C                257          BSR     MODE_DN
000011A2                           258          
000011A2  0C46 0010                259          CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
000011A6  6100 0036                260          BSR     MODE_IAN
000011AA                           261          
000011AA  0C46 0018                262          CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
000011AE  6100 002E                263          BSR     MODE_IAN_POS
000011B2                           264          
000011B2  0C46 0000                265          CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
000011B6  6100 0026                266          BSR     MODE_IAN_PRE
000011BA                           267          
000011BA                           268          * Reached End of CMPI. Everything has been printed out
000011BA  4C9F 0303                269          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000011BE  4E75                     270          RTS
000011C0                           271          
000011C0                           272  CMPIREG
000011C0  3C3C 0000                273          MOVE.W  #0, D6              * Prep lower value for bitmask
000011C4  3E3C 0002                274          MOVE.W  #2, D7              * Prep upper value for bitmask
000011C8  6100 0328                275          BSR     BITMASK             * Finalize bitmask setup
000011CC  CC42                     276          AND     D2,D6               * Apply bitmask
000011CE                           277          
000011CE  0C46 0000                278          CMPI    #%0000000000000000, D6  * Is the Register 000?
000011D2  6700 000A                279          BEQ     CMPIREG000
000011D6                           280          
000011D6  0C46 0001                281          CMPI    #%0000000000000001, D6  * Is the Register 001?
000011DA  6700 0002                282          BEQ     CMPIREG001
000011DE                           283            
000011DE                           284  
000011DE                           285  CMPIREG000  * TODO (xxx).W for CMPI
000011DE                           286  
000011DE                           287  CMPIREG001  * TODO (xxx).L for CMPI
000011DE                           288          
000011DE                           289  MODE_AN
000011DE                           290  
000011DE                           291  MODE_IAN
000011DE                           292  MODE_IAN_POS
000011DE                           293  MODE_IAN_PRE
000011DE                           294  
000011DE                           295  * --- OP 0001 ------------------------------------------
000011DE                           296  * FUNCTIONS     MOVE.B
000011DE                           297  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000011DE                           298  * ADDR REG        
000011DE                           299  * POST COND     All registers return to their previous state.
000011DE                           300  * ------------------------------------------------------
000011DE                           301  OP0001  
000011DE                           302  
000011DE                           303  
000011DE                           304  
000011DE                           305  
000011DE                           306  * --- OP 0010 ------------------------------------------
000011DE                           307  * FUNCTIONS     MOVE.L, MOVEA.L,
000011DE                           308  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000011DE                           309  * ADDR REG        
000011DE                           310  * POST COND     All registers return to their previous state.
000011DE                           311  * ------------------------------------------------------
000011DE                           312  OP0010  
000011DE                           313  
000011DE                           314  
000011DE                           315  * --- OP 0011 ------------------------------------------
000011DE                           316  * FUNCTIONS     MOVE.W, MOVEA.W
000011DE                           317  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000011DE                           318  * ADDR REG        
000011DE                           319  * POST COND     All registers return to their previous state.
000011DE                           320  * ------------------------------------------------------
000011DE                           321  OP0011
000011DE  48A7 FFFE                322      MOVEM   D0-D7/A0-A6, -(A7)
000011E2                           323      
000011E2  3C3C 0006                324      MOVE.W  #6,D6
000011E6  3E3C 0008                325      MOVE.W  #8,D7
000011EA                           326      
000011EA  6100 0306                327      BSR     BITMASK
000011EE                           328      
000011EE  CC42                     329      AND.W   D2,D6
000011F0                           330      
000011F0  BC7C 0040                331      CMP     #%0000000001000000,D6
000011F4                           332      *BNE     NEXT15
000011F4  61FE                     333      BSR     * for MOVEA.W
000011F6                           334  
000011F6                           335  
000011F6                           336  * --- OP 0100 ------------------------------------------
000011F6                           337  * FUNCTIONS     NO_OP, MOVEM, LEA, NEG, JSR, RTS
000011F6                           338  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000011F6                           339  * ADDR REG        
000011F6                           340  * POST COND     All registers return to their previous state.
000011F6                           341  * ------------------------------------------------------
000011F6                           342  OP0100  * TODO: lea, jsr, rts
000011F6                           343  
000011F6  48A7 C0C0                344          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000011FA                           345          
000011FA                           346          *NOP
000011FA  0C42 4E71                347          CMPI    #%0100111001110001,D2
000011FE  6600 0012                348          BNE     NOTNOP
00001202                           349          
00001202  43F9 00001539            350          LEA     NOOPERATION,A1
00001208  103C 000D                351          MOVE.B  #13,D0          * Print a newline
0000120C  4E4F                     352          TRAP    #15
0000120E                           353          
0000120E  6000 00DC                354          BRA     DONE *we found it, move on to the next iteration
00001212                           355  NOTNOP *NEG
00001212                           356          
00001212                           357          * prep values for BITMASK subroutine
00001212  7C08                     358          MOVE.L  #8,D6
00001214  7E0B                     359          MOVE.L  #11,D7
00001216                           360          
00001216  6100 02DA                361          BSR     BITMASK
0000121A                           362          
0000121A  CC42                     363          AND     D2,D6                   * apply bitmask
0000121C                           364          
0000121C  0C46 0400                365          CMPI    #%0000010000000000,D6   * are we NEG?
00001220  6600 0036                366          BNE     NOTNEG                  * not neg
00001224                           367          
00001224  7C03                     368          MOVE.L  #3,D6
00001226  7E05                     369          MOVE.L  #5,D7
00001228                           370          
00001228  6100 02C8                371          BSR     BITMASK * generate a bitmask to be used to check mode
0000122C                           372          
0000122C  0C46 0008                373          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
00001230  6700 00B6                374          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001234                           375        
00001234                           376          * it is NEG, print
00001234  43F9 0000153D            377          LEA     NEGOP,A1
0000123A  103C 000E                378          MOVE.B  #14,D0
0000123E  4E4F                     379          TRAP    #15
00001240                           380          
00001240  6100 01C0                381          BSR     SIZE67
00001244                           382          
00001244  43F9 00001569            383          LEA     SPACE,A1
0000124A  103C 000E                384          MOVE.B  #14,D0
0000124E  4E4F                     385          TRAP    #15
00001250                           386          
00001250  6100 00A2                387          BSR     EAHELPER05
00001254                           388          
00001254  6000 0096                389          BRA     DONE * we found the op, move to next iteration
00001258                           390          
00001258                           391  NOTNEG *MOVEM
00001258                           392  
00001258                           393          * prep values for BITMASK subroutine
00001258  7C07                     394          MOVE.L  #7,D6
0000125A  7E09                     395          MOVE.L  #9,D7
0000125C                           396          
0000125C  6100 0294                397          BSR     BITMASK
00001260                           398          
00001260  CC42                     399          AND     D2,D6   * apply bitmask
00001262                           400          
00001262  0C46 0080                401          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001266  6600 0014                402          BNE     NOTMOVEM          * it is not MOVEM
0000126A                           403          
0000126A                           404          * make sure it is a valid size and mode for MOVEM
0000126A                           405          
0000126A                           406          * it is MOVEM
0000126A  43F9 00001541            407          LEA     MOVEMOP,A1
00001270  103C 000E                408          MOVE.B  #14,D0          * Print a newline
00001274  4E4F                     409          TRAP    #15
00001276                           410          
00001276                           411          * probably needs its own special code for printing the rest due to uniqueness of movem
00001276                           412          
00001276  341A                     413          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001278                           414          
00001278  6000 0072                415          BRA     DONE          * we found and printed, move on to the next iteration
0000127C                           416          
0000127C                           417  NOTMOVEM *JSR
0000127C                           418          * prep values for BITMASK subroutine
0000127C  7C06                     419          MOVE.L  #6,D6
0000127E  7E08                     420          MOVE.L  #8,D7
00001280                           421          
00001280  6100 0270                422          BSR     BITMASK
00001284                           423          
00001284  CC42                     424          AND     D2,D6   * apply bitmask
00001286                           425          
00001286  0C46 0080                426          CMPI    #%0000000010000000,D6
0000128A  6600 0016                427          BNE     NOTJSR          * it's not JSR
0000128E                           428          
0000128E  43F9 00001547            429          LEA     JSROP,A1
00001294  103C 000E                430          MOVE.B  #14,D0          * Print a newline and JSR
00001298  4E4F                     431          TRAP    #15
0000129A                           432          
0000129A                           433          * print out where we are jumping to
0000129A                           434          
0000129A  341A                     435          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000129C  341A                     436          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000129E                           437          
0000129E  6000 004C                438          BRA     DONE          * we already found instruction, next iteration
000012A2                           439  NOTJSR *RTS
000012A2                           440  
000012A2                           441          * prep values for BITMASK subroutine
000012A2  7C06                     442          MOVE.L  #6,D6
000012A4  7E08                     443          MOVE.L  #8,D7
000012A6                           444          
000012A6  6100 024A                445          BSR     BITMASK
000012AA                           446          
000012AA  CC42                     447          AND     D2,D6   * apply bitmask
000012AC                           448          
000012AC  0C46 0040                449          CMPI    #%0000000001000000,D6
000012B0  6600 0012                450          BNE     NOTRTS          * it's not RTS
000012B4                           451          
000012B4  43F9 0000154B            452          LEA     RTSOP,A1
000012BA  103C 000E                453          MOVE.B  #14,D0          * Print a newline and RTS
000012BE  4E4F                     454          TRAP    #15
000012C0                           455          
000012C0  6000 002A                456          BRA     DONE          * we already found instruction, next iteration
000012C4                           457  NOTRTS  *LEA
000012C4                           458         
000012C4                           459          * prep values for BITMASK subroutine
000012C4  7C06                     460          MOVE.L  #6,D6
000012C6  7E08                     461          MOVE.L  #8,D7
000012C8                           462          
000012C8  6100 0228                463          BSR     BITMASK
000012CC                           464          
000012CC  CC42                     465          AND     D2,D6   * apply bitmask
000012CE                           466          
000012CE  0C46 01C0                467          CMPI    #%0000000111000000,D6
000012D2  6600 0014                468          BNE     UNKNOWN          * it's not LEA, we dont know what it is
000012D6                           469          
000012D6                           470          * check to make sure it is a supported mode and size
000012D6                           471          
000012D6  43F9 0000154F            472          LEA     LEAOP,A1
000012DC  103C 000E                473          MOVE.B  #14,D0          * Print LEA
000012E0  4E4F                     474          TRAP    #15
000012E2                           475          
000012E2                           476          * call EA helper
000012E2  341A                     477          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000012E4                           478                  
000012E4  6000 0006                479          BRA     DONE          * we already found instruction, next iteration
000012E8                           480          
000012E8                           481  UNKNOWN *dont know what it is
000012E8  6100 01DE                482          BSR     UNKNOWNOP
000012EC                           483          
000012EC                           484  DONE
000012EC  4C9F 0303                485          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000012F0  6000 FD5E                486          BRA     ITERATION
000012F4                           487          
000012F4                           488          
000012F4                           489          
000012F4                           490  
000012F4                           491  * --- OP 0101 ------------------------------------------
000012F4                           492  * FUNCTIONS     SUBQ
000012F4                           493  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000012F4                           494  * ADDR REG        
000012F4                           495  * POST COND     All registers return to their previous state.
000012F4                           496  * ------------------------------------------------------
000012F4                           497  OP0101
000012F4                           498  
000012F4                           499  
000012F4                           500  
000012F4                           501  * --- OP 0110 ------------------------------------------
000012F4                           502  * FUNCTIONS     BCC, BCS, BGE, BLT, BVC, BRA
000012F4                           503  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000012F4                           504  * ADDR REG        
000012F4                           505  * POST COND     All registers return to their previous state.
000012F4                           506  * ------------------------------------------------------
000012F4                           507  OP0110
000012F4                           508  
000012F4                           509  
000012F4                           510  
000012F4                           511  
000012F4                           512  * --- OP 0111 ------------------------------------------
000012F4                           513  * FUNCTIONS     
000012F4                           514  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000012F4                           515  * ADDR REG        
000012F4                           516  * POST COND     All registers return to their previous state.
000012F4                           517  * ------------------------------------------------------
000012F4                           518  OP0111
000012F4                           519  
000012F4                           520  
000012F4                           521  
000012F4                           522  * --- OP 1000 ------------------------------------------
000012F4                           523  * FUNCTIONS     DIVS, OR
000012F4                           524  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000012F4                           525  * ADDR REG        
000012F4                           526  * POST COND     All registers return to their previous state.
000012F4                           527  * ------------------------------------------------------
000012F4                           528  OP1000
000012F4                           529  
000012F4                           530  
000012F4                           531  
000012F4                           532  * --- OP 1001 ------------------------------------------
000012F4                           533  * FUNCTIONS     SUB
000012F4                           534  * DATA REG      D0, D1 for output. D2 for entire instruction. D6 for bitmask.
000012F4                           535  * ADDR REG        
000012F4                           536  * POST COND     All registers return to their previous state.
000012F4                           537  * ------------------------------------------------------
000012F4                           538  OP1001
000012F4                           539  
000012F4                           540  
000012F4                           541  
000012F4                           542  * --- OP 1010 ------------------------------------------
000012F4                           543  * FUNCTIONS     
000012F4                           544  * DATA REG      D0, D1 for output. D2 for entire instruction. D6 for bitmask.
000012F4                           545  * ADDR REG        
000012F4                           546  * POST COND     All registers return to their previous state.
000012F4                           547  * ------------------------------------------------------
000012F4                           548  OP1010
000012F4                           549  
000012F4                           550  
000012F4                           551  * --- OP 1011 ------------------------------------------
000012F4                           552  * FUNCTIONS     EOR, CMP 
000012F4                           553  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
000012F4                           554  * ADDR REG        
000012F4                           555  * POST COND     All registers return to their previous state.
000012F4                           556  * ------------------------------------------------------
000012F4                           557  OP1011
000012F4                           558  
000012F4                           559  
000012F4                           560  * --- OP 1100 ------------------------------------------
000012F4                           561  * FUNCTIONS     MULS
000012F4                           562  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
000012F4                           563  * ADDR REG        
000012F4                           564  * POST COND     All registers return to their previous state.
000012F4                           565  * ------------------------------------------------------
000012F4                           566  OP1100
000012F4                           567  
000012F4                           568  
000012F4                           569  
000012F4                           570  * --- OP 1101 ------------------------------------------
000012F4                           571  * FUNCTIONS     ADD, ADDA,
000012F4                           572  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
000012F4                           573  * ADDR REG        
000012F4                           574  * POST COND     All registers return to their previous state.
000012F4                           575  * ------------------------------------------------------
000012F4                           576  OP1101
000012F4                           577  
000012F4                           578  
000012F4                           579  
000012F4                           580  * --- OP 1110 ------------------------------------------
000012F4                           581  * FUNCTIONS     LSL, LSR, ASL, ASR, ROL, ROR, 
000012F4                           582  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000012F4                           583  * ADDR REG        
000012F4                           584  * POST COND     All registers return to their previous state.
000012F4                           585  * ------------------------------------------------------
000012F4                           586  OP1110
000012F4                           587  
000012F4                           588  
000012F4                           589  
000012F4                           590  
000012F4                           591  * --- OP 1111 ------------------------------------------
000012F4                           592  * FUNCTIONS     
000012F4                           593  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000012F4                           594  * ADDR REG        
000012F4                           595  * POST COND     All registers return to their previous state.
000012F4                           596  * ------------------------------------------------------
000012F4                           597  OP1111
000012F4                           598  
000012F4                           599  * --- EAHELPER05 ----------------------------------------
000012F4                           600  * PRE  COND     D2 contains the instruction we wish to 
000012F4                           601  *               print the modes, registers for.
000012F4                           602  *               Only call this helper for operations that only
000012F4                           603  *               have one mode, register.
000012F4                           604  * POST COND     Determines mode, passes D2 to REGHELPER to print
000012F4                           605  * ------------------------------------------------------
000012F4                           606  
000012F4                           607  EAHELPER05
000012F4                           608      
000012F4  48A7 FFC0                609      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000012F8                           610      
000012F8  7C03                     611      MOVE.L  #3,D6
000012FA  7E05                     612      MOVE.L  #5,D7
000012FC                           613      
000012FC  6100 01F4                614      BSR     BITMASK * generate a bitmask to identify the mode
00001300                           615      
00001300  CC42                     616      AND     D2,D6   * mask off the parts of D2 we don't need
00001302                           617      
00001302  0C46 0000                618      CMPI    #%0000000000000000,D6 * is it data register direct?
00001306  6600 0012                619      BNE     NOTDATAREG
0000130A                           620      
0000130A  7C00                     621      MOVE.L  #0,D6
0000130C  7E02                     622      MOVE.L  #2,D7
0000130E                           623      
0000130E  6100 01E2                624      BSR     BITMASK * generate a bitmask to identify the mode
00001312                           625      
00001312  CC42                     626      AND     D2,D6   * mask off the parts of D2 we don't need
00001314                           627      
00001314  6100 0006                628      BSR     MODE_DN
00001318  4E75                     629      RTS
0000131A                           630      
0000131A                           631  NOTDATAREG
0000131A  4E75                     632      RTS
0000131C                           633  
0000131C                           634  * --- Effective Address --------------------------------
0000131C                           635  * PURPOSE       To generalize the EA part of the project.
0000131C                           636  * PRE CON       The Mode must have been correctly identified. All Modes must be called by RTS
0000131C                           637  * POST CON      After the EA, the entire op will head back to the BSR that called it.
0000131C                           638  * ------------------------------------------------------        
0000131C                           639  MODE_DN
0000131C  3C3C 0000                640          MOVE.W  #0, D6              * Prep lower value for bitmask
00001320  3E3C 0002                641          MOVE.W  #2, D7              * Prep upper value for bitmask
00001324  6100 01CC                642          BSR     BITMASK             * Finalize bitmask setup
00001328  CC42                     643          AND     D2,D6               * Apply bitmask
0000132A                           644          
0000132A  0C46 0000                645          CMPI    #%000000000000000, D6   * Data Register D0?
0000132E  6600 0008                646          BNE     NOTD0
00001332                           647          
00001332  6100 005E                648          BSR     PRINTD0
00001336  4E75                     649          RTS
00001338                           650  NOTD0      
00001338  0C46 0001                651          CMPI    #%000000000000001, D6   * Data Register D1?
0000133C  6600 0008                652          BNE     NOTD1
00001340                           653          
00001340  6100 005E                654          BSR     PRINTD1
00001344  4E75                     655          RTS
00001346                           656  NOTD1
00001346  0C46 0002                657          CMPI    #%000000000000010, D6   * Data Register D2?
0000134A  6600 0008                658          BNE     NOTD2
0000134E                           659          
0000134E  6100 005E                660          BSR     PRINTD2
00001352  4E75                     661          RTS
00001354                           662  NOTD2
00001354  0C46 0003                663          CMPI    #%000000000000011, D6   * Data Register D3?
00001358  6600 0008                664          BNE     NOTD3
0000135C                           665          
0000135C  6100 005E                666          BSR     PRINTD3
00001360  4E75                     667          RTS
00001362                           668  NOTD3
00001362  0C46 0004                669          CMPI    #%000000000000100, D6   * Data Register D4?
00001366  6600 0008                670          BNE     NOTD4
0000136A                           671          
0000136A  6100 005E                672          BSR     PRINTD4
0000136E  4E75                     673          RTS
00001370                           674  NOTD4
00001370  0C46 0005                675          CMPI    #%000000000000101, D6   * Data Register D5?
00001374  6600 0008                676          BNE     NOTD5
00001378                           677          
00001378  6100 005E                678          BSR     PRINTD5
0000137C  4E75                     679          RTS
0000137E                           680  NOTD5
0000137E  0C46 0006                681          CMPI    #%000000000000110, D6   * Data Register D6?
00001382  6600 0008                682          BNE     NOTD6
00001386                           683          
00001386  6100 005E                684          BSR     PRINTD6
0000138A  4E75                     685          RTS
0000138C                           686  NOTD6
0000138C  6100 0066                687          BSR     PRINTD7
00001390  4E75                     688          RTS
00001392                           689  
00001392                           690  
00001392                           691  
00001392                           692  PRINTD0
00001392  43F9 00001593            693          LEA     __D0, A1        * Load 'D0'
00001398  103C 000E                694          MOVE.B  #14, D0         * Load Trap #14 to print out
0000139C  4E4F                     695          TRAP    #15             * Perform Trap #14
0000139E  4E75                     696          RTS
000013A0                           697          
000013A0                           698  PRINTD1
000013A0  43F9 00001596            699          LEA     __D1, A1        * Load 'D1'
000013A6  103C 000E                700          MOVE.B  #14, D0         * Load Trap #14 to print out
000013AA  4E4F                     701          TRAP    #15             * Perform Trap #14
000013AC  4E75                     702          RTS
000013AE                           703          
000013AE                           704  PRINTD2
000013AE  43F9 00001599            705          LEA     __D2, A1        * Load 'D2'
000013B4  103C 000E                706          MOVE.B  #14, D0         * Load Trap #14 to print out
000013B8  4E4F                     707          TRAP    #15             * Perform Trap #14
000013BA  4E75                     708          RTS
000013BC                           709          
000013BC                           710  PRINTD3
000013BC  43F9 0000159C            711          LEA     __D3, A1        * Load 'D3'
000013C2  103C 000E                712          MOVE.B  #14, D0         * Load Trap #14 to print out
000013C6  4E4F                     713          TRAP    #15             * Perform Trap #14
000013C8  4E75                     714          RTS
000013CA                           715          
000013CA                           716  PRINTD4
000013CA  43F9 0000159F            717          LEA     __D4, A1        * Load 'D4'
000013D0  103C 000E                718          MOVE.B  #14, D0         * Load Trap #14 to print out
000013D4  4E4F                     719          TRAP    #15             * Perform Trap #14
000013D6  4E75                     720          RTS
000013D8                           721          
000013D8                           722  PRINTD5
000013D8  43F9 000015A2            723          LEA     __D5, A1        * Load 'D5'
000013DE  103C 000E                724          MOVE.B  #14, D0         * Load Trap #14 to print out
000013E2  4E4F                     725          TRAP    #15             * Perform Trap #14
000013E4  4E75                     726          RTS
000013E6                           727          
000013E6                           728  PRINTD6
000013E6  43F9 000015A5            729          LEA     __D6, A1        * Load 'D6'
000013EC  103C 000E                730          MOVE.B  #14, D0         * Load Trap #14 to print out
000013F0  4E4F                     731          TRAP    #15             * Perform Trap #14
000013F2  4E75                     732          RTS
000013F4                           733          
000013F4                           734  PRINTD7
000013F4  43F9 000015A8            735          LEA     __D7, A1        * Load 'D7'
000013FA  103C 000E                736          MOVE.B  #14, D0         * Load Trap #14 to print out
000013FE  4E4F                     737          TRAP    #15             * Perform Trap #14
00001400  4E75                     738          RTS
00001402                           739          
00001402                           740  SIZE67  * If the size is stored in bits 6->7
00001402  48A7 FFFE                741          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001406  3C3C 0006                742          MOVE.W  #6, D6              * Prep lower value for bitmask
0000140A  3E3C 0007                743          MOVE.W  #7, D7              * Prep upper value for bitmask
0000140E  6100 00E2                744          BSR     BITMASK             * Finalize bitmask setup
00001412  CC42                     745          AND     D2,D6               * Apply bitmask     
00001414                           746  
00001414  0C46 0000                747          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001418  6600 000A                748          BNE     NOT67BYTE
0000141C                           749          
0000141C  6100 0080                750          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001420  6000 001E                751          BRA     END67
00001424                           752  NOT67BYTE        
00001424  0C46 0040                753          CMPI    #%0000000001000000, D6   * is it a WORD?
00001428  6600 000A                754          BNE     NOT67WORD
0000142C                           755          
0000142C  6100 007E                756          BSR     PRINTWORD               * Branch to handle WORD sizes
00001430  6000 000E                757          BRA     END67
00001434                           758  NOT67WORD
00001434  0C46 0080                759          CMPI    #%0000000010000000, D6   * is it a LONG?
00001438  6600 0006                760          BNE     END67
0000143C                           761          
0000143C  6100 007C                762          BSR     PRINTLONG               * Branch to handle LONG sizes
00001440                           763  END67
00001440  4C9F 7FFF                764          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001444  4E75                     765          RTS                             * Return. Size handling is finished.
00001446                           766          
00001446                           767  SIZE68  * If the size is stored in bits 6->8 
00001446  48A7 FFFE                768          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
0000144A  3C3C 0006                769          MOVE.W  #6, D6              * Prep lower value for bitmask
0000144E  3E3C 0008                770          MOVE.W  #8, D7              * Prep upper value for bitmask
00001452  6100 009E                771          BSR     BITMASK             * Finalize bitmask setup
00001456  CC42                     772          AND     D2,D6               * Apply bitmask          
00001458                           773          
00001458  0C46 0000                774          CMPI    #%0000000000000000, D6   * is it a BYTE?
0000145C  6100 0040                775          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001460  0C46 0100                776          CMPI    #%0000000100000000, D6   * is it a BYTE?
00001464  6100 0038                777          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001468                           778        
00001468  0C46 0040                779          CMPI    #%0000000001000000, D6   * is it a WORD?
0000146C  6100 003E                780          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001470  0C46 0140                781          CMPI    #%0000000101000000, D6   * is it a WORD?
00001474  6100 0036                782          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001478  0C46 00C0                783          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
0000147C  6100 002E                784          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001480                           785  
00001480  0C46 0080                786          CMPI    #%0000000010000000, D6   * is it a LONG?
00001484  6100 0034                787          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001488  0C46 0180                788          CMPI    #%0000000110000000, D6   * is it a LONG?
0000148C  6100 002C                789          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001490  0C46 01C0                790          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001494  6100 0024                791          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001498                           792  
00001498  4C9F 7FFF                793          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
0000149C  4E75                     794          RTS                             * Return. Size handling is finished.              
0000149E                           795          
0000149E                           796  PRINTBYTE
0000149E  43F9 0000156F            797          LEA     __B,A1      * Load '.B ' into A1
000014A4  103C 000E                798          MOVE.B  #14,D0      * Trap #14 setup to print
000014A8  4E4F                     799          TRAP    #15         * Perform Trap #14
000014AA  4E75                     800          RTS                 * Return to SIZE67/SIZE68
000014AC                           801          
000014AC                           802  PRINTWORD
000014AC  43F9 00001573            803          LEA     __W,A1      * Load '.W ' into A1
000014B2  103C 000E                804          MOVE.B  #14,D0      * Trap #14 setup to print
000014B6  4E4F                     805          TRAP    #15         * Perform Trap #14
000014B8  4E75                     806          RTS                 * Return to SIZE67/SIZE68
000014BA                           807  
000014BA                           808  PRINTLONG
000014BA  43F9 00001577            809          LEA     __L,A1      * Load '.L ' into A1
000014C0  103C 000E                810          MOVE.B  #14,D0      * Trap #14 setup to print
000014C4  4E4F                     811          TRAP    #15         * Perform Trap #14
000014C6  4E75                     812          RTS                 * Return to SIZE67/SIZE68
000014C8                           813  
000014C8                           814  * --- UNKNOWNOP ----------------------------------------
000014C8                           815  * PRE  COND     D2 contains the instruction we wish to print.
000014C8                           816  *               D2 has already been identified as an unknown operation
000014C8                           817  * 
000014C8                           818  * POST COND     D2 is no longer the opcode
000014C8                           819  * ------------------------------------------------------
000014C8                           820     
000014C8                           821  UNKNOWNOP
000014C8  220A                     822          MOVE.L  A2,D1   * prep the add to print
000014CA                           823          
000014CA  5581                     824          SUB.L   #2,D1   * off by two error due to post increment correct
000014CC                           825          
000014CC  2602                     826          MOVE.L  D2,D3   * save the opcode to print
000014CE                           827          
000014CE  7410                     828          MOVE.L  #16,D2  * set the base to 16
000014D0                           829          
000014D0  700F                     830          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000014D2  4E4F                     831          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000014D4                           832          
000014D4  43F9 00001561            833          LEA     DATA,A1 * load " DATA $" into register A1
000014DA  700E                     834          MOVE.L  #14,D0  * print the string stored in A1
000014DC  4E4F                     835          TRAP    #15
000014DE                           836          
000014DE  2203                     837          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
000014E0                           838          
000014E0  103C 000F                839          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
000014E4  4E4F                     840          TRAP    #15      * Perform Trap #3
000014E6                           841          
000014E6  43F9 00001536            842          LEA     NEWLINE,A1 * load newline into register A1
000014EC  700E                     843          MOVE.L  #14,D0  * print the string stored in A1
000014EE  4E4F                     844          TRAP    #15
000014F0                           845          
000014F0  4E75                     846          RTS
000014F2                           847          *BRA     ITERATION * done with this op, move on to the next iteration
000014F2                           848  
000014F2                           849   * --- BITMASK ----------------------------------------------------------------
000014F2                           850   *@pre      D6 contains the starting bit you want masked, D7 the ending bit
000014F2                           851   *
000014F2                           852   *@post     D6 contains the bitmask, ready for use
000014F2                           853   
000014F2                           854  BITMASK
000014F2  3F05                     855          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
000014F4  4245                     856          CLR     D5          * clear D5 so we can use it
000014F6                           857  LOOPBIT 
000014F6  0DC5                     858          BSET    D6,D5       * set the D6th bit in D5 to 1
000014F8  5246                     859          ADD     #1,D6       * increment D6
000014FA                           860          
000014FA  BC47                     861          CMP     D7,D6       * have we finished?
000014FC  6E00 0004                862          BGT     BITMASKDONE * yes
00001500  60F4                     863          BRA     LOOPBIT     * no, iterate again
00001502                           864          
00001502                           865  BITMASKDONE
00001502                           866  
00001502  2C05                     867          MOVE.L  D5,D6
00001504  3A1F                     868          MOVE    (A7)+,D5    * restore D5
00001506  4E75                     869          RTS
00001508                           870          
00001508                           871   * --- OP0100 -----------------------------------------------------------------
00001508                           872   * @pre      D2 contains the opcode
00001508                           873   *
00001508                           874   * @post     all registers are returned to their previous state
00001508                           875  
00001508                           876  
00001508                           877  
00001508                           878   * ----------------------------------------------------------------------------
00001508                           879   * ----------------------------------------------------------------------------
00001508                           880   * Constants for printing information to the console
00001508                           881  
00001508  =0000000D                882  CR      EQU     $0D
00001508  =0000000A                883  LF      EQU     $0A
00001508= 45 4E 54 45 52 20 ...    884  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001520= 45 4E 54 45 52 20 ...    885  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001536= 0D 0A 00                 886  NEWLINE     DC.B    CR,LF,0
00001539= 4E 4F 50 00              887  NOOPERATION DC.B    'NOP',0
0000153D= 4E 45 47 00              888  NEGOP       DC.B    'NEG',0
00001541= 4D 4F 56 45 4D 00        889  MOVEMOP     DC.B    'MOVEM',0
00001547= 4A 53 52 00              890  JSROP       DC.B    'JSR',0
0000154B= 52 54 53 00              891  RTSOP       DC.B    'RTS',0
0000154F= 4C 45 41 00              892  LEAOP       DC.B    'LEA',0
00001553= 42 43 4C 52 00           893  BCLROP      DC.B    'BCLR',0
00001558= 4F 52 49 00              894  ORIOP       DC.B    'ORI',0
0000155C= 43 4D 50 49 00           895  CMPIOP      DC.B    'CMPI',0
00001561= 20 44 41 54 41 20 ...    896  DATA        DC.B    ' DATA $',0
00001569                           897  
00001569                           898   * ----------------------------------------------------------------------------
00001569                           899   * ----------------------------------------------------------------------------
00001569                           900   * Data defined constants
00001569                           901   *   - B/W/L (representing Byte, Word, Long)
00001569                           902   *   - A0-A7 (representing the 8 address registers)
00001569                           903   *   - D0-D7 (representing the 8 data registers)
00001569                           904   * ----------------------------------------------------------------------------
00001569                           905  
00001569= 20 00                    906  SPACE      DC.B    ' ',0
0000156B= 23 00                    907  IMD        DC.B    '#',0
0000156D= 2C 00                    908  COMMA      DC.B    ',',0
0000156F= 2E 42 20 00              909  __B        DC.B    '.B ',0
00001573= 2E 57 20 00              910  __W        DC.B    '.W ',0
00001577= 2E 4C 20 00              911  __L        DC.B    '.L ',0
0000157B                           912  
0000157B= 41 30 00                 913  __A0        DC.B   'A0',0
0000157E= 41 31 00                 914  __A1        DC.B   'A1',0    
00001581= 41 32 00                 915  __A2        DC.B   'A2',0
00001584= 41 33 00                 916  __A3        DC.B   'A3',0
00001587= 41 34 00                 917  __A4        DC.B   'A4',0
0000158A= 41 35 00                 918  __A5        DC.B   'A5',0
0000158D= 41 36 00                 919  __A6        DC.B   'A6',0
00001590= 41 37 00                 920  __A7        DC.B   'A7',0
00001593                           921  
00001593= 44 30 00                 922  __D0        DC.B   'D0',0
00001596= 44 31 00                 923  __D1        DC.B   'D1',0
00001599= 44 32 00                 924  __D2        DC.B   'D2',0
0000159C= 44 33 00                 925  __D3        DC.B   'D3',0
0000159F= 44 34 00                 926  __D4        DC.B   'D4',0
000015A2= 44 35 00                 927  __D5        DC.B   'D5',0
000015A5= 44 36 00                 928  __D6        DC.B   'D6',0
000015A8= 44 37 00                 929  __D7        DC.B   'D7',0
000015AB                           930   * ---------------------------------------------------------------------------
000015AB                           931   * End of definition segment
000015AB                           932   * ---------------------------------------------------------------------------
000015AB                           933   * ---------------------------------------------------------------------------
000015AB                           934  
000015AB                           935  * Put variables and constants here
000015AB                           936  
00004000                           937      ORG $4000
00004000                           938  
00004000  4E71                     939      NOP
00004002  103C 009A                940      MOVE.B   #%10011010, D0
00004006  123C 00A9                941      MOVE.B   #%10101001, D1
0000400A  D200                     942      ADD.B    D0,D1
0000400C  48A7 4000                943      MOVEM    D1,-(A7)
00004010  43F8 1547                944      LEA      JSROP,A1
00004014  4443                     945      NEG.W    D3
00004016  4EB9 0000401C            946      JSR      END
0000401C                           947  
0000401C                           948  END
0000401C  4E75                     949      RTS
0000401E                           950  RLLYEND
0000401E                           951      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BCLROP              1553
BITMASK             14F2
BITMASKDONE         1502
CMPIBYTE            10E0
CMPIEA              1154
CMPILONG            112E
CMPIOP              155C
CMPIREG             11C0
CMPIREG000          11DE
CMPIREG001          11DE
CMPIWORD            1108
COMMA               156D
CR                  D
DATA                1561
DONE                12EC
EAHELPER05          12F4
END                 401C
END67               1440
IMD                 156B
ISCMPI              10A6
ISORI               10A6
ITERATION           1050
JSROP               1547
LEAOP               154F
LF                  A
LOOP                103A
LOOPBIT             14F6
MODE_AN             11DE
MODE_DN             131C
MODE_IAN            11DE
MODE_IAN_POS        11DE
MODE_IAN_PRE        11DE
MOVEMOP             1541
MSGEND              1520
MSGSTART            1508
NEGOP               153D
NEWLINE             1536
NEXT                104C
NOOPERATION         1539
NOT67BYTE           1424
NOT67WORD           1434
NOTBCLR             1084
NOTD0               1338
NOTD1               1346
NOTD2               1354
NOTD3               1362
NOTD4               1370
NOTD5               137E
NOTD6               138C
NOTDATAREG          131A
NOTJSR              12A2
NOTMOVEM            127C
NOTNEG              1258
NOTNOP              1212
NOTRTS              12C4
OP0000              105A
OP0001              11DE
OP0010              11DE
OP0011              11DE
OP0100              11F6
OP0101              12F4
OP0110              12F4
OP0111              12F4
OP1000              12F4
OP1001              12F4
OP1010              12F4
OP1011              12F4
OP1100              12F4
OP1101              12F4
OP1110              12F4
OP1111              12F4
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
ORIOP               1558
PRINTBYTE           149E
PRINTD0             1392
PRINTD1             13A0
PRINTD2             13AE
PRINTD3             13BC
PRINTD4             13CA
PRINTD5             13D8
PRINTD6             13E6
PRINTD7             13F4
PRINTLONG           14BA
PRINTWORD           14AC
RLLYEND             401E
RTSOP               154B
SIZE67              1402
SIZE68              1446
SPACE               1569
START               1000
UNKNOWN             12E8
UNKNOWNOP           14C8
__A0                157B
__A1                157E
__A2                1581
__A3                1584
__A4                1587
__A5                158A
__A6                158D
__A7                1590
__B                 156F
__D0                1593
__D1                1596
__D2                1599
__D3                159C
__D4                159F
__D5                15A2
__D6                15A5
__D7                15A8
__L                 1577
__W                 1573
