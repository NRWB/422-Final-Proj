00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/1/2014 2:59:43 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001A22             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001A3A             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001A50             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 09D4                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A                           100          
0000103A                           101          * MOVE.W  #BITMASK,D2     * Load the bitmask into data register D2
0000103A  3F06                     102          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     103          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     104          AND.W   D2,D6           * Apply this bitmask
00001040                           105          
00001040  BC7C 1000                106          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001044  6600 000A                107          BNE     NOT0001            * No, check next case
00001048  6100 018E                108          BSR     OP0001          * Branch to subroutine 0001
0000104C  6000 0016                109          BRA     ITERATION       * Move to next iteration of the loop
00001050                           110  NOT0001       
00001050  BC7C 4000                111          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001054  6600 000A                112          BNE     NEXT            * No, check next case
00001058  6100 01E6                113          BSR     OP0100          * Branch to subroutine 0100
0000105C  6000 0006                114          BRA     ITERATION       * Move to next iteration of the loop
00001060                           115          
00001060                           116  NEXT
00001060  6100 07F2                117          BSR     UNKNOWNOP
00001064                           118          
00001064                           119  ITERATION
00001064  3C1F                     120          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001066                           121  
00001066                           122          *MOVE.B  #14,D0          * Print a newline
00001066                           123          *TRAP    #15             * Perform Trap #14
00001066                           124  
00001066  BA4A                     125          CMP     A2,D5           * Compare the starting address to ending address
00001068  6700 2FB2                126          BEQ     END             * If they are equal, branch 
0000106C  60CC                     127          BRA     LOOP            * Otherwise, branch back to LOOP
0000106E                           128  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000106E                           129  *-----------------------------------------------------------------------------
0000106E                           130  
0000106E                           131  
0000106E                           132  
0000106E                           133  *-----------------------------------------------------------------------------
0000106E                           134  *-----------------------------------------------------------------------------
0000106E                           135  * NAME: OP_0000   (BCLR, ORI, CMPI)
0000106E                           136  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000106E                           137  * PRE-CONDITION:  xyz
0000106E                           138  * POST-CONDITION: All registers return to their previous state, and the output
0000106E                           139  *                 goes to the output console for reading the raw data or the
0000106E                           140  *                 actual instruction.
0000106E                           141  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000106E                           142  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000106E                           143  OP0000
0000106E  48A7 C0C0                144          MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
00001072  3C3C 0006                145          MOVE.W  #6, D6              * Prep lower value for bitmask
00001076  3E3C 0008                146          MOVE.W  #8, D7              * Prep upper value for bitmask
0000107A  6100 0990                147          BSR     BITMASK             * Finalize bitmask setup
0000107E  CC42                     148          AND     D2,D6               * Apply bitmask
00001080                           149          
00001080  0C46 0180                150          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001084  6600 0012                151          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
00001088                           152          
00001088  43F9 00001A78            153          LEA     BCLROP,A1           * We found BCLR
0000108E  103C 000E                154          MOVE.B  #14,D0              * Trap #14 prints out the data
00001092  4E4F                     155          TRAP    #15                 * Perform Trap #14
00001094  6000 013C                156          BRA     END0000              * Found the op, move to next iteration
00001098                           157  
00001098                           158  NOTBCLR * Possible options left are ORI or CMPI
00001098  3C3C 0009                159          MOVE.W  #9, D6              * Prep lower value for bitmask
0000109C  3E3C 000B                160          MOVE.W  #11, D7             * Prep upper value for bitmask
000010A0  6100 096A                161          BSR     BITMASK             * Finalize bitmask setup
000010A4  CC42                     162          AND     D2,D6               * Apply bitmask
000010A6                           163          
000010A6  0C46 0000                164          CMPI    #%0000000000000000, D6  * Are we ORI?
000010AA  6700 000E                165          BEQ     ISORI                   * If ORI, branch to ISORI
000010AE                           166          
000010AE  0C46 0C00                167          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
000010B2  6700 0006                168          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
000010B6                           169          
000010B6  6600 079C                170          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
000010BA                           171                                          * We don't deal too kindly with imposters.
000010BA                           172          
000010BA                           173  ISORI   * TODO
000010BA                           174          
000010BA                           175  
000010BA                           176  ISCMPI
000010BA  43F9 00001A81            177          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000010C0  103C 000E                178          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000010C4  4E4F                     179          TRAP    #15                 * Perform Trap #14
000010C6                           180          
000010C6                           181          * Determine the Size
000010C6  3C3C 0006                182          MOVE.W  #6, D6              * Prep lower value for bitmask
000010CA  3E3C 0007                183          MOVE.W  #7, D7              * Prep upper value for bitmask
000010CE  6100 093C                184          BSR     BITMASK             * Finalize bitmask setup
000010D2  CC42                     185          AND     D2,D6               * Apply bitmask
000010D4                           186          
000010D4  0C46 00C0                187          CMPI    #%0000000011000000, D6  * Imposter Op
000010D8  6700 077A                188          BEQ     UNKNOWNOP               * Deal with the imposter
000010DC                           189          
000010DC  0C46 0000                190          CMPI    #%0000000000000000, D6  * The size is a BYTE
000010E0  6700 0012                191          BEQ     CMPIBYTE                * Branch to CMPI.B
000010E4                           192          
000010E4  0C46 0040                193          CMPI    #%0000000001000000, D6  * The size is a WORD
000010E8  6700 0032                194          BEQ     CMPIWORD                * Branch to CMPI.W
000010EC                           195          
000010EC  0C46 0080                196          CMPI    #%0000000010000000, D6  * The size is a LONG
000010F0  6700 0050                197          BEQ     CMPILONG                * Branch to CMPI.L
000010F4                           198          
000010F4                           199  CMPIBYTE
000010F4  43F9 00001AD6            200          LEA     __B, A1     * Load .B
000010FA  103C 000E                201          MOVE.B  #14, D0     * Print out data
000010FE  4E4F                     202          TRAP    #15         * Perform Trap #14
00001100                           203          
00001100  43F9 00001ACA            204          LEA     IMD, A1     * Load #
00001106  103C 000E                205          MOVE.B  #14, D0     * Print out data
0000110A  4E4F                     206          TRAP    #15         * Perform Trap #14
0000110C                           207          
0000110C  361A                     208          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000110E  1203                     209          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
00001110  3622                     210          MOVE.W  -(A2),D3    * Now go back
00001112  103C 000E                211          MOVE.B  #14, D0     * Print out the data
00001116  4E4F                     212          TRAP    #15         * Perform Trap #14 
00001118                           213          
00001118  6000 004E                214          BRA     CMPIEA      * Branch to determine Effective Address
0000111C                           215          
0000111C                           216  CMPIWORD
0000111C  43F9 00001ADA            217          LEA     __W, A1     * Load .W
00001122  103C 000E                218          MOVE.B  #14, D0     * Print out data
00001126  4E4F                     219          TRAP    #15         * Perform Trap #14
00001128                           220          
00001128  43F9 00001ACA            221          LEA     IMD, A1     * Load #
0000112E  103C 000E                222          MOVE.B  #14, D0     * Print out data
00001132  4E4F                     223          TRAP    #15         * Perform Trap #14
00001134                           224          
00001134  361A                     225          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001136  3222                     226          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
00001138  103C 000E                227          MOVE.B  #14, D0     * Print out the data
0000113C  4E4F                     228          TRAP    #15         * Perform Trap #14
0000113E                           229          
0000113E                           230          
0000113E  6000 0028                231          BRA     CMPIEA      * Branch to determine Effective Address
00001142                           232          
00001142                           233  CMPILONG
00001142  43F9 00001ADE            234          LEA     __L, A1     * Load .L
00001148  103C 000E                235          MOVE.B  #14, D0     * Print out data
0000114C  4E4F                     236          TRAP    #15         * Perform Trap #14
0000114E                           237          
0000114E  43F9 00001ACA            238          LEA     IMD, A1     * Load #
00001154  103C 000E                239          MOVE.B  #14, D0     * Print out data
00001158  4E4F                     240          TRAP    #15         * Perform Trap #14
0000115A                           241          
0000115A  361A                     242          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000115C  2222                     243          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
0000115E  103C 000E                244          MOVE.B  #14, D0     * Print out the data
00001162  4E4F                     245          TRAP    #15         * Perform Trap #14
00001164                           246          
00001164  6000 0002                247          BRA     CMPIEA      * Branch to determine Effective Address
00001168                           248          
00001168                           249  CMPIEA
00001168                           250          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
00001168  43F9 00001ACC            251          LEA     COMMA, A1   * Load ,
0000116E  103C 000E                252          MOVE.B  #14, D0     * Print out data
00001172  4E4F                     253          TRAP    #15         * Perform Trap #14
00001174                           254          
00001174  43F9 00001ADE            255          LEA     __L, A1     * Load .L
0000117A  103C 000E                256          MOVE.B  #14, D0     * Print out data
0000117E  4E4F                     257          TRAP    #15         * Perform Trap #14
00001180                           258          
00001180                           259          * Determine the mode
00001180  3C3C 0003                260          MOVE.W  #3, D6              * Prep lower value for bitmask
00001184  3E3C 0005                261          MOVE.W  #5, D7              * Prep upper value for bitmask
00001188  6100 0882                262          BSR     BITMASK             * Finalize bitmask setup
0000118C  CC42                     263          AND     D2,D6               * Apply bitmask
0000118E                           264          
0000118E  0C46 0008                265          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
00001192  6700 06C0                266          BEQ     UNKNOWNOP               * Imposter op
00001196                           267          
00001196  0C46 0028                268          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
0000119A  6700 06B8                269          BEQ     UNKNOWNOP               * Imposter op
0000119E                           270          
0000119E  0C46 0030                271          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
000011A2  6700 06B0                272          BEQ     UNKNOWNOP               * Imposter op
000011A6                           273  
000011A6  0C46 0038                274          CMPI    #%0000000000111000, D6  * Is the Mode 111?
000011AA  6700 0008                275          BEQ     CMPIREG                 * Further investigation is needed
000011AE                           276          
000011AE                           277          * will need to call the EA helpers when they are complete
000011AE                           278          
000011AE                           279          * Mode is verified to be valid at this point
000011AE                           280          *CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
000011AE                           281          *BSR     MODE_DN
000011AE                           282          
000011AE                           283          *CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
000011AE                           284          *BSR     MODE_AN
000011AE                           285          
000011AE                           286          *CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
000011AE                           287          *BSR     MODE_IAN_POS
000011AE                           288          
000011AE                           289          *CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
000011AE                           290          *BSR     MODE_IAN_PRE
000011AE                           291          
000011AE                           292          * Reached End of CMPI. Everything has been printed out
000011AE  4C9F 0303                293          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000011B2  4E75                     294          RTS
000011B4                           295          
000011B4                           296  CMPIREG
000011B4  3C3C 0000                297          MOVE.W  #0, D6              * Prep lower value for bitmask
000011B8  3E3C 0002                298          MOVE.W  #2, D7              * Prep upper value for bitmask
000011BC  6100 084E                299          BSR     BITMASK             * Finalize bitmask setup
000011C0  CC42                     300          AND     D2,D6               * Apply bitmask
000011C2                           301          
000011C2  0C46 0000                302          CMPI    #%0000000000000000, D6  * Is the Register 000?
000011C6  6700 0010                303          BEQ     CMPIREG000
000011CA                           304          
000011CA  0C46 0001                305          CMPI    #%0000000000000001, D6  * Is the Register 001?
000011CE  6700 0008                306          BEQ     CMPIREG001
000011D2                           307          
000011D2                           308  END0000          
000011D2  4C9F 0303                309         MOVEM   (A7)+,D0-D1/A0-A1   * Push values to the stack to save
000011D6  4E75                     310         RTS
000011D8                           311         
000011D8                           312  CMPIREG000  * TODO (xxx).W for CMPI
000011D8                           313  
000011D8                           314  CMPIREG001  * TODO (xxx).L for CMPI
000011D8                           315  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000011D8                           316  *-----------------------------------------------------------------------------
000011D8                           317  
000011D8                           318  
000011D8                           319  
000011D8                           320  *-----------------------------------------------------------------------------
000011D8                           321  *-----------------------------------------------------------------------------
000011D8                           322  * NAME: OP_0001   (MOVE.B)
000011D8                           323  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000011D8                           324  * PRE-CONDITION:  xyz
000011D8                           325  * POST-CONDITION: All registers return to their previous state, and the output
000011D8                           326  *                 goes to the output console for reading the raw data or the
000011D8                           327  *                 actual instruction.
000011D8                           328  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000011D8                           329  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000011D8                           330  OP0001  
000011D8  48A7 FFC0                331          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
000011DC  3C3C 0006                332          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E0  3E3C 0008                333          MOVE.W  #8, D7              * Prep upper value for bitmask
000011E4  6100 0826                334          BSR     BITMASK             * Finalize bitmask setup
000011E8  CC42                     335          AND     D2,D6               * Apply bitmask
000011EA                           336          
000011EA                           337          * I may have fucked off this part, sorry - Caleb
000011EA                           338          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
000011EA                           339          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
000011EA                           340          
000011EA  43F9 00001A60            341          LEA     MOVEOP,A1   * Put 'MOVE' into the window
000011F0  103C 000E                342          MOVE.B  #14,D0      * Trap #14 to print out
000011F4  4E4F                     343          TRAP    #15         * Perform Trap #14
000011F6                           344          
000011F6  6100 0596                345          BSR     SIZE67
000011FA  6100 0294                346          BSR     EAHELPER05
000011FE                           347          
000011FE  43F9 00001ACC            348          LEA     COMMA,A1
00001204  103C 000E                349          MOVE.B  #14,D0
00001208  4E4F                     350          TRAP    #15
0000120A                           351          
0000120A  6100 0250                352          BSR     EAHELPER611
0000120E                           353          
0000120E  43F9 00001A50            354          LEA     NEWLINE,A1
00001214  103C 000E                355          MOVE.B  #14,D0
00001218  4E4F                     356          TRAP    #15
0000121A                           357          
0000121A  6000 0006                358          BRA     ENDOP0001
0000121E                           359          *LEA     __B,A1      * Put '.B' into the window
0000121E                           360          *MOVE.B  #14,D0      * Trap #14 to print out
0000121E                           361          *TRAP    #15         * Perform Trap #14
0000121E                           362          
0000121E                           363  UNKNOWNOP0001
0000121E                           364  
0000121E  6100 0634                365          BSR     UNKNOWNOP
00001222                           366          
00001222                           367  ENDOP0001
00001222                           368  
00001222  4C9F 03FF                369          MOVEM (A7)+,D0-D7/A0-A1
00001226  4E75                     370          RTS        
00001228                           371          
00001228                           372          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
00001228                           373  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001228                           374  *-----------------------------------------------------------------------------
00001228                           375  
00001228                           376  
00001228                           377  
00001228                           378  *-----------------------------------------------------------------------------
00001228                           379  *-----------------------------------------------------------------------------
00001228                           380  * NAME: OP_0010   (MOVE.L, MOVEA.L)
00001228                           381  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001228                           382  * PRE-CONDITION:  xyz
00001228                           383  * POST-CONDITION: All registers return to their previous state, and the output
00001228                           384  *                 goes to the output console for reading the raw data or the
00001228                           385  *                 actual instruction.
00001228                           386  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001228                           387  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001228                           388  OP0010
00001228                           389  
00001228                           390  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001228                           391  *-----------------------------------------------------------------------------
00001228                           392  
00001228                           393  
00001228                           394  
00001228                           395  *-----------------------------------------------------------------------------
00001228                           396  *-----------------------------------------------------------------------------
00001228                           397  * NAME: OP_0011   (MOVE.W, MOVEA.W)
00001228                           398  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001228                           399  * PRE-CONDITION:  xyz
00001228                           400  * POST-CONDITION: All registers return to their previous state, and the output
00001228                           401  *                 goes to the output console for reading the raw data or the
00001228                           402  *                 actual instruction.
00001228                           403  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001228                           404  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001228                           405  OP0011
00001228  48A7 FFFE                406      MOVEM   D0-D7/A0-A6, -(A7)
0000122C                           407      
0000122C  3C3C 0006                408      MOVE.W  #6,D6
00001230  3E3C 0008                409      MOVE.W  #8,D7
00001234                           410      
00001234  6100 07D6                411      BSR     BITMASK
00001238                           412      
00001238  CC42                     413      AND.W   D2,D6
0000123A                           414      
0000123A  BC7C 0040                415      CMP     #%0000000001000000,D6
0000123E                           416      *BNE     NEXT15
0000123E  61FE                     417      BSR     * for MOVEA.W
00001240                           418  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001240                           419  *-----------------------------------------------------------------------------
00001240                           420  
00001240                           421  
00001240                           422  
00001240                           423  *-----------------------------------------------------------------------------
00001240                           424  *-----------------------------------------------------------------------------
00001240                           425  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
00001240                           426  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001240                           427  * PRE-CONDITION:  xyz
00001240                           428  * POST-CONDITION: All registers return to their previous state, and the output
00001240                           429  *                 goes to the output console for reading the raw data or the
00001240                           430  *                 actual instruction.
00001240                           431  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001240                           432  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001240                           433  OP0100  
00001240                           434          * TODO: lea, movem, neg?
00001240                           435  
00001240  48A7 C0C0                436          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001244                           437          
00001244                           438          *NOP
00001244  0C42 4E71                439          CMPI    #%0100111001110001,D2
00001248  6600 0012                440          BNE     NOTNOP
0000124C                           441          
0000124C  43F9 00001A58            442          LEA     NOOPERATION,A1
00001252  103C 000D                443          MOVE.B  #13,D0          * Print a newline
00001256  4E4F                     444          TRAP    #15
00001258                           445          
00001258  6000 0108                446          BRA     DONE *we found it, move on to the next iteration
0000125C                           447  NOTNOP *NEG
0000125C                           448          
0000125C                           449          * prep values for BITMASK subroutine
0000125C  7C08                     450          MOVE.L  #8,D6
0000125E  7E0B                     451          MOVE.L  #11,D7
00001260                           452          
00001260  6100 07AA                453          BSR     BITMASK
00001264                           454          
00001264  CC42                     455          AND     D2,D6                   * apply bitmask
00001266                           456          
00001266  0C46 0400                457          CMPI    #%0000010000000000,D6   * are we NEG?
0000126A  6600 0046                458          BNE     NOTNEG                  * not neg
0000126E                           459          
0000126E  7C03                     460          MOVE.L  #3,D6
00001270  7E05                     461          MOVE.L  #5,D7
00001272                           462          
00001272  6100 0798                463          BSR     BITMASK * generate a bitmask to be used to check mode
00001276                           464          
00001276  0C46 0008                465          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
0000127A  6700 00E2                466          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000127E                           467          
0000127E  0C46 0028                468          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001282  6700 00DA                469          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001286                           470          
00001286  0C46 0030                471          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000128A  6700 00D2                472          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000128E                           473        
0000128E                           474          * it is NEG, print
0000128E  43F9 00001A5C            475          LEA     NEGOP,A1
00001294  103C 000E                476          MOVE.B  #14,D0
00001298  4E4F                     477          TRAP    #15
0000129A                           478          
0000129A  6100 04F2                479          BSR     SIZE67
0000129E                           480          
0000129E  6100 01F0                481          BSR     EAHELPER05
000012A2                           482          
000012A2  43F9 00001A50            483          LEA     NEWLINE,A1
000012A8  103C 000E                484          MOVE.B  #14,D0
000012AC  4E4F                     485          TRAP    #15
000012AE                           486          
000012AE  6000 00B2                487          BRA     DONE * we found the op, move to next iteration
000012B2                           488          
000012B2                           489  NOTNEG *MOVEM
000012B2                           490  
000012B2                           491          * prep values for BITMASK subroutine
000012B2  7C07                     492          MOVE.L  #7,D6
000012B4  7E09                     493          MOVE.L  #9,D7
000012B6                           494          
000012B6  6100 0754                495          BSR     BITMASK
000012BA                           496          
000012BA  CC42                     497          AND     D2,D6   * apply bitmask
000012BC                           498          
000012BC  0C46 0080                499          CMPI    #%0000000010000000,D6 * is it MOVEM?
000012C0  6600 0014                500          BNE     NOTMOVEM          * it is not MOVEM
000012C4                           501          
000012C4                           502          * make sure it is a valid size and mode for MOVEM
000012C4                           503          
000012C4                           504          * it is MOVEM
000012C4  43F9 00001A65            505          LEA     MOVEMOP,A1
000012CA  103C 000D                506          MOVE.B  #13,D0          * Print a newline
000012CE  4E4F                     507          TRAP    #15
000012D0                           508          
000012D0                           509          * probably needs its own special code for printing the rest due to uniqueness of movem
000012D0                           510          
000012D0  341A                     511          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000012D2                           512          
000012D2  6000 008E                513          BRA     DONE          * we found and printed, move on to the next iteration
000012D6                           514          
000012D6                           515  NOTMOVEM *JSR
000012D6                           516          * prep values for BITMASK subroutine
000012D6  7C06                     517          MOVE.L  #6,D6
000012D8  7E08                     518          MOVE.L  #8,D7
000012DA                           519          
000012DA  6100 0730                520          BSR     BITMASK
000012DE                           521          
000012DE  CC42                     522          AND     D2,D6   * apply bitmask
000012E0                           523          
000012E0  0C46 0080                524          CMPI    #%0000000010000000,D6
000012E4  6600 0032                525          BNE     NOTJSR          * it's not JSR
000012E8                           526          
000012E8  43F9 00001A6B            527          LEA     JSROP,A1
000012EE  103C 000E                528          MOVE.B  #14,D0          * Print a newline and JSR
000012F2  4E4F                     529          TRAP    #15
000012F4                           530          
000012F4                           531          * print out where we are jumping to
000012F4                           532          
000012F4  341A                     533          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000012F6                           534          
000012F6  2202                     535          MOVE.L  D2,D1   * save the opcode to print
000012F8                           536          
000012F8  7410                     537          MOVE.L  #16,D2  * set the base to 16
000012FA                           538          
000012FA  700F                     539          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000012FC  4E4F                     540          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000012FE                           541          
000012FE  341A                     542          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001300                           543          
00001300  2202                     544          MOVE.L  D2,D1   * save the opcode to print
00001302                           545          
00001302  7410                     546          MOVE.L  #16,D2  * set the base to 16
00001304                           547          
00001304  700F                     548          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001306  4E4F                     549          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001308                           550          
00001308  43F9 00001A50            551          LEA     NEWLINE,A1
0000130E  103C 000E                552          MOVE.B  #14,D0          * Print a newline
00001312  4E4F                     553          TRAP    #15
00001314                           554          
00001314  6000 004C                555          BRA     DONE          * we already found instruction, next iteration
00001318                           556  NOTJSR *RTS
00001318                           557  
00001318                           558          * prep values for BITMASK subroutine
00001318  7C06                     559          MOVE.L  #6,D6
0000131A  7E08                     560          MOVE.L  #8,D7
0000131C                           561          
0000131C  6100 06EE                562          BSR     BITMASK
00001320                           563          
00001320  CC42                     564          AND     D2,D6   * apply bitmask
00001322                           565          
00001322  0C46 0040                566          CMPI    #%0000000001000000,D6
00001326  6600 0012                567          BNE     NOTRTS          * it's not RTS
0000132A                           568          
0000132A  43F9 00001A70            569          LEA     RTSOP,A1
00001330  103C 000D                570          MOVE.B  #13,D0          * Print a newline and RTS
00001334  4E4F                     571          TRAP    #15
00001336                           572          
00001336  6000 002A                573          BRA     DONE          * we already found instruction, next iteration
0000133A                           574  NOTRTS  *LEA
0000133A                           575         
0000133A                           576          * prep values for BITMASK subroutine
0000133A  7C06                     577          MOVE.L  #6,D6
0000133C  7E08                     578          MOVE.L  #8,D7
0000133E                           579          
0000133E  6100 06CC                580          BSR     BITMASK
00001342                           581          
00001342  CC42                     582          AND     D2,D6   * apply bitmask
00001344                           583          
00001344  0C46 01C0                584          CMPI    #%0000000111000000,D6
00001348  6600 0014                585          BNE     UNKNOWN          * it's not LEA, we dont know what it is
0000134C                           586          
0000134C                           587          * check to make sure it is a supported mode and size
0000134C                           588          
0000134C  43F9 00001A74            589          LEA     LEAOP,A1
00001352  103C 000D                590          MOVE.B  #13,D0          * Print LEA
00001356  4E4F                     591          TRAP    #15
00001358                           592          
00001358                           593          * call EA helper
00001358  341A                     594          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000135A                           595                  
0000135A  6000 0006                596          BRA     DONE          * we already found instruction, next iteration
0000135E                           597          
0000135E                           598  UNKNOWN *dont know what it is
0000135E  6100 04F4                599          BSR     UNKNOWNOP
00001362                           600          
00001362                           601  DONE
00001362  4C9F 0303                602          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001366  4E75                     603          RTS
00001368                           604          
00001368  6000 FCFA                605          BRA     ITERATION
0000136C                           606  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000136C                           607  *-----------------------------------------------------------------------------        
0000136C                           608          
0000136C                           609          
0000136C                           610  
0000136C                           611  *-----------------------------------------------------------------------------
0000136C                           612  *-----------------------------------------------------------------------------
0000136C                           613  * NAME: OP_0101   (SUBQ)
0000136C                           614  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000136C                           615  * PRE-CONDITION:  xyz
0000136C                           616  * POST-CONDITION: All registers return to their previous state, and the output
0000136C                           617  *                 goes to the output console for reading the raw data or the
0000136C                           618  *                 actual instruction.
0000136C                           619  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000136C                           620  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000136C                           621  OP0101
0000136C                           622  
0000136C                           623  * testing branching
0000136C                           624  * op op op
0000136C                           625  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000136C                           626  *-----------------------------------------------------------------------------
0000136C                           627  
0000136C                           628  
0000136C                           629  
0000136C                           630  *-----------------------------------------------------------------------------
0000136C                           631  *-----------------------------------------------------------------------------
0000136C                           632  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
0000136C                           633  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000136C                           634  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
0000136C                           635  *                 in the instruction and determines what the bits match to a
0000136C                           636  *                 given condition code. If the 8 bit offset is $00, or $FF,
0000136C                           637  *                 this signifies a word or long offset (for $00 and $FF
0000136C                           638  *                 respectively). The 8 bit offset is in 2's comp. form, and
0000136C                           639  *                 should be un-done, then plus or minus to the current
0000136C                           640  *                 program counter (PC) to get the actual memory label to
0000136C                           641  *                 output to console. The word offset signal eats an
0000136C                           642  *                 additional 16 bits and the long offset eats an additional
0000136C                           643  *                 32 bits. The word/long offset are for memory alignment.
0000136C                           644  * POST-CONDITION: All registers return to their previous state, and the output
0000136C                           645  *                 goes to the output console for reading the raw data or the
0000136C                           646  *                 actual instruction.
0000136C                           647  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000136C                           648  *                 A1 (output)
0000136C                           649  * CONDITIONS TABLE:
0000136C                           650  *                Condition Names  - Mnemonic - Condition Code
0000136C                           651  *                --------------------------------------------
0000136C                           652  *                True             -    T     - 0000
0000136C                           653  *                False            -    F     - 0001
0000136C                           654  *                Higher           -    HI    - 0010
0000136C                           655  *                Lower or Same    -    LS    - 0011
0000136C                           656  *                Carry Clear      -    CC    - 0100
0000136C                           657  *                Carry Set        -    CS    - 0101
0000136C                           658  *                Not Equal        -    NE    - 0110
0000136C                           659  *                Equal            -    EQ    - 0111
0000136C                           660  *                Overflow Clear   -    VC    - 1000
0000136C                           661  *                Overflow Set     -    VS    - 1001
0000136C                           662  *                Plus             -    PL    - 1010
0000136C                           663  *                Minus            -    MI    - 1011
0000136C                           664  *                Greater or Equal -    GE    - 1100
0000136C                           665  *                Less Than        -    LT    - 1101
0000136C                           666  *                Greater Than     -    GT    - 1110
0000136C                           667  *                Less or Equal    -    LE    - 1111
0000136C                           668  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000136C                           669  OP0110
0000136C  48A7 C0C0                670          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
00001370                           671          
00001370                           672          * Ready four bits to help distinguish op's with the 0110 prefix
00001370  3C3C 0000                673          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
00001374                           674                                        * BITMASK sub-routine call)
00001374  3E3C 0007                675          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001378                           676                                        * BITMASK sub-routine call)
00001378                           677                                        
00001378                           678          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001378  6100 0692                679          BSR     BITMASK               * Call BITMASK sub-routine
0000137C                           680                                        * Returns a bitmask in D6
0000137C                           681          
0000137C  CC42                     682          AND     D2,D6                 * And the index op, which was pre-loaded
0000137E                           683                                        * in the main memory loop with the bitmask
0000137E                           684                                        * to use to determine what case we need.
0000137E                           685          
0000137E                           686          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
0000137E                           687          * $00 == word offset, $FF == long offset
0000137E                           688       ***CMPI    #%0000000000000000,D6
0000137E                           689       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
0000137E                           690       ***
0000137E                           691       ***CMPI    #%0000000011111111,D6
0000137E                           692       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
0000137E                           693          
0000137E                           694          * IF PASSED BOTH CMPI CHECKS (ABOVE),
0000137E                           695          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
0000137E                           696          
0000137E  3C3C 0009                697          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
00001382  3E3C 000B                698          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
00001386                           699                                        
00001386                           700          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001386  6100 0684                701          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
0000138A  CC42                     702          AND     D2,D6   * apply the BITMASK
0000138C                           703          
0000138C                           704          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
0000138C  0C46 0400                705          CMPI    #%0000010000000000,D6
00001390  6700 002A                706          BEQ     OP_BCC
00001394                           707          
00001394                           708          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
00001394  0C46 0500                709          CMPI    #%0000010100000000,D6
00001398  6700 002C                710          BEQ     OP_BCS
0000139C                           711          
0000139C                           712          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
0000139C  0C46 0C00                713          CMPI    #%0000110000000000,D6
000013A0  6700 002E                714          BEQ     OP_BGE
000013A4                           715          
000013A4                           716          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
000013A4  0C46 0D00                717          CMPI    #%0000110100000000,D6
000013A8  6700 0030                718          BEQ     OP_BLT
000013AC                           719          
000013AC                           720          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
000013AC  0C46 0800                721          CMPI    #%0000100000000000,D6
000013B0  6700 0032                722          BEQ     OP_BVC
000013B4                           723          
000013B4                           724          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
000013B4                           725          * NOTE: A branch to the immediately following instruction automatically
000013B4                           726          *       uses the 16-bit displacement format because the 8-bit displacement
000013B4                           727          *       field contains $00 zero offset
000013B4                           728          * http://68k.hax.com/BRA
000013B4                           729          * NOTE2 ---> Does this mean, there should be no checks when debugging
000013B4                           730          *            for word/long offsets?
000013B4  0C46 0000                731          CMPI    #%0000000000000000,D6
000013B8  6700 0034                732          BEQ     OP_BRA
000013BC                           733          
000013BC                           734          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
000013BC                           735          ; call raw data print out sub routine
000013BC                           736  
000013BC                           737  OP_BCC
000013BC  43F9 00001A8E            738          LEA     OP_BCC_MSG,A1
000013C2  6000 0034                739          BRA     OP_BRANCHES_PRINT
000013C6                           740  OP_BCS
000013C6  43F9 00001A92            741          LEA     OP_BCS_MSG,A1
000013CC  6000 002A                742          BRA     OP_BRANCHES_PRINT
000013D0                           743  OP_BGE
000013D0  43F9 00001A96            744          LEA     OP_BGE_MSG,A1
000013D6  6000 0020                745          BRA     OP_BRANCHES_PRINT
000013DA                           746  OP_BLT
000013DA  43F9 00001A9A            747          LEA     OP_BLT_MSG,A1
000013E0  6000 0016                748          BRA     OP_BRANCHES_PRINT
000013E4                           749  OP_BVC
000013E4  43F9 00001A9E            750          LEA     OP_BVC_MSG,A1
000013EA  6000 000C                751          BRA     OP_BRANCHES_PRINT
000013EE                           752  OP_BRA
000013EE  43F9 00001AA2            753          LEA     OP_BRA_MSG,A1
000013F4  6000 0002                754          BRA     OP_BRANCHES_PRINT
000013F8                           755  
000013F8                           756  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000013F8                           757          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000013F8                           758          * assemble output to console
000013F8                           759  OP_BRANCHES_PRINT
000013F8  103C 000E                760          MOVE.B  #14,D0 * print instruction op
000013FC  4E4F                     761          TRAP    #15
000013FE                           762          
000013FE  43F9 00001A86            763          LEA     DATA,A1
00001404  103C 000E                764          MOVE.B  #14,D0 * print raw data hex of the LABEL
00001408  4E4F                     765          TRAP    #15
0000140A                           766          
0000140A  1A1A                     767          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
0000140C  2845                     768          MOVE.L  D5,A4 * ready the 8bits into a4
0000140E  43D4                     769          LEA     (A4),A1 * ready the a4 into a1 for print
00001410  103C 000E                770          MOVE.B  #14,D0 * print the 8bit addr
00001414  4E4F                     771          TRAP    #15
00001416                           772  
00001416  6000 0002                773          BRA     BCC_END
0000141A                           774  
0000141A                           775  BCC_END * reload the memory, call RTS
0000141A  4C9F 0303                776          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
0000141E  4E75                     777          RTS
00001420                           778  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001420                           779  *-----------------------------------------------------------------------------
00001420                           780  
00001420                           781  
00001420                           782  
00001420                           783  *-----------------------------------------------------------------------------
00001420                           784  *-----------------------------------------------------------------------------
00001420                           785  * NAME: OP_0111   ()
00001420                           786  * DESCRIPTION:    a
00001420                           787  * PRE-CONDITION:  b
00001420                           788  * POST-CONDITION: c
00001420                           789  * REGISTERS:      d
00001420                           790  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001420                           791  OP0111
00001420                           792  
00001420                           793  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001420                           794  *-----------------------------------------------------------------------------
00001420                           795  
00001420                           796  
00001420                           797  
00001420                           798  *-----------------------------------------------------------------------------
00001420                           799  *-----------------------------------------------------------------------------
00001420                           800  * NAME: OP_1000   (DIVS, OR)
00001420                           801  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001420                           802  * PRE-CONDITION:  xyz
00001420                           803  * POST-CONDITION: All registers return to their previous state, and the output
00001420                           804  *                 goes to the output console for reading the raw data or the
00001420                           805  *                 actual instruction.
00001420                           806  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001420                           807  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001420                           808  OP1000
00001420                           809          * Saving values to the stack
00001420  48A7 FFC0                810          MOVEM   D0-D7/A0-A1,-(A7)
00001424                           811  
00001424                           812          * Check if the EA Mode is 001 since both DIVS and OR do not support it
00001424  3C3C 0003                813          MOVE.W  #3, D6              * Prep lower value for bitmask
00001428  3E3C 0005                814          MOVE.W  #5, D7              * Prep upper value for bitmask
0000142C  6100 05DE                815          BSR     BITMASK             * Finalize bitmask setup
00001430  CC42                     816          AND     D2,D6               * Apply bitmask
00001432                           817          
00001432  0C46 0008                818          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
00001436  6700 FF26                819          BEQ     UNKNOWN                 * If so, the op is not supported
0000143A                           820          
0000143A                           821          * Checking for DIVS
0000143A  3C3C 0006                822          MOVE.W  #6, D6              * Prep lower value for bitmask
0000143E  3E3C 0008                823          MOVE.W  #8, D7              * Prep upper value for bitmask
00001442  6100 05C8                824          BSR     BITMASK             * Finalize bitmask setup
00001446  CC42                     825          AND     D2,D6               * Apply bitmask
00001448                           826          
00001448  0C46 01C0                827          CMPI    #%0000000111000000, D6  * Are we DIVS?
0000144C  6600 000E                828          BNE     NOTDIVS                 * If not, branch to see if it's OR
00001450                           829          
00001450  43F9 00001A53            830          LEA     DIVSOP,A1           * We found DIVS
00001456  103C 000E                831          MOVE.B  #14,D0              * Trap #14 prints out the data
0000145A  4E4F                     832          TRAP    #15                 * Perform Trap #14
0000145C                           833          
0000145C                           834  
0000145C                           835          * TODO: Print out register, EA mode, and EA register
0000145C                           836          
0000145C                           837  NOTDIVS * It is confirmed OR at this point
0000145C                           838          * TODO: Print out register, EA mode, and EA register
0000145C                           839  
0000145C                           840  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           841  *-----------------------------------------------------------------------------
0000145C                           842  
0000145C                           843  
0000145C                           844  
0000145C                           845  *-----------------------------------------------------------------------------
0000145C                           846  *-----------------------------------------------------------------------------
0000145C                           847  * NAME: OP_1001   (SUB)
0000145C                           848  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000145C                           849  * PRE-CONDITION:  xyz
0000145C                           850  * POST-CONDITION: All registers return to their previous state, and the output
0000145C                           851  *                 goes to the output console for reading the raw data or the
0000145C                           852  *                 actual instruction.
0000145C                           853  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000145C                           854  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           855  OP1001
0000145C                           856  
0000145C                           857  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           858  *-----------------------------------------------------------------------------
0000145C                           859  
0000145C                           860  
0000145C                           861  
0000145C                           862  *-----------------------------------------------------------------------------
0000145C                           863  *-----------------------------------------------------------------------------
0000145C                           864  * NAME: OP_1010   ()
0000145C                           865  * DESCRIPTION:    a
0000145C                           866  * PRE-CONDITION:  b
0000145C                           867  * POST-CONDITION: c
0000145C                           868  * REGISTERS:      d
0000145C                           869  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           870  OP1010
0000145C                           871  
0000145C                           872  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           873  *-----------------------------------------------------------------------------
0000145C                           874  
0000145C                           875  
0000145C                           876  
0000145C                           877  *-----------------------------------------------------------------------------
0000145C                           878  *-----------------------------------------------------------------------------
0000145C                           879  * NAME: OP_1011   (EOR, CMP)
0000145C                           880  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000145C                           881  * PRE-CONDITION:  xyz
0000145C                           882  * POST-CONDITION: All registers return to their previous state, and the output
0000145C                           883  *                 goes to the output console for reading the raw data or the
0000145C                           884  *                 actual instruction.
0000145C                           885  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000145C                           886  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           887  OP1011
0000145C                           888  
0000145C                           889  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           890  *-----------------------------------------------------------------------------
0000145C                           891  
0000145C                           892  
0000145C                           893  
0000145C                           894  *-----------------------------------------------------------------------------
0000145C                           895  *-----------------------------------------------------------------------------
0000145C                           896  * NAME: OP_1100   (MULS)
0000145C                           897  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000145C                           898  * PRE-CONDITION:  xyz
0000145C                           899  * POST-CONDITION: All registers return to their previous state, and the output
0000145C                           900  *                 goes to the output console for reading the raw data or the
0000145C                           901  *                 actual instruction.
0000145C                           902  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000145C                           903  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           904  OP1100
0000145C                           905  
0000145C                           906  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           907  *-----------------------------------------------------------------------------
0000145C                           908  
0000145C                           909  
0000145C                           910  
0000145C                           911  *-----------------------------------------------------------------------------
0000145C                           912  *-----------------------------------------------------------------------------
0000145C                           913  * NAME: OP_1101   (ADD, ADDA)
0000145C                           914  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000145C                           915  * PRE-CONDITION:  xyz
0000145C                           916  * POST-CONDITION: All registers return to their previous state, and the output
0000145C                           917  *                 goes to the output console for reading the raw data or the
0000145C                           918  *                 actual instruction.
0000145C                           919  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000145C                           920  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           921  OP1101
0000145C                           922  
0000145C                           923  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           924  *-----------------------------------------------------------------------------
0000145C                           925  
0000145C                           926  
0000145C                           927  
0000145C                           928  *-----------------------------------------------------------------------------
0000145C                           929  *-----------------------------------------------------------------------------
0000145C                           930  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
0000145C                           931  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000145C                           932  * PRE-CONDITION:  xyz
0000145C                           933  * POST-CONDITION: All registers return to their previous state, and the output
0000145C                           934  *                 goes to the output console for reading the raw data or the
0000145C                           935  *                 actual instruction.
0000145C                           936  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000145C                           937  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           938  OP1110
0000145C                           939  
0000145C                           940  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           941  *-----------------------------------------------------------------------------
0000145C                           942  
0000145C                           943  
0000145C                           944  
0000145C                           945  *-----------------------------------------------------------------------------
0000145C                           946  *-----------------------------------------------------------------------------
0000145C                           947  * NAME: OP_1111   ()
0000145C                           948  * DESCRIPTION:    a
0000145C                           949  * PRE-CONDITION:  b
0000145C                           950  * POST-CONDITION: c
0000145C                           951  * REGISTERS:      d
0000145C                           952  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           953  OP1111
0000145C                           954  
0000145C                           955  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145C                           956  *-----------------------------------------------------------------------------
0000145C                           957  
0000145C                           958  
0000145C                           959  
0000145C                           960  *-----------------------------------------------------------------------------
0000145C                           961  *-----------------------------------------------------------------------------
0000145C                           962  * NAME:           EAHELPER611
0000145C                           963  * DESCRIPTION:    a
0000145C                           964  * PRE-CONDITION:  D2 contains the instruction to print modes for.
0000145C                           965  * POST-CONDITION: Determines mode, passes D2 to EAHELPER05 to print.
0000145C                           966  * REGISTERS:      a
0000145C                           967  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145C                           968  EAHELPER611
0000145C  48A7 FFC0                969      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
00001460                           970      
00001460                           971      * to move the mode where EAHELPER50 can process it
00001460  7C06                     972      MOVE.L  #6,D6   *prep registers to create bitmask
00001462  7E08                     973      MOVE.L  #8,D7
00001464                           974      
00001464  6100 05A6                975      BSR     BITMASK * create bitmask
00001468                           976      
00001468  CC42                     977      AND     D2,D6   * apply bitmask
0000146A                           978      
0000146A  4243                     979      CLR     D3      * prep D3 to store values
0000146C                           980      
0000146C  3606                     981      MOVE.W  D6,D3   * store bitmasked value in D3
0000146E                           982      
0000146E  E64B                     983      LSR     #3,D3   * move bits 6-8 to 3-5
00001470                           984      
00001470                           985      * to move the register where EAHELPER50 can process it
00001470  7C09                     986      MOVE.L  #9,D6   *prep registers to create bitmask
00001472  7E0B                     987      MOVE.L  #11,D7
00001474                           988      
00001474  6100 0596                989      BSR     BITMASK * create bitmask
00001478                           990      
00001478  CC42                     991      AND     D2,D6   * apply bitmask
0000147A                           992      
0000147A  4244                     993      CLR     D4      * prep D3 to store values
0000147C                           994      
0000147C  3806                     995      MOVE.W  D6,D4   * store bitmasked value in D3
0000147E                           996      
0000147E  E04C                     997      LSR     #8,D4   * move bits 9-11 to 0-2
00001480  E24C                     998      LSR     #1,D4   * move bits 9-11 to 0-2
00001482                           999      
00001482  8684                    1000      OR.L    D4,D3   * combind the register and mode
00001484                          1001      
00001484  2403                    1002      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
00001486                          1003      
00001486  6100 0008               1004      BSR     EAHELPER05
0000148A                          1005      
0000148A  4C9F 03FF               1006      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
0000148E                          1007      
0000148E  4E75                    1008      RTS
00001490                          1009  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001490                          1010  *-----------------------------------------------------------------------------
00001490                          1011  
00001490                          1012  
00001490                          1013  
00001490                          1014  *-----------------------------------------------------------------------------
00001490                          1015  *-----------------------------------------------------------------------------
00001490                          1016  * NAME:           EAHELPER05
00001490                          1017  * DESCRIPTION:    a
00001490                          1018  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
00001490                          1019  *                 this sub-routine helper for operations that only have one
00001490                          1020  *                 mode register.
00001490                          1021  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
00001490                          1022  * REGISTERS:      a
00001490                          1023  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001490                          1024  EAHELPER05
00001490                          1025      * todo: add code for printing immediate values
00001490                          1026      
00001490  48A7 FFC0               1027      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001494                          1028      
00001494  7C03                    1029      MOVE.L  #3,D6
00001496  7E05                    1030      MOVE.L  #5,D7
00001498                          1031      
00001498  6100 0572               1032      BSR     BITMASK * generate a bitmask to identify the mode
0000149C                          1033      
0000149C  CC42                    1034      AND     D2,D6   * mask off the parts of D2 we don't need
0000149E                          1035      
0000149E  2A06                    1036      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
000014A0                          1037      
000014A0  0C46 0000               1038      CMPI    #%0000000000000000,D6 * is it data register direct?
000014A4  6600 000A               1039      BNE     NOTDATAREG
000014A8                          1040      
000014A8  6100 00E4               1041      BSR     MODE_DN
000014AC                          1042       
000014AC  6000 00DA               1043      BRA     ENDEAHELPER05
000014B0                          1044      
000014B0                          1045  NOTDATAREG * address register direct
000014B0                          1046      
000014B0  0C46 0008               1047      CMPI    #%0000000000001000,D6 * is it address register direct?
000014B4  6600 000A               1048      BNE     NOTADRDIRECT
000014B8                          1049      
000014B8  6100 01D4               1050      BSR     MODE_AN * simply prints out the address register
000014BC                          1051       
000014BC  6000 00CA               1052      BRA     ENDEAHELPER05
000014C0                          1053      
000014C0                          1054  NOTADRDIRECT * address register indirect
000014C0                          1055          
000014C0  0C46 0010               1056      CMPI    #%0000000000010000,D6 * is it address register indirect?
000014C4  6600 0022               1057      BNE     NOTADRINDIRECT
000014C8                          1058      
000014C8  43F9 00001ACE           1059      LEA     OBRACK,A1       * Load '('
000014CE  303C 000E               1060      MOVE.W  #14,D0          * Trap #14 to display message
000014D2  4E4F                    1061      TRAP    #15             * Perform #14
000014D4                          1062          
000014D4                          1063  
000014D4  6100 01B8               1064      BSR     MODE_AN * print out an address register
000014D8                          1065      
000014D8  43F9 00001AD0           1066      LEA     CBRACK,A1       * Load ')'
000014DE  303C 000E               1067      MOVE.W  #14,D0          * Trap #14 to display message
000014E2  4E4F                    1068      TRAP    #15             * Perform #14
000014E4                          1069       
000014E4  6000 00A2               1070      BRA     ENDEAHELPER05
000014E8                          1071      
000014E8                          1072  NOTADRINDIRECT * address register indirect, post increment
000014E8                          1073      
000014E8  0C46 0018               1074      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
000014EC  6600 002E               1075      BNE     NOTADRINDIRECTPOST
000014F0                          1076      
000014F0  43F9 00001ACE           1077      LEA     OBRACK,A1       * Load '('
000014F6  303C 000E               1078      MOVE.W  #14,D0          * Trap #14 to display message
000014FA  4E4F                    1079      TRAP    #15             * Perform #14
000014FC                          1080          
000014FC                          1081  
000014FC  6100 0190               1082      BSR     MODE_AN * print out an address register
00001500                          1083      
00001500  43F9 00001AD0           1084      LEA     CBRACK,A1       * Load ')'
00001506  303C 000E               1085      MOVE.W  #14,D0          * Trap #14 to display message
0000150A  4E4F                    1086      TRAP    #15             * Perform #14
0000150C                          1087      
0000150C  43F9 00001AD2           1088      LEA     PLUS,A1       * Load '+'
00001512  303C 000E               1089      MOVE.W  #14,D0          * Trap #14 to display message
00001516  4E4F                    1090      TRAP    #15             * Perform #14
00001518                          1091       
00001518  6000 006E               1092      BRA     ENDEAHELPER05
0000151C                          1093      
0000151C                          1094  NOTADRINDIRECTPOST * address register indirect, pre decrement
0000151C                          1095      
0000151C  0C46 0020               1096      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
00001520  6600 002E               1097      BNE     NOTADRINDIRECTPRE
00001524                          1098      
00001524  43F9 00001AD4           1099      LEA     MINUS,A1       * Load '-'
0000152A  303C 000E               1100      MOVE.W  #14,D0          * Trap #14 to display message
0000152E  4E4F                    1101      TRAP    #15             * Perform #14
00001530                          1102      
00001530  43F9 00001ACE           1103      LEA     OBRACK,A1       * Load '('
00001536  303C 000E               1104      MOVE.W  #14,D0          * Trap #14 to display message
0000153A  4E4F                    1105      TRAP    #15             * Perform #14
0000153C                          1106          
0000153C                          1107  
0000153C  6100 0150               1108      BSR     MODE_AN * print out an address register
00001540                          1109      
00001540  43F9 00001AD0           1110      LEA     CBRACK,A1       * Load ')'
00001546  303C 000E               1111      MOVE.W  #14,D0          * Trap #14 to display message
0000154A  4E4F                    1112      TRAP    #15             * Perform #14
0000154C                          1113       
0000154C  6000 003A               1114      BRA     ENDEAHELPER05
00001550                          1115      
00001550                          1116  NOTADRINDIRECTPRE * immediate
00001550                          1117      
00001550  0C46 0038               1118      CMPI    #%0000000000111000,D6 * is it immediate?
00001554  6600 002E               1119      BNE     NOTIMMEDIATE
00001558                          1120  
00001558  3C3C 0006               1121      MOVE.W  #6, D6              * Prep lower value for bitmask
0000155C  3E3C 0007               1122      MOVE.W  #7, D7              * Prep upper value for bitmask
00001560  6100 04AA               1123      BSR     BITMASK             * Finalize bitmask setup
00001564  CC42                    1124      AND     D2,D6               * Apply bitmask  
00001566                          1125  
00001566  43F9 00001ACA           1126      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000156C  103C 000E               1127      MOVE.B  #14,D0
00001570  4E4F                    1128      TRAP    #15
00001572                          1129          
00001572  341A                    1130      MOVE.W  (A2)+,D2
00001574                          1131      
00001574  3202                    1132      MOVE.W  D2,D1
00001576                          1133      
00001576  343C 0010               1134      MOVE.W  #16,D2
0000157A                          1135          
0000157A  103C 000F               1136      MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000157E  4E4F                    1137      TRAP    #15      * Perform Trap #3
00001580                          1138      
00001580  6000 0006               1139      BRA     ENDEAHELPER05
00001584                          1140      
00001584                          1141  NOTIMMEDIATE * if none of the previous cases are true, it is a mode not supported by our decompiler
00001584                          1142  
00001584  6100 02CE               1143      BSR     UNKNOWNOP
00001588                          1144      
00001588                          1145  ENDEAHELPER05
00001588  4C9F 03FF               1146      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
0000158C  4E75                    1147      RTS
0000158E                          1148  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000158E                          1149  *-----------------------------------------------------------------------------
0000158E                          1150  
0000158E                          1151  
0000158E                          1152  
0000158E                          1153  *-----------------------------------------------------------------------------
0000158E                          1154  *-----------------------------------------------------------------------------
0000158E                          1155  * NAME:           MODE_DN
0000158E                          1156  * DESCRIPTION:    Generalize the EA part of the project.
0000158E                          1157  * PRE-CONDITION:  The mode must have been correctly identified. All modes
0000158E                          1158  *                 must be called by RTS.
0000158E                          1159  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
0000158E                          1160  *                 called it.
0000158E                          1161  * REGISTERS:      a
0000158E                          1162  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000158E                          1163  * ---> Dn
0000158E                          1164  MODE_DN
0000158E  48A7 FFC0               1165          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001592                          1166  
00001592  3C3C 0000               1167          MOVE.W  #0, D6              * Prep lower value for bitmask
00001596  3E3C 0002               1168          MOVE.W  #2, D7              * Prep upper value for bitmask
0000159A  6100 0470               1169          BSR     BITMASK             * Finalize bitmask setup
0000159E  CC42                    1170          AND     D2,D6               * Apply bitmask
000015A0                          1171          
000015A0  0C46 0000               1172          CMPI    #%000000000000000, D6   * Data Register D0?
000015A4  6600 000A               1173          BNE     NOTD0
000015A8                          1174          
000015A8  6100 0074               1175          BSR     PRINTD0
000015AC  6000 006A               1176          BRA     ENDMODE_DN
000015B0                          1177  NOTD0      
000015B0  0C46 0001               1178          CMPI    #%000000000000001, D6   * Data Register D1?
000015B4  6600 000A               1179          BNE     NOTD1
000015B8                          1180          
000015B8  6100 0072               1181          BSR     PRINTD1
000015BC  6000 005A               1182          BRA     ENDMODE_DN
000015C0                          1183  NOTD1
000015C0  0C46 0002               1184          CMPI    #%000000000000010, D6   * Data Register D2?
000015C4  6600 000A               1185          BNE     NOTD2
000015C8                          1186          
000015C8  6100 0070               1187          BSR     PRINTD2
000015CC  6000 004A               1188          BRA     ENDMODE_DN
000015D0                          1189  NOTD2
000015D0  0C46 0003               1190          CMPI    #%000000000000011, D6   * Data Register D3?
000015D4  6600 000A               1191          BNE     NOTD3
000015D8                          1192          
000015D8  6100 006E               1193          BSR     PRINTD3
000015DC  6000 003A               1194          BRA     ENDMODE_DN
000015E0                          1195  NOTD3
000015E0  0C46 0004               1196          CMPI    #%000000000000100, D6   * Data Register D4?
000015E4  6600 000A               1197          BNE     NOTD4
000015E8                          1198          
000015E8  6100 006C               1199          BSR     PRINTD4
000015EC  6000 002A               1200          BRA     ENDMODE_DN
000015F0                          1201  NOTD4
000015F0  0C46 0005               1202          CMPI    #%000000000000101, D6   * Data Register D5?
000015F4  6600 000A               1203          BNE     NOTD5
000015F8                          1204          
000015F8  6100 006A               1205          BSR     PRINTD5
000015FC  6000 001A               1206          BRA     ENDMODE_DN
00001600                          1207  NOTD5
00001600  0C46 0006               1208          CMPI    #%000000000000110, D6   * Data Register D6?
00001604  6600 000A               1209          BNE     NOTD6
00001608                          1210          
00001608  6100 0068               1211          BSR     PRINTD6
0000160C  6000 000A               1212          BRA     ENDMODE_DN
00001610                          1213  NOTD6
00001610  6100 006E               1214          BSR     PRINTD7
00001614  6000 0002               1215          BRA     ENDMODE_DN
00001618                          1216          
00001618                          1217  ENDMODE_DN
00001618  4C9F 03FF               1218          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
0000161C  4E75                    1219          RTS
0000161E                          1220  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000161E                          1221  *-----------------------------------------------------------------------------
0000161E                          1222  
0000161E                          1223  
0000161E                          1224  
0000161E                          1225  *-----------------------------------------------------------------------------
0000161E                          1226  *-----------------------------------------------------------------------------
0000161E                          1227  * NAME:           PRINTD0
0000161E                          1228  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
0000161E                          1229  * PRE-CONDITION:  a
0000161E                          1230  * POST-CONDITION: a
0000161E                          1231  * REGISTERS:      a
0000161E                          1232  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000161E                          1233  PRINTD0
0000161E  43F9 00001AFA           1234          LEA     __D0, A1        * Load 'D0'
00001624  103C 000E               1235          MOVE.B  #14, D0         * Load Trap #14 to print out
00001628  4E4F                    1236          TRAP    #15             * Perform Trap #14
0000162A  4E75                    1237          RTS
0000162C                          1238  PRINTD1
0000162C  43F9 00001AFD           1239          LEA     __D1, A1        * Load 'D1'
00001632  103C 000E               1240          MOVE.B  #14, D0         * Load Trap #14 to print out
00001636  4E4F                    1241          TRAP    #15             * Perform Trap #14
00001638  4E75                    1242          RTS      
0000163A                          1243  PRINTD2
0000163A  43F9 00001B00           1244          LEA     __D2, A1        * Load 'D2'
00001640  103C 000E               1245          MOVE.B  #14, D0         * Load Trap #14 to print out
00001644  4E4F                    1246          TRAP    #15             * Perform Trap #14
00001646  4E75                    1247          RTS      
00001648                          1248  PRINTD3
00001648  43F9 00001B03           1249          LEA     __D3, A1        * Load 'D3'
0000164E  103C 000E               1250          MOVE.B  #14, D0         * Load Trap #14 to print out
00001652  4E4F                    1251          TRAP    #15             * Perform Trap #14
00001654  4E75                    1252          RTS      
00001656                          1253  PRINTD4
00001656  43F9 00001B06           1254          LEA     __D4, A1        * Load 'D4'
0000165C  103C 000E               1255          MOVE.B  #14, D0         * Load Trap #14 to print out
00001660  4E4F                    1256          TRAP    #15             * Perform Trap #14
00001662  4E75                    1257          RTS       
00001664                          1258  PRINTD5
00001664  43F9 00001B09           1259          LEA     __D5, A1        * Load 'D5'
0000166A  103C 000E               1260          MOVE.B  #14, D0         * Load Trap #14 to print out
0000166E  4E4F                    1261          TRAP    #15             * Perform Trap #14
00001670  4E75                    1262          RTS      
00001672                          1263  PRINTD6
00001672  43F9 00001B0C           1264          LEA     __D6, A1        * Load 'D6'
00001678  103C 000E               1265          MOVE.B  #14, D0         * Load Trap #14 to print out
0000167C  4E4F                    1266          TRAP    #15             * Perform Trap #14
0000167E  4E75                    1267          RTS
00001680                          1268  PRINTD7
00001680  43F9 00001B0F           1269          LEA     __D7, A1        * Load 'D7'
00001686  103C 000E               1270          MOVE.B  #14, D0         * Load Trap #14 to print out
0000168A  4E4F                    1271          TRAP    #15             * Perform Trap #14
0000168C  4E75                    1272          RTS
0000168E                          1273  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000168E                          1274  *-----------------------------------------------------------------------------
0000168E                          1275  
0000168E                          1276  
0000168E                          1277  
0000168E                          1278  *-----------------------------------------------------------------------------
0000168E                          1279  *-----------------------------------------------------------------------------
0000168E                          1280  * NAME:           MODE_AN
0000168E                          1281  * DESCRIPTION:    Simply chooses to print A0-A7.
0000168E                          1282  * PRE-CONDITION:  a
0000168E                          1283  * POST-CONDITION: a
0000168E                          1284  * REGISTERS:      a
0000168E                          1285  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000168E                          1286  MODE_AN
0000168E  48A7 FFC0               1287          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
00001692                          1288  
00001692  3C3C 0000               1289          MOVE.W  #0, D6              * Prep lower value for bitmask
00001696  3E3C 0002               1290          MOVE.W  #2, D7              * Prep upper value for bitmask
0000169A  6100 0370               1291          BSR     BITMASK             * Finalize bitmask setup
0000169E  CC42                    1292          AND     D2,D6               * Apply bitmask
000016A0                          1293          
000016A0  0C46 0000               1294          CMPI    #%000000000000000, D6   * Address Register A0?
000016A4  6600 000A               1295          BNE     NOTA0
000016A8                          1296          
000016A8  6100 0074               1297          BSR     PRINTA0
000016AC                          1298          
000016AC  6000 006A               1299          BRA     ENDMODE_AN
000016B0                          1300  NOTA0      
000016B0  0C46 0001               1301          CMPI    #%000000000000001, D6   * Address Register A1?
000016B4  6600 000A               1302          BNE     NOTA1
000016B8                          1303          
000016B8  6100 0072               1304          BSR     PRINTA1
000016BC                          1305          
000016BC  6000 005A               1306          BRA     ENDMODE_AN
000016C0                          1307  NOTA1
000016C0  0C46 0002               1308          CMPI    #%000000000000010, D6   * Address Register A2?
000016C4  6600 000A               1309          BNE     NOTA2
000016C8                          1310          
000016C8  6100 0070               1311          BSR     PRINTA2
000016CC                          1312          
000016CC  6000 004A               1313          BRA     ENDMODE_AN
000016D0                          1314  NOTA2
000016D0  0C46 0003               1315          CMPI    #%000000000000011, D6   * Address Register A3?
000016D4  6600 000A               1316          BNE     NOTA3
000016D8                          1317          
000016D8  6100 006E               1318          BSR     PRINTA3
000016DC                          1319          
000016DC  6000 003A               1320          BRA     ENDMODE_AN
000016E0                          1321  NOTA3
000016E0  0C46 0004               1322          CMPI    #%000000000000100, D6   * Address Register A4?
000016E4  6600 000A               1323          BNE     NOTA4
000016E8                          1324          
000016E8  6100 006C               1325          BSR     PRINTA4
000016EC                          1326          
000016EC  6000 002A               1327          BRA     ENDMODE_AN
000016F0                          1328  NOTA4
000016F0  0C46 0005               1329          CMPI    #%000000000000101, D6   * Address Register A5?
000016F4  6600 000A               1330          BNE     NOTA5
000016F8                          1331          
000016F8  6100 006A               1332          BSR     PRINTA5
000016FC                          1333          
000016FC  6000 001A               1334          BRA     ENDMODE_AN
00001700                          1335  NOTA5
00001700  0C46 0006               1336          CMPI    #%000000000000110, D6   * Address Register A6?
00001704  6600 000A               1337          BNE     NOTA6
00001708                          1338          
00001708  6100 0068               1339          BSR     PRINTA6
0000170C                          1340          
0000170C  6000 000A               1341          BRA     ENDMODE_AN
00001710                          1342  NOTA6
00001710  6100 006E               1343          BSR     PRINTA7
00001714                          1344          
00001714  6000 0002               1345          BRA     ENDMODE_AN
00001718                          1346  ENDMODE_AN
00001718  4C9F 03FF               1347          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
0000171C  4E75                    1348          RTS
0000171E                          1349  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000171E                          1350  *-----------------------------------------------------------------------------
0000171E                          1351  
0000171E                          1352  
0000171E                          1353  
0000171E                          1354  *-----------------------------------------------------------------------------
0000171E                          1355  *-----------------------------------------------------------------------------
0000171E                          1356  * NAME:           PRINTA0
0000171E                          1357  * DESCRIPTION:    Simply print out the address register.
0000171E                          1358  * PRE-CONDITION:  a
0000171E                          1359  * POST-CONDITION: a
0000171E                          1360  * REGISTERS:      a
0000171E                          1361  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000171E                          1362  PRINTA0
0000171E  43F9 00001AE2           1363          LEA     __A0, A1        * Load 'A0'
00001724  103C 000E               1364          MOVE.B  #14, D0         * Load Trap #14 to print out
00001728  4E4F                    1365          TRAP    #15             * Perform Trap #14
0000172A  4E75                    1366          RTS
0000172C                          1367  
0000172C                          1368  PRINTA1
0000172C  43F9 00001AE5           1369          LEA     __A1, A1        * Load 'A1'
00001732  103C 000E               1370          MOVE.B  #14, D0         * Load Trap #14 to print out
00001736  4E4F                    1371          TRAP    #15             * Perform Trap #14
00001738  4E75                    1372          RTS
0000173A                          1373          
0000173A                          1374  PRINTA2
0000173A  43F9 00001AE8           1375          LEA     __A2, A1        * Load 'A2'
00001740  103C 000E               1376          MOVE.B  #14, D0         * Load Trap #14 to print out
00001744  4E4F                    1377          TRAP    #15             * Perform Trap #14
00001746  4E75                    1378          RTS
00001748                          1379  
00001748                          1380  PRINTA3
00001748  43F9 00001AEB           1381          LEA     __A3, A1        * Load 'A3'
0000174E  103C 000E               1382          MOVE.B  #14, D0         * Load Trap #14 to print out
00001752  4E4F                    1383          TRAP    #15             * Perform Trap #14
00001754  4E75                    1384          RTS
00001756                          1385  
00001756                          1386  PRINTA4
00001756  43F9 00001AEE           1387          LEA     __A4, A1        * Load 'A4'
0000175C  103C 000E               1388          MOVE.B  #14, D0         * Load Trap #14 to print out
00001760  4E4F                    1389          TRAP    #15             * Perform Trap #14
00001762  4E75                    1390          RTS
00001764                          1391  
00001764                          1392  PRINTA5
00001764  43F9 00001AF1           1393          LEA     __A5, A1        * Load 'A5'
0000176A  103C 000E               1394          MOVE.B  #14, D0         * Load Trap #14 to print out
0000176E  4E4F                    1395          TRAP    #15             * Perform Trap #14
00001770  4E75                    1396          RTS
00001772                          1397  
00001772                          1398  PRINTA6
00001772  43F9 00001AF4           1399          LEA     __A6, A1        * Load 'A6'
00001778  103C 000E               1400          MOVE.B  #14, D0         * Load Trap #14 to print out
0000177C  4E4F                    1401          TRAP    #15             * Perform Trap #14
0000177E  4E75                    1402          RTS
00001780                          1403  
00001780                          1404  PRINTA7
00001780  43F9 00001AF7           1405          LEA     __A7, A1        * Load 'A7'
00001786  103C 000E               1406          MOVE.B  #14, D0         * Load Trap #14 to print out
0000178A  4E4F                    1407          TRAP    #15             * Perform Trap #14
0000178C  4E75                    1408          RTS
0000178E                          1409  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000178E                          1410  *-----------------------------------------------------------------------------
0000178E                          1411  
0000178E                          1412  
0000178E                          1413  
0000178E                          1414  *-----------------------------------------------------------------------------
0000178E                          1415  *-----------------------------------------------------------------------------
0000178E                          1416  * NAME:           SIZE67
0000178E                          1417  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
0000178E                          1418  * PRE-CONDITION:  a
0000178E                          1419  * POST-CONDITION: a
0000178E                          1420  * REGISTERS:      a
0000178E                          1421  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000178E                          1422  SIZE67
0000178E  48A7 FFFE               1423          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001792  3C3C 0006               1424          MOVE.W  #6, D6              * Prep lower value for bitmask
00001796  3E3C 0007               1425          MOVE.W  #7, D7              * Prep upper value for bitmask
0000179A  6100 0270               1426          BSR     BITMASK             * Finalize bitmask setup
0000179E  CC42                    1427          AND     D2,D6               * Apply bitmask     
000017A0                          1428  
000017A0  0C46 0000               1429          CMPI    #%0000000000000000, D6   * is it a BYTE?
000017A4  6600 000A               1430          BNE     NOT67BYTE
000017A8                          1431          
000017A8  6100 0080               1432          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000017AC  6000 001E               1433          BRA     END67
000017B0                          1434  NOT67BYTE        
000017B0  0C46 0040               1435          CMPI    #%0000000001000000, D6   * is it a WORD?
000017B4  6600 000A               1436          BNE     NOT67WORD
000017B8                          1437          
000017B8  6100 007E               1438          BSR     PRINTWORD               * Branch to handle WORD sizes
000017BC  6000 000E               1439          BRA     END67
000017C0                          1440  NOT67WORD
000017C0  0C46 0080               1441          CMPI    #%0000000010000000, D6   * is it a LONG?
000017C4  6600 0006               1442          BNE     END67
000017C8                          1443          
000017C8  6100 007C               1444          BSR     PRINTLONG               * Branch to handle LONG sizes
000017CC                          1445  END67
000017CC  4C9F 7FFF               1446          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
000017D0  4E75                    1447          RTS                             * Return. Size handling is finished.
000017D2                          1448  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000017D2                          1449  *-----------------------------------------------------------------------------
000017D2                          1450  
000017D2                          1451  
000017D2                          1452  
000017D2                          1453  *-----------------------------------------------------------------------------
000017D2                          1454  *-----------------------------------------------------------------------------
000017D2                          1455  * NAME:           SIZE68
000017D2                          1456  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
000017D2                          1457  * PRE-CONDITION:  a
000017D2                          1458  * POST-CONDITION: a
000017D2                          1459  * REGISTERS:      a
000017D2                          1460  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000017D2                          1461  SIZE68
000017D2                          1462          * finish later, need to follow the same format as SIZE67
000017D2                          1463          
000017D2                          1464          
000017D2  48A7 FFFE               1465          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
000017D6  3C3C 0006               1466          MOVE.W  #6, D6              * Prep lower value for bitmask
000017DA  3E3C 0008               1467          MOVE.W  #8, D7              * Prep upper value for bitmask
000017DE  6100 022C               1468          BSR     BITMASK             * Finalize bitmask setup
000017E2  CC42                    1469          AND     D2,D6               * Apply bitmask          
000017E4                          1470          
000017E4  0C46 0000               1471          CMPI    #%0000000000000000, D6   * is it a BYTE?
000017E8  6100 0040               1472          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000017EC  0C46 0100               1473          CMPI    #%0000000100000000, D6   * is it a BYTE?
000017F0  6100 0038               1474          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
000017F4                          1475        
000017F4  0C46 0040               1476          CMPI    #%0000000001000000, D6   * is it a WORD?
000017F8  6100 003E               1477          BSR     PRINTWORD               * Branch to handle BYTE sizes
000017FC  0C46 0140               1478          CMPI    #%0000000101000000, D6   * is it a WORD?
00001800  6100 0036               1479          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001804  0C46 00C0               1480          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
00001808  6100 002E               1481          BSR     PRINTWORD               * Branch to handle BYTE sizes
0000180C                          1482  
0000180C  0C46 0080               1483          CMPI    #%0000000010000000, D6   * is it a LONG?
00001810  6100 0034               1484          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001814  0C46 0180               1485          CMPI    #%0000000110000000, D6   * is it a LONG?
00001818  6100 002C               1486          BSR     PRINTLONG               * Branch to handle BYTE sizes
0000181C  0C46 01C0               1487          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001820  6100 0024               1488          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001824                          1489  
00001824  4C9F 7FFF               1490          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001828  4E75                    1491          RTS                             * Return. Size handling is finished.
0000182A                          1492  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000182A                          1493  *-----------------------------------------------------------------------------
0000182A                          1494  
0000182A                          1495  
0000182A                          1496  
0000182A                          1497  *-----------------------------------------------------------------------------
0000182A                          1498  *-----------------------------------------------------------------------------
0000182A                          1499  * NAME:           PRINTBYTE
0000182A                          1500  * DESCRIPTION:    a
0000182A                          1501  * PRE-CONDITION:  a
0000182A                          1502  * POST-CONDITION: a
0000182A                          1503  * REGISTERS:      a
0000182A                          1504  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000182A                          1505  PRINTBYTE
0000182A  43F9 00001AD6           1506          LEA     __B,A1      * Load '.B ' into A1
00001830  103C 000E               1507          MOVE.B  #14,D0      * Trap #14 setup to print
00001834  4E4F                    1508          TRAP    #15         * Perform Trap #14
00001836  4E75                    1509          RTS                 * Return to SIZE67/SIZE68
00001838                          1510          
00001838                          1511  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001838                          1512  *-----------------------------------------------------------------------------
00001838                          1513  
00001838                          1514  
00001838                          1515  
00001838                          1516  *-----------------------------------------------------------------------------
00001838                          1517  *-----------------------------------------------------------------------------
00001838                          1518  * NAME:           PRINTWORD
00001838                          1519  * DESCRIPTION:    a
00001838                          1520  * PRE-CONDITION:  a
00001838                          1521  * POST-CONDITION: a
00001838                          1522  * REGISTERS:      a
00001838                          1523  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001838                          1524  PRINTWORD
00001838  43F9 00001ADA           1525          LEA     __W,A1      * Load '.W ' into A1
0000183E  103C 000E               1526          MOVE.B  #14,D0      * Trap #14 setup to print
00001842  4E4F                    1527          TRAP    #15         * Perform Trap #14
00001844  4E75                    1528          RTS                 * Return to SIZE67/SIZE68
00001846                          1529          
00001846                          1530  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001846                          1531  *-----------------------------------------------------------------------------
00001846                          1532  
00001846                          1533  
00001846                          1534  
00001846                          1535  *-----------------------------------------------------------------------------
00001846                          1536  *-----------------------------------------------------------------------------
00001846                          1537  * NAME:           PRINTLONG
00001846                          1538  * DESCRIPTION:    a
00001846                          1539  * PRE-CONDITION:  a
00001846                          1540  * POST-CONDITION: a
00001846                          1541  * REGISTERS:      a
00001846                          1542  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001846                          1543  PRINTLONG
00001846  43F9 00001ADE           1544          LEA     __L,A1      * Load '.L ' into A1
0000184C  103C 000E               1545          MOVE.B  #14,D0      * Trap #14 setup to print
00001850  4E4F                    1546          TRAP    #15         * Perform Trap #14
00001852  4E75                    1547          RTS                 * Return to SIZE67/SIZE68
00001854                          1548          
00001854                          1549  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001854                          1550  *-----------------------------------------------------------------------------
00001854                          1551  
00001854                          1552  
00001854                          1553  
00001854                          1554  *-----------------------------------------------------------------------------
00001854                          1555  *-----------------------------------------------------------------------------
00001854                          1556  * NAME:           UNKNOWNOP
00001854                          1557  * DESCRIPTION:    a
00001854                          1558  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001854                          1559  *                 identified as an unknown operation.
00001854                          1560  * POST-CONDITION: D2 is no longer the opcode.
00001854                          1561  * REGISTERS:      a
00001854                          1562  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001854                          1563  UNKNOWNOP
00001854  220A                    1564          MOVE.L  A2,D1   * prep the add to print
00001856                          1565          
00001856  5581                    1566          SUB.L   #2,D1   * off by two error due to post increment correct
00001858                          1567          
00001858  2602                    1568          MOVE.L  D2,D3   * save the opcode to print
0000185A                          1569          
0000185A  7410                    1570          MOVE.L  #16,D2  * set the base to 16
0000185C                          1571          
0000185C  700F                    1572          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
0000185E  4E4F                    1573          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001860                          1574          
00001860  43F9 00001A86           1575          LEA     DATA,A1 * load " DATA $" into register A1
00001866  700E                    1576          MOVE.L  #14,D0  * print the string stored in A1
00001868  4E4F                    1577          TRAP    #15
0000186A                          1578          
0000186A  2203                    1579          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
0000186C                          1580          
0000186C  103C 000F               1581          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001870  4E4F                    1582          TRAP    #15      * Perform Trap #3
00001872                          1583  
00001872  43F9 00001A50           1584          LEA     NEWLINE,A1 * load newline into register A1
00001878  700E                    1585          MOVE.L  #14,D0  * print the string stored in A1
0000187A  4E4F                    1586          TRAP    #15
0000187C                          1587  
0000187C  4E75                    1588          RTS
0000187E                          1589  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000187E                          1590  *-----------------------------------------------------------------------------
0000187E                          1591  
0000187E                          1592  
0000187E                          1593  
0000187E                          1594  *-----------------------------------------------------------------------------
0000187E                          1595  *-----------------------------------------------------------------------------
0000187E                          1596  * NAME: Print ASCII hex char
0000187E                          1597  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
0000187E                          1598  * PRE-CONDITION:  A6 contains the register for memory to print.
0000187E                          1599  *                 This parameter would be pre-loaded by, for example:
0000187E                          1600  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
0000187E                          1601  *                 D6 contains the loops to do (number of bytes).
0000187E                          1602  * POST-CONDITION: 
0000187E                          1603  * REGISTERS:      
0000187E                          1604  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000187E                          1605  PRINT_ASCII_HEX_CHAR
0000187E  48E7 FFFC               1606      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001882  4285                    1607      CLR.L       D5
00001884                          1608      
00001884                          1609      * fence post check (if-statement, check if 0 > chars)
00001884  0C06 0000               1610      CMPI.B      #0,D6
00001888  6700 017C               1611      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
0000188C                          1612      
0000188C                          1613  *    MOVE.L      A6,D4
0000188C  2E0E                    1614      MOVE.L      A6,D7
0000188E                          1615  PRINT_ASCII_LOOP
0000188E                          1616  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
0000188E                          1617  *    MOVE.L      D4,D7 * make a mutable copy
0000188E  E99F                    1618      ROL.L       #4,D7 * roll to next spot
00001890  48E7 0100               1619      MOVEM.L     D7,-(A7) * save D7
00001894                          1620  
00001894  0287 0000000F           1621      ANDI.L      #HEX_VALUE_MASK_LONG,D7
0000189A                          1622      
0000189A  0C87 00000000           1623      CMPI.L      #0,D7
000018A0  6D00 0164               1624      BLT         INVALID_ASCII_INPUT
000018A4                          1625  
000018A4  0C87 0000000F           1626      CMPI.L      #15,D7
000018AA  6E00 015A               1627      BGT         INVALID_ASCII_INPUT
000018AE                          1628  
000018AE                          1629      * this might be faster... to do later, after entire assignment done
000018AE                          1630       * CMPI.L      #9,D7
000018AE                          1631       * BLE         PRINT_ASCII_0_TO_9
000018AE                          1632  
000018AE  0C87 00000000           1633      CMPI.L      #0,D7
000018B4  6700 0098               1634      BEQ         PRINT_ASCII_0
000018B8  0C87 00000001           1635      CMPI.L      #1,D7
000018BE  6700 0098               1636      BEQ         PRINT_ASCII_1
000018C2  0C87 00000002           1637      CMPI.L      #2,D7
000018C8  6700 0098               1638      BEQ         PRINT_ASCII_2
000018CC  0C87 00000003           1639      CMPI.L      #3,D7
000018D2  6700 0098               1640      BEQ         PRINT_ASCII_3
000018D6  0C87 00000004           1641      CMPI.L      #4,D7
000018DC  6700 0098               1642      BEQ         PRINT_ASCII_4
000018E0  0C87 00000005           1643      CMPI.L      #5,D7
000018E6  6700 0098               1644      BEQ         PRINT_ASCII_5
000018EA  0C87 00000006           1645      CMPI.L      #6,D7
000018F0  6700 0098               1646      BEQ         PRINT_ASCII_6
000018F4  0C87 00000007           1647      CMPI.L      #7,D7
000018FA  6700 0098               1648      BEQ         PRINT_ASCII_7
000018FE  0C87 00000008           1649      CMPI.L      #8,D7
00001904  6700 0098               1650      BEQ         PRINT_ASCII_8
00001908  0C87 00000009           1651      CMPI.L      #9,D7
0000190E  6700 0098               1652      BEQ         PRINT_ASCII_9
00001912  0C87 0000000A           1653      CMPI.L      #10,D7
00001918  6700 0098               1654      BEQ         PRINT_ASCII_A
0000191C  0C87 0000000B           1655      CMPI.L      #11,D7
00001922  6700 0098               1656      BEQ         PRINT_ASCII_B
00001926  0C87 0000000C           1657      CMPI.L      #12,D7
0000192C  6700 0098               1658      BEQ         PRINT_ASCII_C
00001930  0C87 0000000D           1659      CMPI.L      #13,D7
00001936  6700 0098               1660      BEQ         PRINT_ASCII_D
0000193A  0C87 0000000E           1661      CMPI.L      #14,D7
00001940  6700 0098               1662      BEQ         PRINT_ASCII_E
00001944  0C87 0000000F           1663      CMPI.L      #15,D7
0000194A  6700 0098               1664      BEQ         PRINT_ASCII_F
0000194E                          1665  PRINT_ASCII_0
0000194E  43F9 00001AA6           1666      LEA         ASCII_0,A1
00001954  6000 0098               1667      BRA         PRINT_ASCII_CHAR
00001958                          1668  PRINT_ASCII_1
00001958  43F9 00001AA8           1669      LEA         ASCII_1,A1
0000195E  6000 008E               1670      BRA         PRINT_ASCII_CHAR
00001962                          1671  PRINT_ASCII_2
00001962  43F9 00001AAA           1672      LEA         ASCII_2,A1
00001968  6000 0084               1673      BRA         PRINT_ASCII_CHAR
0000196C                          1674  PRINT_ASCII_3
0000196C  43F9 00001AAC           1675      LEA         ASCII_3,A1
00001972  6000 007A               1676      BRA         PRINT_ASCII_CHAR
00001976                          1677  PRINT_ASCII_4
00001976  43F9 00001AAE           1678      LEA         ASCII_4,A1
0000197C  6000 0070               1679      BRA         PRINT_ASCII_CHAR
00001980                          1680  PRINT_ASCII_5
00001980  43F9 00001AB0           1681      LEA         ASCII_5,A1
00001986  6000 0066               1682      BRA         PRINT_ASCII_CHAR
0000198A                          1683  PRINT_ASCII_6
0000198A  43F9 00001AB2           1684      LEA         ASCII_6,A1
00001990  6000 005C               1685      BRA         PRINT_ASCII_CHAR
00001994                          1686  PRINT_ASCII_7
00001994  43F9 00001AB4           1687      LEA         ASCII_7,A1
0000199A  6000 0052               1688      BRA         PRINT_ASCII_CHAR
0000199E                          1689  PRINT_ASCII_8
0000199E  43F9 00001AB6           1690      LEA         ASCII_8,A1
000019A4  6000 0048               1691      BRA         PRINT_ASCII_CHAR
000019A8                          1692  PRINT_ASCII_9
000019A8  43F9 00001AB8           1693      LEA         ASCII_9,A1
000019AE  6000 003E               1694      BRA         PRINT_ASCII_CHAR
000019B2                          1695  PRINT_ASCII_A
000019B2  43F9 00001ABA           1696      LEA         ASCII_A,A1
000019B8  6000 0034               1697      BRA         PRINT_ASCII_CHAR
000019BC                          1698  PRINT_ASCII_B
000019BC  43F9 00001ABC           1699      LEA         ASCII_B,A1
000019C2  6000 002A               1700      BRA         PRINT_ASCII_CHAR
000019C6                          1701  PRINT_ASCII_C
000019C6  43F9 00001ABE           1702      LEA         ASCII_C,A1
000019CC  6000 0020               1703      BRA         PRINT_ASCII_CHAR
000019D0                          1704  PRINT_ASCII_D
000019D0  43F9 00001AC0           1705      LEA         ASCII_D,A1
000019D6  6000 0016               1706      BRA         PRINT_ASCII_CHAR
000019DA                          1707  PRINT_ASCII_E
000019DA  43F9 00001AC2           1708      LEA         ASCII_E,A1
000019E0  6000 000C               1709      BRA         PRINT_ASCII_CHAR
000019E4                          1710  PRINT_ASCII_F
000019E4  43F9 00001AC4           1711      LEA         ASCII_F,A1
000019EA  6000 0002               1712      BRA         PRINT_ASCII_CHAR
000019EE                          1713  PRINT_ASCII_CHAR
000019EE  103C 000E               1714      MOVE.B      #14,D0
000019F2  4E4F                    1715      TRAP        #15
000019F4                          1716      
000019F4  5205                    1717      ADD.B       #1,D5 * loop until counter stops
000019F6  BA06                    1718      CMP.B       D6,D5
000019F8  6C00 000C               1719      BGE         PRINT_ASCII_FINISH
000019FC                          1720      
000019FC  4287                    1721      CLR.L       D7
000019FE  4CDF 0080               1722      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001A02                          1723      
00001A02  6000 FE8A               1724      BRA         PRINT_ASCII_LOOP
00001A06                          1725  INVALID_ASCII_INPUT
00001A06                          1726  PRINT_ASCII_FINISH
00001A06  4CDF 3FFF               1727      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001A0A  4E75                    1728      RTS
00001A0C                          1729  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A0C                          1730  *-----------------------------------------------------------------------------
00001A0C                          1731  
00001A0C                          1732  
00001A0C                          1733  
00001A0C                          1734  *-----------------------------------------------------------------------------
00001A0C                          1735  *-----------------------------------------------------------------------------
00001A0C                          1736  * NAME: Bitmask
00001A0C                          1737  * DESCRIPTION:    Masks bits in a data register.
00001A0C                          1738  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001A0C                          1739  *                 the ending bit.  For example, a starting bit of decimal
00001A0C                          1740  *                 value 0 and an ending bit of decimal value 3 will mask the
00001A0C                          1741  *                 bits 0, 1, 2, and 3.
00001A0C                          1742  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001A0C                          1743  * REGISTERS:      D5,D6,D7
00001A0C                          1744  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A0C                          1745  BITMASK
00001A0C  3F05                    1746          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001A0E  4245                    1747          CLR     D5          * clear D5 so we can use it
00001A10                          1748  LOOPBIT 
00001A10  0DC5                    1749          BSET    D6,D5       * set the D6th bit in D5 to 1
00001A12  5246                    1750          ADD     #1,D6       * increment D6
00001A14                          1751  
00001A14  BC47                    1752          CMP     D7,D6       * have we finished?
00001A16  6E00 0004               1753          BGT     BITMASKDONE * yes
00001A1A  60F4                    1754          BRA     LOOPBIT     * no, iterate again
00001A1C                          1755  
00001A1C                          1756  BITMASKDONE
00001A1C  2C05                    1757          MOVE.L  D5,D6
00001A1E  3A1F                    1758          MOVE    (A7)+,D5    * restore D5
00001A20  4E75                    1759          RTS
00001A22                          1760  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A22                          1761  *-----------------------------------------------------------------------------
00001A22                          1762  
00001A22                          1763  
00001A22                          1764  
00001A22                          1765  *-----------------------------------------------------------------------------
00001A22                          1766  *-----------------------------------------------------------------------------
00001A22                          1767  * SECTION: Constants/variables used throughout the program.
00001A22                          1768  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A22                          1769  * ---> GENERAL
00001A22  =0000000D               1770  CR          EQU     $0D
00001A22  =0000000A               1771  LF          EQU     $0A
00001A22= 45 4E 54 45 52 20 ...   1772  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001A3A= 45 4E 54 45 52 20 ...   1773  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001A50= 0D 0A 00                1774  NEWLINE     DC.B    CR,LF,0
00001A53                          1775  * ---> OPS
00001A53= 44 49 56 53 00          1776  DIVSOP      DC.B    'DIVS',0
00001A58= 4E 4F 50 00             1777  NOOPERATION DC.B    'NOP',0
00001A5C= 4E 45 47 00             1778  NEGOP       DC.B    'NEG',0
00001A60= 4D 4F 56 45 00          1779  MOVEOP      DC.B    'MOVE',0
00001A65= 4D 4F 56 45 4D 00       1780  MOVEMOP     DC.B    'MOVEM',0
00001A6B= 4A 53 52 20 00          1781  JSROP       DC.B    'JSR ',0
00001A70= 52 54 53 00             1782  RTSOP       DC.B    'RTS',0
00001A74= 4C 45 41 00             1783  LEAOP       DC.B    'LEA',0
00001A78= 42 43 4C 52 00          1784  BCLROP      DC.B    'BCLR',0
00001A7D= 4F 52 49 00             1785  ORIOP       DC.B    'ORI',0
00001A81= 43 4D 50 49 00          1786  CMPIOP      DC.B    'CMPI',0
00001A86= 20 44 41 54 41 20 ...   1787  DATA        DC.B    ' DATA $',0
00001A8E= 42 43 43 00             1788  OP_BCC_MSG  DC.B    'BCC',0
00001A92= 42 43 53 00             1789  OP_BCS_MSG  DC.B    'BCS',0
00001A96= 42 47 45 00             1790  OP_BGE_MSG  DC.B    'BGE',0
00001A9A= 42 4C 54 00             1791  OP_BLT_MSG  DC.B    'BLT',0
00001A9E= 42 56 43 00             1792  OP_BVC_MSG  DC.B    'BVC',0
00001AA2= 42 52 41 00             1793  OP_BRA_MSG  DC.B    'BRA',0
00001AA6                          1794  * ---> HEX CHARS
00001AA6= 30 00                   1795  ASCII_0     DC.B    '0',0
00001AA8= 31 00                   1796  ASCII_1     DC.B    '1',0
00001AAA= 32 00                   1797  ASCII_2     DC.B    '2',0
00001AAC= 33 00                   1798  ASCII_3     DC.B    '3',0
00001AAE= 34 00                   1799  ASCII_4     DC.B    '4',0
00001AB0= 35 00                   1800  ASCII_5     DC.B    '5',0
00001AB2= 36 00                   1801  ASCII_6     DC.B    '6',0
00001AB4= 37 00                   1802  ASCII_7     DC.B    '7',0
00001AB6= 38 00                   1803  ASCII_8     DC.B    '8',0
00001AB8= 39 00                   1804  ASCII_9     DC.B    '9',0
00001ABA= 41 00                   1805  ASCII_A     DC.B    'A',0
00001ABC= 42 00                   1806  ASCII_B     DC.B    'B',0
00001ABE= 43 00                   1807  ASCII_C     DC.B    'C',0
00001AC0= 44 00                   1808  ASCII_D     DC.B    'D',0
00001AC2= 45 00                   1809  ASCII_E     DC.B    'E',0
00001AC4= 46 00                   1810  ASCII_F     DC.B    'F',0
00001AC6                          1811  * ---> SPECIAL CHARACTERS
00001AC6= 20 00                   1812  SPACE       DC.B    ' ',0
00001AC8= 24 00                   1813  DOLLAR      DC.B    '$',0
00001ACA= 23 00                   1814  IMD         DC.B    '#',0
00001ACC= 2C 00                   1815  COMMA       DC.B    ',',0
00001ACE= 28 00                   1816  OBRACK      DC.B    '(',0
00001AD0= 29 00                   1817  CBRACK      DC.B    ')',0
00001AD2= 2B 00                   1818  PLUS        DC.B    '+',0
00001AD4= 2D 00                   1819  MINUS       DC.B    '-',0
00001AD6                          1820  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001AD6= 2E 42 20 00             1821  __B         DC.B    '.B ',0
00001ADA= 2E 57 20 00             1822  __W         DC.B    '.W ',0
00001ADE= 2E 4C 20 00             1823  __L         DC.B    '.L ',0
00001AE2                          1824  * ---> ADDRESS REGISTERS A0-A7
00001AE2= 41 30 00                1825  __A0        DC.B   'A0',0
00001AE5= 41 31 00                1826  __A1        DC.B   'A1',0    
00001AE8= 41 32 00                1827  __A2        DC.B   'A2',0
00001AEB= 41 33 00                1828  __A3        DC.B   'A3',0
00001AEE= 41 34 00                1829  __A4        DC.B   'A4',0
00001AF1= 41 35 00                1830  __A5        DC.B   'A5',0
00001AF4= 41 36 00                1831  __A6        DC.B   'A6',0
00001AF7= 41 37 00                1832  __A7        DC.B   'A7',0
00001AFA                          1833  * ---> DATA REGISTERS D0-D7
00001AFA= 44 30 00                1834  __D0        DC.B   'D0',0
00001AFD= 44 31 00                1835  __D1        DC.B   'D1',0
00001B00= 44 32 00                1836  __D2        DC.B   'D2',0
00001B03= 44 33 00                1837  __D3        DC.B   'D3',0
00001B06= 44 34 00                1838  __D4        DC.B   'D4',0
00001B09= 44 35 00                1839  __D5        DC.B   'D5',0
00001B0C= 44 36 00                1840  __D6        DC.B   'D6',0
00001B0F= 44 37 00                1841  __D7        DC.B   'D7',0
00001B12                          1842  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B12                          1843  *-----------------------------------------------------------------------------
00001B12                          1844  
00001B12                          1845  
00001B12                          1846  
00001B12                          1847  *-----------------------------------------------------------------------------
00001B12                          1848  *-----------------------------------------------------------------------------
00001B12                          1849  * SECTION: Sample program to run, then attempt testing disassembly on.
00001B12                          1850  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          1851      ORG $4000
00004000                          1852  
00004000  4E71                    1853      NOP
00004002  103C 009A               1854      MOVE.B   #%10011010, D0
00004006  123C 00A9               1855      MOVE.B   #%10101001, D1
0000400A  D200                    1856      ADD.B    D0,D1
0000400C  48A7 4000               1857      MOVEM    D1,-(A7)
00004010  43F8 1A6B               1858      LEA      JSROP,A1
00004014  4467                    1859      NEG.W    -(A7)
00004016  4EB9 0000401C           1860      JSR      END
0000401C                          1861  
0000401C                          1862  END
0000401C  4E75                    1863      RTS
0000401E                          1864  RLLYEND
0000401E                          1865      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1AA6
ASCII_1             1AA8
ASCII_2             1AAA
ASCII_3             1AAC
ASCII_4             1AAE
ASCII_5             1AB0
ASCII_6             1AB2
ASCII_7             1AB4
ASCII_8             1AB6
ASCII_9             1AB8
ASCII_A             1ABA
ASCII_B             1ABC
ASCII_C             1ABE
ASCII_D             1AC0
ASCII_E             1AC2
ASCII_F             1AC4
BCC_END             141A
BCLROP              1A78
BITMASK             1A0C
BITMASKDONE         1A1C
CBRACK              1AD0
CMPIBYTE            10F4
CMPIEA              1168
CMPILONG            1142
CMPIOP              1A81
CMPIREG             11B4
CMPIREG000          11D8
CMPIREG001          11D8
CMPIWORD            111C
COMMA               1ACC
CR                  D
DATA                1A86
DIVSOP              1A53
DOLLAR              1AC8
DONE                1362
EAHELPER05          1490
EAHELPER611         145C
END                 401C
END0000             11D2
END67               17CC
ENDEAHELPER05       1588
ENDMODE_AN          1718
ENDMODE_DN          1618
ENDOP0001           1222
HEX_VALUE_MASK_LONG  F
IMD                 1ACA
INVALID_ASCII_INPUT  1A06
ISCMPI              10BA
ISORI               10BA
ITERATION           1064
JSROP               1A6B
LEAOP               1A74
LF                  A
LOOP                103A
LOOPBIT             1A10
MINUS               1AD4
MODE_AN             168E
MODE_DN             158E
MOVEMOP             1A65
MOVEOP              1A60
MSGEND              1A3A
MSGSTART            1A22
NEGOP               1A5C
NEWLINE             1A50
NEXT                1060
NOOPERATION         1A58
NOT0001             1050
NOT67BYTE           17B0
NOT67WORD           17C0
NOTA0               16B0
NOTA1               16C0
NOTA2               16D0
NOTA3               16E0
NOTA4               16F0
NOTA5               1700
NOTA6               1710
NOTADRDIRECT        14C0
NOTADRINDIRECT      14E8
NOTADRINDIRECTPOST  151C
NOTADRINDIRECTPRE   1550
NOTBCLR             1098
NOTD0               15B0
NOTD1               15C0
NOTD2               15D0
NOTD3               15E0
NOTD4               15F0
NOTD5               1600
NOTD6               1610
NOTDATAREG          14B0
NOTDIVS             145C
NOTIMMEDIATE        1584
NOTJSR              1318
NOTMOVEM            12D6
NOTNEG              12B2
NOTNOP              125C
NOTRTS              133A
OBRACK              1ACE
OP0000              106E
OP0001              11D8
OP0010              1228
OP0011              1228
OP0100              1240
OP0101              136C
OP0110              136C
OP0111              1420
OP1000              1420
OP1001              145C
OP1010              145C
OP1011              145C
OP1100              145C
OP1101              145C
OP1110              145C
OP1111              145C
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              13BC
OP_BCC_MSG          1A8E
OP_BCS              13C6
OP_BCS_MSG          1A92
OP_BGE              13D0
OP_BGE_MSG          1A96
OP_BLT              13DA
OP_BLT_MSG          1A9A
OP_BRA              13EE
OP_BRANCHES_PRINT   13F8
OP_BRA_MSG          1AA2
OP_BVC              13E4
OP_BVC_MSG          1A9E
ORIOP               1A7D
PLUS                1AD2
PRINTA0             171E
PRINTA1             172C
PRINTA2             173A
PRINTA3             1748
PRINTA4             1756
PRINTA5             1764
PRINTA6             1772
PRINTA7             1780
PRINTBYTE           182A
PRINTD0             161E
PRINTD1             162C
PRINTD2             163A
PRINTD3             1648
PRINTD4             1656
PRINTD5             1664
PRINTD6             1672
PRINTD7             1680
PRINTLONG           1846
PRINTWORD           1838
PRINT_ASCII_0       194E
PRINT_ASCII_1       1958
PRINT_ASCII_2       1962
PRINT_ASCII_3       196C
PRINT_ASCII_4       1976
PRINT_ASCII_5       1980
PRINT_ASCII_6       198A
PRINT_ASCII_7       1994
PRINT_ASCII_8       199E
PRINT_ASCII_9       19A8
PRINT_ASCII_A       19B2
PRINT_ASCII_B       19BC
PRINT_ASCII_C       19C6
PRINT_ASCII_CHAR    19EE
PRINT_ASCII_D       19D0
PRINT_ASCII_E       19DA
PRINT_ASCII_F       19E4
PRINT_ASCII_FINISH  1A06
PRINT_ASCII_HEX_CHAR  187E
PRINT_ASCII_LOOP    188E
RLLYEND             401E
RTSOP               1A70
SIZE67              178E
SIZE68              17D2
SPACE               1AC6
START               1000
UNKNOWN             135E
UNKNOWNOP           1854
UNKNOWNOP0001       121E
__A0                1AE2
__A1                1AE5
__A2                1AE8
__A3                1AEB
__A4                1AEE
__A5                1AF1
__A6                1AF4
__A7                1AF7
__B                 1AD6
__D0                1AFA
__D1                1AFD
__D2                1B00
__D3                1B03
__D4                1B06
__D5                1B09
__D6                1B0C
__D7                1B0F
__L                 1ADE
__W                 1ADA
