00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/5/2014 5:05:02 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001BDC             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001BF4             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001C0A             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0B8E                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 0260                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 02B4                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 02AA                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 02A8                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 03C4                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 03BA                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 045E                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 0454                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 04B6                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 04AC                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 04A2                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 0498                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 048E                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 0484                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 047A                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 08CC                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2ED6                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 C0C0                212          MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0A68                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162  0C46 0180                218          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0012                219          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           220          
0000116A  43F9 00001C31            221          LEA     BCLROP,A1           * We found BCLR
00001170  103C 000E                222          MOVE.B  #14,D0              * Trap #14 prints out the data
00001174  4E4F                     223          TRAP    #15                 * Perform Trap #14
00001176  6000 013C                224          BRA     END0000              * Found the op, move to next iteration
0000117A                           225  
0000117A                           226  NOTBCLR * Possible options left are ORI or CMPI
0000117A  3C3C 0009                227          MOVE.W  #9, D6              * Prep lower value for bitmask
0000117E  3E3C 000B                228          MOVE.W  #11, D7             * Prep upper value for bitmask
00001182  6100 0A42                229          BSR     BITMASK             * Finalize bitmask setup
00001186  CC42                     230          AND     D2,D6               * Apply bitmask
00001188                           231          
00001188  0C46 0000                232          CMPI    #%0000000000000000, D6  * Are we ORI?
0000118C  6700 000E                233          BEQ     ISORI                   * If ORI, branch to ISORI
00001190                           234          
00001190  0C46 0C00                235          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
00001194  6700 0006                236          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
00001198                           237          
00001198  6600 0874                238          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
0000119C                           239                                          * We don't deal too kindly with imposters.
0000119C                           240          
0000119C                           241  ISORI   * TODO
0000119C                           242          
0000119C                           243  
0000119C                           244  ISCMPI
0000119C  43F9 00001C3E            245          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000011A2  103C 000E                246          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000011A6  4E4F                     247          TRAP    #15                 * Perform Trap #14
000011A8                           248          
000011A8                           249          * Determine the Size
000011A8  3C3C 0006                250          MOVE.W  #6, D6              * Prep lower value for bitmask
000011AC  3E3C 0007                251          MOVE.W  #7, D7              * Prep upper value for bitmask
000011B0  6100 0A14                252          BSR     BITMASK             * Finalize bitmask setup
000011B4  CC42                     253          AND     D2,D6               * Apply bitmask
000011B6                           254          
000011B6  0C46 00C0                255          CMPI    #%0000000011000000, D6  * Imposter Op
000011BA  6700 0852                256          BEQ     UNKNOWNOP               * Deal with the imposter
000011BE                           257          
000011BE  0C46 0000                258          CMPI    #%0000000000000000, D6  * The size is a BYTE
000011C2  6700 0012                259          BEQ     CMPIBYTE                * Branch to CMPI.B
000011C6                           260          
000011C6  0C46 0040                261          CMPI    #%0000000001000000, D6  * The size is a WORD
000011CA  6700 0032                262          BEQ     CMPIWORD                * Branch to CMPI.W
000011CE                           263          
000011CE  0C46 0080                264          CMPI    #%0000000010000000, D6  * The size is a LONG
000011D2  6700 0050                265          BEQ     CMPILONG                * Branch to CMPI.L
000011D6                           266          
000011D6                           267  CMPIBYTE
000011D6  43F9 00001C99            268          LEA     __B, A1     * Load .B
000011DC  103C 000E                269          MOVE.B  #14, D0     * Print out data
000011E0  4E4F                     270          TRAP    #15         * Perform Trap #14
000011E2                           271          
000011E2  43F9 00001C8D            272          LEA     IMD, A1     * Load #
000011E8  103C 000E                273          MOVE.B  #14, D0     * Print out data
000011EC  4E4F                     274          TRAP    #15         * Perform Trap #14
000011EE                           275          
000011EE  361A                     276          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
000011F0  1203                     277          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
000011F2  3622                     278          MOVE.W  -(A2),D3    * Now go back
000011F4  103C 000E                279          MOVE.B  #14, D0     * Print out the data
000011F8  4E4F                     280          TRAP    #15         * Perform Trap #14 
000011FA                           281          
000011FA  6000 004E                282          BRA     CMPIEA      * Branch to determine Effective Address
000011FE                           283          
000011FE                           284  CMPIWORD
000011FE  43F9 00001C9D            285          LEA     __W, A1     * Load .W
00001204  103C 000E                286          MOVE.B  #14, D0     * Print out data
00001208  4E4F                     287          TRAP    #15         * Perform Trap #14
0000120A                           288          
0000120A  43F9 00001C8D            289          LEA     IMD, A1     * Load #
00001210  103C 000E                290          MOVE.B  #14, D0     * Print out data
00001214  4E4F                     291          TRAP    #15         * Perform Trap #14
00001216                           292          
00001216  361A                     293          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001218  3222                     294          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
0000121A  103C 000E                295          MOVE.B  #14, D0     * Print out the data
0000121E  4E4F                     296          TRAP    #15         * Perform Trap #14
00001220                           297          
00001220                           298          
00001220  6000 0028                299          BRA     CMPIEA      * Branch to determine Effective Address
00001224                           300          
00001224                           301  CMPILONG
00001224  43F9 00001CA1            302          LEA     __L, A1     * Load .L
0000122A  103C 000E                303          MOVE.B  #14, D0     * Print out data
0000122E  4E4F                     304          TRAP    #15         * Perform Trap #14
00001230                           305          
00001230  43F9 00001C8D            306          LEA     IMD, A1     * Load #
00001236  103C 000E                307          MOVE.B  #14, D0     * Print out data
0000123A  4E4F                     308          TRAP    #15         * Perform Trap #14
0000123C                           309          
0000123C  361A                     310          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000123E  2222                     311          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
00001240  103C 000E                312          MOVE.B  #14, D0     * Print out the data
00001244  4E4F                     313          TRAP    #15         * Perform Trap #14
00001246                           314          
00001246  6000 0002                315          BRA     CMPIEA      * Branch to determine Effective Address
0000124A                           316          
0000124A                           317  CMPIEA
0000124A                           318          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
0000124A  43F9 00001C8F            319          LEA     COMMA, A1   * Load ,
00001250  103C 000E                320          MOVE.B  #14, D0     * Print out data
00001254  4E4F                     321          TRAP    #15         * Perform Trap #14
00001256                           322          
00001256  43F9 00001CA1            323          LEA     __L, A1     * Load .L
0000125C  103C 000E                324          MOVE.B  #14, D0     * Print out data
00001260  4E4F                     325          TRAP    #15         * Perform Trap #14
00001262                           326          
00001262                           327          * Determine the mode
00001262  3C3C 0003                328          MOVE.W  #3, D6              * Prep lower value for bitmask
00001266  3E3C 0005                329          MOVE.W  #5, D7              * Prep upper value for bitmask
0000126A  6100 095A                330          BSR     BITMASK             * Finalize bitmask setup
0000126E  CC42                     331          AND     D2,D6               * Apply bitmask
00001270                           332          
00001270  0C46 0008                333          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
00001274  6700 0798                334          BEQ     UNKNOWNOP               * Imposter op
00001278                           335          
00001278  0C46 0028                336          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
0000127C  6700 0790                337          BEQ     UNKNOWNOP               * Imposter op
00001280                           338          
00001280  0C46 0030                339          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
00001284  6700 0788                340          BEQ     UNKNOWNOP               * Imposter op
00001288                           341  
00001288  0C46 0038                342          CMPI    #%0000000000111000, D6  * Is the Mode 111?
0000128C  6700 0008                343          BEQ     CMPIREG                 * Further investigation is needed
00001290                           344          
00001290                           345          * will need to call the EA helpers when they are complete
00001290                           346          
00001290                           347          * Mode is verified to be valid at this point
00001290                           348          *CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
00001290                           349          *BSR     MODE_DN
00001290                           350          
00001290                           351          *CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
00001290                           352          *BSR     MODE_AN
00001290                           353          
00001290                           354          *CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
00001290                           355          *BSR     MODE_IAN_POS
00001290                           356          
00001290                           357          *CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
00001290                           358          *BSR     MODE_IAN_PRE
00001290                           359          
00001290                           360          * Reached End of CMPI. Everything has been printed out
00001290  4C9F 0303                361          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001294  4E75                     362          RTS
00001296                           363          
00001296                           364  CMPIREG
00001296  3C3C 0000                365          MOVE.W  #0, D6              * Prep lower value for bitmask
0000129A  3E3C 0002                366          MOVE.W  #2, D7              * Prep upper value for bitmask
0000129E  6100 0926                367          BSR     BITMASK             * Finalize bitmask setup
000012A2  CC42                     368          AND     D2,D6               * Apply bitmask
000012A4                           369          
000012A4  0C46 0000                370          CMPI    #%0000000000000000, D6  * Is the Register 000?
000012A8  6700 0010                371          BEQ     CMPIREG000
000012AC                           372          
000012AC  0C46 0001                373          CMPI    #%0000000000000001, D6  * Is the Register 001?
000012B0  6700 0008                374          BEQ     CMPIREG001
000012B4                           375          
000012B4                           376  END0000          
000012B4  4C9F 0303                377         MOVEM   (A7)+,D0-D1/A0-A1   * Push values to the stack to save
000012B8  4E75                     378         RTS
000012BA                           379         
000012BA                           380  CMPIREG000  * TODO (xxx).W for CMPI
000012BA                           381  
000012BA                           382  CMPIREG001  * TODO (xxx).L for CMPI
000012BA                           383  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012BA                           384  *-----------------------------------------------------------------------------
000012BA                           385  
000012BA                           386  
000012BA                           387  
000012BA                           388  *-----------------------------------------------------------------------------
000012BA                           389  *-----------------------------------------------------------------------------
000012BA                           390  * NAME: OP_0001   (MOVE.B)
000012BA                           391  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012BA                           392  * PRE-CONDITION:  xyz
000012BA                           393  * POST-CONDITION: All registers return to their previous state, and the output
000012BA                           394  *                 goes to the output console for reading the raw data or the
000012BA                           395  *                 actual instruction.
000012BA                           396  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012BA                           397  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012BA                           398  OP0001  
000012BA  48A7 FFC0                399          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
000012BE  3C3C 0006                400          MOVE.W  #6, D6              * Prep lower value for bitmask
000012C2  3E3C 0008                401          MOVE.W  #8, D7              * Prep upper value for bitmask
000012C6  6100 08FE                402          BSR     BITMASK             * Finalize bitmask setup
000012CA  CC42                     403          AND     D2,D6               * Apply bitmask
000012CC                           404          
000012CC                           405          * I may have fucked off this part, sorry - Caleb
000012CC                           406          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
000012CC                           407          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
000012CC                           408          
000012CC  43F9 00001C1A            409          LEA     MOVEOP,A1   * Put 'MOVE' into the window
000012D2  103C 000E                410          MOVE.B  #14,D0      * Trap #14 to print out
000012D6  4E4F                     411          TRAP    #15         * Perform Trap #14
000012D8                           412          
000012D8  3C3C 000C                413          MOVE.W  #12, D6              * Prep lower value for bitmask
000012DC  3E3C 000D                414          MOVE.W  #13, D7              * Prep upper value for bitmask
000012E0  6100 08E4                415          BSR     BITMASK             * Finalize bitmask setup
000012E4                           416          
000012E4  CC42                     417          AND     D2,D6   * get the size bits
000012E6                           418          
000012E6  2A06                     419          MOVE.L  D6,D5
000012E8                           420          
000012E8  E04D                     421          LSR     #8,D5
000012EA  E84D                     422          LSR     #4,D5
000012EC                           423          
000012EC  6100 065A                424          BSR     SIZE67
000012F0  6100 02F8                425          BSR     EAHELPER05
000012F4                           426          
000012F4  43F9 00001C8F            427          LEA     COMMA,A1
000012FA  103C 000E                428          MOVE.B  #14,D0
000012FE  4E4F                     429          TRAP    #15
00001300                           430          
00001300  6100 02B8                431          BSR     EAHELPER611
00001304                           432          
00001304  43F9 00001C0A            433          LEA     NEWLINE,A1
0000130A  103C 000E                434          MOVE.B  #14,D0
0000130E  4E4F                     435          TRAP    #15
00001310                           436          
00001310  6000 0006                437          BRA     ENDOP0001
00001314                           438          *LEA     __B,A1      * Put '.B' into the window
00001314                           439          *MOVE.B  #14,D0      * Trap #14 to print out
00001314                           440          *TRAP    #15         * Perform Trap #14
00001314                           441          
00001314                           442  UNKNOWNOP0001
00001314                           443  
00001314  6100 06F8                444          BSR     UNKNOWNOP
00001318                           445          
00001318                           446  ENDOP0001
00001318                           447  
00001318  4C9F 03FF                448          MOVEM (A7)+,D0-D7/A0-A1
0000131C  4E75                     449          RTS        
0000131E                           450          
0000131E                           451          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
0000131E                           452  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000131E                           453  *-----------------------------------------------------------------------------
0000131E                           454  
0000131E                           455  
0000131E                           456  
0000131E                           457  *-----------------------------------------------------------------------------
0000131E                           458  *-----------------------------------------------------------------------------
0000131E                           459  * NAME: OP_0010   (MOVE.L, MOVEA.L)
0000131E                           460  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000131E                           461  * PRE-CONDITION:  xyz
0000131E                           462  * POST-CONDITION: All registers return to their previous state, and the output
0000131E                           463  *                 goes to the output console for reading the raw data or the
0000131E                           464  *                 actual instruction.
0000131E                           465  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000131E                           466  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000131E                           467  OP0010
0000131E                           468  
0000131E  6100 06EE                469      BSR     UNKNOWNOP
00001322  4E75                     470      RTS
00001324                           471  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001324                           472  *-----------------------------------------------------------------------------
00001324                           473  
00001324                           474  
00001324                           475  
00001324                           476  *-----------------------------------------------------------------------------
00001324                           477  *-----------------------------------------------------------------------------
00001324                           478  * NAME: OP_0011   (MOVE.W, MOVEA.W)
00001324                           479  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001324                           480  * PRE-CONDITION:  xyz
00001324                           481  * POST-CONDITION: All registers return to their previous state, and the output
00001324                           482  *                 goes to the output console for reading the raw data or the
00001324                           483  *                 actual instruction.
00001324                           484  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001324                           485  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001324                           486  OP0011
00001324  48A7 FFFE                487      MOVEM   D0-D7/A0-A6, -(A7)
00001328                           488      
00001328                           489      *MOVE.W  #6,D6
00001328                           490      *MOVE.W  #8,D7
00001328                           491      
00001328                           492      *BSR     BITMASK
00001328                           493      
00001328                           494      *AND.W   D2,D6
00001328                           495      
00001328                           496      *CMP     #%0000000001000000,D6
00001328                           497      *BNE     NEXT15
00001328                           498      *BSR     * for MOVEA.W
00001328                           499      
00001328  4C9F 7FFF                500      MOVEM   (A7)+,D0-D7/A0-A6
0000132C                           501      
0000132C  6100 06E0                502      BSR     UNKNOWNOP
00001330  4E75                     503      RTS
00001332                           504  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001332                           505  *-----------------------------------------------------------------------------
00001332                           506  
00001332                           507  
00001332                           508  
00001332                           509  *-----------------------------------------------------------------------------
00001332                           510  *-----------------------------------------------------------------------------
00001332                           511  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
00001332                           512  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001332                           513  * PRE-CONDITION:  xyz
00001332                           514  * POST-CONDITION: All registers return to their previous state, and the output
00001332                           515  *                 goes to the output console for reading the raw data or the
00001332                           516  *                 actual instruction.
00001332                           517  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001332                           518  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001332                           519  OP0100  
00001332                           520          * TODO: lea, movem
00001332                           521  
00001332  48A7 C0C0                522          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001336                           523          
00001336                           524          *NOP
00001336  0C42 4E71                525          CMPI    #%0100111001110001,D2
0000133A  6600 0012                526          BNE     NOTNOP
0000133E                           527          
0000133E  43F9 00001C12            528          LEA     NOOPERATION,A1
00001344  103C 000D                529          MOVE.B  #13,D0          * Print a newline
00001348  4E4F                     530          TRAP    #15
0000134A                           531          
0000134A  6000 0108                532          BRA     DONE *we found it, move on to the next iteration
0000134E                           533  NOTNOP *NEG
0000134E                           534          
0000134E                           535          * prep values for BITMASK subroutine
0000134E  7C08                     536          MOVE.L  #8,D6
00001350  7E0B                     537          MOVE.L  #11,D7
00001352                           538          
00001352  6100 0872                539          BSR     BITMASK
00001356                           540          
00001356  CC42                     541          AND     D2,D6                   * apply bitmask
00001358                           542          
00001358  0C46 0400                543          CMPI    #%0000010000000000,D6   * are we NEG?
0000135C  6600 0046                544          BNE     NOTNEG                  * not neg
00001360                           545          
00001360  7C03                     546          MOVE.L  #3,D6
00001362  7E05                     547          MOVE.L  #5,D7
00001364                           548          
00001364  6100 0860                549          BSR     BITMASK * generate a bitmask to be used to check mode
00001368                           550          
00001368  0C46 0008                551          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
0000136C  6700 00E2                552          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001370                           553          
00001370  0C46 0028                554          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001374  6700 00DA                555          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001378                           556          
00001378  0C46 0030                557          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000137C  6700 00D2                558          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001380                           559        
00001380                           560          * it is NEG, print
00001380  43F9 00001C16            561          LEA     NEGOP,A1
00001386  103C 000E                562          MOVE.B  #14,D0
0000138A  4E4F                     563          TRAP    #15
0000138C                           564          
0000138C  6100 05BA                565          BSR     SIZE67
00001390                           566          
00001390  6100 0258                567          BSR     EAHELPER05
00001394                           568          
00001394  43F9 00001C0A            569          LEA     NEWLINE,A1
0000139A  103C 000E                570          MOVE.B  #14,D0
0000139E  4E4F                     571          TRAP    #15
000013A0                           572          
000013A0  6000 00B2                573          BRA     DONE * we found the op, move to next iteration
000013A4                           574          
000013A4                           575  NOTNEG *MOVEM
000013A4                           576  
000013A4                           577          * prep values for BITMASK subroutine
000013A4  7C07                     578          MOVE.L  #7,D6
000013A6  7E09                     579          MOVE.L  #9,D7
000013A8                           580          
000013A8  6100 081C                581          BSR     BITMASK
000013AC                           582          
000013AC  CC42                     583          AND     D2,D6   * apply bitmask
000013AE                           584          
000013AE  0C46 0080                585          CMPI    #%0000000010000000,D6 * is it MOVEM?
000013B2  6600 0014                586          BNE     NOTMOVEM          * it is not MOVEM
000013B6                           587          
000013B6                           588          * make sure it is a valid size and mode for MOVEM
000013B6                           589          
000013B6                           590          * it is MOVEM
000013B6  43F9 00001C1F            591          LEA     MOVEMOP,A1
000013BC  103C 000D                592          MOVE.B  #13,D0          * Print a newline
000013C0  4E4F                     593          TRAP    #15
000013C2                           594          
000013C2                           595          * probably needs its own special code for printing the rest due to uniqueness of movem
000013C2                           596          
000013C2  341A                     597          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013C4                           598          
000013C4  6000 008E                599          BRA     DONE          * we found and printed, move on to the next iteration
000013C8                           600          
000013C8                           601  NOTMOVEM *JSR
000013C8                           602          * prep values for BITMASK subroutine
000013C8  7C06                     603          MOVE.L  #6,D6
000013CA  7E08                     604          MOVE.L  #8,D7
000013CC                           605          
000013CC  6100 07F8                606          BSR     BITMASK
000013D0                           607          
000013D0  CC42                     608          AND     D2,D6   * apply bitmask
000013D2                           609          
000013D2  0C46 0080                610          CMPI    #%0000000010000000,D6
000013D6  6600 0032                611          BNE     NOTJSR          * it's not JSR
000013DA                           612          
000013DA  43F9 00001C25            613          LEA     JSROP,A1
000013E0  103C 000E                614          MOVE.B  #14,D0          * Print a newline and JSR
000013E4  4E4F                     615          TRAP    #15
000013E6                           616          
000013E6                           617          * print out where we are jumping to
000013E6                           618          
000013E6  341A                     619          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013E8                           620          
000013E8  2202                     621          MOVE.L  D2,D1   * save the opcode to print
000013EA                           622          
000013EA  7410                     623          MOVE.L  #16,D2  * set the base to 16
000013EC                           624          
000013EC  700F                     625          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000013EE  4E4F                     626          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000013F0                           627          
000013F0  341A                     628          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013F2                           629          
000013F2  2202                     630          MOVE.L  D2,D1   * save the opcode to print
000013F4                           631          
000013F4  7410                     632          MOVE.L  #16,D2  * set the base to 16
000013F6                           633          
000013F6  700F                     634          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000013F8  4E4F                     635          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000013FA                           636          
000013FA  43F9 00001C0A            637          LEA     NEWLINE,A1
00001400  103C 000E                638          MOVE.B  #14,D0          * Print a newline
00001404  4E4F                     639          TRAP    #15
00001406                           640          
00001406  6000 004C                641          BRA     DONE          * we already found instruction, next iteration
0000140A                           642  NOTJSR *RTS
0000140A                           643  
0000140A                           644          * prep values for BITMASK subroutine
0000140A  7C06                     645          MOVE.L  #6,D6
0000140C  7E08                     646          MOVE.L  #8,D7
0000140E                           647          
0000140E  6100 07B6                648          BSR     BITMASK
00001412                           649          
00001412  CC42                     650          AND     D2,D6   * apply bitmask
00001414                           651          
00001414  0C46 0040                652          CMPI    #%0000000001000000,D6
00001418  6600 0012                653          BNE     NOTRTS          * it's not RTS
0000141C                           654          
0000141C  43F9 00001C29            655          LEA     RTSOP,A1
00001422  103C 000D                656          MOVE.B  #13,D0          * Print a newline and RTS
00001426  4E4F                     657          TRAP    #15
00001428                           658          
00001428  6000 002A                659          BRA     DONE          * we already found instruction, next iteration
0000142C                           660  NOTRTS  *LEA
0000142C                           661         
0000142C                           662          * prep values for BITMASK subroutine
0000142C  7C06                     663          MOVE.L  #6,D6
0000142E  7E08                     664          MOVE.L  #8,D7
00001430                           665          
00001430  6100 0794                666          BSR     BITMASK
00001434                           667          
00001434  CC42                     668          AND     D2,D6   * apply bitmask
00001436                           669          
00001436  0C46 01C0                670          CMPI    #%0000000111000000,D6
0000143A  6600 0014                671          BNE     UNKNOWN          * it's not LEA, we dont know what it is
0000143E                           672          
0000143E                           673          * check to make sure it is a supported mode and size
0000143E                           674          
0000143E  43F9 00001C2D            675          LEA     LEAOP,A1
00001444  103C 000D                676          MOVE.B  #13,D0          * Print LEA
00001448  4E4F                     677          TRAP    #15
0000144A                           678          
0000144A                           679          * call EA helper
0000144A  341A                     680          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000144C                           681                  
0000144C  6000 0006                682          BRA     DONE          * we already found instruction, next iteration
00001450                           683          
00001450                           684  UNKNOWN *dont know what it is
00001450  6100 05BC                685          BSR     UNKNOWNOP
00001454                           686          
00001454                           687  DONE
00001454  4C9F 0303                688          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001458  4E75                     689          RTS
0000145A                           690          
0000145A  6000 FCE8                691          BRA     ITERATION
0000145E                           692  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145E                           693  *-----------------------------------------------------------------------------        
0000145E                           694          
0000145E                           695          
0000145E                           696  
0000145E                           697  *-----------------------------------------------------------------------------
0000145E                           698  *-----------------------------------------------------------------------------
0000145E                           699  * NAME: OP_0101   (SUBQ)
0000145E                           700  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000145E                           701  * PRE-CONDITION:  xyz
0000145E                           702  * POST-CONDITION: All registers return to their previous state, and the output
0000145E                           703  *                 goes to the output console for reading the raw data or the
0000145E                           704  *                 actual instruction.
0000145E                           705  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000145E                           706  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145E                           707  OP0101
0000145E                           708  
0000145E  6100 05AE                709      BSR     UNKNOWNOP
00001462  4E75                     710      RTS
00001464                           711  
00001464                           712  * testing branching
00001464                           713  * op op op
00001464                           714  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001464                           715  *-----------------------------------------------------------------------------
00001464                           716  
00001464                           717  
00001464                           718  
00001464                           719  *-----------------------------------------------------------------------------
00001464                           720  *-----------------------------------------------------------------------------
00001464                           721  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
00001464                           722  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001464                           723  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
00001464                           724  *                 in the instruction and determines what the bits match to a
00001464                           725  *                 given condition code. If the 8 bit offset is $00, or $FF,
00001464                           726  *                 this signifies a word or long offset (for $00 and $FF
00001464                           727  *                 respectively). The 8 bit offset is in 2's comp. form, and
00001464                           728  *                 should be un-done, then plus or minus to the current
00001464                           729  *                 program counter (PC) to get the actual memory label to
00001464                           730  *                 output to console. The word offset signal eats an
00001464                           731  *                 additional 16 bits and the long offset eats an additional
00001464                           732  *                 32 bits. The word/long offset are for memory alignment.
00001464                           733  * POST-CONDITION: All registers return to their previous state, and the output
00001464                           734  *                 goes to the output console for reading the raw data or the
00001464                           735  *                 actual instruction.
00001464                           736  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001464                           737  *                 A1 (output)
00001464                           738  * CONDITIONS TABLE:
00001464                           739  *                Condition Names  - Mnemonic - Condition Code
00001464                           740  *                --------------------------------------------
00001464                           741  *                True             -    T     - 0000
00001464                           742  *                False            -    F     - 0001
00001464                           743  *                Higher           -    HI    - 0010
00001464                           744  *                Lower or Same    -    LS    - 0011
00001464                           745  *                Carry Clear      -    CC    - 0100
00001464                           746  *                Carry Set        -    CS    - 0101
00001464                           747  *                Not Equal        -    NE    - 0110
00001464                           748  *                Equal            -    EQ    - 0111
00001464                           749  *                Overflow Clear   -    VC    - 1000
00001464                           750  *                Overflow Set     -    VS    - 1001
00001464                           751  *                Plus             -    PL    - 1010
00001464                           752  *                Minus            -    MI    - 1011
00001464                           753  *                Greater or Equal -    GE    - 1100
00001464                           754  *                Less Than        -    LT    - 1101
00001464                           755  *                Greater Than     -    GT    - 1110
00001464                           756  *                Less or Equal    -    LE    - 1111
00001464                           757  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001464                           758  OP0110
00001464  48A7 C0C0                759          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
00001468                           760          
00001468                           761          * Ready four bits to help distinguish op's with the 0110 prefix
00001468  3C3C 0000                762          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
0000146C                           763                                        * BITMASK sub-routine call)
0000146C  3E3C 0007                764          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001470                           765                                        * BITMASK sub-routine call)
00001470                           766                                        
00001470                           767          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001470  6100 0754                768          BSR     BITMASK               * Call BITMASK sub-routine
00001474                           769                                        * Returns a bitmask in D6
00001474                           770          
00001474  CC42                     771          AND     D2,D6                 * And the index op, which was pre-loaded
00001476                           772                                        * in the main memory loop with the bitmask
00001476                           773                                        * to use to determine what case we need.
00001476                           774          
00001476                           775          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
00001476                           776          * $00 == word offset, $FF == long offset
00001476                           777       ***CMPI    #%0000000000000000,D6
00001476                           778       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
00001476                           779       ***
00001476                           780       ***CMPI    #%0000000011111111,D6
00001476                           781       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
00001476                           782          
00001476                           783          * IF PASSED BOTH CMPI CHECKS (ABOVE),
00001476                           784          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
00001476                           785          
00001476  3C3C 0009                786          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
0000147A  3E3C 000B                787          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
0000147E                           788                                        
0000147E                           789          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
0000147E  6100 0746                790          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
00001482  CC42                     791          AND     D2,D6   * apply the BITMASK
00001484                           792          
00001484                           793          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001484  0C46 0400                794          CMPI    #%0000010000000000,D6
00001488  6700 002A                795          BEQ     OP_BCC
0000148C                           796          
0000148C                           797          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
0000148C  0C46 0500                798          CMPI    #%0000010100000000,D6
00001490  6700 002C                799          BEQ     OP_BCS
00001494                           800          
00001494                           801          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001494  0C46 0C00                802          CMPI    #%0000110000000000,D6
00001498  6700 002E                803          BEQ     OP_BGE
0000149C                           804          
0000149C                           805          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
0000149C  0C46 0D00                806          CMPI    #%0000110100000000,D6
000014A0  6700 0030                807          BEQ     OP_BLT
000014A4                           808          
000014A4                           809          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
000014A4  0C46 0800                810          CMPI    #%0000100000000000,D6
000014A8  6700 0032                811          BEQ     OP_BVC
000014AC                           812          
000014AC                           813          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
000014AC                           814          * NOTE: A branch to the immediately following instruction automatically
000014AC                           815          *       uses the 16-bit displacement format because the 8-bit displacement
000014AC                           816          *       field contains $00 zero offset
000014AC                           817          * http://68k.hax.com/BRA
000014AC                           818          * NOTE2 ---> Does this mean, there should be no checks when debugging
000014AC                           819          *            for word/long offsets?
000014AC  0C46 0000                820          CMPI    #%0000000000000000,D6
000014B0  6700 0034                821          BEQ     OP_BRA
000014B4                           822          
000014B4                           823          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
000014B4                           824          ; call raw data print out sub routine
000014B4                           825  
000014B4                           826  OP_BCC
000014B4  43F9 00001C4B            827          LEA     OP_BCC_MSG,A1
000014BA  6000 0034                828          BRA     OP_BRANCHES_PRINT
000014BE                           829  OP_BCS
000014BE  43F9 00001C50            830          LEA     OP_BCS_MSG,A1
000014C4  6000 002A                831          BRA     OP_BRANCHES_PRINT
000014C8                           832  OP_BGE
000014C8  43F9 00001C55            833          LEA     OP_BGE_MSG,A1
000014CE  6000 0020                834          BRA     OP_BRANCHES_PRINT
000014D2                           835  OP_BLT
000014D2  43F9 00001C5A            836          LEA     OP_BLT_MSG,A1
000014D8  6000 0016                837          BRA     OP_BRANCHES_PRINT
000014DC                           838  OP_BVC
000014DC  43F9 00001C5F            839          LEA     OP_BVC_MSG,A1
000014E2  6000 000C                840          BRA     OP_BRANCHES_PRINT
000014E6                           841  OP_BRA
000014E6  43F9 00001C64            842          LEA     OP_BRA_MSG,A1
000014EC  6000 0002                843          BRA     OP_BRANCHES_PRINT
000014F0                           844  
000014F0                           845  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000014F0                           846          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000014F0                           847          * assemble output to console
000014F0                           848  OP_BRANCHES_PRINT
000014F0  103C 000E                849          MOVE.B  #14,D0 * print instruction op
000014F4  4E4F                     850          TRAP    #15
000014F6                           851          
000014F6  43F9 00001C43            852          LEA     DATA,A1
000014FC  103C 000E                853          MOVE.B  #14,D0 * print raw data hex of the LABEL
00001500  4E4F                     854          TRAP    #15
00001502                           855          
00001502  1A1A                     856          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
00001504  2845                     857          MOVE.L  D5,A4 * ready the 8bits into a4
00001506  43D4                     858          LEA     (A4),A1 * ready the a4 into a1 for print
00001508  103C 000E                859          MOVE.B  #14,D0 * print the 8bit addr
0000150C  4E4F                     860          TRAP    #15
0000150E                           861  
0000150E  6000 0002                862          BRA     BCC_END
00001512                           863  
00001512                           864  BCC_END * reload the memory, call RTS
00001512  4C9F 0303                865          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001516  4E75                     866          RTS
00001518                           867  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001518                           868  *-----------------------------------------------------------------------------
00001518                           869  
00001518                           870  
00001518                           871  
00001518                           872  *-----------------------------------------------------------------------------
00001518                           873  *-----------------------------------------------------------------------------
00001518                           874  * NAME: OP_0111   ()
00001518                           875  * DESCRIPTION:    OP code 0111 is not supported. 
00001518                           876  * PRE-CONDITION:  
00001518                           877  * POST-CONDITION: 
00001518                           878  * REGISTERS:
00001518                           879  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001518                           880  OP0111
00001518  6100 04F4                881      BSR     UNKNOWNOP
0000151C  4E75                     882      RTS
0000151E                           883  
0000151E                           884  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000151E                           885  *-----------------------------------------------------------------------------
0000151E                           886  
0000151E                           887  
0000151E                           888  
0000151E                           889  *-----------------------------------------------------------------------------
0000151E                           890  *-----------------------------------------------------------------------------
0000151E                           891  * NAME: OP_1000   (DIVS, OR)
0000151E                           892  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000151E                           893  * PRE-CONDITION:  xyz
0000151E                           894  * POST-CONDITION: All registers return to their previous state, and the output
0000151E                           895  *                 goes to the output console for reading the raw data or the
0000151E                           896  *                 actual instruction.
0000151E                           897  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000151E                           898  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000151E                           899  OP1000
0000151E                           900          * Saving values to the stack
0000151E  48A7 FFC0                901          MOVEM   D0-D7/A0-A1,-(A7)
00001522                           902  
00001522                           903          * Check if the EA Mode is 001 since both DIVS and OR do not support it
00001522  3C3C 0003                904          MOVE.W  #3, D6              * Prep lower value for bitmask
00001526  3E3C 0005                905          MOVE.W  #5, D7              * Prep upper value for bitmask
0000152A  6100 069A                906          BSR     BITMASK             * Finalize bitmask setup
0000152E  CC42                     907          AND     D2,D6               * Apply bitmask
00001530                           908          
00001530  0C46 0008                909          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
00001534  6700 FF1A                910          BEQ     UNKNOWN                 * If so, the op is not supported
00001538                           911          
00001538                           912          * Checking for DIVS
00001538  3C3C 0006                913          MOVE.W  #6, D6              * Prep lower value for bitmask
0000153C  3E3C 0008                914          MOVE.W  #8, D7              * Prep upper value for bitmask
00001540  6100 0684                915          BSR     BITMASK             * Finalize bitmask setup
00001544  CC42                     916          AND     D2,D6               * Apply bitmask
00001546                           917          
00001546  0C46 01C0                918          CMPI    #%0000000111000000, D6  * Are we DIVS?
0000154A  6600 002E                919          BNE     NOTDIVS                 * If not, branch to see if it's OR
0000154E                           920          
0000154E  43F9 00001C0D            921          LEA     DIVSOP,A1           * We found DIVS
00001554  103C 000E                922          MOVE.B  #14,D0              * Trap #14 prints out the data
00001558  4E4F                     923          TRAP    #15                 * Perform Trap #14
0000155A                           924          
0000155A  6100 005E                925          BSR     EAHELPER611         * Print out data. TODO: DOESN'T WORK
0000155E                           926          
0000155E  43F9 00001C8F            927          LEA     COMMA,A1            * We found DIVS
00001564  103C 000E                928          MOVE.B  #14,D0              * Trap #14 prints out the data
00001568  4E4F                     929          TRAP    #15                 * Perform Trap #14
0000156A                           930          
0000156A  6100 007E                931          BSR     EAHELPER05         * Print out data. TODO: DOESN'T WORK
0000156E                           932          
0000156E  43F9 00001C0A            933          LEA     NEWLINE,A1          * We found DIVS
00001574  103C 000E                934          MOVE.B  #14,D0              * Trap #14 prints out the data
00001578  4E4F                     935          TRAP    #15                 * Perform Trap #14
0000157A                           936          
0000157A                           937  NOTDIVS * It is confirmed OR at this point
0000157A  43F9 00001C37            938          LEA     OROP,A1         * We found OR
00001580  103C 000E                939          MOVE.B  #14,D0          * Trap #14 prints out the data
00001584  4E4F                     940          TRAP    #15             * Perform Trap #14
00001586                           941          
00001586  6100 0032                942          BSR     EAHELPER611
0000158A                           943  
0000158A                           944  OP1000END
0000158A  48A7 FFC0                945          MOVEM   D0-D7/A0-A1,-(A7)
0000158E  4E75                     946          RTS
00001590                           947  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001590                           948  *-----------------------------------------------------------------------------
00001590                           949  
00001590                           950  
00001590                           951  
00001590                           952  *-----------------------------------------------------------------------------
00001590                           953  *-----------------------------------------------------------------------------
00001590                           954  * NAME: OP_1001   (SUB)
00001590                           955  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001590                           956  * PRE-CONDITION:  xyz
00001590                           957  * POST-CONDITION: All registers return to their previous state, and the output
00001590                           958  *                 goes to the output console for reading the raw data or the
00001590                           959  *                 actual instruction.
00001590                           960  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001590                           961  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001590                           962  OP1001
00001590                           963  
00001590  6100 047C                964      BSR     UNKNOWNOP
00001594  4E75                     965      RTS
00001596                           966  
00001596                           967  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001596                           968  *-----------------------------------------------------------------------------
00001596                           969  
00001596                           970  
00001596                           971  
00001596                           972  *-----------------------------------------------------------------------------
00001596                           973  *-----------------------------------------------------------------------------
00001596                           974  * NAME: OP_1010   ()
00001596                           975  * DESCRIPTION:    a
00001596                           976  * PRE-CONDITION:  b
00001596                           977  * POST-CONDITION: c
00001596                           978  * REGISTERS:      d
00001596                           979  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001596                           980  OP1010
00001596                           981  
00001596  6100 0476                982      BSR     UNKNOWNOP
0000159A  4E75                     983      RTS
0000159C                           984  
0000159C                           985  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000159C                           986  *-----------------------------------------------------------------------------
0000159C                           987  
0000159C                           988  
0000159C                           989  
0000159C                           990  *-----------------------------------------------------------------------------
0000159C                           991  *-----------------------------------------------------------------------------
0000159C                           992  * NAME: OP_1011   (EOR, CMP)
0000159C                           993  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000159C                           994  * PRE-CONDITION:  xyz
0000159C                           995  * POST-CONDITION: All registers return to their previous state, and the output
0000159C                           996  *                 goes to the output console for reading the raw data or the
0000159C                           997  *                 actual instruction.
0000159C                           998  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000159C                           999  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000159C                          1000  OP1011
0000159C                          1001  
0000159C  6100 0470               1002      BSR     UNKNOWNOP
000015A0  4E75                    1003      RTS
000015A2                          1004  
000015A2                          1005  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015A2                          1006  *-----------------------------------------------------------------------------
000015A2                          1007  
000015A2                          1008  
000015A2                          1009  
000015A2                          1010  *-----------------------------------------------------------------------------
000015A2                          1011  *-----------------------------------------------------------------------------
000015A2                          1012  * NAME: OP_1100   (MULS)
000015A2                          1013  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015A2                          1014  * PRE-CONDITION:  xyz
000015A2                          1015  * POST-CONDITION: All registers return to their previous state, and the output
000015A2                          1016  *                 goes to the output console for reading the raw data or the
000015A2                          1017  *                 actual instruction.
000015A2                          1018  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015A2                          1019  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015A2                          1020  OP1100
000015A2                          1021  
000015A2  6100 046A               1022      BSR     UNKNOWNOP
000015A6  4E75                    1023      RTS
000015A8                          1024  
000015A8                          1025  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015A8                          1026  *-----------------------------------------------------------------------------
000015A8                          1027  
000015A8                          1028  
000015A8                          1029  
000015A8                          1030  *-----------------------------------------------------------------------------
000015A8                          1031  *-----------------------------------------------------------------------------
000015A8                          1032  * NAME: OP_1101   (ADD, ADDA)
000015A8                          1033  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015A8                          1034  * PRE-CONDITION:  xyz
000015A8                          1035  * POST-CONDITION: All registers return to their previous state, and the output
000015A8                          1036  *                 goes to the output console for reading the raw data or the
000015A8                          1037  *                 actual instruction.
000015A8                          1038  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015A8                          1039  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015A8                          1040  OP1101
000015A8                          1041  
000015A8  6100 0464               1042      BSR     UNKNOWNOP
000015AC  4E75                    1043      RTS
000015AE                          1044  
000015AE                          1045  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015AE                          1046  *-----------------------------------------------------------------------------
000015AE                          1047  
000015AE                          1048  
000015AE                          1049  
000015AE                          1050  *-----------------------------------------------------------------------------
000015AE                          1051  *-----------------------------------------------------------------------------
000015AE                          1052  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
000015AE                          1053  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015AE                          1054  * PRE-CONDITION:  xyz
000015AE                          1055  * POST-CONDITION: All registers return to their previous state, and the output
000015AE                          1056  *                 goes to the output console for reading the raw data or the
000015AE                          1057  *                 actual instruction.
000015AE                          1058  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015AE                          1059  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015AE                          1060  OP1110
000015AE                          1061  
000015AE  6100 045E               1062      BSR     UNKNOWNOP
000015B2  4E75                    1063      RTS
000015B4                          1064  
000015B4                          1065  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015B4                          1066  *-----------------------------------------------------------------------------
000015B4                          1067  
000015B4                          1068  
000015B4                          1069  
000015B4                          1070  *-----------------------------------------------------------------------------
000015B4                          1071  *-----------------------------------------------------------------------------
000015B4                          1072  * NAME: OP_1111   ()
000015B4                          1073  * DESCRIPTION:    a
000015B4                          1074  * PRE-CONDITION:  b
000015B4                          1075  * POST-CONDITION: c
000015B4                          1076  * REGISTERS:      d
000015B4                          1077  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015B4                          1078  OP1111
000015B4                          1079  
000015B4  6100 0458               1080      BSR     UNKNOWNOP
000015B8  4E75                    1081      RTS
000015BA                          1082  
000015BA                          1083  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015BA                          1084  *-----------------------------------------------------------------------------
000015BA                          1085  
000015BA                          1086  
000015BA                          1087  
000015BA                          1088  *-----------------------------------------------------------------------------
000015BA                          1089  *-----------------------------------------------------------------------------
000015BA                          1090  * NAME:           EAHELPER611
000015BA                          1091  * DESCRIPTION:    a
000015BA                          1092  * PRE-CONDITION:  D2 contains the instruction to print modes for.
000015BA                          1093  *                 D5 contains the size of potential immediate data
000015BA                          1094  * POST-CONDITION: Determines mode, passes D2 to EAHELPER05 to print.
000015BA                          1095  * REGISTERS:      a
000015BA                          1096  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015BA                          1097  EAHELPER611
000015BA  48A7 FFC0               1098      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
000015BE                          1099      
000015BE                          1100      * to move the mode where EAHELPER50 can process it
000015BE                          1101      
000015BE  6100 0606               1102      BSR     BITMASK * create bitmask
000015C2                          1103      
000015C2  CC42                    1104      AND     D2,D6   * apply bitmask
000015C4                          1105      
000015C4  4243                    1106      CLR     D3      * prep D3 to store values
000015C6                          1107      
000015C6  3606                    1108      MOVE.W  D6,D3   * store bitmasked value in D3
000015C8                          1109      
000015C8  E64B                    1110      LSR     #3,D3   * move bits 6-8 to 3-5
000015CA                          1111      
000015CA                          1112      * to move the register where EAHELPER50 can process it
000015CA  7C09                    1113      MOVE.L  #9,D6   *prep registers to create bitmask
000015CC  7E0B                    1114      MOVE.L  #11,D7
000015CE                          1115      
000015CE  6100 05F6               1116      BSR     BITMASK * create bitmask
000015D2                          1117      
000015D2  CC42                    1118      AND     D2,D6   * apply bitmask
000015D4                          1119      
000015D4  4244                    1120      CLR     D4      * prep D3 to store values
000015D6                          1121      
000015D6  3806                    1122      MOVE.W  D6,D4   * store bitmasked value in D3
000015D8                          1123      
000015D8  E04C                    1124      LSR     #8,D4   * move bits 9-11 to 0-2
000015DA  E24C                    1125      LSR     #1,D4   * move bits 9-11 to 0-2
000015DC                          1126      
000015DC  8684                    1127      OR.L    D4,D3   * combind the register and mode
000015DE                          1128      
000015DE  2403                    1129      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
000015E0                          1130      
000015E0  6100 0008               1131      BSR     EAHELPER05
000015E4                          1132      
000015E4  4C9F 03FF               1133      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
000015E8                          1134      
000015E8  4E75                    1135      RTS
000015EA                          1136  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015EA                          1137  *-----------------------------------------------------------------------------
000015EA                          1138  
000015EA                          1139  
000015EA                          1140  
000015EA                          1141  *-----------------------------------------------------------------------------
000015EA                          1142  *-----------------------------------------------------------------------------
000015EA                          1143  * NAME:           EAHELPER05
000015EA                          1144  * DESCRIPTION:    a
000015EA                          1145  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
000015EA                          1146  *                 this sub-routine helper for operations that only have one
000015EA                          1147  *                 mode register.
000015EA                          1148  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
000015EA                          1149  * REGISTERS:      a
000015EA                          1150  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015EA                          1151  EAHELPER05
000015EA                          1152      * todo: add code for printing immediate values
000015EA                          1153      
000015EA  48A7 FFC0               1154      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000015EE                          1155      
000015EE  2605                    1156      MOVE.L  D5,D3   * move the register containing the potential size into D3
000015F0                          1157      
000015F0  7C03                    1158      MOVE.L  #3,D6
000015F2  7E05                    1159      MOVE.L  #5,D7
000015F4                          1160      
000015F4  6100 05D0               1161      BSR     BITMASK * generate a bitmask to identify the mode
000015F8                          1162      
000015F8  CC42                    1163      AND     D2,D6   * mask off the parts of D2 we don't need
000015FA                          1164      
000015FA  2A06                    1165      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
000015FC                          1166      
000015FC  0C46 0000               1167      CMPI    #%0000000000000000,D6 * is it data register direct?
00001600  6600 000A               1168      BNE     NOTDATAREG
00001604                          1169      
00001604  6100 0142               1170      BSR     MODE_DN
00001608                          1171       
00001608  6000 0138               1172      BRA     ENDEAHELPER05
0000160C                          1173      
0000160C                          1174  NOTDATAREG * address register direct
0000160C                          1175      
0000160C  0C46 0008               1176      CMPI    #%0000000000001000,D6 * is it address register direct?
00001610  6600 000A               1177      BNE     NOTADRDIRECT
00001614                          1178      
00001614  6100 0232               1179      BSR     MODE_AN * simply prints out the address register
00001618                          1180       
00001618  6000 0128               1181      BRA     ENDEAHELPER05
0000161C                          1182      
0000161C                          1183  NOTADRDIRECT * address register indirect
0000161C                          1184          
0000161C  0C46 0010               1185      CMPI    #%0000000000010000,D6 * is it address register indirect?
00001620  6600 0022               1186      BNE     NOTADRINDIRECT
00001624                          1187      
00001624  43F9 00001C91           1188      LEA     OBRACK,A1       * Load '('
0000162A  303C 000E               1189      MOVE.W  #14,D0          * Trap #14 to display message
0000162E  4E4F                    1190      TRAP    #15             * Perform #14
00001630                          1191          
00001630                          1192  
00001630  6100 0216               1193      BSR     MODE_AN * print out an address register
00001634                          1194      
00001634  43F9 00001C93           1195      LEA     CBRACK,A1       * Load ')'
0000163A  303C 000E               1196      MOVE.W  #14,D0          * Trap #14 to display message
0000163E  4E4F                    1197      TRAP    #15             * Perform #14
00001640                          1198       
00001640  6000 0100               1199      BRA     ENDEAHELPER05
00001644                          1200      
00001644                          1201  NOTADRINDIRECT * address register indirect, post increment
00001644                          1202      
00001644  0C46 0018               1203      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
00001648  6600 002E               1204      BNE     NOTADRINDIRECTPOST
0000164C                          1205      
0000164C  43F9 00001C91           1206      LEA     OBRACK,A1       * Load '('
00001652  303C 000E               1207      MOVE.W  #14,D0          * Trap #14 to display message
00001656  4E4F                    1208      TRAP    #15             * Perform #14
00001658                          1209          
00001658                          1210  
00001658  6100 01EE               1211      BSR     MODE_AN * print out an address register
0000165C                          1212      
0000165C  43F9 00001C93           1213      LEA     CBRACK,A1       * Load ')'
00001662  303C 000E               1214      MOVE.W  #14,D0          * Trap #14 to display message
00001666  4E4F                    1215      TRAP    #15             * Perform #14
00001668                          1216      
00001668  43F9 00001C95           1217      LEA     PLUS,A1       * Load '+'
0000166E  303C 000E               1218      MOVE.W  #14,D0          * Trap #14 to display message
00001672  4E4F                    1219      TRAP    #15             * Perform #14
00001674                          1220       
00001674  6000 00CC               1221      BRA     ENDEAHELPER05
00001678                          1222      
00001678                          1223  NOTADRINDIRECTPOST * address register indirect, pre decrement
00001678                          1224      
00001678  0C46 0020               1225      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
0000167C  6600 002E               1226      BNE     NOTADRINDIRECTPRE
00001680                          1227      
00001680  43F9 00001C97           1228      LEA     MINUS,A1       * Load '-'
00001686  303C 000E               1229      MOVE.W  #14,D0          * Trap #14 to display message
0000168A  4E4F                    1230      TRAP    #15             * Perform #14
0000168C                          1231      
0000168C  43F9 00001C91           1232      LEA     OBRACK,A1       * Load '('
00001692  303C 000E               1233      MOVE.W  #14,D0          * Trap #14 to display message
00001696  4E4F                    1234      TRAP    #15             * Perform #14
00001698                          1235          
00001698                          1236  
00001698  6100 01AE               1237      BSR     MODE_AN * print out an address register
0000169C                          1238      
0000169C  43F9 00001C93           1239      LEA     CBRACK,A1       * Load ')'
000016A2  303C 000E               1240      MOVE.W  #14,D0          * Trap #14 to display message
000016A6  4E4F                    1241      TRAP    #15             * Perform #14
000016A8                          1242       
000016A8  6000 0098               1243      BRA     ENDEAHELPER05
000016AC                          1244      
000016AC                          1245  NOTADRINDIRECTPRE * immediate
000016AC                          1246      
000016AC  0C46 0038               1247      CMPI    #%0000000000111000,D6 * is it immediate?
000016B0  6600 008C               1248      BNE     NOTIMMEDIATE
000016B4                          1249  
000016B4  3C3C 0000               1250      MOVE.W  #0, D6              * Prep lower value for bitmask
000016B8  3E3C 0002               1251      MOVE.W  #2, D7              * Prep upper value for bitmask
000016BC  6100 0508               1252      BSR     BITMASK             * Finalize bitmask setup
000016C0  CC42                    1253      AND     D2,D6               * Apply bitmask
000016C2                          1254  
000016C2  0C43 0001               1255      CMPI    #1,D3 * is it a byte?
000016C6  6600 0028               1256      BNE     NOTIMMBYTE
000016CA                          1257      
000016CA  43F9 00001C8D           1258      LEA     IMD,A1 *print out the '#' indicating an immediate value
000016D0  103C 000E               1259      MOVE.B  #14,D0
000016D4  4E4F                    1260      TRAP    #15
000016D6                          1261      
000016D6  3C3C 0008               1262      MOVE.W  #8, D6              * Prep lower value for bitmask
000016DA  3E3C 001F               1263      MOVE.W  #31, D7              * Prep upper value for bitmask
000016DE  6100 04E6               1264      BSR     BITMASK             * Finalize bitmask setup
000016E2                          1265          
000016E2  321A                    1266      MOVE.W  (A2)+,D1
000016E4                          1267      
000016E4  C246                    1268      AND     D6,D1
000016E6                          1269          
000016E6  103C 0003               1270      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000016EA  4E4F                    1271      TRAP    #15      * Perform Trap #3
000016EC                          1272      
000016EC  6000 0054               1273      BRA     ENDEAHELPER05
000016F0                          1274  
000016F0                          1275  NOTIMMBYTE
000016F0                          1276      
000016F0  0C43 0002               1277      CMPI    #2,D3 * is it a word?
000016F4  6600 0028               1278      BNE     NOTIMMWORD
000016F8                          1279      
000016F8  43F9 00001C8D           1280      LEA     IMD,A1 *print out the '#' indicating an immediate value
000016FE  103C 000E               1281      MOVE.B  #14,D0
00001702  4E4F                    1282      TRAP    #15
00001704                          1283      
00001704  3C3C 0010               1284      MOVE.W  #16, D6              * Prep lower value for bitmask
00001708  3E3C 001F               1285      MOVE.W  #31, D7             * Prep upper value for bitmask
0000170C  6100 04B8               1286      BSR     BITMASK             * Finalize bitmask setup
00001710                          1287          
00001710  321A                    1288      MOVE.W  (A2)+,D1
00001712                          1289      
00001712  C246                    1290      AND     D6,D1               * Apply bitmask
00001714                          1291          
00001714  103C 0003               1292      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001718  4E4F                    1293      TRAP    #15      * Perform Trap #3
0000171A                          1294      
0000171A  6000 0026               1295      BRA     ENDEAHELPER05
0000171E                          1296      
0000171E                          1297  NOTIMMWORD
0000171E  0C46 0003               1298      CMPI    #3,D6 * is it a long?
00001722  6600 001A               1299      BNE     NOTIMMEDIATE
00001726                          1300      
00001726  43F9 00001C8D           1301      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000172C  103C 000E               1302      MOVE.B  #14,D0
00001730  4E4F                    1303      TRAP    #15
00001732                          1304          
00001732  221A                    1305      MOVE.L  (A2)+,D1
00001734                          1306          
00001734  103C 0003               1307      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001738  4E4F                    1308      TRAP    #15      * Perform Trap #3
0000173A                          1309      
0000173A  6000 0006               1310      BRA     ENDEAHELPER05
0000173E                          1311      
0000173E                          1312  NOTIMMEDIATE * if none of the previous cases are true, it is a mode not supported by our decompiler
0000173E                          1313  
0000173E  6100 02CE               1314      BSR     UNKNOWNOP
00001742                          1315      
00001742                          1316  ENDEAHELPER05
00001742  4C9F 03FF               1317      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001746  4E75                    1318      RTS
00001748                          1319  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001748                          1320  *-----------------------------------------------------------------------------
00001748                          1321  
00001748                          1322  
00001748                          1323  
00001748                          1324  *-----------------------------------------------------------------------------
00001748                          1325  *-----------------------------------------------------------------------------
00001748                          1326  * NAME:           MODE_DN
00001748                          1327  * DESCRIPTION:    Generalize the EA part of the project.
00001748                          1328  * PRE-CONDITION:  The mode must have been correctly identified. All modes
00001748                          1329  *                 must be called by RTS.
00001748                          1330  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
00001748                          1331  *                 called it.
00001748                          1332  * REGISTERS:      a
00001748                          1333  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001748                          1334  * ---> Dn
00001748                          1335  MODE_DN
00001748  48A7 FFC0               1336          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
0000174C                          1337  
0000174C  3C3C 0000               1338          MOVE.W  #0, D6              * Prep lower value for bitmask
00001750  3E3C 0002               1339          MOVE.W  #2, D7              * Prep upper value for bitmask
00001754  6100 0470               1340          BSR     BITMASK             * Finalize bitmask setup
00001758  CC42                    1341          AND     D2,D6               * Apply bitmask
0000175A                          1342          
0000175A  0C46 0000               1343          CMPI    #%000000000000000, D6   * Data Register D0?
0000175E  6600 000A               1344          BNE     NOTD0
00001762                          1345          
00001762  6100 0074               1346          BSR     PRINTD0
00001766  6000 006A               1347          BRA     ENDMODE_DN
0000176A                          1348  NOTD0      
0000176A  0C46 0001               1349          CMPI    #%000000000000001, D6   * Data Register D1?
0000176E  6600 000A               1350          BNE     NOTD1
00001772                          1351          
00001772  6100 0072               1352          BSR     PRINTD1
00001776  6000 005A               1353          BRA     ENDMODE_DN
0000177A                          1354  NOTD1
0000177A  0C46 0002               1355          CMPI    #%000000000000010, D6   * Data Register D2?
0000177E  6600 000A               1356          BNE     NOTD2
00001782                          1357          
00001782  6100 0070               1358          BSR     PRINTD2
00001786  6000 004A               1359          BRA     ENDMODE_DN
0000178A                          1360  NOTD2
0000178A  0C46 0003               1361          CMPI    #%000000000000011, D6   * Data Register D3?
0000178E  6600 000A               1362          BNE     NOTD3
00001792                          1363          
00001792  6100 006E               1364          BSR     PRINTD3
00001796  6000 003A               1365          BRA     ENDMODE_DN
0000179A                          1366  NOTD3
0000179A  0C46 0004               1367          CMPI    #%000000000000100, D6   * Data Register D4?
0000179E  6600 000A               1368          BNE     NOTD4
000017A2                          1369          
000017A2  6100 006C               1370          BSR     PRINTD4
000017A6  6000 002A               1371          BRA     ENDMODE_DN
000017AA                          1372  NOTD4
000017AA  0C46 0005               1373          CMPI    #%000000000000101, D6   * Data Register D5?
000017AE  6600 000A               1374          BNE     NOTD5
000017B2                          1375          
000017B2  6100 006A               1376          BSR     PRINTD5
000017B6  6000 001A               1377          BRA     ENDMODE_DN
000017BA                          1378  NOTD5
000017BA  0C46 0006               1379          CMPI    #%000000000000110, D6   * Data Register D6?
000017BE  6600 000A               1380          BNE     NOTD6
000017C2                          1381          
000017C2  6100 0068               1382          BSR     PRINTD6
000017C6  6000 000A               1383          BRA     ENDMODE_DN
000017CA                          1384  NOTD6
000017CA  6100 006E               1385          BSR     PRINTD7
000017CE  6000 0002               1386          BRA     ENDMODE_DN
000017D2                          1387          
000017D2                          1388  ENDMODE_DN
000017D2  4C9F 03FF               1389          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
000017D6  4E75                    1390          RTS
000017D8                          1391  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000017D8                          1392  *-----------------------------------------------------------------------------
000017D8                          1393  
000017D8                          1394  
000017D8                          1395  
000017D8                          1396  *-----------------------------------------------------------------------------
000017D8                          1397  *-----------------------------------------------------------------------------
000017D8                          1398  * NAME:           PRINTD0
000017D8                          1399  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
000017D8                          1400  * PRE-CONDITION:  a
000017D8                          1401  * POST-CONDITION: a
000017D8                          1402  * REGISTERS:      a
000017D8                          1403  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000017D8                          1404  PRINTD0
000017D8  43F9 00001CBD           1405          LEA     __D0, A1        * Load 'D0'
000017DE  103C 000E               1406          MOVE.B  #14, D0         * Load Trap #14 to print out
000017E2  4E4F                    1407          TRAP    #15             * Perform Trap #14
000017E4  4E75                    1408          RTS
000017E6                          1409  PRINTD1
000017E6  43F9 00001CC0           1410          LEA     __D1, A1        * Load 'D1'
000017EC  103C 000E               1411          MOVE.B  #14, D0         * Load Trap #14 to print out
000017F0  4E4F                    1412          TRAP    #15             * Perform Trap #14
000017F2  4E75                    1413          RTS      
000017F4                          1414  PRINTD2
000017F4  43F9 00001CC3           1415          LEA     __D2, A1        * Load 'D2'
000017FA  103C 000E               1416          MOVE.B  #14, D0         * Load Trap #14 to print out
000017FE  4E4F                    1417          TRAP    #15             * Perform Trap #14
00001800  4E75                    1418          RTS      
00001802                          1419  PRINTD3
00001802  43F9 00001CC6           1420          LEA     __D3, A1        * Load 'D3'
00001808  103C 000E               1421          MOVE.B  #14, D0         * Load Trap #14 to print out
0000180C  4E4F                    1422          TRAP    #15             * Perform Trap #14
0000180E  4E75                    1423          RTS      
00001810                          1424  PRINTD4
00001810  43F9 00001CC9           1425          LEA     __D4, A1        * Load 'D4'
00001816  103C 000E               1426          MOVE.B  #14, D0         * Load Trap #14 to print out
0000181A  4E4F                    1427          TRAP    #15             * Perform Trap #14
0000181C  4E75                    1428          RTS       
0000181E                          1429  PRINTD5
0000181E  43F9 00001CCC           1430          LEA     __D5, A1        * Load 'D5'
00001824  103C 000E               1431          MOVE.B  #14, D0         * Load Trap #14 to print out
00001828  4E4F                    1432          TRAP    #15             * Perform Trap #14
0000182A  4E75                    1433          RTS      
0000182C                          1434  PRINTD6
0000182C  43F9 00001CCF           1435          LEA     __D6, A1        * Load 'D6'
00001832  103C 000E               1436          MOVE.B  #14, D0         * Load Trap #14 to print out
00001836  4E4F                    1437          TRAP    #15             * Perform Trap #14
00001838  4E75                    1438          RTS
0000183A                          1439  PRINTD7
0000183A  43F9 00001CD2           1440          LEA     __D7, A1        * Load 'D7'
00001840  103C 000E               1441          MOVE.B  #14, D0         * Load Trap #14 to print out
00001844  4E4F                    1442          TRAP    #15             * Perform Trap #14
00001846  4E75                    1443          RTS
00001848                          1444  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001848                          1445  *-----------------------------------------------------------------------------
00001848                          1446  
00001848                          1447  
00001848                          1448  
00001848                          1449  *-----------------------------------------------------------------------------
00001848                          1450  *-----------------------------------------------------------------------------
00001848                          1451  * NAME:           MODE_AN
00001848                          1452  * DESCRIPTION:    Simply chooses to print A0-A7.
00001848                          1453  * PRE-CONDITION:  a
00001848                          1454  * POST-CONDITION: a
00001848                          1455  * REGISTERS:      a
00001848                          1456  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001848                          1457  MODE_AN
00001848  48A7 FFC0               1458          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
0000184C                          1459  
0000184C  3C3C 0000               1460          MOVE.W  #0, D6              * Prep lower value for bitmask
00001850  3E3C 0002               1461          MOVE.W  #2, D7              * Prep upper value for bitmask
00001854  6100 0370               1462          BSR     BITMASK             * Finalize bitmask setup
00001858  CC42                    1463          AND     D2,D6               * Apply bitmask
0000185A                          1464          
0000185A  0C46 0000               1465          CMPI    #%000000000000000, D6   * Address Register A0?
0000185E  6600 000A               1466          BNE     NOTA0
00001862                          1467          
00001862  6100 0074               1468          BSR     PRINTA0
00001866                          1469          
00001866  6000 006A               1470          BRA     ENDMODE_AN
0000186A                          1471  NOTA0      
0000186A  0C46 0001               1472          CMPI    #%000000000000001, D6   * Address Register A1?
0000186E  6600 000A               1473          BNE     NOTA1
00001872                          1474          
00001872  6100 0072               1475          BSR     PRINTA1
00001876                          1476          
00001876  6000 005A               1477          BRA     ENDMODE_AN
0000187A                          1478  NOTA1
0000187A  0C46 0002               1479          CMPI    #%000000000000010, D6   * Address Register A2?
0000187E  6600 000A               1480          BNE     NOTA2
00001882                          1481          
00001882  6100 0070               1482          BSR     PRINTA2
00001886                          1483          
00001886  6000 004A               1484          BRA     ENDMODE_AN
0000188A                          1485  NOTA2
0000188A  0C46 0003               1486          CMPI    #%000000000000011, D6   * Address Register A3?
0000188E  6600 000A               1487          BNE     NOTA3
00001892                          1488          
00001892  6100 006E               1489          BSR     PRINTA3
00001896                          1490          
00001896  6000 003A               1491          BRA     ENDMODE_AN
0000189A                          1492  NOTA3
0000189A  0C46 0004               1493          CMPI    #%000000000000100, D6   * Address Register A4?
0000189E  6600 000A               1494          BNE     NOTA4
000018A2                          1495          
000018A2  6100 006C               1496          BSR     PRINTA4
000018A6                          1497          
000018A6  6000 002A               1498          BRA     ENDMODE_AN
000018AA                          1499  NOTA4
000018AA  0C46 0005               1500          CMPI    #%000000000000101, D6   * Address Register A5?
000018AE  6600 000A               1501          BNE     NOTA5
000018B2                          1502          
000018B2  6100 006A               1503          BSR     PRINTA5
000018B6                          1504          
000018B6  6000 001A               1505          BRA     ENDMODE_AN
000018BA                          1506  NOTA5
000018BA  0C46 0006               1507          CMPI    #%000000000000110, D6   * Address Register A6?
000018BE  6600 000A               1508          BNE     NOTA6
000018C2                          1509          
000018C2  6100 0068               1510          BSR     PRINTA6
000018C6                          1511          
000018C6  6000 000A               1512          BRA     ENDMODE_AN
000018CA                          1513  NOTA6
000018CA  6100 006E               1514          BSR     PRINTA7
000018CE                          1515          
000018CE  6000 0002               1516          BRA     ENDMODE_AN
000018D2                          1517  ENDMODE_AN
000018D2  4C9F 03FF               1518          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
000018D6  4E75                    1519          RTS
000018D8                          1520  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018D8                          1521  *-----------------------------------------------------------------------------
000018D8                          1522  
000018D8                          1523  
000018D8                          1524  
000018D8                          1525  *-----------------------------------------------------------------------------
000018D8                          1526  *-----------------------------------------------------------------------------
000018D8                          1527  * NAME:           PRINTA0
000018D8                          1528  * DESCRIPTION:    Simply print out the address register.
000018D8                          1529  * PRE-CONDITION:  a
000018D8                          1530  * POST-CONDITION: a
000018D8                          1531  * REGISTERS:      a
000018D8                          1532  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018D8                          1533  PRINTA0
000018D8  43F9 00001CA5           1534          LEA     __A0, A1        * Load 'A0'
000018DE  103C 000E               1535          MOVE.B  #14, D0         * Load Trap #14 to print out
000018E2  4E4F                    1536          TRAP    #15             * Perform Trap #14
000018E4  4E75                    1537          RTS
000018E6                          1538  
000018E6                          1539  PRINTA1
000018E6  43F9 00001CA8           1540          LEA     __A1, A1        * Load 'A1'
000018EC  103C 000E               1541          MOVE.B  #14, D0         * Load Trap #14 to print out
000018F0  4E4F                    1542          TRAP    #15             * Perform Trap #14
000018F2  4E75                    1543          RTS
000018F4                          1544          
000018F4                          1545  PRINTA2
000018F4  43F9 00001CAB           1546          LEA     __A2, A1        * Load 'A2'
000018FA  103C 000E               1547          MOVE.B  #14, D0         * Load Trap #14 to print out
000018FE  4E4F                    1548          TRAP    #15             * Perform Trap #14
00001900  4E75                    1549          RTS
00001902                          1550  
00001902                          1551  PRINTA3
00001902  43F9 00001CAE           1552          LEA     __A3, A1        * Load 'A3'
00001908  103C 000E               1553          MOVE.B  #14, D0         * Load Trap #14 to print out
0000190C  4E4F                    1554          TRAP    #15             * Perform Trap #14
0000190E  4E75                    1555          RTS
00001910                          1556  
00001910                          1557  PRINTA4
00001910  43F9 00001CB1           1558          LEA     __A4, A1        * Load 'A4'
00001916  103C 000E               1559          MOVE.B  #14, D0         * Load Trap #14 to print out
0000191A  4E4F                    1560          TRAP    #15             * Perform Trap #14
0000191C  4E75                    1561          RTS
0000191E                          1562  
0000191E                          1563  PRINTA5
0000191E  43F9 00001CB4           1564          LEA     __A5, A1        * Load 'A5'
00001924  103C 000E               1565          MOVE.B  #14, D0         * Load Trap #14 to print out
00001928  4E4F                    1566          TRAP    #15             * Perform Trap #14
0000192A  4E75                    1567          RTS
0000192C                          1568  
0000192C                          1569  PRINTA6
0000192C  43F9 00001CB7           1570          LEA     __A6, A1        * Load 'A6'
00001932  103C 000E               1571          MOVE.B  #14, D0         * Load Trap #14 to print out
00001936  4E4F                    1572          TRAP    #15             * Perform Trap #14
00001938  4E75                    1573          RTS
0000193A                          1574  
0000193A                          1575  PRINTA7
0000193A  43F9 00001CBA           1576          LEA     __A7, A1        * Load 'A7'
00001940  103C 000E               1577          MOVE.B  #14, D0         * Load Trap #14 to print out
00001944  4E4F                    1578          TRAP    #15             * Perform Trap #14
00001946  4E75                    1579          RTS
00001948                          1580  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001948                          1581  *-----------------------------------------------------------------------------
00001948                          1582  
00001948                          1583  
00001948                          1584  
00001948                          1585  *-----------------------------------------------------------------------------
00001948                          1586  *-----------------------------------------------------------------------------
00001948                          1587  * NAME:           SIZE67
00001948                          1588  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001948                          1589  * PRE-CONDITION:  a
00001948                          1590  * POST-CONDITION: a
00001948                          1591  * REGISTERS:      a
00001948                          1592  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001948                          1593  SIZE67
00001948  48A7 FFFE               1594          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
0000194C  3C3C 0006               1595          MOVE.W  #6, D6              * Prep lower value for bitmask
00001950  3E3C 0007               1596          MOVE.W  #7, D7              * Prep upper value for bitmask
00001954  6100 0270               1597          BSR     BITMASK             * Finalize bitmask setup
00001958  CC42                    1598          AND     D2,D6               * Apply bitmask     
0000195A                          1599  
0000195A  0C46 0000               1600          CMPI    #%0000000000000000, D6   * is it a BYTE?
0000195E  6600 000A               1601          BNE     NOT67BYTE
00001962                          1602          
00001962  6100 0080               1603          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001966  6000 001E               1604          BRA     END67
0000196A                          1605  NOT67BYTE        
0000196A  0C46 0040               1606          CMPI    #%0000000001000000, D6   * is it a WORD?
0000196E  6600 000A               1607          BNE     NOT67WORD
00001972                          1608          
00001972  6100 007E               1609          BSR     PRINTWORD               * Branch to handle WORD sizes
00001976  6000 000E               1610          BRA     END67
0000197A                          1611  NOT67WORD
0000197A  0C46 0080               1612          CMPI    #%0000000010000000, D6   * is it a LONG?
0000197E  6600 0006               1613          BNE     END67
00001982                          1614          
00001982  6100 007C               1615          BSR     PRINTLONG               * Branch to handle LONG sizes
00001986                          1616  END67
00001986  4C9F 7FFF               1617          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
0000198A  4E75                    1618          RTS                             * Return. Size handling is finished.
0000198C                          1619  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000198C                          1620  *-----------------------------------------------------------------------------
0000198C                          1621  
0000198C                          1622  
0000198C                          1623  
0000198C                          1624  *-----------------------------------------------------------------------------
0000198C                          1625  *-----------------------------------------------------------------------------
0000198C                          1626  * NAME:           SIZE68
0000198C                          1627  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
0000198C                          1628  * PRE-CONDITION:  a
0000198C                          1629  * POST-CONDITION: a
0000198C                          1630  * REGISTERS:      a
0000198C                          1631  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000198C                          1632  SIZE68
0000198C                          1633          * finish later, need to follow the same format as SIZE67
0000198C                          1634          
0000198C                          1635          
0000198C  48A7 FFFE               1636          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001990  3C3C 0006               1637          MOVE.W  #6, D6              * Prep lower value for bitmask
00001994  3E3C 0008               1638          MOVE.W  #8, D7              * Prep upper value for bitmask
00001998  6100 022C               1639          BSR     BITMASK             * Finalize bitmask setup
0000199C  CC42                    1640          AND     D2,D6               * Apply bitmask          
0000199E                          1641          
0000199E  0C46 0000               1642          CMPI    #%0000000000000000, D6   * is it a BYTE?
000019A2  6100 0040               1643          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000019A6  0C46 0100               1644          CMPI    #%0000000100000000, D6   * is it a BYTE?
000019AA  6100 0038               1645          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
000019AE                          1646        
000019AE  0C46 0040               1647          CMPI    #%0000000001000000, D6   * is it a WORD?
000019B2  6100 003E               1648          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019B6  0C46 0140               1649          CMPI    #%0000000101000000, D6   * is it a WORD?
000019BA  6100 0036               1650          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019BE  0C46 00C0               1651          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
000019C2  6100 002E               1652          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019C6                          1653  
000019C6  0C46 0080               1654          CMPI    #%0000000010000000, D6   * is it a LONG?
000019CA  6100 0034               1655          BSR     PRINTLONG               * Branch to handle BYTE sizes
000019CE  0C46 0180               1656          CMPI    #%0000000110000000, D6   * is it a LONG?
000019D2  6100 002C               1657          BSR     PRINTLONG               * Branch to handle BYTE sizes
000019D6  0C46 01C0               1658          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
000019DA  6100 0024               1659          BSR     PRINTLONG               * Branch to handle BYTE sizes
000019DE                          1660  
000019DE  4C9F 7FFF               1661          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
000019E2  4E75                    1662          RTS                             * Return. Size handling is finished.
000019E4                          1663  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019E4                          1664  *-----------------------------------------------------------------------------
000019E4                          1665  
000019E4                          1666  
000019E4                          1667  
000019E4                          1668  *-----------------------------------------------------------------------------
000019E4                          1669  *-----------------------------------------------------------------------------
000019E4                          1670  * NAME:           PRINTBYTE
000019E4                          1671  * DESCRIPTION:    a
000019E4                          1672  * PRE-CONDITION:  a
000019E4                          1673  * POST-CONDITION: a
000019E4                          1674  * REGISTERS:      a
000019E4                          1675  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019E4                          1676  PRINTBYTE
000019E4  43F9 00001C99           1677          LEA     __B,A1      * Load '.B ' into A1
000019EA  103C 000E               1678          MOVE.B  #14,D0      * Trap #14 setup to print
000019EE  4E4F                    1679          TRAP    #15         * Perform Trap #14
000019F0  4E75                    1680          RTS                 * Return to SIZE67/SIZE68
000019F2                          1681          
000019F2                          1682  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019F2                          1683  *-----------------------------------------------------------------------------
000019F2                          1684  
000019F2                          1685  
000019F2                          1686  
000019F2                          1687  *-----------------------------------------------------------------------------
000019F2                          1688  *-----------------------------------------------------------------------------
000019F2                          1689  * NAME:           PRINTWORD
000019F2                          1690  * DESCRIPTION:    a
000019F2                          1691  * PRE-CONDITION:  a
000019F2                          1692  * POST-CONDITION: a
000019F2                          1693  * REGISTERS:      a
000019F2                          1694  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019F2                          1695  PRINTWORD
000019F2  43F9 00001C9D           1696          LEA     __W,A1      * Load '.W ' into A1
000019F8  103C 000E               1697          MOVE.B  #14,D0      * Trap #14 setup to print
000019FC  4E4F                    1698          TRAP    #15         * Perform Trap #14
000019FE  4E75                    1699          RTS                 * Return to SIZE67/SIZE68
00001A00                          1700          
00001A00                          1701  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A00                          1702  *-----------------------------------------------------------------------------
00001A00                          1703  
00001A00                          1704  
00001A00                          1705  
00001A00                          1706  *-----------------------------------------------------------------------------
00001A00                          1707  *-----------------------------------------------------------------------------
00001A00                          1708  * NAME:           PRINTLONG
00001A00                          1709  * DESCRIPTION:    a
00001A00                          1710  * PRE-CONDITION:  a
00001A00                          1711  * POST-CONDITION: a
00001A00                          1712  * REGISTERS:      a
00001A00                          1713  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A00                          1714  PRINTLONG
00001A00  43F9 00001CA1           1715          LEA     __L,A1      * Load '.L ' into A1
00001A06  103C 000E               1716          MOVE.B  #14,D0      * Trap #14 setup to print
00001A0A  4E4F                    1717          TRAP    #15         * Perform Trap #14
00001A0C  4E75                    1718          RTS                 * Return to SIZE67/SIZE68
00001A0E                          1719          
00001A0E                          1720  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A0E                          1721  *-----------------------------------------------------------------------------
00001A0E                          1722  
00001A0E                          1723  
00001A0E                          1724  
00001A0E                          1725  *-----------------------------------------------------------------------------
00001A0E                          1726  *-----------------------------------------------------------------------------
00001A0E                          1727  * NAME:           UNKNOWNOP
00001A0E                          1728  * DESCRIPTION:    a
00001A0E                          1729  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001A0E                          1730  *                 identified as an unknown operation.
00001A0E                          1731  * POST-CONDITION: D2 is no longer the opcode.
00001A0E                          1732  * REGISTERS:      a
00001A0E                          1733  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A0E                          1734  UNKNOWNOP
00001A0E  220A                    1735          MOVE.L  A2,D1   * prep the add to print
00001A10                          1736          
00001A10  5581                    1737          SUB.L   #2,D1   * off by two error due to post increment correct
00001A12                          1738          
00001A12  2602                    1739          MOVE.L  D2,D3   * save the opcode to print
00001A14                          1740          
00001A14  7410                    1741          MOVE.L  #16,D2  * set the base to 16
00001A16                          1742          
00001A16  700F                    1743          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001A18  4E4F                    1744          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001A1A                          1745          
00001A1A  43F9 00001C43           1746          LEA     DATA,A1 * load " DATA $" into register A1
00001A20  700E                    1747          MOVE.L  #14,D0  * print the string stored in A1
00001A22  4E4F                    1748          TRAP    #15
00001A24                          1749          
00001A24  2203                    1750          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001A26                          1751          
00001A26  103C 000F               1752          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A2A  4E4F                    1753          TRAP    #15      * Perform Trap #3
00001A2C                          1754  
00001A2C  43F9 00001C0A           1755          LEA     NEWLINE,A1 * load newline into register A1
00001A32  700E                    1756          MOVE.L  #14,D0  * print the string stored in A1
00001A34  4E4F                    1757          TRAP    #15
00001A36                          1758  
00001A36  4E75                    1759          RTS
00001A38                          1760  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A38                          1761  *-----------------------------------------------------------------------------
00001A38                          1762  
00001A38                          1763  
00001A38                          1764  
00001A38                          1765  *-----------------------------------------------------------------------------
00001A38                          1766  *-----------------------------------------------------------------------------
00001A38                          1767  * NAME: Print ASCII hex char
00001A38                          1768  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
00001A38                          1769  * PRE-CONDITION:  A6 contains the register for memory to print.
00001A38                          1770  *                 This parameter would be pre-loaded by, for example:
00001A38                          1771  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001A38                          1772  *                 D6 contains the loops to do (number of bytes).
00001A38                          1773  * POST-CONDITION: 
00001A38                          1774  * REGISTERS:      
00001A38                          1775  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A38                          1776  PRINT_ASCII_HEX_CHAR
00001A38  48E7 FFFC               1777      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001A3C  4285                    1778      CLR.L       D5
00001A3E                          1779      
00001A3E                          1780      * fence post check (if-statement, check if 0 > chars)
00001A3E  0C06 0000               1781      CMPI.B      #0,D6
00001A42  6700 017C               1782      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001A46                          1783      
00001A46                          1784  *    MOVE.L      A6,D4
00001A46  2E0E                    1785      MOVE.L      A6,D7
00001A48                          1786  PRINT_ASCII_LOOP
00001A48                          1787  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001A48                          1788  *    MOVE.L      D4,D7 * make a mutable copy
00001A48  E99F                    1789      ROL.L       #4,D7 * roll to next spot
00001A4A  48E7 0100               1790      MOVEM.L     D7,-(A7) * save D7
00001A4E                          1791  
00001A4E  0287 0000000F           1792      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001A54                          1793      
00001A54  0C87 00000000           1794      CMPI.L      #0,D7
00001A5A  6D00 0164               1795      BLT         INVALID_ASCII_INPUT
00001A5E                          1796  
00001A5E  0C87 0000000F           1797      CMPI.L      #15,D7
00001A64  6E00 015A               1798      BGT         INVALID_ASCII_INPUT
00001A68                          1799  
00001A68                          1800      * this might be faster... to do later, after entire assignment done
00001A68                          1801       * CMPI.L      #9,D7
00001A68                          1802       * BLE         PRINT_ASCII_0_TO_9
00001A68                          1803  
00001A68  0C87 00000000           1804      CMPI.L      #0,D7
00001A6E  6700 0098               1805      BEQ         PRINT_ASCII_0
00001A72  0C87 00000001           1806      CMPI.L      #1,D7
00001A78  6700 0098               1807      BEQ         PRINT_ASCII_1
00001A7C  0C87 00000002           1808      CMPI.L      #2,D7
00001A82  6700 0098               1809      BEQ         PRINT_ASCII_2
00001A86  0C87 00000003           1810      CMPI.L      #3,D7
00001A8C  6700 0098               1811      BEQ         PRINT_ASCII_3
00001A90  0C87 00000004           1812      CMPI.L      #4,D7
00001A96  6700 0098               1813      BEQ         PRINT_ASCII_4
00001A9A  0C87 00000005           1814      CMPI.L      #5,D7
00001AA0  6700 0098               1815      BEQ         PRINT_ASCII_5
00001AA4  0C87 00000006           1816      CMPI.L      #6,D7
00001AAA  6700 0098               1817      BEQ         PRINT_ASCII_6
00001AAE  0C87 00000007           1818      CMPI.L      #7,D7
00001AB4  6700 0098               1819      BEQ         PRINT_ASCII_7
00001AB8  0C87 00000008           1820      CMPI.L      #8,D7
00001ABE  6700 0098               1821      BEQ         PRINT_ASCII_8
00001AC2  0C87 00000009           1822      CMPI.L      #9,D7
00001AC8  6700 0098               1823      BEQ         PRINT_ASCII_9
00001ACC  0C87 0000000A           1824      CMPI.L      #10,D7
00001AD2  6700 0098               1825      BEQ         PRINT_ASCII_A
00001AD6  0C87 0000000B           1826      CMPI.L      #11,D7
00001ADC  6700 0098               1827      BEQ         PRINT_ASCII_B
00001AE0  0C87 0000000C           1828      CMPI.L      #12,D7
00001AE6  6700 0098               1829      BEQ         PRINT_ASCII_C
00001AEA  0C87 0000000D           1830      CMPI.L      #13,D7
00001AF0  6700 0098               1831      BEQ         PRINT_ASCII_D
00001AF4  0C87 0000000E           1832      CMPI.L      #14,D7
00001AFA  6700 0098               1833      BEQ         PRINT_ASCII_E
00001AFE  0C87 0000000F           1834      CMPI.L      #15,D7
00001B04  6700 0098               1835      BEQ         PRINT_ASCII_F
00001B08                          1836  PRINT_ASCII_0
00001B08  43F9 00001C69           1837      LEA         ASCII_0,A1
00001B0E  6000 0098               1838      BRA         PRINT_ASCII_CHAR
00001B12                          1839  PRINT_ASCII_1
00001B12  43F9 00001C6B           1840      LEA         ASCII_1,A1
00001B18  6000 008E               1841      BRA         PRINT_ASCII_CHAR
00001B1C                          1842  PRINT_ASCII_2
00001B1C  43F9 00001C6D           1843      LEA         ASCII_2,A1
00001B22  6000 0084               1844      BRA         PRINT_ASCII_CHAR
00001B26                          1845  PRINT_ASCII_3
00001B26  43F9 00001C6F           1846      LEA         ASCII_3,A1
00001B2C  6000 007A               1847      BRA         PRINT_ASCII_CHAR
00001B30                          1848  PRINT_ASCII_4
00001B30  43F9 00001C71           1849      LEA         ASCII_4,A1
00001B36  6000 0070               1850      BRA         PRINT_ASCII_CHAR
00001B3A                          1851  PRINT_ASCII_5
00001B3A  43F9 00001C73           1852      LEA         ASCII_5,A1
00001B40  6000 0066               1853      BRA         PRINT_ASCII_CHAR
00001B44                          1854  PRINT_ASCII_6
00001B44  43F9 00001C75           1855      LEA         ASCII_6,A1
00001B4A  6000 005C               1856      BRA         PRINT_ASCII_CHAR
00001B4E                          1857  PRINT_ASCII_7
00001B4E  43F9 00001C77           1858      LEA         ASCII_7,A1
00001B54  6000 0052               1859      BRA         PRINT_ASCII_CHAR
00001B58                          1860  PRINT_ASCII_8
00001B58  43F9 00001C79           1861      LEA         ASCII_8,A1
00001B5E  6000 0048               1862      BRA         PRINT_ASCII_CHAR
00001B62                          1863  PRINT_ASCII_9
00001B62  43F9 00001C7B           1864      LEA         ASCII_9,A1
00001B68  6000 003E               1865      BRA         PRINT_ASCII_CHAR
00001B6C                          1866  PRINT_ASCII_A
00001B6C  43F9 00001C7D           1867      LEA         ASCII_A,A1
00001B72  6000 0034               1868      BRA         PRINT_ASCII_CHAR
00001B76                          1869  PRINT_ASCII_B
00001B76  43F9 00001C7F           1870      LEA         ASCII_B,A1
00001B7C  6000 002A               1871      BRA         PRINT_ASCII_CHAR
00001B80                          1872  PRINT_ASCII_C
00001B80  43F9 00001C81           1873      LEA         ASCII_C,A1
00001B86  6000 0020               1874      BRA         PRINT_ASCII_CHAR
00001B8A                          1875  PRINT_ASCII_D
00001B8A  43F9 00001C83           1876      LEA         ASCII_D,A1
00001B90  6000 0016               1877      BRA         PRINT_ASCII_CHAR
00001B94                          1878  PRINT_ASCII_E
00001B94  43F9 00001C85           1879      LEA         ASCII_E,A1
00001B9A  6000 000C               1880      BRA         PRINT_ASCII_CHAR
00001B9E                          1881  PRINT_ASCII_F
00001B9E  43F9 00001C87           1882      LEA         ASCII_F,A1
00001BA4  6000 0002               1883      BRA         PRINT_ASCII_CHAR
00001BA8                          1884  PRINT_ASCII_CHAR
00001BA8  103C 000E               1885      MOVE.B      #14,D0
00001BAC  4E4F                    1886      TRAP        #15
00001BAE                          1887      
00001BAE  5205                    1888      ADD.B       #1,D5 * loop until counter stops
00001BB0  BA06                    1889      CMP.B       D6,D5
00001BB2  6C00 000C               1890      BGE         PRINT_ASCII_FINISH
00001BB6                          1891      
00001BB6  4287                    1892      CLR.L       D7
00001BB8  4CDF 0080               1893      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001BBC                          1894      
00001BBC  6000 FE8A               1895      BRA         PRINT_ASCII_LOOP
00001BC0                          1896  INVALID_ASCII_INPUT
00001BC0                          1897  PRINT_ASCII_FINISH
00001BC0  4CDF 3FFF               1898      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001BC4  4E75                    1899      RTS
00001BC6                          1900  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001BC6                          1901  *-----------------------------------------------------------------------------
00001BC6                          1902  
00001BC6                          1903  
00001BC6                          1904  
00001BC6                          1905  *-----------------------------------------------------------------------------
00001BC6                          1906  *-----------------------------------------------------------------------------
00001BC6                          1907  * NAME: Bitmask
00001BC6                          1908  * DESCRIPTION:    Masks bits in a data register.
00001BC6                          1909  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001BC6                          1910  *                 the ending bit.  For example, a starting bit of decimal
00001BC6                          1911  *                 value 0 and an ending bit of decimal value 3 will mask the
00001BC6                          1912  *                 bits 0, 1, 2, and 3.
00001BC6                          1913  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001BC6                          1914  * REGISTERS:      D5,D6,D7
00001BC6                          1915  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001BC6                          1916  BITMASK
00001BC6  3F05                    1917          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001BC8  4245                    1918          CLR     D5          * clear D5 so we can use it
00001BCA                          1919  LOOPBIT 
00001BCA  0DC5                    1920          BSET    D6,D5       * set the D6th bit in D5 to 1
00001BCC  5246                    1921          ADD     #1,D6       * increment D6
00001BCE                          1922  
00001BCE  BC47                    1923          CMP     D7,D6       * have we finished?
00001BD0  6E00 0004               1924          BGT     BITMASKDONE * yes
00001BD4  60F4                    1925          BRA     LOOPBIT     * no, iterate again
00001BD6                          1926  
00001BD6                          1927  BITMASKDONE
00001BD6  2C05                    1928          MOVE.L  D5,D6
00001BD8  3A1F                    1929          MOVE    (A7)+,D5    * restore D5
00001BDA  4E75                    1930          RTS
00001BDC                          1931  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001BDC                          1932  *-----------------------------------------------------------------------------
00001BDC                          1933  
00001BDC                          1934  
00001BDC                          1935  
00001BDC                          1936  *-----------------------------------------------------------------------------
00001BDC                          1937  *-----------------------------------------------------------------------------
00001BDC                          1938  * SECTION: Constants/variables used throughout the program.
00001BDC                          1939  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001BDC                          1940  * ---> GENERAL
00001BDC  =0000000D               1941  CR          EQU     $0D
00001BDC  =0000000A               1942  LF          EQU     $0A
00001BDC= 45 4E 54 45 52 20 ...   1943  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001BF4= 45 4E 54 45 52 20 ...   1944  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001C0A= 0D 0A 00                1945  NEWLINE     DC.B    CR,LF,0
00001C0D                          1946  * ---> OPS
00001C0D= 44 49 56 53 00          1947  DIVSOP      DC.B    'DIVS',0
00001C12= 4E 4F 50 00             1948  NOOPERATION DC.B    'NOP',0
00001C16= 4E 45 47 00             1949  NEGOP       DC.B    'NEG',0
00001C1A= 4D 4F 56 45 00          1950  MOVEOP      DC.B    'MOVE',0
00001C1F= 4D 4F 56 45 4D 00       1951  MOVEMOP     DC.B    'MOVEM',0
00001C25= 4A 53 52 00             1952  JSROP       DC.B    'JSR',0
00001C29= 52 54 53 00             1953  RTSOP       DC.B    'RTS',0
00001C2D= 4C 45 41 00             1954  LEAOP       DC.B    'LEA',0
00001C31= 42 43 4C 52 20 00       1955  BCLROP      DC.B    'BCLR ',0
00001C37= 4F 52 00                1956  OROP        DC.B    'OR',0
00001C3A= 4F 52 49 00             1957  ORIOP       DC.B    'ORI',0
00001C3E= 43 4D 50 49 00          1958  CMPIOP      DC.B    'CMPI',0
00001C43= 20 44 41 54 41 20 ...   1959  DATA        DC.B    ' DATA $',0
00001C4B= 42 43 43 20 00          1960  OP_BCC_MSG  DC.B    'BCC ',0
00001C50= 42 43 53 20 00          1961  OP_BCS_MSG  DC.B    'BCS ',0
00001C55= 42 47 45 20 00          1962  OP_BGE_MSG  DC.B    'BGE ',0
00001C5A= 42 4C 54 20 00          1963  OP_BLT_MSG  DC.B    'BLT ',0
00001C5F= 42 56 43 20 00          1964  OP_BVC_MSG  DC.B    'BVC ',0
00001C64= 42 52 41 20 00          1965  OP_BRA_MSG  DC.B    'BRA ',0
00001C69                          1966  * ---> HEX CHARS
00001C69= 30 00                   1967  ASCII_0     DC.B    '0',0
00001C6B= 31 00                   1968  ASCII_1     DC.B    '1',0
00001C6D= 32 00                   1969  ASCII_2     DC.B    '2',0
00001C6F= 33 00                   1970  ASCII_3     DC.B    '3',0
00001C71= 34 00                   1971  ASCII_4     DC.B    '4',0
00001C73= 35 00                   1972  ASCII_5     DC.B    '5',0
00001C75= 36 00                   1973  ASCII_6     DC.B    '6',0
00001C77= 37 00                   1974  ASCII_7     DC.B    '7',0
00001C79= 38 00                   1975  ASCII_8     DC.B    '8',0
00001C7B= 39 00                   1976  ASCII_9     DC.B    '9',0
00001C7D= 41 00                   1977  ASCII_A     DC.B    'A',0
00001C7F= 42 00                   1978  ASCII_B     DC.B    'B',0
00001C81= 43 00                   1979  ASCII_C     DC.B    'C',0
00001C83= 44 00                   1980  ASCII_D     DC.B    'D',0
00001C85= 45 00                   1981  ASCII_E     DC.B    'E',0
00001C87= 46 00                   1982  ASCII_F     DC.B    'F',0
00001C89                          1983  * ---> SPECIAL CHARACTERS
00001C89= 20 00                   1984  SPACE       DC.B    ' ',0
00001C8B= 24 00                   1985  DOLLAR      DC.B    '$',0
00001C8D= 23 00                   1986  IMD         DC.B    '#',0
00001C8F= 2C 00                   1987  COMMA       DC.B    ',',0
00001C91= 28 00                   1988  OBRACK      DC.B    '(',0
00001C93= 29 00                   1989  CBRACK      DC.B    ')',0
00001C95= 2B 00                   1990  PLUS        DC.B    '+',0
00001C97= 2D 00                   1991  MINUS       DC.B    '-',0
00001C99                          1992  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001C99= 2E 42 20 00             1993  __B         DC.B    '.B ',0
00001C9D= 2E 57 20 00             1994  __W         DC.B    '.W ',0
00001CA1= 2E 4C 20 00             1995  __L         DC.B    '.L ',0
00001CA5                          1996  * ---> ADDRESS REGISTERS A0-A7
00001CA5= 41 30 00                1997  __A0        DC.B   'A0',0
00001CA8= 41 31 00                1998  __A1        DC.B   'A1',0    
00001CAB= 41 32 00                1999  __A2        DC.B   'A2',0
00001CAE= 41 33 00                2000  __A3        DC.B   'A3',0
00001CB1= 41 34 00                2001  __A4        DC.B   'A4',0
00001CB4= 41 35 00                2002  __A5        DC.B   'A5',0
00001CB7= 41 36 00                2003  __A6        DC.B   'A6',0
00001CBA= 41 37 00                2004  __A7        DC.B   'A7',0
00001CBD                          2005  * ---> DATA REGISTERS D0-D7
00001CBD= 44 30 00                2006  __D0        DC.B   'D0',0
00001CC0= 44 31 00                2007  __D1        DC.B   'D1',0
00001CC3= 44 32 00                2008  __D2        DC.B   'D2',0
00001CC6= 44 33 00                2009  __D3        DC.B   'D3',0
00001CC9= 44 34 00                2010  __D4        DC.B   'D4',0
00001CCC= 44 35 00                2011  __D5        DC.B   'D5',0
00001CCF= 44 36 00                2012  __D6        DC.B   'D6',0
00001CD2= 44 37 00                2013  __D7        DC.B   'D7',0
00001CD5                          2014  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001CD5                          2015  *-----------------------------------------------------------------------------
00001CD5                          2016  
00001CD5                          2017  
00001CD5                          2018  
00001CD5                          2019  *-----------------------------------------------------------------------------
00001CD5                          2020  *-----------------------------------------------------------------------------
00001CD5                          2021  * SECTION: Sample program to run, then attempt testing disassembly on.
00001CD5                          2022  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2023      ORG $4000
00004000                          2024  
00004000  4E71                    2025      NOP
00004002  103C 009A               2026      MOVE.B   #%10011010, D0
00004006  123C 00A9               2027      MOVE.B   #%10101001, D1
0000400A  D200                    2028      ADD.B    D0,D1
0000400C  48A7 4000               2029      MOVEM    D1,-(A7)
00004010  43F8 1C25               2030      LEA      JSROP,A1
00004014  4467                    2031      NEG.W    -(A7)
00004016  4EB9 00004020           2032      JSR      END
0000401C  81FC 0001               2033      DIVS    #1, D0
00004020                          2034  
00004020                          2035  END
00004020  4E75                    2036      RTS
00004022                          2037  RLLYEND
00004022                          2038      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1C69
ASCII_1             1C6B
ASCII_2             1C6D
ASCII_3             1C6F
ASCII_4             1C71
ASCII_5             1C73
ASCII_6             1C75
ASCII_7             1C77
ASCII_8             1C79
ASCII_9             1C7B
ASCII_A             1C7D
ASCII_B             1C7F
ASCII_C             1C81
ASCII_D             1C83
ASCII_E             1C85
ASCII_F             1C87
BCC_END             1512
BCLROP              1C31
BITMASK             1BC6
BITMASKDONE         1BD6
CBRACK              1C93
CMPIBYTE            11D6
CMPIEA              124A
CMPILONG            1224
CMPIOP              1C3E
CMPIREG             1296
CMPIREG000          12BA
CMPIREG001          12BA
CMPIWORD            11FE
COMMA               1C8F
CR                  D
DATA                1C43
DIVSOP              1C0D
DOLLAR              1C8B
DONE                1454
EAHELPER05          15EA
EAHELPER611         15BA
END                 4020
END0000             12B4
END67               1986
ENDEAHELPER05       1742
ENDMODE_AN          18D2
ENDMODE_DN          17D2
ENDOP0001           1318
HEX_VALUE_MASK_LONG  F
IMD                 1C8D
INVALID_ASCII_INPUT  1BC0
ISCMPI              119C
ISORI               119C
ITERATION           1144
JSROP               1C25
LEAOP               1C2D
LF                  A
LOOP                103A
LOOPBIT             1BCA
LOOPUNKNOWNOP       1140
MINUS               1C97
MODE_AN             1848
MODE_DN             1748
MOVEMOP             1C1F
MOVEOP              1C1A
MSGEND              1BF4
MSGSTART            1BDC
NEGOP               1C16
NEWLINE             1C0A
NOOPERATION         1C12
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           196A
NOT67WORD           197A
NOTA0               186A
NOTA1               187A
NOTA2               188A
NOTA3               189A
NOTA4               18AA
NOTA5               18BA
NOTA6               18CA
NOTADRDIRECT        161C
NOTADRINDIRECT      1644
NOTADRINDIRECTPOST  1678
NOTADRINDIRECTPRE   16AC
NOTBCLR             117A
NOTD0               176A
NOTD1               177A
NOTD2               178A
NOTD3               179A
NOTD4               17AA
NOTD5               17BA
NOTD6               17CA
NOTDATAREG          160C
NOTDIVS             157A
NOTIMMBYTE          16F0
NOTIMMEDIATE        173E
NOTIMMWORD          171E
NOTJSR              140A
NOTMOVEM            13C8
NOTNEG              13A4
NOTNOP              134E
NOTRTS              142C
OBRACK              1C91
OP0000              1150
OP0001              12BA
OP0010              131E
OP0011              1324
OP0100              1332
OP0101              145E
OP0110              1464
OP0111              1518
OP1000              151E
OP1000END           158A
OP1001              1590
OP1010              1596
OP1011              159C
OP1100              15A2
OP1101              15A8
OP1110              15AE
OP1111              15B4
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              14B4
OP_BCC_MSG          1C4B
OP_BCS              14BE
OP_BCS_MSG          1C50
OP_BGE              14C8
OP_BGE_MSG          1C55
OP_BLT              14D2
OP_BLT_MSG          1C5A
OP_BRA              14E6
OP_BRANCHES_PRINT   14F0
OP_BRA_MSG          1C64
OP_BVC              14DC
OP_BVC_MSG          1C5F
ORIOP               1C3A
OROP                1C37
PLUS                1C95
PRINTA0             18D8
PRINTA1             18E6
PRINTA2             18F4
PRINTA3             1902
PRINTA4             1910
PRINTA5             191E
PRINTA6             192C
PRINTA7             193A
PRINTBYTE           19E4
PRINTD0             17D8
PRINTD1             17E6
PRINTD2             17F4
PRINTD3             1802
PRINTD4             1810
PRINTD5             181E
PRINTD6             182C
PRINTD7             183A
PRINTLONG           1A00
PRINTWORD           19F2
PRINT_ASCII_0       1B08
PRINT_ASCII_1       1B12
PRINT_ASCII_2       1B1C
PRINT_ASCII_3       1B26
PRINT_ASCII_4       1B30
PRINT_ASCII_5       1B3A
PRINT_ASCII_6       1B44
PRINT_ASCII_7       1B4E
PRINT_ASCII_8       1B58
PRINT_ASCII_9       1B62
PRINT_ASCII_A       1B6C
PRINT_ASCII_B       1B76
PRINT_ASCII_C       1B80
PRINT_ASCII_CHAR    1BA8
PRINT_ASCII_D       1B8A
PRINT_ASCII_E       1B94
PRINT_ASCII_F       1B9E
PRINT_ASCII_FINISH  1BC0
PRINT_ASCII_HEX_CHAR  1A38
PRINT_ASCII_LOOP    1A48
RLLYEND             4022
RTSOP               1C29
SIZE67              1948
SIZE68              198C
SPACE               1C89
START               1000
UNKNOWN             1450
UNKNOWNOP           1A0E
UNKNOWNOP0001       1314
__A0                1CA5
__A1                1CA8
__A2                1CAB
__A3                1CAE
__A4                1CB1
__A5                1CB4
__A6                1CB7
__A7                1CBA
__B                 1C99
__D0                1CBD
__D1                1CC0
__D2                1CC3
__D3                1CC6
__D4                1CC9
__D5                1CCC
__D6                1CCF
__D7                1CD2
__L                 1CA1
__W                 1C9D
