00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/5/2014 10:55:33 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001BE6             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001BFE             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001C14             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0B98                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 0260                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 02AE                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 02A4                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 02A2                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 03BE                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 03B4                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 0458                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 044E                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 04B6                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 04AC                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 04A2                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 0498                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 048E                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 0484                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 047A                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 08D6                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2ED6                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 C0C0                212          MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0A72                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162  0C46 0180                218          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0012                219          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           220          
0000116A  43F9 00001C3B            221          LEA     BCLROP,A1           * We found BCLR
00001170  103C 000E                222          MOVE.B  #14,D0              * Trap #14 prints out the data
00001174  4E4F                     223          TRAP    #15                 * Perform Trap #14
00001176  6000 013C                224          BRA     END0000              * Found the op, move to next iteration
0000117A                           225  
0000117A                           226  NOTBCLR * Possible options left are ORI or CMPI
0000117A  3C3C 0009                227          MOVE.W  #9, D6              * Prep lower value for bitmask
0000117E  3E3C 000B                228          MOVE.W  #11, D7             * Prep upper value for bitmask
00001182  6100 0A4C                229          BSR     BITMASK             * Finalize bitmask setup
00001186  CC42                     230          AND     D2,D6               * Apply bitmask
00001188                           231          
00001188  0C46 0000                232          CMPI    #%0000000000000000, D6  * Are we ORI?
0000118C  6700 000E                233          BEQ     ISORI                   * If ORI, branch to ISORI
00001190                           234          
00001190  0C46 0C00                235          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
00001194  6700 0006                236          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
00001198                           237          
00001198  6600 087E                238          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
0000119C                           239                                          * We don't deal too kindly with imposters.
0000119C                           240          
0000119C                           241  ISORI   * TODO
0000119C                           242          
0000119C                           243  
0000119C                           244  ISCMPI
0000119C  43F9 00001C48            245          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000011A2  103C 000E                246          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000011A6  4E4F                     247          TRAP    #15                 * Perform Trap #14
000011A8                           248          
000011A8                           249          * Determine the Size
000011A8  3C3C 0006                250          MOVE.W  #6, D6              * Prep lower value for bitmask
000011AC  3E3C 0007                251          MOVE.W  #7, D7              * Prep upper value for bitmask
000011B0  6100 0A1E                252          BSR     BITMASK             * Finalize bitmask setup
000011B4  CC42                     253          AND     D2,D6               * Apply bitmask
000011B6                           254          
000011B6  0C46 00C0                255          CMPI    #%0000000011000000, D6  * Imposter Op
000011BA  6700 085C                256          BEQ     UNKNOWNOP               * Deal with the imposter
000011BE                           257          
000011BE  0C46 0000                258          CMPI    #%0000000000000000, D6  * The size is a BYTE
000011C2  6700 0012                259          BEQ     CMPIBYTE                * Branch to CMPI.B
000011C6                           260          
000011C6  0C46 0040                261          CMPI    #%0000000001000000, D6  * The size is a WORD
000011CA  6700 0032                262          BEQ     CMPIWORD                * Branch to CMPI.W
000011CE                           263          
000011CE  0C46 0080                264          CMPI    #%0000000010000000, D6  * The size is a LONG
000011D2  6700 0050                265          BEQ     CMPILONG                * Branch to CMPI.L
000011D6                           266          
000011D6                           267  CMPIBYTE
000011D6  43F9 00001CA3            268          LEA     __B, A1     * Load .B
000011DC  103C 000E                269          MOVE.B  #14, D0     * Print out data
000011E0  4E4F                     270          TRAP    #15         * Perform Trap #14
000011E2                           271          
000011E2  43F9 00001C97            272          LEA     IMD, A1     * Load #
000011E8  103C 000E                273          MOVE.B  #14, D0     * Print out data
000011EC  4E4F                     274          TRAP    #15         * Perform Trap #14
000011EE                           275          
000011EE  361A                     276          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
000011F0  1203                     277          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
000011F2  3622                     278          MOVE.W  -(A2),D3    * Now go back
000011F4  103C 000E                279          MOVE.B  #14, D0     * Print out the data
000011F8  4E4F                     280          TRAP    #15         * Perform Trap #14 
000011FA                           281          
000011FA  6000 004E                282          BRA     CMPIEA      * Branch to determine Effective Address
000011FE                           283          
000011FE                           284  CMPIWORD
000011FE  43F9 00001CA7            285          LEA     __W, A1     * Load .W
00001204  103C 000E                286          MOVE.B  #14, D0     * Print out data
00001208  4E4F                     287          TRAP    #15         * Perform Trap #14
0000120A                           288          
0000120A  43F9 00001C97            289          LEA     IMD, A1     * Load #
00001210  103C 000E                290          MOVE.B  #14, D0     * Print out data
00001214  4E4F                     291          TRAP    #15         * Perform Trap #14
00001216                           292          
00001216  361A                     293          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001218  3222                     294          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
0000121A  103C 000E                295          MOVE.B  #14, D0     * Print out the data
0000121E  4E4F                     296          TRAP    #15         * Perform Trap #14
00001220                           297          
00001220                           298          
00001220  6000 0028                299          BRA     CMPIEA      * Branch to determine Effective Address
00001224                           300          
00001224                           301  CMPILONG
00001224  43F9 00001CAB            302          LEA     __L, A1     * Load .L
0000122A  103C 000E                303          MOVE.B  #14, D0     * Print out data
0000122E  4E4F                     304          TRAP    #15         * Perform Trap #14
00001230                           305          
00001230  43F9 00001C97            306          LEA     IMD, A1     * Load #
00001236  103C 000E                307          MOVE.B  #14, D0     * Print out data
0000123A  4E4F                     308          TRAP    #15         * Perform Trap #14
0000123C                           309          
0000123C  361A                     310          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000123E  2222                     311          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
00001240  103C 000E                312          MOVE.B  #14, D0     * Print out the data
00001244  4E4F                     313          TRAP    #15         * Perform Trap #14
00001246                           314          
00001246  6000 0002                315          BRA     CMPIEA      * Branch to determine Effective Address
0000124A                           316          
0000124A                           317  CMPIEA
0000124A                           318          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
0000124A  43F9 00001C99            319          LEA     COMMA, A1   * Load ,
00001250  103C 000E                320          MOVE.B  #14, D0     * Print out data
00001254  4E4F                     321          TRAP    #15         * Perform Trap #14
00001256                           322          
00001256  43F9 00001CAB            323          LEA     __L, A1     * Load .L
0000125C  103C 000E                324          MOVE.B  #14, D0     * Print out data
00001260  4E4F                     325          TRAP    #15         * Perform Trap #14
00001262                           326          
00001262                           327          * Determine the mode
00001262  3C3C 0003                328          MOVE.W  #3, D6              * Prep lower value for bitmask
00001266  3E3C 0005                329          MOVE.W  #5, D7              * Prep upper value for bitmask
0000126A  6100 0964                330          BSR     BITMASK             * Finalize bitmask setup
0000126E  CC42                     331          AND     D2,D6               * Apply bitmask
00001270                           332          
00001270  0C46 0008                333          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
00001274  6700 07A2                334          BEQ     UNKNOWNOP               * Imposter op
00001278                           335          
00001278  0C46 0028                336          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
0000127C  6700 079A                337          BEQ     UNKNOWNOP               * Imposter op
00001280                           338          
00001280  0C46 0030                339          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
00001284  6700 0792                340          BEQ     UNKNOWNOP               * Imposter op
00001288                           341  
00001288  0C46 0038                342          CMPI    #%0000000000111000, D6  * Is the Mode 111?
0000128C  6700 0008                343          BEQ     CMPIREG                 * Further investigation is needed
00001290                           344          
00001290                           345          * will need to call the EA helpers when they are complete
00001290                           346          
00001290                           347          * Mode is verified to be valid at this point
00001290                           348          *CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
00001290                           349          *BSR     MODE_DN
00001290                           350          
00001290                           351          *CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
00001290                           352          *BSR     MODE_AN
00001290                           353          
00001290                           354          *CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
00001290                           355          *BSR     MODE_IAN_POS
00001290                           356          
00001290                           357          *CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
00001290                           358          *BSR     MODE_IAN_PRE
00001290                           359          
00001290                           360          * Reached End of CMPI. Everything has been printed out
00001290  4C9F 0303                361          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001294  4E75                     362          RTS
00001296                           363          
00001296                           364  CMPIREG
00001296  3C3C 0000                365          MOVE.W  #0, D6              * Prep lower value for bitmask
0000129A  3E3C 0002                366          MOVE.W  #2, D7              * Prep upper value for bitmask
0000129E  6100 0930                367          BSR     BITMASK             * Finalize bitmask setup
000012A2  CC42                     368          AND     D2,D6               * Apply bitmask
000012A4                           369          
000012A4  0C46 0000                370          CMPI    #%0000000000000000, D6  * Is the Register 000?
000012A8  6700 0010                371          BEQ     CMPIREG000
000012AC                           372          
000012AC  0C46 0001                373          CMPI    #%0000000000000001, D6  * Is the Register 001?
000012B0  6700 0008                374          BEQ     CMPIREG001
000012B4                           375          
000012B4                           376  END0000          
000012B4  4C9F 0303                377         MOVEM   (A7)+,D0-D1/A0-A1   * Push values to the stack to save
000012B8  4E75                     378         RTS
000012BA                           379         
000012BA                           380  CMPIREG000  * TODO (xxx).W for CMPI
000012BA                           381  
000012BA                           382  CMPIREG001  * TODO (xxx).L for CMPI
000012BA                           383  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012BA                           384  *-----------------------------------------------------------------------------
000012BA                           385  
000012BA                           386  
000012BA                           387  
000012BA                           388  *-----------------------------------------------------------------------------
000012BA                           389  *-----------------------------------------------------------------------------
000012BA                           390  * NAME: OP_0001   (MOVE.B)
000012BA                           391  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012BA                           392  * PRE-CONDITION:  xyz
000012BA                           393  * POST-CONDITION: All registers return to their previous state, and the output
000012BA                           394  *                 goes to the output console for reading the raw data or the
000012BA                           395  *                 actual instruction.
000012BA                           396  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012BA                           397  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012BA                           398  OP0001  
000012BA  48A7 FFC0                399          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
000012BE  3C3C 0006                400          MOVE.W  #6, D6              * Prep lower value for bitmask
000012C2  3E3C 0008                401          MOVE.W  #8, D7              * Prep upper value for bitmask
000012C6  6100 0908                402          BSR     BITMASK             * Finalize bitmask setup
000012CA  CC42                     403          AND     D2,D6               * Apply bitmask
000012CC                           404          
000012CC                           405          * I may have fucked off this part, sorry - Caleb
000012CC                           406          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
000012CC                           407          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
000012CC                           408          
000012CC  43F9 00001C24            409          LEA     MOVEOP,A1   * Put 'MOVE' into the window
000012D2  103C 000E                410          MOVE.B  #14,D0      * Trap #14 to print out
000012D6  4E4F                     411          TRAP    #15         * Perform Trap #14
000012D8                           412          
000012D8  3C3C 000C                413          MOVE.W  #12, D6              * Prep lower value for bitmask
000012DC  3E3C 000D                414          MOVE.W  #13, D7              * Prep upper value for bitmask
000012E0  6100 08EE                415          BSR     BITMASK             * Finalize bitmask setup
000012E4                           416          
000012E4  6100 066C                417          BSR     SIZE67
000012E8  6100 02D0                418          BSR     EAHELPER611
000012EC                           419          
000012EC  43F9 00001C99            420          LEA     COMMA,A1
000012F2  103C 000E                421          MOVE.B  #14,D0
000012F6  4E4F                     422          TRAP    #15
000012F8                           423          
000012F8  4245                     424          CLR     D5
000012FA                           425          
000012FA  6100 038C                426          BSR     EAHELPER05
000012FE                           427          
000012FE  43F9 00001C14            428          LEA     NEWLINE,A1
00001304  103C 000E                429          MOVE.B  #14,D0
00001308  4E4F                     430          TRAP    #15
0000130A                           431          
0000130A  6000 0006                432          BRA     ENDOP0001
0000130E                           433          *LEA     __B,A1      * Put '.B' into the window
0000130E                           434          *MOVE.B  #14,D0      * Trap #14 to print out
0000130E                           435          *TRAP    #15         * Perform Trap #14
0000130E                           436          
0000130E                           437  UNKNOWNOP0001
0000130E                           438  
0000130E  6100 0708                439          BSR     UNKNOWNOP
00001312                           440          
00001312                           441  ENDOP0001
00001312                           442  
00001312  4C9F 03FF                443          MOVEM (A7)+,D0-D7/A0-A1
00001316  4E75                     444          RTS        
00001318                           445          
00001318                           446          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
00001318                           447  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001318                           448  *-----------------------------------------------------------------------------
00001318                           449  
00001318                           450  
00001318                           451  
00001318                           452  *-----------------------------------------------------------------------------
00001318                           453  *-----------------------------------------------------------------------------
00001318                           454  * NAME: OP_0010   (MOVE.L, MOVEA.L)
00001318                           455  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001318                           456  * PRE-CONDITION:  xyz
00001318                           457  * POST-CONDITION: All registers return to their previous state, and the output
00001318                           458  *                 goes to the output console for reading the raw data or the
00001318                           459  *                 actual instruction.
00001318                           460  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001318                           461  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001318                           462  OP0010
00001318                           463  
00001318  6100 06FE                464      BSR     UNKNOWNOP
0000131C  4E75                     465      RTS
0000131E                           466  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000131E                           467  *-----------------------------------------------------------------------------
0000131E                           468  
0000131E                           469  
0000131E                           470  
0000131E                           471  *-----------------------------------------------------------------------------
0000131E                           472  *-----------------------------------------------------------------------------
0000131E                           473  * NAME: OP_0011   (MOVE.W, MOVEA.W)
0000131E                           474  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000131E                           475  * PRE-CONDITION:  xyz
0000131E                           476  * POST-CONDITION: All registers return to their previous state, and the output
0000131E                           477  *                 goes to the output console for reading the raw data or the
0000131E                           478  *                 actual instruction.
0000131E                           479  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000131E                           480  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000131E                           481  OP0011
0000131E  48A7 FFFE                482      MOVEM   D0-D7/A0-A6, -(A7)
00001322                           483      
00001322                           484      *MOVE.W  #6,D6
00001322                           485      *MOVE.W  #8,D7
00001322                           486      
00001322                           487      *BSR     BITMASK
00001322                           488      
00001322                           489      *AND.W   D2,D6
00001322                           490      
00001322                           491      *CMP     #%0000000001000000,D6
00001322                           492      *BNE     NEXT15
00001322                           493      *BSR     * for MOVEA.W
00001322                           494      
00001322  4C9F 7FFF                495      MOVEM   (A7)+,D0-D7/A0-A6
00001326                           496      
00001326  6100 06F0                497      BSR     UNKNOWNOP
0000132A  4E75                     498      RTS
0000132C                           499  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000132C                           500  *-----------------------------------------------------------------------------
0000132C                           501  
0000132C                           502  
0000132C                           503  
0000132C                           504  *-----------------------------------------------------------------------------
0000132C                           505  *-----------------------------------------------------------------------------
0000132C                           506  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
0000132C                           507  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000132C                           508  * PRE-CONDITION:  xyz
0000132C                           509  * POST-CONDITION: All registers return to their previous state, and the output
0000132C                           510  *                 goes to the output console for reading the raw data or the
0000132C                           511  *                 actual instruction.
0000132C                           512  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000132C                           513  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000132C                           514  OP0100  
0000132C                           515          * TODO: lea, movem
0000132C                           516  
0000132C  48A7 C0C0                517          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001330                           518          
00001330                           519          *NOP
00001330  0C42 4E71                520          CMPI    #%0100111001110001,D2
00001334  6600 0012                521          BNE     NOTNOP
00001338                           522          
00001338  43F9 00001C1C            523          LEA     NOOPERATION,A1
0000133E  103C 000D                524          MOVE.B  #13,D0          * Print a newline
00001342  4E4F                     525          TRAP    #15
00001344                           526          
00001344  6000 0108                527          BRA     DONE *we found it, move on to the next iteration
00001348                           528  NOTNOP *NEG
00001348                           529          
00001348                           530          * prep values for BITMASK subroutine
00001348  7C08                     531          MOVE.L  #8,D6
0000134A  7E0B                     532          MOVE.L  #11,D7
0000134C                           533          
0000134C  6100 0882                534          BSR     BITMASK
00001350                           535          
00001350  CC42                     536          AND     D2,D6                   * apply bitmask
00001352                           537          
00001352  0C46 0400                538          CMPI    #%0000010000000000,D6   * are we NEG?
00001356  6600 0046                539          BNE     NOTNEG                  * not neg
0000135A                           540          
0000135A  7C03                     541          MOVE.L  #3,D6
0000135C  7E05                     542          MOVE.L  #5,D7
0000135E                           543          
0000135E  6100 0870                544          BSR     BITMASK * generate a bitmask to be used to check mode
00001362                           545          
00001362  0C46 0008                546          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
00001366  6700 00E2                547          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000136A                           548          
0000136A  0C46 0028                549          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
0000136E  6700 00DA                550          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001372                           551          
00001372  0C46 0030                552          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
00001376  6700 00D2                553          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000137A                           554        
0000137A                           555          * it is NEG, print
0000137A  43F9 00001C20            556          LEA     NEGOP,A1
00001380  103C 000E                557          MOVE.B  #14,D0
00001384  4E4F                     558          TRAP    #15
00001386                           559          
00001386  6100 05CA                560          BSR     SIZE67
0000138A                           561          
0000138A  6100 02FC                562          BSR     EAHELPER05
0000138E                           563          
0000138E  43F9 00001C14            564          LEA     NEWLINE,A1
00001394  103C 000E                565          MOVE.B  #14,D0
00001398  4E4F                     566          TRAP    #15
0000139A                           567          
0000139A  6000 00B2                568          BRA     DONE * we found the op, move to next iteration
0000139E                           569          
0000139E                           570  NOTNEG *MOVEM
0000139E                           571  
0000139E                           572          * prep values for BITMASK subroutine
0000139E  7C07                     573          MOVE.L  #7,D6
000013A0  7E09                     574          MOVE.L  #9,D7
000013A2                           575          
000013A2  6100 082C                576          BSR     BITMASK
000013A6                           577          
000013A6  CC42                     578          AND     D2,D6   * apply bitmask
000013A8                           579          
000013A8  0C46 0080                580          CMPI    #%0000000010000000,D6 * is it MOVEM?
000013AC  6600 0014                581          BNE     NOTMOVEM          * it is not MOVEM
000013B0                           582          
000013B0                           583          * make sure it is a valid size and mode for MOVEM
000013B0                           584          
000013B0                           585          * it is MOVEM
000013B0  43F9 00001C29            586          LEA     MOVEMOP,A1
000013B6  103C 000D                587          MOVE.B  #13,D0          * Print a newline
000013BA  4E4F                     588          TRAP    #15
000013BC                           589          
000013BC                           590          * probably needs its own special code for printing the rest due to uniqueness of movem
000013BC                           591          
000013BC  341A                     592          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013BE                           593          
000013BE  6000 008E                594          BRA     DONE          * we found and printed, move on to the next iteration
000013C2                           595          
000013C2                           596  NOTMOVEM *JSR
000013C2                           597          * prep values for BITMASK subroutine
000013C2  7C06                     598          MOVE.L  #6,D6
000013C4  7E08                     599          MOVE.L  #8,D7
000013C6                           600          
000013C6  6100 0808                601          BSR     BITMASK
000013CA                           602          
000013CA  CC42                     603          AND     D2,D6   * apply bitmask
000013CC                           604          
000013CC  0C46 0080                605          CMPI    #%0000000010000000,D6
000013D0  6600 0032                606          BNE     NOTJSR          * it's not JSR
000013D4                           607          
000013D4  43F9 00001C2F            608          LEA     JSROP,A1
000013DA  103C 000E                609          MOVE.B  #14,D0          * Print a newline and JSR
000013DE  4E4F                     610          TRAP    #15
000013E0                           611          
000013E0                           612          * print out where we are jumping to
000013E0                           613          
000013E0  341A                     614          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013E2                           615          
000013E2  2202                     616          MOVE.L  D2,D1   * save the opcode to print
000013E4                           617          
000013E4  7410                     618          MOVE.L  #16,D2  * set the base to 16
000013E6                           619          
000013E6  700F                     620          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000013E8  4E4F                     621          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000013EA                           622          
000013EA  341A                     623          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013EC                           624          
000013EC  2202                     625          MOVE.L  D2,D1   * save the opcode to print
000013EE                           626          
000013EE  7410                     627          MOVE.L  #16,D2  * set the base to 16
000013F0                           628          
000013F0  700F                     629          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000013F2  4E4F                     630          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000013F4                           631          
000013F4  43F9 00001C14            632          LEA     NEWLINE,A1
000013FA  103C 000E                633          MOVE.B  #14,D0          * Print a newline
000013FE  4E4F                     634          TRAP    #15
00001400                           635          
00001400  6000 004C                636          BRA     DONE          * we already found instruction, next iteration
00001404                           637  NOTJSR *RTS
00001404                           638  
00001404                           639          * prep values for BITMASK subroutine
00001404  7C06                     640          MOVE.L  #6,D6
00001406  7E08                     641          MOVE.L  #8,D7
00001408                           642          
00001408  6100 07C6                643          BSR     BITMASK
0000140C                           644          
0000140C  CC42                     645          AND     D2,D6   * apply bitmask
0000140E                           646          
0000140E  0C46 0040                647          CMPI    #%0000000001000000,D6
00001412  6600 0012                648          BNE     NOTRTS          * it's not RTS
00001416                           649          
00001416  43F9 00001C33            650          LEA     RTSOP,A1
0000141C  103C 000D                651          MOVE.B  #13,D0          * Print a newline and RTS
00001420  4E4F                     652          TRAP    #15
00001422                           653          
00001422  6000 002A                654          BRA     DONE          * we already found instruction, next iteration
00001426                           655  NOTRTS  *LEA
00001426                           656         
00001426                           657          * prep values for BITMASK subroutine
00001426  7C06                     658          MOVE.L  #6,D6
00001428  7E08                     659          MOVE.L  #8,D7
0000142A                           660          
0000142A  6100 07A4                661          BSR     BITMASK
0000142E                           662          
0000142E  CC42                     663          AND     D2,D6   * apply bitmask
00001430                           664          
00001430  0C46 01C0                665          CMPI    #%0000000111000000,D6
00001434  6600 0014                666          BNE     UNKNOWN          * it's not LEA, we dont know what it is
00001438                           667          
00001438                           668          * check to make sure it is a supported mode and size
00001438                           669          
00001438  43F9 00001C37            670          LEA     LEAOP,A1
0000143E  103C 000D                671          MOVE.B  #13,D0          * Print LEA
00001442  4E4F                     672          TRAP    #15
00001444                           673          
00001444                           674          * call EA helper
00001444  341A                     675          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001446                           676                  
00001446  6000 0006                677          BRA     DONE          * we already found instruction, next iteration
0000144A                           678          
0000144A                           679  UNKNOWN *dont know what it is
0000144A  6100 05CC                680          BSR     UNKNOWNOP
0000144E                           681          
0000144E                           682  DONE
0000144E  4C9F 0303                683          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001452  4E75                     684          RTS
00001454                           685          
00001454  6000 FCEE                686          BRA     ITERATION
00001458                           687  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001458                           688  *-----------------------------------------------------------------------------        
00001458                           689          
00001458                           690          
00001458                           691  
00001458                           692  *-----------------------------------------------------------------------------
00001458                           693  *-----------------------------------------------------------------------------
00001458                           694  * NAME: OP_0101   (SUBQ)
00001458                           695  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001458                           696  * PRE-CONDITION:  xyz
00001458                           697  * POST-CONDITION: All registers return to their previous state, and the output
00001458                           698  *                 goes to the output console for reading the raw data or the
00001458                           699  *                 actual instruction.
00001458                           700  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001458                           701  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001458                           702  OP0101
00001458                           703  
00001458  6100 05BE                704      BSR     UNKNOWNOP
0000145C  4E75                     705      RTS
0000145E                           706  
0000145E                           707  * testing branching
0000145E                           708  * op op op
0000145E                           709  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000145E                           710  *-----------------------------------------------------------------------------
0000145E                           711  
0000145E                           712  
0000145E                           713  
0000145E                           714  *-----------------------------------------------------------------------------
0000145E                           715  *-----------------------------------------------------------------------------
0000145E                           716  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
0000145E                           717  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000145E                           718  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
0000145E                           719  *                 in the instruction and determines what the bits match to a
0000145E                           720  *                 given condition code. If the 8 bit offset is $00, or $FF,
0000145E                           721  *                 this signifies a word or long offset (for $00 and $FF
0000145E                           722  *                 respectively). The 8 bit offset is in 2's comp. form, and
0000145E                           723  *                 should be un-done, then plus or minus to the current
0000145E                           724  *                 program counter (PC) to get the actual memory label to
0000145E                           725  *                 output to console. The word offset signal eats an
0000145E                           726  *                 additional 16 bits and the long offset eats an additional
0000145E                           727  *                 32 bits. The word/long offset are for memory alignment.
0000145E                           728  * POST-CONDITION: All registers return to their previous state, and the output
0000145E                           729  *                 goes to the output console for reading the raw data or the
0000145E                           730  *                 actual instruction.
0000145E                           731  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000145E                           732  *                 A1 (output)
0000145E                           733  * CONDITIONS TABLE:
0000145E                           734  *                Condition Names  - Mnemonic - Condition Code
0000145E                           735  *                --------------------------------------------
0000145E                           736  *                True             -    T     - 0000
0000145E                           737  *                False            -    F     - 0001
0000145E                           738  *                Higher           -    HI    - 0010
0000145E                           739  *                Lower or Same    -    LS    - 0011
0000145E                           740  *                Carry Clear      -    CC    - 0100
0000145E                           741  *                Carry Set        -    CS    - 0101
0000145E                           742  *                Not Equal        -    NE    - 0110
0000145E                           743  *                Equal            -    EQ    - 0111
0000145E                           744  *                Overflow Clear   -    VC    - 1000
0000145E                           745  *                Overflow Set     -    VS    - 1001
0000145E                           746  *                Plus             -    PL    - 1010
0000145E                           747  *                Minus            -    MI    - 1011
0000145E                           748  *                Greater or Equal -    GE    - 1100
0000145E                           749  *                Less Than        -    LT    - 1101
0000145E                           750  *                Greater Than     -    GT    - 1110
0000145E                           751  *                Less or Equal    -    LE    - 1111
0000145E                           752  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000145E                           753  OP0110
0000145E  48A7 C0C0                754          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
00001462                           755          
00001462                           756          * Ready four bits to help distinguish op's with the 0110 prefix
00001462  3C3C 0000                757          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
00001466                           758                                        * BITMASK sub-routine call)
00001466  3E3C 0007                759          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
0000146A                           760                                        * BITMASK sub-routine call)
0000146A                           761                                        
0000146A                           762          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
0000146A  6100 0764                763          BSR     BITMASK               * Call BITMASK sub-routine
0000146E                           764                                        * Returns a bitmask in D6
0000146E                           765          
0000146E  CC42                     766          AND     D2,D6                 * And the index op, which was pre-loaded
00001470                           767                                        * in the main memory loop with the bitmask
00001470                           768                                        * to use to determine what case we need.
00001470                           769          
00001470                           770          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
00001470                           771          * $00 == word offset, $FF == long offset
00001470                           772       ***CMPI    #%0000000000000000,D6
00001470                           773       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
00001470                           774       ***
00001470                           775       ***CMPI    #%0000000011111111,D6
00001470                           776       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
00001470                           777          
00001470                           778          * IF PASSED BOTH CMPI CHECKS (ABOVE),
00001470                           779          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
00001470                           780          
00001470  3C3C 0009                781          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
00001474  3E3C 000B                782          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
00001478                           783                                        
00001478                           784          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001478  6100 0756                785          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
0000147C  CC42                     786          AND     D2,D6   * apply the BITMASK
0000147E                           787          
0000147E                           788          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
0000147E  0C46 0400                789          CMPI    #%0000010000000000,D6
00001482  6700 002A                790          BEQ     OP_BCC
00001486                           791          
00001486                           792          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
00001486  0C46 0500                793          CMPI    #%0000010100000000,D6
0000148A  6700 002C                794          BEQ     OP_BCS
0000148E                           795          
0000148E                           796          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
0000148E  0C46 0C00                797          CMPI    #%0000110000000000,D6
00001492  6700 002E                798          BEQ     OP_BGE
00001496                           799          
00001496                           800          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
00001496  0C46 0D00                801          CMPI    #%0000110100000000,D6
0000149A  6700 0030                802          BEQ     OP_BLT
0000149E                           803          
0000149E                           804          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
0000149E  0C46 0800                805          CMPI    #%0000100000000000,D6
000014A2  6700 0032                806          BEQ     OP_BVC
000014A6                           807          
000014A6                           808          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
000014A6                           809          * NOTE: A branch to the immediately following instruction automatically
000014A6                           810          *       uses the 16-bit displacement format because the 8-bit displacement
000014A6                           811          *       field contains $00 zero offset
000014A6                           812          * http://68k.hax.com/BRA
000014A6                           813          * NOTE2 ---> Does this mean, there should be no checks when debugging
000014A6                           814          *            for word/long offsets?
000014A6  0C46 0000                815          CMPI    #%0000000000000000,D6
000014AA  6700 0034                816          BEQ     OP_BRA
000014AE                           817          
000014AE                           818          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
000014AE                           819          ; call raw data print out sub routine
000014AE                           820  
000014AE                           821  OP_BCC
000014AE  43F9 00001C55            822          LEA     OP_BCC_MSG,A1
000014B4  6000 0034                823          BRA     OP_BRANCHES_PRINT
000014B8                           824  OP_BCS
000014B8  43F9 00001C5A            825          LEA     OP_BCS_MSG,A1
000014BE  6000 002A                826          BRA     OP_BRANCHES_PRINT
000014C2                           827  OP_BGE
000014C2  43F9 00001C5F            828          LEA     OP_BGE_MSG,A1
000014C8  6000 0020                829          BRA     OP_BRANCHES_PRINT
000014CC                           830  OP_BLT
000014CC  43F9 00001C64            831          LEA     OP_BLT_MSG,A1
000014D2  6000 0016                832          BRA     OP_BRANCHES_PRINT
000014D6                           833  OP_BVC
000014D6  43F9 00001C69            834          LEA     OP_BVC_MSG,A1
000014DC  6000 000C                835          BRA     OP_BRANCHES_PRINT
000014E0                           836  OP_BRA
000014E0  43F9 00001C6E            837          LEA     OP_BRA_MSG,A1
000014E6  6000 0002                838          BRA     OP_BRANCHES_PRINT
000014EA                           839  
000014EA                           840  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000014EA                           841          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000014EA                           842          * assemble output to console
000014EA                           843  OP_BRANCHES_PRINT
000014EA  103C 000E                844          MOVE.B  #14,D0 * print instruction op
000014EE  4E4F                     845          TRAP    #15
000014F0                           846          
000014F0  43F9 00001C4D            847          LEA     DATA,A1
000014F6  103C 000E                848          MOVE.B  #14,D0 * print raw data hex of the LABEL
000014FA  4E4F                     849          TRAP    #15
000014FC                           850          
000014FC  1A1A                     851          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
000014FE  2845                     852          MOVE.L  D5,A4 * ready the 8bits into a4
00001500  43D4                     853          LEA     (A4),A1 * ready the a4 into a1 for print
00001502  103C 000E                854          MOVE.B  #14,D0 * print the 8bit addr
00001506  4E4F                     855          TRAP    #15
00001508                           856  
00001508  6000 0002                857          BRA     BCC_END
0000150C                           858  
0000150C                           859  BCC_END * reload the memory, call RTS
0000150C  4C9F 0303                860          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001510  4E75                     861          RTS
00001512                           862  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001512                           863  *-----------------------------------------------------------------------------
00001512                           864  
00001512                           865  
00001512                           866  
00001512                           867  *-----------------------------------------------------------------------------
00001512                           868  *-----------------------------------------------------------------------------
00001512                           869  * NAME: OP_0111   ()
00001512                           870  * DESCRIPTION:    OP code 0111 is not supported. 
00001512                           871  * PRE-CONDITION:  
00001512                           872  * POST-CONDITION: 
00001512                           873  * REGISTERS:
00001512                           874  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001512                           875  OP0111
00001512  6100 0504                876      BSR     UNKNOWNOP
00001516  4E75                     877      RTS
00001518                           878  
00001518                           879  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001518                           880  *-----------------------------------------------------------------------------
00001518                           881  
00001518                           882  
00001518                           883  
00001518                           884  *-----------------------------------------------------------------------------
00001518                           885  *-----------------------------------------------------------------------------
00001518                           886  * NAME: OP_1000   (DIVS, OR)
00001518                           887  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001518                           888  * PRE-CONDITION:  xyz
00001518                           889  * POST-CONDITION: All registers return to their previous state, and the output
00001518                           890  *                 goes to the output console for reading the raw data or the
00001518                           891  *                 actual instruction.
00001518                           892  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001518                           893  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001518                           894  OP1000
00001518                           895          * Saving values to the stack
00001518  48A7 FFC0                896          MOVEM   D0-D7/A0-A1,-(A7)
0000151C                           897  
0000151C                           898          * Check if the EA Mode is 001 since both DIVS and OR do not support it
0000151C  3C3C 0003                899          MOVE.W  #3, D6              * Prep lower value for bitmask
00001520  3E3C 0005                900          MOVE.W  #5, D7              * Prep upper value for bitmask
00001524  6100 06AA                901          BSR     BITMASK             * Finalize bitmask setup
00001528  CC42                     902          AND     D2,D6               * Apply bitmask
0000152A                           903          
0000152A  0C46 0008                904          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
0000152E  6700 FF1A                905          BEQ     UNKNOWN                 * If so, the op is not supported
00001532                           906          
00001532                           907          * Checking for DIVS
00001532  3C3C 0006                908          MOVE.W  #6, D6              * Prep lower value for bitmask
00001536  3E3C 0008                909          MOVE.W  #8, D7              * Prep upper value for bitmask
0000153A  6100 0694                910          BSR     BITMASK             * Finalize bitmask setup
0000153E  CC42                     911          AND     D2,D6               * Apply bitmask
00001540                           912          
00001540  0C46 01C0                913          CMPI    #%0000000111000000, D6  * Are we DIVS?
00001544  6600 0034                914          BNE     NOTDIVS                 * If not, branch to see if it's OR
00001548                           915          
00001548  43F9 00001C17            916          LEA     DIVSOP,A1           * We found DIVS
0000154E  103C 000E                917          MOVE.B  #14,D0              * Trap #14 prints out the data
00001552  4E4F                     918          TRAP    #15                 * Perform Trap #14
00001554                           919          
00001554  6100 0132                920          BSR     EAHELPER05         * Print out data. TODO: DOESN'T WORK
00001558                           921          
00001558  43F9 00001C99            922          LEA     COMMA,A1            * We found DIVS
0000155E  103C 000E                923          MOVE.B  #14,D0              * Trap #14 prints out the data
00001562  4E4F                     924          TRAP    #15                 * Perform Trap #14
00001564                           925          
00001564                           926          * ================================================================
00001564                           927          * the following logic is to move the size bits into the 0-1 positions 
00001564                           928          * of D5 so that eahelper611 can process immediates.
00001564                           929          
00001564  4245                     930          CLR     D5
00001566  08C5 0000                931          BSET    #0,D5
0000156A                           932          
0000156A                           933          * end size bit manip into D5 logic
0000156A                           934          *=================================================================
0000156A                           935          
0000156A  6100 004E                936          BSR     EAHELPER611         * Print out data. TODO: DOESN'T WORK
0000156E                           937          
0000156E                           938  
0000156E                           939          
0000156E  43F9 00001C14            940          LEA     NEWLINE,A1          * We found DIVS
00001574  103C 000E                941          MOVE.B  #14,D0              * Trap #14 prints out the data
00001578  4E4F                     942          TRAP    #15                 * Perform Trap #14
0000157A                           943          
0000157A                           944  NOTDIVS * It is confirmed OR at this point
0000157A  43F9 00001C41            945          LEA     OROP,A1         * We found OR
00001580  103C 000E                946          MOVE.B  #14,D0          * Trap #14 prints out the data
00001584  4E4F                     947          TRAP    #15             * Perform Trap #14
00001586                           948          *================================================================
00001586                           949          * todo, move the size of the operation into the leading bits of D5
00001586                           950          * before subroutine call
00001586  6100 0032                951          BSR     EAHELPER611
0000158A                           952  
0000158A                           953  OP1000END
0000158A  48A7 FFC0                954          MOVEM   D0-D7/A0-A1,-(A7)
0000158E  4E75                     955          RTS
00001590                           956  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001590                           957  *-----------------------------------------------------------------------------
00001590                           958  
00001590                           959  
00001590                           960  
00001590                           961  *-----------------------------------------------------------------------------
00001590                           962  *-----------------------------------------------------------------------------
00001590                           963  * NAME: OP_1001   (SUB)
00001590                           964  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001590                           965  * PRE-CONDITION:  xyz
00001590                           966  * POST-CONDITION: All registers return to their previous state, and the output
00001590                           967  *                 goes to the output console for reading the raw data or the
00001590                           968  *                 actual instruction.
00001590                           969  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001590                           970  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001590                           971  OP1001
00001590                           972  
00001590  6100 0486                973      BSR     UNKNOWNOP
00001594  4E75                     974      RTS
00001596                           975  
00001596                           976  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001596                           977  *-----------------------------------------------------------------------------
00001596                           978  
00001596                           979  
00001596                           980  
00001596                           981  *-----------------------------------------------------------------------------
00001596                           982  *-----------------------------------------------------------------------------
00001596                           983  * NAME: OP_1010   ()
00001596                           984  * DESCRIPTION:    a
00001596                           985  * PRE-CONDITION:  b
00001596                           986  * POST-CONDITION: c
00001596                           987  * REGISTERS:      d
00001596                           988  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001596                           989  OP1010
00001596                           990  
00001596  6100 0480                991      BSR     UNKNOWNOP
0000159A  4E75                     992      RTS
0000159C                           993  
0000159C                           994  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000159C                           995  *-----------------------------------------------------------------------------
0000159C                           996  
0000159C                           997  
0000159C                           998  
0000159C                           999  *-----------------------------------------------------------------------------
0000159C                          1000  *-----------------------------------------------------------------------------
0000159C                          1001  * NAME: OP_1011   (EOR, CMP)
0000159C                          1002  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000159C                          1003  * PRE-CONDITION:  xyz
0000159C                          1004  * POST-CONDITION: All registers return to their previous state, and the output
0000159C                          1005  *                 goes to the output console for reading the raw data or the
0000159C                          1006  *                 actual instruction.
0000159C                          1007  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000159C                          1008  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000159C                          1009  OP1011
0000159C                          1010  
0000159C  6100 047A               1011      BSR     UNKNOWNOP
000015A0  4E75                    1012      RTS
000015A2                          1013  
000015A2                          1014  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015A2                          1015  *-----------------------------------------------------------------------------
000015A2                          1016  
000015A2                          1017  
000015A2                          1018  
000015A2                          1019  *-----------------------------------------------------------------------------
000015A2                          1020  *-----------------------------------------------------------------------------
000015A2                          1021  * NAME: OP_1100   (MULS)
000015A2                          1022  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015A2                          1023  * PRE-CONDITION:  xyz
000015A2                          1024  * POST-CONDITION: All registers return to their previous state, and the output
000015A2                          1025  *                 goes to the output console for reading the raw data or the
000015A2                          1026  *                 actual instruction.
000015A2                          1027  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015A2                          1028  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015A2                          1029  OP1100
000015A2                          1030  
000015A2  6100 0474               1031      BSR     UNKNOWNOP
000015A6  4E75                    1032      RTS
000015A8                          1033  
000015A8                          1034  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015A8                          1035  *-----------------------------------------------------------------------------
000015A8                          1036  
000015A8                          1037  
000015A8                          1038  
000015A8                          1039  *-----------------------------------------------------------------------------
000015A8                          1040  *-----------------------------------------------------------------------------
000015A8                          1041  * NAME: OP_1101   (ADD, ADDA)
000015A8                          1042  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015A8                          1043  * PRE-CONDITION:  xyz
000015A8                          1044  * POST-CONDITION: All registers return to their previous state, and the output
000015A8                          1045  *                 goes to the output console for reading the raw data or the
000015A8                          1046  *                 actual instruction.
000015A8                          1047  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015A8                          1048  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015A8                          1049  OP1101
000015A8                          1050  
000015A8  6100 046E               1051      BSR     UNKNOWNOP
000015AC  4E75                    1052      RTS
000015AE                          1053  
000015AE                          1054  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015AE                          1055  *-----------------------------------------------------------------------------
000015AE                          1056  
000015AE                          1057  
000015AE                          1058  
000015AE                          1059  *-----------------------------------------------------------------------------
000015AE                          1060  *-----------------------------------------------------------------------------
000015AE                          1061  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
000015AE                          1062  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015AE                          1063  * PRE-CONDITION:  xyz
000015AE                          1064  * POST-CONDITION: All registers return to their previous state, and the output
000015AE                          1065  *                 goes to the output console for reading the raw data or the
000015AE                          1066  *                 actual instruction.
000015AE                          1067  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015AE                          1068  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015AE                          1069  OP1110
000015AE                          1070  
000015AE  6100 0468               1071      BSR     UNKNOWNOP
000015B2  4E75                    1072      RTS
000015B4                          1073  
000015B4                          1074  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015B4                          1075  *-----------------------------------------------------------------------------
000015B4                          1076  
000015B4                          1077  
000015B4                          1078  
000015B4                          1079  *-----------------------------------------------------------------------------
000015B4                          1080  *-----------------------------------------------------------------------------
000015B4                          1081  * NAME: OP_1111   ()
000015B4                          1082  * DESCRIPTION:    a
000015B4                          1083  * PRE-CONDITION:  b
000015B4                          1084  * POST-CONDITION: c
000015B4                          1085  * REGISTERS:      d
000015B4                          1086  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015B4                          1087  OP1111
000015B4                          1088  
000015B4  6100 0462               1089      BSR     UNKNOWNOP
000015B8  4E75                    1090      RTS
000015BA                          1091  
000015BA                          1092  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015BA                          1093  *-----------------------------------------------------------------------------
000015BA                          1094  
000015BA                          1095  
000015BA                          1096  
000015BA                          1097  *-----------------------------------------------------------------------------
000015BA                          1098  *-----------------------------------------------------------------------------
000015BA                          1099  * NAME:           EAHELPER611
000015BA                          1100  * DESCRIPTION:    a
000015BA                          1101  * PRE-CONDITION:  D2 contains the instruction to print modes for.
000015BA                          1102  *                 D5 contains the size of the data to be printed
000015BA                          1103  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
000015BA                          1104  *                 EAHELPER05 to print.
000015BA                          1105  * REGISTERS:      a
000015BA                          1106  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015BA                          1107  EAHELPER611
000015BA  48A7 FFC0               1108      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
000015BE                          1109      
000015BE  3C3C 0006               1110      MOVE.W  #6, D6              * Prep lower value for bitmask
000015C2  3E3C 0008               1111      MOVE.W  #8, D7              * Prep upper value for bitmask
000015C6  6100 0608               1112      BSR     BITMASK             * Finalize bitmask setup
000015CA  CC42                    1113      AND     D2,D6               * Apply bitmask
000015CC                          1114      
000015CC  0C46 01C0               1115      CMPI    #%0000000111000000,D6 * is it immediate?
000015D0  6600 0086               1116      BNE     NOTIMMEDIATE
000015D4                          1117  
000015D4  0C45 0001               1118      CMPI    #1,D5 * is it a byte?
000015D8  6600 0028               1119      BNE     NOTIMMBYTE
000015DC                          1120      
000015DC  43F9 00001C97           1121      LEA     IMD,A1 *print out the '#' indicating an immediate value
000015E2  103C 000E               1122      MOVE.B  #14,D0
000015E6  4E4F                    1123      TRAP    #15
000015E8                          1124      
000015E8  3C3C 0000               1125      MOVE.W  #0, D6              * Prep lower value for bitmask
000015EC  3E3C 0007               1126      MOVE.W  #7, D7              * Prep upper value for bitmask
000015F0  6100 05DE               1127      BSR     BITMASK             * Finalize bitmask setup
000015F4                          1128          
000015F4  321A                    1129      MOVE.W  (A2)+,D1
000015F6                          1130      
000015F6  C246                    1131      AND     D6,D1
000015F8                          1132          
000015F8  103C 0003               1133      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000015FC  4E4F                    1134      TRAP    #15      * Perform Trap #3
000015FE                          1135      
000015FE  6000 0082               1136      BRA     ENDEAHELPER611
00001602                          1137  
00001602                          1138  NOTIMMBYTE
00001602                          1139      
00001602  0C45 0002               1140      CMPI    #2,D5 * is it a word?
00001606  6600 0028               1141      BNE     NOTIMMWORD
0000160A                          1142      
0000160A  43F9 00001C97           1143      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001610  103C 000E               1144      MOVE.B  #14,D0
00001614  4E4F                    1145      TRAP    #15
00001616                          1146      
00001616  3C3C 0000               1147      MOVE.W  #0, D6              * Prep lower value for bitmask
0000161A  3E3C 000F               1148      MOVE.W  #15, D7             * Prep upper value for bitmask
0000161E  6100 05B0               1149      BSR     BITMASK             * Finalize bitmask setup
00001622                          1150          
00001622  321A                    1151      MOVE.W  (A2)+,D1
00001624                          1152      
00001624  C246                    1153      AND     D6,D1               * Apply bitmask
00001626                          1154          
00001626  103C 0003               1155      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000162A  4E4F                    1156      TRAP    #15      * Perform Trap #3
0000162C                          1157      
0000162C  6000 0054               1158      BRA     ENDEAHELPER611
00001630                          1159      
00001630                          1160  NOTIMMWORD
00001630  0C45 0003               1161      CMPI    #3,D5 * is it a long?
00001634  6600 0022               1162      BNE     NOTIMMEDIATE
00001638                          1163      
00001638  43F9 00001C97           1164      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000163E  103C 000E               1165      MOVE.B  #14,D0
00001642  4E4F                    1166      TRAP    #15
00001644                          1167          
00001644  221A                    1168      MOVE.L  (A2)+,D1
00001646                          1169          
00001646  103C 0003               1170      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000164A  4E4F                    1171      TRAP    #15      * Perform Trap #3
0000164C                          1172      
0000164C  321A                    1173      MOVE.W  (A2)+,D1
0000164E                          1174          
0000164E  103C 0003               1175      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001652  4E4F                    1176      TRAP    #15      * Perform Trap #3
00001654                          1177      
00001654  6000 002C               1178      BRA     ENDEAHELPER611
00001658                          1179  
00001658                          1180  NOTIMMEDIATE    
00001658                          1181      * to move the mode where EAHELPER50 can process it
00001658  7C06                    1182      MOVE.L  #6,D6
0000165A  7E08                    1183      MOVE.L  #8,D7
0000165C                          1184      
0000165C  6100 0572               1185      BSR     BITMASK * create bitmask
00001660                          1186      
00001660  CC42                    1187      AND     D2,D6   * apply bitmask
00001662                          1188      
00001662  4243                    1189      CLR     D3      * prep D3 to store values
00001664                          1190      
00001664  3606                    1191      MOVE.W  D6,D3   * store bitmasked value in D3
00001666                          1192      
00001666  E64B                    1193      LSR     #3,D3   * move bits 6-8 to 3-5
00001668                          1194      
00001668                          1195      * to move the register where EAHELPER50 can process it
00001668  7C09                    1196      MOVE.L  #9,D6   *prep registers to create bitmask
0000166A  7E0B                    1197      MOVE.L  #11,D7
0000166C                          1198      
0000166C  6100 0562               1199      BSR     BITMASK * create bitmask
00001670                          1200      
00001670  CC42                    1201      AND     D2,D6   * apply bitmask
00001672                          1202      
00001672  4244                    1203      CLR     D4      * prep D3 to store values
00001674                          1204      
00001674  3806                    1205      MOVE.W  D6,D4   * store bitmasked value in D3
00001676                          1206      
00001676  E04C                    1207      LSR     #8,D4   * move bits 9-11 to 0-2
00001678  E24C                    1208      LSR     #1,D4   * move bits 9-11 to 0-2
0000167A                          1209      
0000167A  8684                    1210      OR.L    D4,D3   * combind the register and mode
0000167C                          1211      
0000167C  2403                    1212      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
0000167E                          1213      
0000167E  6100 0008               1214      BSR     EAHELPER05
00001682                          1215      
00001682                          1216  ENDEAHELPER611
00001682                          1217      
00001682  4C9F 03FF               1218      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
00001686                          1219      
00001686  4E75                    1220      RTS
00001688                          1221  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001688                          1222  *-----------------------------------------------------------------------------
00001688                          1223  
00001688                          1224  
00001688                          1225  
00001688                          1226  *-----------------------------------------------------------------------------
00001688                          1227  *-----------------------------------------------------------------------------
00001688                          1228  * NAME:           EAHELPER05
00001688                          1229  * DESCRIPTION:    a
00001688                          1230  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
00001688                          1231  *                 this sub-routine helper for operations that only have one
00001688                          1232  *                 mode register.
00001688                          1233  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
00001688                          1234  * REGISTERS:      a
00001688                          1235  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001688                          1236  EAHELPER05
00001688                          1237      * todo: add code for printing immediate values
00001688                          1238      
00001688  48A7 FFC0               1239      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
0000168C                          1240      
0000168C  7C03                    1241      MOVE.L  #3,D6
0000168E  7E05                    1242      MOVE.L  #5,D7
00001690                          1243      
00001690  6100 053E               1244      BSR     BITMASK * generate a bitmask to identify the mode
00001694                          1245      
00001694  CC42                    1246      AND     D2,D6   * mask off the parts of D2 we don't need
00001696                          1247      
00001696  2A06                    1248      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
00001698                          1249      
00001698  0C46 0000               1250      CMPI    #%0000000000000000,D6 * is it data register direct?
0000169C  6600 000A               1251      BNE     NOTDATAREG
000016A0                          1252      
000016A0  6100 00B0               1253      BSR     MODE_DN
000016A4                          1254       
000016A4  6000 00A6               1255      BRA     ENDEAHELPER05
000016A8                          1256      
000016A8                          1257  NOTDATAREG * address register direct
000016A8                          1258      
000016A8  0C46 0008               1259      CMPI    #%0000000000001000,D6 * is it address register direct?
000016AC  6600 000A               1260      BNE     NOTADRDIRECT
000016B0                          1261      
000016B0  6100 01A0               1262      BSR     MODE_AN * simply prints out the address register
000016B4                          1263       
000016B4  6000 0096               1264      BRA     ENDEAHELPER05
000016B8                          1265      
000016B8                          1266  NOTADRDIRECT * address register indirect
000016B8                          1267          
000016B8  0C46 0010               1268      CMPI    #%0000000000010000,D6 * is it address register indirect?
000016BC  6600 0022               1269      BNE     NOTADRINDIRECT
000016C0                          1270      
000016C0  43F9 00001C9B           1271      LEA     OBRACK,A1       * Load '('
000016C6  303C 000E               1272      MOVE.W  #14,D0          * Trap #14 to display message
000016CA  4E4F                    1273      TRAP    #15             * Perform #14
000016CC                          1274          
000016CC                          1275  
000016CC  6100 0184               1276      BSR     MODE_AN * print out an address register
000016D0                          1277      
000016D0  43F9 00001C9D           1278      LEA     CBRACK,A1       * Load ')'
000016D6  303C 000E               1279      MOVE.W  #14,D0          * Trap #14 to display message
000016DA  4E4F                    1280      TRAP    #15             * Perform #14
000016DC                          1281       
000016DC  6000 006E               1282      BRA     ENDEAHELPER05
000016E0                          1283      
000016E0                          1284  NOTADRINDIRECT * address register indirect, post increment
000016E0                          1285      
000016E0  0C46 0018               1286      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
000016E4  6600 002E               1287      BNE     NOTADRINDIRECTPOST
000016E8                          1288      
000016E8  43F9 00001C9B           1289      LEA     OBRACK,A1       * Load '('
000016EE  303C 000E               1290      MOVE.W  #14,D0          * Trap #14 to display message
000016F2  4E4F                    1291      TRAP    #15             * Perform #14
000016F4                          1292          
000016F4                          1293  
000016F4  6100 015C               1294      BSR     MODE_AN * print out an address register
000016F8                          1295      
000016F8  43F9 00001C9D           1296      LEA     CBRACK,A1       * Load ')'
000016FE  303C 000E               1297      MOVE.W  #14,D0          * Trap #14 to display message
00001702  4E4F                    1298      TRAP    #15             * Perform #14
00001704                          1299      
00001704  43F9 00001C9F           1300      LEA     PLUS,A1       * Load '+'
0000170A  303C 000E               1301      MOVE.W  #14,D0          * Trap #14 to display message
0000170E  4E4F                    1302      TRAP    #15             * Perform #14
00001710                          1303       
00001710  6000 003A               1304      BRA     ENDEAHELPER05
00001714                          1305      
00001714                          1306  NOTADRINDIRECTPOST * address register indirect, pre decrement
00001714                          1307      
00001714  0C46 0020               1308      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
00001718  6600 002E               1309      BNE     NOTADRINDIRECTPRE
0000171C                          1310      
0000171C  43F9 00001CA1           1311      LEA     MINUS,A1       * Load '-'
00001722  303C 000E               1312      MOVE.W  #14,D0          * Trap #14 to display message
00001726  4E4F                    1313      TRAP    #15             * Perform #14
00001728                          1314      
00001728  43F9 00001C9B           1315      LEA     OBRACK,A1       * Load '('
0000172E  303C 000E               1316      MOVE.W  #14,D0          * Trap #14 to display message
00001732  4E4F                    1317      TRAP    #15             * Perform #14
00001734                          1318          
00001734                          1319  
00001734  6100 011C               1320      BSR     MODE_AN * print out an address register
00001738                          1321      
00001738  43F9 00001C9D           1322      LEA     CBRACK,A1       * Load ')'
0000173E  303C 000E               1323      MOVE.W  #14,D0          * Trap #14 to display message
00001742  4E4F                    1324      TRAP    #15             * Perform #14
00001744                          1325       
00001744  6000 0006               1326      BRA     ENDEAHELPER05
00001748                          1327  
00001748                          1328  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
00001748                          1329  
00001748  6100 02CE               1330      BSR     UNKNOWNOP
0000174C                          1331      
0000174C                          1332  ENDEAHELPER05
0000174C  4C9F 03FF               1333      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001750  4E75                    1334      RTS
00001752                          1335  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001752                          1336  *-----------------------------------------------------------------------------
00001752                          1337  
00001752                          1338  
00001752                          1339  
00001752                          1340  *-----------------------------------------------------------------------------
00001752                          1341  *-----------------------------------------------------------------------------
00001752                          1342  * NAME:           MODE_DN
00001752                          1343  * DESCRIPTION:    Generalize the EA part of the project.
00001752                          1344  * PRE-CONDITION:  The mode must have been correctly identified. All modes
00001752                          1345  *                 must be called by RTS.
00001752                          1346  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
00001752                          1347  *                 called it.
00001752                          1348  * REGISTERS:      a
00001752                          1349  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001752                          1350  * ---> Dn
00001752                          1351  MODE_DN
00001752  48A7 FFC0               1352          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001756                          1353  
00001756  3C3C 0000               1354          MOVE.W  #0, D6              * Prep lower value for bitmask
0000175A  3E3C 0002               1355          MOVE.W  #2, D7              * Prep upper value for bitmask
0000175E  6100 0470               1356          BSR     BITMASK             * Finalize bitmask setup
00001762  CC42                    1357          AND     D2,D6               * Apply bitmask
00001764                          1358          
00001764  0C46 0000               1359          CMPI    #%000000000000000, D6   * Data Register D0?
00001768  6600 000A               1360          BNE     NOTD0
0000176C                          1361          
0000176C  6100 0074               1362          BSR     PRINTD0
00001770  6000 006A               1363          BRA     ENDMODE_DN
00001774                          1364  NOTD0      
00001774  0C46 0001               1365          CMPI    #%000000000000001, D6   * Data Register D1?
00001778  6600 000A               1366          BNE     NOTD1
0000177C                          1367          
0000177C  6100 0072               1368          BSR     PRINTD1
00001780  6000 005A               1369          BRA     ENDMODE_DN
00001784                          1370  NOTD1
00001784  0C46 0002               1371          CMPI    #%000000000000010, D6   * Data Register D2?
00001788  6600 000A               1372          BNE     NOTD2
0000178C                          1373          
0000178C  6100 0070               1374          BSR     PRINTD2
00001790  6000 004A               1375          BRA     ENDMODE_DN
00001794                          1376  NOTD2
00001794  0C46 0003               1377          CMPI    #%000000000000011, D6   * Data Register D3?
00001798  6600 000A               1378          BNE     NOTD3
0000179C                          1379          
0000179C  6100 006E               1380          BSR     PRINTD3
000017A0  6000 003A               1381          BRA     ENDMODE_DN
000017A4                          1382  NOTD3
000017A4  0C46 0004               1383          CMPI    #%000000000000100, D6   * Data Register D4?
000017A8  6600 000A               1384          BNE     NOTD4
000017AC                          1385          
000017AC  6100 006C               1386          BSR     PRINTD4
000017B0  6000 002A               1387          BRA     ENDMODE_DN
000017B4                          1388  NOTD4
000017B4  0C46 0005               1389          CMPI    #%000000000000101, D6   * Data Register D5?
000017B8  6600 000A               1390          BNE     NOTD5
000017BC                          1391          
000017BC  6100 006A               1392          BSR     PRINTD5
000017C0  6000 001A               1393          BRA     ENDMODE_DN
000017C4                          1394  NOTD5
000017C4  0C46 0006               1395          CMPI    #%000000000000110, D6   * Data Register D6?
000017C8  6600 000A               1396          BNE     NOTD6
000017CC                          1397          
000017CC  6100 0068               1398          BSR     PRINTD6
000017D0  6000 000A               1399          BRA     ENDMODE_DN
000017D4                          1400  NOTD6
000017D4  6100 006E               1401          BSR     PRINTD7
000017D8  6000 0002               1402          BRA     ENDMODE_DN
000017DC                          1403          
000017DC                          1404  ENDMODE_DN
000017DC  4C9F 03FF               1405          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
000017E0  4E75                    1406          RTS
000017E2                          1407  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000017E2                          1408  *-----------------------------------------------------------------------------
000017E2                          1409  
000017E2                          1410  
000017E2                          1411  
000017E2                          1412  *-----------------------------------------------------------------------------
000017E2                          1413  *-----------------------------------------------------------------------------
000017E2                          1414  * NAME:           PRINTD0
000017E2                          1415  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
000017E2                          1416  * PRE-CONDITION:  a
000017E2                          1417  * POST-CONDITION: a
000017E2                          1418  * REGISTERS:      a
000017E2                          1419  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000017E2                          1420  PRINTD0
000017E2  43F9 00001CC7           1421          LEA     __D0, A1        * Load 'D0'
000017E8  103C 000E               1422          MOVE.B  #14, D0         * Load Trap #14 to print out
000017EC  4E4F                    1423          TRAP    #15             * Perform Trap #14
000017EE  4E75                    1424          RTS
000017F0                          1425  PRINTD1
000017F0  43F9 00001CCA           1426          LEA     __D1, A1        * Load 'D1'
000017F6  103C 000E               1427          MOVE.B  #14, D0         * Load Trap #14 to print out
000017FA  4E4F                    1428          TRAP    #15             * Perform Trap #14
000017FC  4E75                    1429          RTS      
000017FE                          1430  PRINTD2
000017FE  43F9 00001CCD           1431          LEA     __D2, A1        * Load 'D2'
00001804  103C 000E               1432          MOVE.B  #14, D0         * Load Trap #14 to print out
00001808  4E4F                    1433          TRAP    #15             * Perform Trap #14
0000180A  4E75                    1434          RTS      
0000180C                          1435  PRINTD3
0000180C  43F9 00001CD0           1436          LEA     __D3, A1        * Load 'D3'
00001812  103C 000E               1437          MOVE.B  #14, D0         * Load Trap #14 to print out
00001816  4E4F                    1438          TRAP    #15             * Perform Trap #14
00001818  4E75                    1439          RTS      
0000181A                          1440  PRINTD4
0000181A  43F9 00001CD3           1441          LEA     __D4, A1        * Load 'D4'
00001820  103C 000E               1442          MOVE.B  #14, D0         * Load Trap #14 to print out
00001824  4E4F                    1443          TRAP    #15             * Perform Trap #14
00001826  4E75                    1444          RTS       
00001828                          1445  PRINTD5
00001828  43F9 00001CD6           1446          LEA     __D5, A1        * Load 'D5'
0000182E  103C 000E               1447          MOVE.B  #14, D0         * Load Trap #14 to print out
00001832  4E4F                    1448          TRAP    #15             * Perform Trap #14
00001834  4E75                    1449          RTS      
00001836                          1450  PRINTD6
00001836  43F9 00001CD9           1451          LEA     __D6, A1        * Load 'D6'
0000183C  103C 000E               1452          MOVE.B  #14, D0         * Load Trap #14 to print out
00001840  4E4F                    1453          TRAP    #15             * Perform Trap #14
00001842  4E75                    1454          RTS
00001844                          1455  PRINTD7
00001844  43F9 00001CDC           1456          LEA     __D7, A1        * Load 'D7'
0000184A  103C 000E               1457          MOVE.B  #14, D0         * Load Trap #14 to print out
0000184E  4E4F                    1458          TRAP    #15             * Perform Trap #14
00001850  4E75                    1459          RTS
00001852                          1460  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001852                          1461  *-----------------------------------------------------------------------------
00001852                          1462  
00001852                          1463  
00001852                          1464  
00001852                          1465  *-----------------------------------------------------------------------------
00001852                          1466  *-----------------------------------------------------------------------------
00001852                          1467  * NAME:           MODE_AN
00001852                          1468  * DESCRIPTION:    Simply chooses to print A0-A7.
00001852                          1469  * PRE-CONDITION:  a
00001852                          1470  * POST-CONDITION: a
00001852                          1471  * REGISTERS:      a
00001852                          1472  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001852                          1473  MODE_AN
00001852  48A7 FFC0               1474          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
00001856                          1475  
00001856  3C3C 0000               1476          MOVE.W  #0, D6              * Prep lower value for bitmask
0000185A  3E3C 0002               1477          MOVE.W  #2, D7              * Prep upper value for bitmask
0000185E  6100 0370               1478          BSR     BITMASK             * Finalize bitmask setup
00001862  CC42                    1479          AND     D2,D6               * Apply bitmask
00001864                          1480          
00001864  0C46 0000               1481          CMPI    #%000000000000000, D6   * Address Register A0?
00001868  6600 000A               1482          BNE     NOTA0
0000186C                          1483          
0000186C  6100 0074               1484          BSR     PRINTA0
00001870                          1485          
00001870  6000 006A               1486          BRA     ENDMODE_AN
00001874                          1487  NOTA0      
00001874  0C46 0001               1488          CMPI    #%000000000000001, D6   * Address Register A1?
00001878  6600 000A               1489          BNE     NOTA1
0000187C                          1490          
0000187C  6100 0072               1491          BSR     PRINTA1
00001880                          1492          
00001880  6000 005A               1493          BRA     ENDMODE_AN
00001884                          1494  NOTA1
00001884  0C46 0002               1495          CMPI    #%000000000000010, D6   * Address Register A2?
00001888  6600 000A               1496          BNE     NOTA2
0000188C                          1497          
0000188C  6100 0070               1498          BSR     PRINTA2
00001890                          1499          
00001890  6000 004A               1500          BRA     ENDMODE_AN
00001894                          1501  NOTA2
00001894  0C46 0003               1502          CMPI    #%000000000000011, D6   * Address Register A3?
00001898  6600 000A               1503          BNE     NOTA3
0000189C                          1504          
0000189C  6100 006E               1505          BSR     PRINTA3
000018A0                          1506          
000018A0  6000 003A               1507          BRA     ENDMODE_AN
000018A4                          1508  NOTA3
000018A4  0C46 0004               1509          CMPI    #%000000000000100, D6   * Address Register A4?
000018A8  6600 000A               1510          BNE     NOTA4
000018AC                          1511          
000018AC  6100 006C               1512          BSR     PRINTA4
000018B0                          1513          
000018B0  6000 002A               1514          BRA     ENDMODE_AN
000018B4                          1515  NOTA4
000018B4  0C46 0005               1516          CMPI    #%000000000000101, D6   * Address Register A5?
000018B8  6600 000A               1517          BNE     NOTA5
000018BC                          1518          
000018BC  6100 006A               1519          BSR     PRINTA5
000018C0                          1520          
000018C0  6000 001A               1521          BRA     ENDMODE_AN
000018C4                          1522  NOTA5
000018C4  0C46 0006               1523          CMPI    #%000000000000110, D6   * Address Register A6?
000018C8  6600 000A               1524          BNE     NOTA6
000018CC                          1525          
000018CC  6100 0068               1526          BSR     PRINTA6
000018D0                          1527          
000018D0  6000 000A               1528          BRA     ENDMODE_AN
000018D4                          1529  NOTA6
000018D4  6100 006E               1530          BSR     PRINTA7
000018D8                          1531          
000018D8  6000 0002               1532          BRA     ENDMODE_AN
000018DC                          1533  ENDMODE_AN
000018DC  4C9F 03FF               1534          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
000018E0  4E75                    1535          RTS
000018E2                          1536  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018E2                          1537  *-----------------------------------------------------------------------------
000018E2                          1538  
000018E2                          1539  
000018E2                          1540  
000018E2                          1541  *-----------------------------------------------------------------------------
000018E2                          1542  *-----------------------------------------------------------------------------
000018E2                          1543  * NAME:           PRINTA0
000018E2                          1544  * DESCRIPTION:    Simply print out the address register.
000018E2                          1545  * PRE-CONDITION:  a
000018E2                          1546  * POST-CONDITION: a
000018E2                          1547  * REGISTERS:      a
000018E2                          1548  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018E2                          1549  PRINTA0
000018E2  43F9 00001CAF           1550          LEA     __A0, A1        * Load 'A0'
000018E8  103C 000E               1551          MOVE.B  #14, D0         * Load Trap #14 to print out
000018EC  4E4F                    1552          TRAP    #15             * Perform Trap #14
000018EE  4E75                    1553          RTS
000018F0                          1554  
000018F0                          1555  PRINTA1
000018F0  43F9 00001CB2           1556          LEA     __A1, A1        * Load 'A1'
000018F6  103C 000E               1557          MOVE.B  #14, D0         * Load Trap #14 to print out
000018FA  4E4F                    1558          TRAP    #15             * Perform Trap #14
000018FC  4E75                    1559          RTS
000018FE                          1560          
000018FE                          1561  PRINTA2
000018FE  43F9 00001CB5           1562          LEA     __A2, A1        * Load 'A2'
00001904  103C 000E               1563          MOVE.B  #14, D0         * Load Trap #14 to print out
00001908  4E4F                    1564          TRAP    #15             * Perform Trap #14
0000190A  4E75                    1565          RTS
0000190C                          1566  
0000190C                          1567  PRINTA3
0000190C  43F9 00001CB8           1568          LEA     __A3, A1        * Load 'A3'
00001912  103C 000E               1569          MOVE.B  #14, D0         * Load Trap #14 to print out
00001916  4E4F                    1570          TRAP    #15             * Perform Trap #14
00001918  4E75                    1571          RTS
0000191A                          1572  
0000191A                          1573  PRINTA4
0000191A  43F9 00001CBB           1574          LEA     __A4, A1        * Load 'A4'
00001920  103C 000E               1575          MOVE.B  #14, D0         * Load Trap #14 to print out
00001924  4E4F                    1576          TRAP    #15             * Perform Trap #14
00001926  4E75                    1577          RTS
00001928                          1578  
00001928                          1579  PRINTA5
00001928  43F9 00001CBE           1580          LEA     __A5, A1        * Load 'A5'
0000192E  103C 000E               1581          MOVE.B  #14, D0         * Load Trap #14 to print out
00001932  4E4F                    1582          TRAP    #15             * Perform Trap #14
00001934  4E75                    1583          RTS
00001936                          1584  
00001936                          1585  PRINTA6
00001936  43F9 00001CC1           1586          LEA     __A6, A1        * Load 'A6'
0000193C  103C 000E               1587          MOVE.B  #14, D0         * Load Trap #14 to print out
00001940  4E4F                    1588          TRAP    #15             * Perform Trap #14
00001942  4E75                    1589          RTS
00001944                          1590  
00001944                          1591  PRINTA7
00001944  43F9 00001CC4           1592          LEA     __A7, A1        * Load 'A7'
0000194A  103C 000E               1593          MOVE.B  #14, D0         * Load Trap #14 to print out
0000194E  4E4F                    1594          TRAP    #15             * Perform Trap #14
00001950  4E75                    1595          RTS
00001952                          1596  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001952                          1597  *-----------------------------------------------------------------------------
00001952                          1598  
00001952                          1599  
00001952                          1600  
00001952                          1601  *-----------------------------------------------------------------------------
00001952                          1602  *-----------------------------------------------------------------------------
00001952                          1603  * NAME:           SIZE67
00001952                          1604  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001952                          1605  * PRE-CONDITION:  a
00001952                          1606  * POST-CONDITION: a
00001952                          1607  * REGISTERS:      a
00001952                          1608  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001952                          1609  SIZE67
00001952  48A7 FFFE               1610          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001956  3C3C 0006               1611          MOVE.W  #6, D6              * Prep lower value for bitmask
0000195A  3E3C 0007               1612          MOVE.W  #7, D7              * Prep upper value for bitmask
0000195E  6100 0270               1613          BSR     BITMASK             * Finalize bitmask setup
00001962  CC42                    1614          AND     D2,D6               * Apply bitmask     
00001964                          1615  
00001964  0C46 0000               1616          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001968  6600 000A               1617          BNE     NOT67BYTE
0000196C                          1618          
0000196C  6100 0080               1619          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001970  6000 001E               1620          BRA     END67
00001974                          1621  NOT67BYTE        
00001974  0C46 0040               1622          CMPI    #%0000000001000000, D6   * is it a WORD?
00001978  6600 000A               1623          BNE     NOT67WORD
0000197C                          1624          
0000197C  6100 007E               1625          BSR     PRINTWORD               * Branch to handle WORD sizes
00001980  6000 000E               1626          BRA     END67
00001984                          1627  NOT67WORD
00001984  0C46 0080               1628          CMPI    #%0000000010000000, D6   * is it a LONG?
00001988  6600 0006               1629          BNE     END67
0000198C                          1630          
0000198C  6100 007C               1631          BSR     PRINTLONG               * Branch to handle LONG sizes
00001990                          1632  END67
00001990  4C9F 7FFF               1633          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001994  4E75                    1634          RTS                             * Return. Size handling is finished.
00001996                          1635  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001996                          1636  *-----------------------------------------------------------------------------
00001996                          1637  
00001996                          1638  
00001996                          1639  
00001996                          1640  *-----------------------------------------------------------------------------
00001996                          1641  *-----------------------------------------------------------------------------
00001996                          1642  * NAME:           SIZE68
00001996                          1643  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
00001996                          1644  * PRE-CONDITION:  a
00001996                          1645  * POST-CONDITION: a
00001996                          1646  * REGISTERS:      a
00001996                          1647  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001996                          1648  SIZE68
00001996                          1649          * finish later, need to follow the same format as SIZE67
00001996                          1650          
00001996                          1651          
00001996  48A7 FFFE               1652          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
0000199A  3C3C 0006               1653          MOVE.W  #6, D6              * Prep lower value for bitmask
0000199E  3E3C 0008               1654          MOVE.W  #8, D7              * Prep upper value for bitmask
000019A2  6100 022C               1655          BSR     BITMASK             * Finalize bitmask setup
000019A6  CC42                    1656          AND     D2,D6               * Apply bitmask          
000019A8                          1657          
000019A8  0C46 0000               1658          CMPI    #%0000000000000000, D6   * is it a BYTE?
000019AC  6100 0040               1659          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000019B0  0C46 0100               1660          CMPI    #%0000000100000000, D6   * is it a BYTE?
000019B4  6100 0038               1661          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
000019B8                          1662        
000019B8  0C46 0040               1663          CMPI    #%0000000001000000, D6   * is it a WORD?
000019BC  6100 003E               1664          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019C0  0C46 0140               1665          CMPI    #%0000000101000000, D6   * is it a WORD?
000019C4  6100 0036               1666          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019C8  0C46 00C0               1667          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
000019CC  6100 002E               1668          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019D0                          1669  
000019D0  0C46 0080               1670          CMPI    #%0000000010000000, D6   * is it a LONG?
000019D4  6100 0034               1671          BSR     PRINTLONG               * Branch to handle BYTE sizes
000019D8  0C46 0180               1672          CMPI    #%0000000110000000, D6   * is it a LONG?
000019DC  6100 002C               1673          BSR     PRINTLONG               * Branch to handle BYTE sizes
000019E0  0C46 01C0               1674          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
000019E4  6100 0024               1675          BSR     PRINTLONG               * Branch to handle BYTE sizes
000019E8                          1676  
000019E8  4C9F 7FFF               1677          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
000019EC  4E75                    1678          RTS                             * Return. Size handling is finished.
000019EE                          1679  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019EE                          1680  *-----------------------------------------------------------------------------
000019EE                          1681  
000019EE                          1682  
000019EE                          1683  
000019EE                          1684  *-----------------------------------------------------------------------------
000019EE                          1685  *-----------------------------------------------------------------------------
000019EE                          1686  * NAME:           PRINTBYTE
000019EE                          1687  * DESCRIPTION:    a
000019EE                          1688  * PRE-CONDITION:  a
000019EE                          1689  * POST-CONDITION: a
000019EE                          1690  * REGISTERS:      a
000019EE                          1691  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019EE                          1692  PRINTBYTE
000019EE  43F9 00001CA3           1693          LEA     __B,A1      * Load '.B ' into A1
000019F4  103C 000E               1694          MOVE.B  #14,D0      * Trap #14 setup to print
000019F8  4E4F                    1695          TRAP    #15         * Perform Trap #14
000019FA  4E75                    1696          RTS                 * Return to SIZE67/SIZE68
000019FC                          1697          
000019FC                          1698  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019FC                          1699  *-----------------------------------------------------------------------------
000019FC                          1700  
000019FC                          1701  
000019FC                          1702  
000019FC                          1703  *-----------------------------------------------------------------------------
000019FC                          1704  *-----------------------------------------------------------------------------
000019FC                          1705  * NAME:           PRINTWORD
000019FC                          1706  * DESCRIPTION:    a
000019FC                          1707  * PRE-CONDITION:  a
000019FC                          1708  * POST-CONDITION: a
000019FC                          1709  * REGISTERS:      a
000019FC                          1710  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019FC                          1711  PRINTWORD
000019FC  43F9 00001CA7           1712          LEA     __W,A1      * Load '.W ' into A1
00001A02  103C 000E               1713          MOVE.B  #14,D0      * Trap #14 setup to print
00001A06  4E4F                    1714          TRAP    #15         * Perform Trap #14
00001A08  4E75                    1715          RTS                 * Return to SIZE67/SIZE68
00001A0A                          1716          
00001A0A                          1717  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A0A                          1718  *-----------------------------------------------------------------------------
00001A0A                          1719  
00001A0A                          1720  
00001A0A                          1721  
00001A0A                          1722  *-----------------------------------------------------------------------------
00001A0A                          1723  *-----------------------------------------------------------------------------
00001A0A                          1724  * NAME:           PRINTLONG
00001A0A                          1725  * DESCRIPTION:    a
00001A0A                          1726  * PRE-CONDITION:  a
00001A0A                          1727  * POST-CONDITION: a
00001A0A                          1728  * REGISTERS:      a
00001A0A                          1729  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A0A                          1730  PRINTLONG
00001A0A  43F9 00001CAB           1731          LEA     __L,A1      * Load '.L ' into A1
00001A10  103C 000E               1732          MOVE.B  #14,D0      * Trap #14 setup to print
00001A14  4E4F                    1733          TRAP    #15         * Perform Trap #14
00001A16  4E75                    1734          RTS                 * Return to SIZE67/SIZE68
00001A18                          1735          
00001A18                          1736  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A18                          1737  *-----------------------------------------------------------------------------
00001A18                          1738  
00001A18                          1739  
00001A18                          1740  
00001A18                          1741  *-----------------------------------------------------------------------------
00001A18                          1742  *-----------------------------------------------------------------------------
00001A18                          1743  * NAME:           UNKNOWNOP
00001A18                          1744  * DESCRIPTION:    a
00001A18                          1745  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001A18                          1746  *                 identified as an unknown operation.
00001A18                          1747  * POST-CONDITION: D2 is no longer the opcode.
00001A18                          1748  * REGISTERS:      a
00001A18                          1749  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A18                          1750  UNKNOWNOP
00001A18  220A                    1751          MOVE.L  A2,D1   * prep the add to print
00001A1A                          1752          
00001A1A  5581                    1753          SUB.L   #2,D1   * off by two error due to post increment correct
00001A1C                          1754          
00001A1C  2602                    1755          MOVE.L  D2,D3   * save the opcode to print
00001A1E                          1756          
00001A1E  7410                    1757          MOVE.L  #16,D2  * set the base to 16
00001A20                          1758          
00001A20  700F                    1759          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001A22  4E4F                    1760          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001A24                          1761          
00001A24  43F9 00001C4D           1762          LEA     DATA,A1 * load " DATA $" into register A1
00001A2A  700E                    1763          MOVE.L  #14,D0  * print the string stored in A1
00001A2C  4E4F                    1764          TRAP    #15
00001A2E                          1765          
00001A2E  2203                    1766          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001A30                          1767          
00001A30  103C 000F               1768          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A34  4E4F                    1769          TRAP    #15      * Perform Trap #3
00001A36                          1770  
00001A36  43F9 00001C14           1771          LEA     NEWLINE,A1 * load newline into register A1
00001A3C  700E                    1772          MOVE.L  #14,D0  * print the string stored in A1
00001A3E  4E4F                    1773          TRAP    #15
00001A40                          1774  
00001A40  4E75                    1775          RTS
00001A42                          1776  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A42                          1777  *-----------------------------------------------------------------------------
00001A42                          1778  
00001A42                          1779  
00001A42                          1780  
00001A42                          1781  *-----------------------------------------------------------------------------
00001A42                          1782  *-----------------------------------------------------------------------------
00001A42                          1783  * NAME: Print ASCII hex char
00001A42                          1784  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
00001A42                          1785  * PRE-CONDITION:  A6 contains the register for memory to print.
00001A42                          1786  *                 This parameter would be pre-loaded by, for example:
00001A42                          1787  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001A42                          1788  *                 D6 contains the loops to do (number of bytes).
00001A42                          1789  * POST-CONDITION: 
00001A42                          1790  * REGISTERS:      
00001A42                          1791  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A42                          1792  PRINT_ASCII_HEX_CHAR
00001A42  48E7 FFFC               1793      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001A46  4285                    1794      CLR.L       D5
00001A48                          1795      
00001A48                          1796      * fence post check (if-statement, check if 0 > chars)
00001A48  0C06 0000               1797      CMPI.B      #0,D6
00001A4C  6700 017C               1798      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001A50                          1799      
00001A50                          1800  *    MOVE.L      A6,D4
00001A50  2E0E                    1801      MOVE.L      A6,D7
00001A52                          1802  PRINT_ASCII_LOOP
00001A52                          1803  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001A52                          1804  *    MOVE.L      D4,D7 * make a mutable copy
00001A52  E99F                    1805      ROL.L       #4,D7 * roll to next spot
00001A54  48E7 0100               1806      MOVEM.L     D7,-(A7) * save D7
00001A58                          1807  
00001A58  0287 0000000F           1808      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001A5E                          1809      
00001A5E  0C87 00000000           1810      CMPI.L      #0,D7
00001A64  6D00 0164               1811      BLT         INVALID_ASCII_INPUT
00001A68                          1812  
00001A68  0C87 0000000F           1813      CMPI.L      #15,D7
00001A6E  6E00 015A               1814      BGT         INVALID_ASCII_INPUT
00001A72                          1815  
00001A72                          1816      * this might be faster... to do later, after entire assignment done
00001A72                          1817       * CMPI.L      #9,D7
00001A72                          1818       * BLE         PRINT_ASCII_0_TO_9
00001A72                          1819  
00001A72  0C87 00000000           1820      CMPI.L      #0,D7
00001A78  6700 0098               1821      BEQ         PRINT_ASCII_0
00001A7C  0C87 00000001           1822      CMPI.L      #1,D7
00001A82  6700 0098               1823      BEQ         PRINT_ASCII_1
00001A86  0C87 00000002           1824      CMPI.L      #2,D7
00001A8C  6700 0098               1825      BEQ         PRINT_ASCII_2
00001A90  0C87 00000003           1826      CMPI.L      #3,D7
00001A96  6700 0098               1827      BEQ         PRINT_ASCII_3
00001A9A  0C87 00000004           1828      CMPI.L      #4,D7
00001AA0  6700 0098               1829      BEQ         PRINT_ASCII_4
00001AA4  0C87 00000005           1830      CMPI.L      #5,D7
00001AAA  6700 0098               1831      BEQ         PRINT_ASCII_5
00001AAE  0C87 00000006           1832      CMPI.L      #6,D7
00001AB4  6700 0098               1833      BEQ         PRINT_ASCII_6
00001AB8  0C87 00000007           1834      CMPI.L      #7,D7
00001ABE  6700 0098               1835      BEQ         PRINT_ASCII_7
00001AC2  0C87 00000008           1836      CMPI.L      #8,D7
00001AC8  6700 0098               1837      BEQ         PRINT_ASCII_8
00001ACC  0C87 00000009           1838      CMPI.L      #9,D7
00001AD2  6700 0098               1839      BEQ         PRINT_ASCII_9
00001AD6  0C87 0000000A           1840      CMPI.L      #10,D7
00001ADC  6700 0098               1841      BEQ         PRINT_ASCII_A
00001AE0  0C87 0000000B           1842      CMPI.L      #11,D7
00001AE6  6700 0098               1843      BEQ         PRINT_ASCII_B
00001AEA  0C87 0000000C           1844      CMPI.L      #12,D7
00001AF0  6700 0098               1845      BEQ         PRINT_ASCII_C
00001AF4  0C87 0000000D           1846      CMPI.L      #13,D7
00001AFA  6700 0098               1847      BEQ         PRINT_ASCII_D
00001AFE  0C87 0000000E           1848      CMPI.L      #14,D7
00001B04  6700 0098               1849      BEQ         PRINT_ASCII_E
00001B08  0C87 0000000F           1850      CMPI.L      #15,D7
00001B0E  6700 0098               1851      BEQ         PRINT_ASCII_F
00001B12                          1852  PRINT_ASCII_0
00001B12  43F9 00001C73           1853      LEA         ASCII_0,A1
00001B18  6000 0098               1854      BRA         PRINT_ASCII_CHAR
00001B1C                          1855  PRINT_ASCII_1
00001B1C  43F9 00001C75           1856      LEA         ASCII_1,A1
00001B22  6000 008E               1857      BRA         PRINT_ASCII_CHAR
00001B26                          1858  PRINT_ASCII_2
00001B26  43F9 00001C77           1859      LEA         ASCII_2,A1
00001B2C  6000 0084               1860      BRA         PRINT_ASCII_CHAR
00001B30                          1861  PRINT_ASCII_3
00001B30  43F9 00001C79           1862      LEA         ASCII_3,A1
00001B36  6000 007A               1863      BRA         PRINT_ASCII_CHAR
00001B3A                          1864  PRINT_ASCII_4
00001B3A  43F9 00001C7B           1865      LEA         ASCII_4,A1
00001B40  6000 0070               1866      BRA         PRINT_ASCII_CHAR
00001B44                          1867  PRINT_ASCII_5
00001B44  43F9 00001C7D           1868      LEA         ASCII_5,A1
00001B4A  6000 0066               1869      BRA         PRINT_ASCII_CHAR
00001B4E                          1870  PRINT_ASCII_6
00001B4E  43F9 00001C7F           1871      LEA         ASCII_6,A1
00001B54  6000 005C               1872      BRA         PRINT_ASCII_CHAR
00001B58                          1873  PRINT_ASCII_7
00001B58  43F9 00001C81           1874      LEA         ASCII_7,A1
00001B5E  6000 0052               1875      BRA         PRINT_ASCII_CHAR
00001B62                          1876  PRINT_ASCII_8
00001B62  43F9 00001C83           1877      LEA         ASCII_8,A1
00001B68  6000 0048               1878      BRA         PRINT_ASCII_CHAR
00001B6C                          1879  PRINT_ASCII_9
00001B6C  43F9 00001C85           1880      LEA         ASCII_9,A1
00001B72  6000 003E               1881      BRA         PRINT_ASCII_CHAR
00001B76                          1882  PRINT_ASCII_A
00001B76  43F9 00001C87           1883      LEA         ASCII_A,A1
00001B7C  6000 0034               1884      BRA         PRINT_ASCII_CHAR
00001B80                          1885  PRINT_ASCII_B
00001B80  43F9 00001C89           1886      LEA         ASCII_B,A1
00001B86  6000 002A               1887      BRA         PRINT_ASCII_CHAR
00001B8A                          1888  PRINT_ASCII_C
00001B8A  43F9 00001C8B           1889      LEA         ASCII_C,A1
00001B90  6000 0020               1890      BRA         PRINT_ASCII_CHAR
00001B94                          1891  PRINT_ASCII_D
00001B94  43F9 00001C8D           1892      LEA         ASCII_D,A1
00001B9A  6000 0016               1893      BRA         PRINT_ASCII_CHAR
00001B9E                          1894  PRINT_ASCII_E
00001B9E  43F9 00001C8F           1895      LEA         ASCII_E,A1
00001BA4  6000 000C               1896      BRA         PRINT_ASCII_CHAR
00001BA8                          1897  PRINT_ASCII_F
00001BA8  43F9 00001C91           1898      LEA         ASCII_F,A1
00001BAE  6000 0002               1899      BRA         PRINT_ASCII_CHAR
00001BB2                          1900  PRINT_ASCII_CHAR
00001BB2  103C 000E               1901      MOVE.B      #14,D0
00001BB6  4E4F                    1902      TRAP        #15
00001BB8                          1903      
00001BB8  5205                    1904      ADD.B       #1,D5 * loop until counter stops
00001BBA  BA06                    1905      CMP.B       D6,D5
00001BBC  6C00 000C               1906      BGE         PRINT_ASCII_FINISH
00001BC0                          1907      
00001BC0  4287                    1908      CLR.L       D7
00001BC2  4CDF 0080               1909      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001BC6                          1910      
00001BC6  6000 FE8A               1911      BRA         PRINT_ASCII_LOOP
00001BCA                          1912  INVALID_ASCII_INPUT
00001BCA                          1913  PRINT_ASCII_FINISH
00001BCA  4CDF 3FFF               1914      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001BCE  4E75                    1915      RTS
00001BD0                          1916  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001BD0                          1917  *-----------------------------------------------------------------------------
00001BD0                          1918  
00001BD0                          1919  
00001BD0                          1920  
00001BD0                          1921  *-----------------------------------------------------------------------------
00001BD0                          1922  *-----------------------------------------------------------------------------
00001BD0                          1923  * NAME: Bitmask
00001BD0                          1924  * DESCRIPTION:    Masks bits in a data register.
00001BD0                          1925  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001BD0                          1926  *                 the ending bit.  For example, a starting bit of decimal
00001BD0                          1927  *                 value 0 and an ending bit of decimal value 3 will mask the
00001BD0                          1928  *                 bits 0, 1, 2, and 3.
00001BD0                          1929  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001BD0                          1930  * REGISTERS:      D5,D6,D7
00001BD0                          1931  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001BD0                          1932  BITMASK
00001BD0  3F05                    1933          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001BD2  4245                    1934          CLR     D5          * clear D5 so we can use it
00001BD4                          1935  LOOPBIT 
00001BD4  0DC5                    1936          BSET    D6,D5       * set the D6th bit in D5 to 1
00001BD6  5246                    1937          ADD     #1,D6       * increment D6
00001BD8                          1938  
00001BD8  BC47                    1939          CMP     D7,D6       * have we finished?
00001BDA  6E00 0004               1940          BGT     BITMASKDONE * yes
00001BDE  60F4                    1941          BRA     LOOPBIT     * no, iterate again
00001BE0                          1942  
00001BE0                          1943  BITMASKDONE
00001BE0  2C05                    1944          MOVE.L  D5,D6
00001BE2  3A1F                    1945          MOVE    (A7)+,D5    * restore D5
00001BE4  4E75                    1946          RTS
00001BE6                          1947  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001BE6                          1948  *-----------------------------------------------------------------------------
00001BE6                          1949  
00001BE6                          1950  
00001BE6                          1951  
00001BE6                          1952  *-----------------------------------------------------------------------------
00001BE6                          1953  *-----------------------------------------------------------------------------
00001BE6                          1954  * SECTION: Constants/variables used throughout the program.
00001BE6                          1955  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001BE6                          1956  * ---> GENERAL
00001BE6  =0000000D               1957  CR          EQU     $0D
00001BE6  =0000000A               1958  LF          EQU     $0A
00001BE6= 45 4E 54 45 52 20 ...   1959  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001BFE= 45 4E 54 45 52 20 ...   1960  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001C14= 0D 0A 00                1961  NEWLINE     DC.B    CR,LF,0
00001C17                          1962  * ---> OPS
00001C17= 44 49 56 53 00          1963  DIVSOP      DC.B    'DIVS',0
00001C1C= 4E 4F 50 00             1964  NOOPERATION DC.B    'NOP',0
00001C20= 4E 45 47 00             1965  NEGOP       DC.B    'NEG',0
00001C24= 4D 4F 56 45 00          1966  MOVEOP      DC.B    'MOVE',0
00001C29= 4D 4F 56 45 4D 00       1967  MOVEMOP     DC.B    'MOVEM',0
00001C2F= 4A 53 52 00             1968  JSROP       DC.B    'JSR',0
00001C33= 52 54 53 00             1969  RTSOP       DC.B    'RTS',0
00001C37= 4C 45 41 00             1970  LEAOP       DC.B    'LEA',0
00001C3B= 42 43 4C 52 20 00       1971  BCLROP      DC.B    'BCLR ',0
00001C41= 4F 52 00                1972  OROP        DC.B    'OR',0
00001C44= 4F 52 49 00             1973  ORIOP       DC.B    'ORI',0
00001C48= 43 4D 50 49 00          1974  CMPIOP      DC.B    'CMPI',0
00001C4D= 20 44 41 54 41 20 ...   1975  DATA        DC.B    ' DATA $',0
00001C55= 42 43 43 20 00          1976  OP_BCC_MSG  DC.B    'BCC ',0
00001C5A= 42 43 53 20 00          1977  OP_BCS_MSG  DC.B    'BCS ',0
00001C5F= 42 47 45 20 00          1978  OP_BGE_MSG  DC.B    'BGE ',0
00001C64= 42 4C 54 20 00          1979  OP_BLT_MSG  DC.B    'BLT ',0
00001C69= 42 56 43 20 00          1980  OP_BVC_MSG  DC.B    'BVC ',0
00001C6E= 42 52 41 20 00          1981  OP_BRA_MSG  DC.B    'BRA ',0
00001C73                          1982  * ---> HEX CHARS
00001C73= 30 00                   1983  ASCII_0     DC.B    '0',0
00001C75= 31 00                   1984  ASCII_1     DC.B    '1',0
00001C77= 32 00                   1985  ASCII_2     DC.B    '2',0
00001C79= 33 00                   1986  ASCII_3     DC.B    '3',0
00001C7B= 34 00                   1987  ASCII_4     DC.B    '4',0
00001C7D= 35 00                   1988  ASCII_5     DC.B    '5',0
00001C7F= 36 00                   1989  ASCII_6     DC.B    '6',0
00001C81= 37 00                   1990  ASCII_7     DC.B    '7',0
00001C83= 38 00                   1991  ASCII_8     DC.B    '8',0
00001C85= 39 00                   1992  ASCII_9     DC.B    '9',0
00001C87= 41 00                   1993  ASCII_A     DC.B    'A',0
00001C89= 42 00                   1994  ASCII_B     DC.B    'B',0
00001C8B= 43 00                   1995  ASCII_C     DC.B    'C',0
00001C8D= 44 00                   1996  ASCII_D     DC.B    'D',0
00001C8F= 45 00                   1997  ASCII_E     DC.B    'E',0
00001C91= 46 00                   1998  ASCII_F     DC.B    'F',0
00001C93                          1999  * ---> SPECIAL CHARACTERS
00001C93= 20 00                   2000  SPACE       DC.B    ' ',0
00001C95= 24 00                   2001  DOLLAR      DC.B    '$',0
00001C97= 23 00                   2002  IMD         DC.B    '#',0
00001C99= 2C 00                   2003  COMMA       DC.B    ',',0
00001C9B= 28 00                   2004  OBRACK      DC.B    '(',0
00001C9D= 29 00                   2005  CBRACK      DC.B    ')',0
00001C9F= 2B 00                   2006  PLUS        DC.B    '+',0
00001CA1= 2D 00                   2007  MINUS       DC.B    '-',0
00001CA3                          2008  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001CA3= 2E 42 20 00             2009  __B         DC.B    '.B ',0
00001CA7= 2E 57 20 00             2010  __W         DC.B    '.W ',0
00001CAB= 2E 4C 20 00             2011  __L         DC.B    '.L ',0
00001CAF                          2012  * ---> ADDRESS REGISTERS A0-A7
00001CAF= 41 30 00                2013  __A0        DC.B   'A0',0
00001CB2= 41 31 00                2014  __A1        DC.B   'A1',0    
00001CB5= 41 32 00                2015  __A2        DC.B   'A2',0
00001CB8= 41 33 00                2016  __A3        DC.B   'A3',0
00001CBB= 41 34 00                2017  __A4        DC.B   'A4',0
00001CBE= 41 35 00                2018  __A5        DC.B   'A5',0
00001CC1= 41 36 00                2019  __A6        DC.B   'A6',0
00001CC4= 41 37 00                2020  __A7        DC.B   'A7',0
00001CC7                          2021  * ---> DATA REGISTERS D0-D7
00001CC7= 44 30 00                2022  __D0        DC.B   'D0',0
00001CCA= 44 31 00                2023  __D1        DC.B   'D1',0
00001CCD= 44 32 00                2024  __D2        DC.B   'D2',0
00001CD0= 44 33 00                2025  __D3        DC.B   'D3',0
00001CD3= 44 34 00                2026  __D4        DC.B   'D4',0
00001CD6= 44 35 00                2027  __D5        DC.B   'D5',0
00001CD9= 44 36 00                2028  __D6        DC.B   'D6',0
00001CDC= 44 37 00                2029  __D7        DC.B   'D7',0
00001CDF                          2030  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001CDF                          2031  *-----------------------------------------------------------------------------
00001CDF                          2032  
00001CDF                          2033  
00001CDF                          2034  
00001CDF                          2035  *-----------------------------------------------------------------------------
00001CDF                          2036  *-----------------------------------------------------------------------------
00001CDF                          2037  * SECTION: Sample program to run, then attempt testing disassembly on.
00001CDF                          2038  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2039      ORG $4000
00004000                          2040  
00004000  4E71                    2041      NOP
00004002  103C 009A               2042      MOVE.B   #%10011010, D0
00004006  123C 00A9               2043      MOVE.B   #%10101001, D1
0000400A  D200                    2044      ADD.B    D0,D1
0000400C  48A7 4000               2045      MOVEM    D1,-(A7)
00004010  43F8 1C2F               2046      LEA      JSROP,A1
00004014  4467                    2047      NEG.W    -(A7)
00004016  4EB9 00004020           2048      JSR      END
0000401C  81FC 0001               2049      DIVS    #1, D0
00004020                          2050  
00004020                          2051  END
00004020  4E75                    2052      RTS
00004022                          2053  RLLYEND
00004022                          2054      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1C73
ASCII_1             1C75
ASCII_2             1C77
ASCII_3             1C79
ASCII_4             1C7B
ASCII_5             1C7D
ASCII_6             1C7F
ASCII_7             1C81
ASCII_8             1C83
ASCII_9             1C85
ASCII_A             1C87
ASCII_B             1C89
ASCII_C             1C8B
ASCII_D             1C8D
ASCII_E             1C8F
ASCII_F             1C91
BCC_END             150C
BCLROP              1C3B
BITMASK             1BD0
BITMASKDONE         1BE0
CBRACK              1C9D
CMPIBYTE            11D6
CMPIEA              124A
CMPILONG            1224
CMPIOP              1C48
CMPIREG             1296
CMPIREG000          12BA
CMPIREG001          12BA
CMPIWORD            11FE
COMMA               1C99
CR                  D
DATA                1C4D
DIVSOP              1C17
DOLLAR              1C95
DONE                144E
EAHELPER05          1688
EAHELPER611         15BA
END                 4020
END0000             12B4
END67               1990
ENDEAHELPER05       174C
ENDEAHELPER611      1682
ENDMODE_AN          18DC
ENDMODE_DN          17DC
ENDOP0001           1312
HEX_VALUE_MASK_LONG  F
IMD                 1C97
INVALID_ASCII_INPUT  1BCA
ISCMPI              119C
ISORI               119C
ITERATION           1144
JSROP               1C2F
LEAOP               1C37
LF                  A
LOOP                103A
LOOPBIT             1BD4
LOOPUNKNOWNOP       1140
MINUS               1CA1
MODE_AN             1852
MODE_DN             1752
MOVEMOP             1C29
MOVEOP              1C24
MSGEND              1BFE
MSGSTART            1BE6
NEGOP               1C20
NEWLINE             1C14
NOOPERATION         1C1C
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           1974
NOT67WORD           1984
NOTA0               1874
NOTA1               1884
NOTA2               1894
NOTA3               18A4
NOTA4               18B4
NOTA5               18C4
NOTA6               18D4
NOTADRDIRECT        16B8
NOTADRINDIRECT      16E0
NOTADRINDIRECTPOST  1714
NOTADRINDIRECTPRE   1748
NOTBCLR             117A
NOTD0               1774
NOTD1               1784
NOTD2               1794
NOTD3               17A4
NOTD4               17B4
NOTD5               17C4
NOTD6               17D4
NOTDATAREG          16A8
NOTDIVS             157A
NOTIMMBYTE          1602
NOTIMMEDIATE        1658
NOTIMMWORD          1630
NOTJSR              1404
NOTMOVEM            13C2
NOTNEG              139E
NOTNOP              1348
NOTRTS              1426
OBRACK              1C9B
OP0000              1150
OP0001              12BA
OP0010              1318
OP0011              131E
OP0100              132C
OP0101              1458
OP0110              145E
OP0111              1512
OP1000              1518
OP1000END           158A
OP1001              1590
OP1010              1596
OP1011              159C
OP1100              15A2
OP1101              15A8
OP1110              15AE
OP1111              15B4
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              14AE
OP_BCC_MSG          1C55
OP_BCS              14B8
OP_BCS_MSG          1C5A
OP_BGE              14C2
OP_BGE_MSG          1C5F
OP_BLT              14CC
OP_BLT_MSG          1C64
OP_BRA              14E0
OP_BRANCHES_PRINT   14EA
OP_BRA_MSG          1C6E
OP_BVC              14D6
OP_BVC_MSG          1C69
ORIOP               1C44
OROP                1C41
PLUS                1C9F
PRINTA0             18E2
PRINTA1             18F0
PRINTA2             18FE
PRINTA3             190C
PRINTA4             191A
PRINTA5             1928
PRINTA6             1936
PRINTA7             1944
PRINTBYTE           19EE
PRINTD0             17E2
PRINTD1             17F0
PRINTD2             17FE
PRINTD3             180C
PRINTD4             181A
PRINTD5             1828
PRINTD6             1836
PRINTD7             1844
PRINTLONG           1A0A
PRINTWORD           19FC
PRINT_ASCII_0       1B12
PRINT_ASCII_1       1B1C
PRINT_ASCII_2       1B26
PRINT_ASCII_3       1B30
PRINT_ASCII_4       1B3A
PRINT_ASCII_5       1B44
PRINT_ASCII_6       1B4E
PRINT_ASCII_7       1B58
PRINT_ASCII_8       1B62
PRINT_ASCII_9       1B6C
PRINT_ASCII_A       1B76
PRINT_ASCII_B       1B80
PRINT_ASCII_C       1B8A
PRINT_ASCII_CHAR    1BB2
PRINT_ASCII_D       1B94
PRINT_ASCII_E       1B9E
PRINT_ASCII_F       1BA8
PRINT_ASCII_FINISH  1BCA
PRINT_ASCII_HEX_CHAR  1A42
PRINT_ASCII_LOOP    1A52
RLLYEND             4022
RTSOP               1C33
SIZE67              1952
SIZE68              1996
SPACE               1C93
START               1000
UNKNOWN             144A
UNKNOWNOP           1A18
UNKNOWNOP0001       130E
__A0                1CAF
__A1                1CB2
__A2                1CB5
__A3                1CB8
__A4                1CBB
__A5                1CBE
__A6                1CC1
__A7                1CC4
__B                 1CA3
__D0                1CC7
__D1                1CCA
__D2                1CCD
__D3                1CD0
__D4                1CD3
__D5                1CD6
__D6                1CD9
__D7                1CDC
__L                 1CAB
__W                 1CA7
