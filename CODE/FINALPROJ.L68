00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 2:43:24 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001F88             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001FA0             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001FB6             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0F3A                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 01EC                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 0242                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 0238                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 0236                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 041C                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 047A                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 051E                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 0514                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 0598                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 0588                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 057E                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 0574                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 05EE                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 05E4                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 076A                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 0BC6                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2EFC                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 FFC0                212          MOVEM   D0-D7/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0E14                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162                           218          * TODO: Consider static  AND dynamic BCLR.
00001162                           219          * Only works for Dynamic right now
00001162  0C46 0180                220          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0066                221          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           222          
0000116A  3C3C 0003                223          MOVE.W  #3, D6              * Prep lower value for bitmask
0000116E  3E3C 0005                224          MOVE.W  #5, D7              * Prep upper value for bitmask
00001172  6100 0DFE                225          BSR     BITMASK             * Finalize bitmask setup
00001176  CC42                     226          AND     D2,D6               * Apply bitmask
00001178                           227          
00001178                           228          * Checking for unsupported mode
00001178  0C46 0008                229          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000117C  6700 00BE                230          BEQ     UNKNOWN0000             * If so, branch to other OP0000 functions
00001180                           231          
00001180                           232          * Confirmed BCLR at this point
00001180  43F9 00001FE2            233          LEA     BCLROP,A1           * We found BCLR
00001186  103C 000E                234          MOVE.B  #14,D0              * Trap #14 prints out the data
0000118A  4E4F                     235          TRAP    #15                 * Perform Trap #14
0000118C                           236  
0000118C  43F9 00002057            237          LEA     SPACE,A1            * Formatting
00001192  103C 000E                238          MOVE.B  #14,D0              * Trap #14 prints out space
00001196  4E4F                     239          TRAP    #15                 * Perform Trap #14
00001198                           240          
00001198                           241          * Set up for printing out the Register
00001198  0882 0006                242          BCLR    #6,D2               * Clear bit 6
0000119C  0882 0007                243          BCLR    #7,D2               * Clear bit 7
000011A0  0882 0008                244          BCLR    #8,D2               * Clear bit 8
000011A4                           245          
000011A4  6100 0704                246          BSR     EAHELPER611         * Print out Register
000011A8                           247  
000011A8  43F9 0000205D            248          LEA     COMMA,A1            * formatting
000011AE  103C 000E                249          MOVE.B  #14,D0              * Trap #14 prints out a comma
000011B2  4E4F                     250          TRAP    #15                 * Perform Trap #14
000011B4                           251          
000011B4  4243                     252          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000011B6  08C3 0000                253          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000011BA                           254      
000011BA  6100 0730                255          BSR     EAHELPER05          * Print out data.
000011BE                           256          
000011BE  43F9 00001FB6            257          LEA     NEWLINE,A1          * Formatting
000011C4  103C 000E                258          MOVE.B  #14,D0              * Trap #14 prints out the data
000011C8  4E4F                     259          TRAP    #15                 * Perform Trap #14
000011CA                           260          
000011CA  6000 0074                261          BRA     END0000             * Found the op, move to next iteration
000011CE                           262          
000011CE                           263  NOTBCLR * Possible options left are ORI or CMPI
000011CE  3C3C 0009                264          MOVE.W  #9, D6              * Prep lower value for bitmask
000011D2  3E3C 000B                265          MOVE.W  #11, D7             * Prep upper value for bitmask
000011D6  6100 0D9A                266          BSR     BITMASK             * Finalize bitmask setup
000011DA  CC42                     267          AND     D2,D6               * Apply bitmask
000011DC                           268          
000011DC  0C46 0000                269          CMPI    #%0000000000000000, D6   * Are we possibly ORI?
000011E0  6600 0052                270          BNE     NOTORI                   * If not, branch to NOTORI
000011E4                           271          
000011E4                           272          * Size check to see if unsupported ORI mode
000011E4  3C3C 0006                273          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E8  3E3C 0007                274          MOVE.W  #7, D7              * Prep upper value for bitmask
000011EC  6100 0D84                275          BSR     BITMASK             * Finalize bitmask setup
000011F0  CC42                     276          AND     D2,D6               * Apply bitmask
000011F2                           277          
000011F2  0C46 00C0                278          CMPI    #%0000000011000000, D6  * Are bits 6,7 == 1,1?
000011F6  6700 0044                279          BEQ     UNKNOWN0000             * If so, unknown op. 
000011FA                           280          
000011FA                           281          * Mode check to see if unsupported ORI mode
000011FA  3C3C 0003                282          MOVE.W  #3, D6              * Prep lower value for bitmask
000011FE  3E3C 0005                283          MOVE.W  #5, D7              * Prep upper value for bitmask
00001202  6100 0D6E                284          BSR     BITMASK             * Finalize bitmask setup
00001206  CC42                     285          AND     D2,D6               * Apply bitmask
00001208                           286          
00001208  0C46 0008                287          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000120C  6700 002E                288          BEQ     UNKNOWN0000             * If so, unknown op. 
00001210                           289          
00001210                           290          * Confirmed ORI at this point
00001210                           291          * TODO: Get the immediate data following the instruction and print it out
00001210  43F9 00001FF0            292          LEA     ORIOP, A1           * Load 'ORI' into the output window
00001216  103C 000E                293          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
0000121A  4E4F                     294          TRAP    #15                 * Perform Trap #14
0000121C                           295          
0000121C  6100 0A24                296          BSR     SIZE67              * Print the size
00001220  6100 06CA                297          BSR     EAHELPER05          * Print out the EA
00001224                           298          
00001224  43F9 00001FB6            299          LEA     NEWLINE,A1          * Formatting
0000122A  103C 000E                300          MOVE.B  #14,D0              * Trap #14 prints out the data
0000122E  4E4F                     301          TRAP    #15                 * Perform Trap #14
00001230                           302          
00001230  6000 000E                303          BRA     END0000             * Done with op. Move to next iteration
00001234                           304          
00001234                           305  NOTORI  * Possible option left is CMPI
00001234  0C46 0C00                306          CMPI    #%0000110000000000, D6  * Are we CMPI?
00001238  6600 0002                307          BNE     UNKNOWN0000             * If not, unknown op
0000123C                           308          
0000123C                           309          * TODO: Continue checking for CMPI validity
0000123C                           310          
0000123C                           311  UNKNOWN0000
0000123C  6100 0ACA                312          BSR     UNKNOWNOP       * Unknown op
00001240                           313          
00001240                           314  END0000          
00001240  4C9F 03FF                315         MOVEM   (A7)+,D0-D7/A0-A1   * Push values to the stack to save
00001244  4E75                     316         RTS
00001246                           317  
00001246                           318  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001246                           319  *-----------------------------------------------------------------------------
00001246                           320  
00001246                           321  
00001246                           322  
00001246                           323  *-----------------------------------------------------------------------------
00001246                           324  *-----------------------------------------------------------------------------
00001246                           325  * NAME: OP_0001   (MOVE.B)
00001246                           326  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001246                           327  * PRE-CONDITION:  xyz
00001246                           328  * POST-CONDITION: All registers return to their previous state, and the output
00001246                           329  *                 goes to the output console for reading the raw data or the
00001246                           330  *                 actual instruction.
00001246                           331  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001246                           332  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001246                           333  OP0001  
00001246  48A7 FFC0                334          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
0000124A  3C3C 0006                335          MOVE.W  #6, D6              * Prep lower value for bitmask
0000124E  3E3C 0008                336          MOVE.W  #8, D7              * Prep upper value for bitmask
00001252  6100 0D1E                337          BSR     BITMASK             * Finalize bitmask setup
00001256  CC42                     338          AND     D2,D6               * Apply bitmask
00001258                           339          
00001258                           340          * I may have fucked off this part, sorry - Caleb
00001258                           341          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
00001258                           342          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
00001258                           343          
00001258  43F9 00001FC6            344          LEA     MOVEOP,A1   * Put 'MOVE' into the window
0000125E  103C 000E                345          MOVE.B  #14,D0      * Trap #14 to print out
00001262  4E4F                     346          TRAP    #15         * Perform Trap #14
00001264                           347          
00001264                           348          *-----------------------------------------------------------
00001264                           349          * the following code is to move the size bits into the
00001264                           350          * 0-1 positions of D3 so that eahelper05 case use that as a "parameter"
00001264                           351          * for eahelper05
00001264                           352          
00001264  3C3C 000C                353          MOVE.W  #12, D6              * Prep lower value for bitmask
00001268  3E3C 000D                354          MOVE.W  #13, D7              * Prep upper value for bitmask
0000126C  6100 0D04                355          BSR     BITMASK             * Finalize bitmask setup
00001270                           356          
00001270  CC42                     357          AND     D2,D6
00001272                           358          
00001272  E04E                     359          LSR     #8,D6
00001274  E84E                     360          LSR     #4,D6
00001276                           361          
00001276  4243                     362          CLR     D3
00001278                           363          
00001278  1606                     364          MOVE.B  D6,D3
0000127A                           365          
0000127A                           366          *---------------------------------------------------------------
0000127A                           367          
0000127A                           368          
0000127A  6100 09C6                369          BSR     SIZE67
0000127E  6100 066C                370          BSR     EAHELPER05
00001282                           371          
00001282  43F9 0000205D            372          LEA     COMMA,A1
00001288  103C 000E                373          MOVE.B  #14,D0
0000128C  4E4F                     374          TRAP    #15
0000128E                           375          
0000128E  6100 061A                376          BSR     EAHELPER611
00001292                           377          
00001292  43F9 00001FB6            378          LEA     NEWLINE,A1
00001298  103C 000E                379          MOVE.B  #14,D0
0000129C  4E4F                     380          TRAP    #15
0000129E                           381          
0000129E  6000 0006                382          BRA     ENDOP0001
000012A2                           383          *LEA     __B,A1      * Put '.B' into the window
000012A2                           384          *MOVE.B  #14,D0      * Trap #14 to print out
000012A2                           385          *TRAP    #15         * Perform Trap #14
000012A2                           386          
000012A2                           387  UNKNOWNOP0001
000012A2                           388  
000012A2  6100 0A64                389          BSR     UNKNOWNOP
000012A6                           390          
000012A6                           391  ENDOP0001
000012A6                           392  
000012A6  4C9F 03FF                393          MOVEM (A7)+,D0-D7/A0-A1
000012AA  4E75                     394          RTS        
000012AC                           395          
000012AC                           396          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
000012AC                           397  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012AC                           398  *-----------------------------------------------------------------------------
000012AC                           399  
000012AC                           400  
000012AC                           401  
000012AC                           402  *-----------------------------------------------------------------------------
000012AC                           403  *-----------------------------------------------------------------------------
000012AC                           404  * NAME: OP_0010   (MOVE.L, MOVEA.L)
000012AC                           405  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012AC                           406  * PRE-CONDITION:  xyz
000012AC                           407  * POST-CONDITION: All registers return to their previous state, and the output
000012AC                           408  *                 goes to the output console for reading the raw data or the
000012AC                           409  *                 actual instruction.
000012AC                           410  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012AC                           411  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012AC                           412  OP0010
000012AC                           413  
000012AC  6100 0A5A                414      BSR     UNKNOWNOP
000012B0  4E75                     415      RTS
000012B2                           416  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012B2                           417  *-----------------------------------------------------------------------------
000012B2                           418  
000012B2                           419  
000012B2                           420  
000012B2                           421  *-----------------------------------------------------------------------------
000012B2                           422  *-----------------------------------------------------------------------------
000012B2                           423  * NAME: OP_0011   (MOVE.W, MOVEA.W)
000012B2                           424  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012B2                           425  * PRE-CONDITION:  xyz
000012B2                           426  * POST-CONDITION: All registers return to their previous state, and the output
000012B2                           427  *                 goes to the output console for reading the raw data or the
000012B2                           428  *                 actual instruction.
000012B2                           429  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012B2                           430  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012B2                           431  OP0011
000012B2  48A7 FFFE                432      MOVEM   D0-D7/A0-A6, -(A7)
000012B6                           433      
000012B6                           434      *MOVE.W  #6,D6
000012B6                           435      *MOVE.W  #8,D7
000012B6                           436      
000012B6                           437      *BSR     BITMASK
000012B6                           438      
000012B6                           439      *AND.W   D2,D6
000012B6                           440      
000012B6                           441      *CMP     #%0000000001000000,D6
000012B6                           442      *BNE     NEXT15
000012B6                           443      *BSR     * for MOVEA.W
000012B6                           444      
000012B6  4C9F 7FFF                445      MOVEM   (A7)+,D0-D7/A0-A6
000012BA                           446      
000012BA  6100 0A4C                447      BSR     UNKNOWNOP
000012BE  4E75                     448      RTS
000012C0                           449  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012C0                           450  *-----------------------------------------------------------------------------
000012C0                           451  
000012C0                           452  
000012C0                           453  
000012C0                           454  *-----------------------------------------------------------------------------
000012C0                           455  *-----------------------------------------------------------------------------
000012C0                           456  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
000012C0                           457  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012C0                           458  * PRE-CONDITION:  xyz
000012C0                           459  * POST-CONDITION: All registers return to their previous state, and the output
000012C0                           460  *                 goes to the output console for reading the raw data or the
000012C0                           461  *                 actual instruction.
000012C0                           462  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012C0                           463  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012C0                           464  OP0100  
000012C0                           465          * TODO: movem
000012C0                           466  
000012C0  48A7 C0C0                467          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000012C4                           468          
000012C4                           469          *NOP
000012C4  0C42 4E71                470          CMPI    #%0100111001110001,D2
000012C8  6600 0012                471          BNE     NOTNOP
000012CC                           472          
000012CC  43F9 00001FBE            473          LEA     NOOPERATION,A1
000012D2  103C 000D                474          MOVE.B  #13,D0          * Print a newline
000012D6  4E4F                     475          TRAP    #15
000012D8                           476          
000012D8  6000 01D2                477          BRA     DONE0100 *we found it, move on to the next iteration
000012DC                           478  NOTNOP *NEG
000012DC                           479          
000012DC                           480          * prep values for BITMASK subroutine
000012DC  7C08                     481          MOVE.L  #8,D6
000012DE  7E0B                     482          MOVE.L  #11,D7
000012E0                           483          
000012E0  6100 0C90                484          BSR     BITMASK
000012E4                           485          
000012E4  CC42                     486          AND     D2,D6                   * apply bitmask
000012E6                           487          
000012E6  0C46 0400                488          CMPI    #%0000010000000000,D6   * are we NEG?
000012EA  6600 0046                489          BNE     NOTNEG                  * not neg
000012EE                           490          
000012EE  7C03                     491          MOVE.L  #3,D6
000012F0  7E05                     492          MOVE.L  #5,D7
000012F2                           493          
000012F2  6100 0C7E                494          BSR     BITMASK * generate a bitmask to be used to check mode
000012F6                           495          
000012F6  0C46 0008                496          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
000012FA  6700 01AC                497          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
000012FE                           498          
000012FE  0C46 0028                499          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001302  6700 01A4                500          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
00001306                           501          
00001306  0C46 0030                502          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000130A  6700 019C                503          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
0000130E                           504        
0000130E                           505          * it is NEG, print
0000130E  43F9 00001FC2            506          LEA     NEGOP,A1
00001314  103C 000E                507          MOVE.B  #14,D0
00001318  4E4F                     508          TRAP    #15
0000131A                           509          
0000131A  6100 0926                510          BSR     SIZE67
0000131E                           511          
0000131E  6100 05CC                512          BSR     EAHELPER05
00001322                           513          
00001322  43F9 00001FB6            514          LEA     NEWLINE,A1
00001328  103C 000E                515          MOVE.B  #14,D0
0000132C  4E4F                     516          TRAP    #15
0000132E                           517          
0000132E  6000 017C                518          BRA     DONE0100 * we found the op, move to next iteration
00001332                           519          
00001332                           520  NOTNEG *MOVEM
00001332                           521  
00001332                           522          * prep values for BITMASK subroutine
00001332  7C07                     523          MOVE.L  #7,D6
00001334  7E09                     524          MOVE.L  #9,D7
00001336                           525          
00001336  6100 0C3A                526          BSR     BITMASK
0000133A                           527          
0000133A  CC42                     528          AND     D2,D6   * apply bitmask
0000133C                           529          
0000133C  0C46 0080                530          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001340  6600 0014                531          BNE     NOTMOVEM          * it is not MOVEM
00001344                           532          
00001344                           533          * make sure it is a valid size and mode for MOVEM
00001344                           534          
00001344                           535          * it is MOVEM
00001344  43F9 00001FCB            536          LEA     MOVEMOP,A1
0000134A  103C 000D                537          MOVE.B  #13,D0          * Print a newline
0000134E  4E4F                     538          TRAP    #15
00001350                           539          
00001350                           540          * probably needs its own special code for printing the rest due to uniqueness of movem
00001350                           541          
00001350  341A                     542          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001352                           543          
00001352  6000 0158                544          BRA     DONE0100          * we found and printed, move on to the next iteration
00001356                           545          
00001356                           546  NOTMOVEM *JSR
00001356                           547          * prep values for BITMASK subroutine
00001356  7C06                     548          MOVE.L  #6,D6
00001358  7E08                     549          MOVE.L  #8,D7
0000135A                           550          
0000135A  6100 0C16                551          BSR     BITMASK
0000135E                           552          
0000135E  CC42                     553          AND     D2,D6   * apply bitmask
00001360                           554          
00001360  0C46 0080                555          CMPI    #%0000000010000000,D6
00001364  6600 003E                556          BNE     NOTJSR          * it's not JSR
00001368                           557          
00001368  43F9 00001FD1            558          LEA     JSROP,A1
0000136E  103C 000E                559          MOVE.B  #14,D0          * Print a newline and JSR
00001372  4E4F                     560          TRAP    #15
00001374                           561          
00001374  43F9 00002057            562          LEA     SPACE,A1
0000137A  103C 000E                563          MOVE.B  #14,D0          * Print a newline and JSR
0000137E  4E4F                     564          TRAP    #15
00001380                           565          
00001380                           566          * print out where we are jumping to
00001380                           567          
00001380  341A                     568          MOVE.W  (A2)+,D2 * read in the next word of the instruction 
00001382                           569          
00001382  2202                     570          MOVE.L  D2,D1   * save the opcode to print
00001384                           571          
00001384  7410                     572          MOVE.L  #16,D2  * set the base to 16
00001386                           573          
00001386  700F                     574          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001388  4E4F                     575          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000138A                           576          
0000138A  341A                     577          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000138C                           578          
0000138C  2202                     579          MOVE.L  D2,D1   * save the opcode to print
0000138E                           580          
0000138E  7410                     581          MOVE.L  #16,D2  * set the base to 16
00001390                           582          
00001390  700F                     583          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001392  4E4F                     584          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001394                           585          
00001394  43F9 00001FB6            586          LEA     NEWLINE,A1
0000139A  103C 000E                587          MOVE.B  #14,D0          * Print a newline
0000139E  4E4F                     588          TRAP    #15
000013A0                           589          
000013A0  6000 010A                590          BRA     DONE0100          * we already found instruction, next iteration
000013A4                           591  NOTJSR *RTS
000013A4                           592  
000013A4                           593          * prep values for BITMASK subroutine
000013A4  7C06                     594          MOVE.L  #6,D6
000013A6  7E08                     595          MOVE.L  #8,D7
000013A8                           596          
000013A8  6100 0BC8                597          BSR     BITMASK
000013AC                           598          
000013AC  CC42                     599          AND     D2,D6   * apply bitmask
000013AE                           600          
000013AE  0C46 0040                601          CMPI    #%0000000001000000,D6
000013B2  6600 0012                602          BNE     NOTRTS          * it's not RTS
000013B6                           603          
000013B6  43F9 00001FD5            604          LEA     RTSOP,A1
000013BC  103C 000D                605          MOVE.B  #13,D0          * Print a newline and RTS
000013C0  4E4F                     606          TRAP    #15
000013C2                           607          
000013C2  6000 00E8                608          BRA     DONE0100          * we already found instruction, next iteration
000013C6                           609  NOTRTS  *LEA
000013C6                           610         
000013C6                           611          * prep values for BITMASK subroutine
000013C6  7C06                     612          MOVE.L  #6,D6
000013C8  7E08                     613          MOVE.L  #8,D7
000013CA                           614          
000013CA  6100 0BA6                615          BSR     BITMASK
000013CE                           616          
000013CE  CC42                     617          AND     D2,D6   * apply bitmask
000013D0                           618          
000013D0  0C46 01C0                619          CMPI    #%0000000111000000,D6
000013D4  6600 00D2                620          BNE     UNKNOWN0100          * it's not LEA, we dont know what it is
000013D8                           621          
000013D8                           622          * prep values for BITMASK subroutine
000013D8  7C03                     623          MOVE.L  #3,D6
000013DA  7E05                     624          MOVE.L  #5,D7
000013DC                           625          
000013DC  6100 0B94                626          BSR     BITMASK
000013E0                           627          
000013E0  CC42                     628          AND     D2,D6   * apply bitmask
000013E2                           629          
000013E2  0C46 0008                630          CMPI    #%0000000000001000,D6
000013E6  6700 00C0                631          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013EA                           632          
000013EA  0C46 0018                633          CMPI    #%0000000000011000,D6
000013EE  6700 00B8                634          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013F2                           635          
000013F2  0C46 0020                636          CMPI    #%0000000000100000,D6
000013F6  6700 00B0                637          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013FA                           638          
000013FA  0C46 0028                639          CMPI    #%0000000000101000,D6
000013FE  6700 00A8                640          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001402                           641          
00001402  0C46 0030                642          CMPI    #%0000000000110000,D6
00001406  6700 00A0                643          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
0000140A                           644          
0000140A  0C46 0038                645          CMPI    #%0000000000111000,D6
0000140E  6700 0046                646          BEQ     TWOWORDLEA          * it's not LEA, we dont know what it is
00001412                           647          
00001412                           648          * check to make sure it is a supported mode and size
00001412                           649          
00001412  43F9 00001FDE            650          LEA     LEAOP,A1
00001418  103C 000E                651          MOVE.B  #14,D0          * Print LEA
0000141C  4E4F                     652          TRAP    #15
0000141E                           653          
0000141E  0882 0007                654          BCLR    #7,D2
00001422  0882 0008                655          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001426                           656          
00001426  43F9 00002057            657          LEA     SPACE,A1
0000142C  103C 000E                658          MOVE.B  #14,D0          * Print SPACE
00001430  4E4F                     659          TRAP    #15
00001432                           660          
00001432  6100 04B8                661          BSR     EAHELPER05
00001436                           662          
00001436  43F9 0000205D            663          LEA     COMMA,A1
0000143C  103C 000E                664          MOVE.B  #14,D0          * Print COMMA
00001440  4E4F                     665          TRAP    #15
00001442                           666          
00001442  6100 0466                667          BSR     EAHELPER611
00001446                           668          
00001446  43F9 00001FB6            669          LEA     NEWLINE,A1
0000144C  103C 000E                670          MOVE.B  #14,D0          * Start a new line
00001450  4E4F                     671          TRAP    #15
00001452                           672          
00001452                           673          
00001452                           674          * call EA helper
00001452                           675          * MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001452                           676                  
00001452  6000 0058                677          BRA     DONE0100          * we already found instruction, next iteration
00001456                           678          
00001456                           679  TWOWORDLEA
00001456                           680  
00001456  43F9 00001FDE            681          LEA     LEAOP,A1
0000145C  103C 000E                682          MOVE.B  #14,D0   * Print LEA
00001460  4E4F                     683          TRAP    #15
00001462                           684          
00001462  43F9 00002057            685          LEA     SPACE,A1
00001468  103C 000E                686          MOVE.B  #14,D0   * Print SPACE
0000146C  4E4F                     687          TRAP    #15
0000146E                           688  
0000146E  321A                     689          MOVE.W  (A2)+,D1
00001470                           690          
00001470  7C00                     691          MOVE.L  #0,D6
00001472  7E0F                     692          MOVE.L  #15,D7
00001474                           693          
00001474  6100 0AFC                694          BSR     BITMASK
00001478                           695          
00001478  C286                     696          AND.L   D6,D1   * shave off bad info
0000147A                           697          
0000147A  103C 0003                698          MOVE.B  #3,D0   * Print the address which was the source
0000147E  4E4F                     699          TRAP    #15
00001480                           700          
00001480  43F9 0000205D            701          LEA     COMMA,A1
00001486  103C 000E                702          MOVE.B  #14,D0  * Print COMMA
0000148A  4E4F                     703          TRAP    #15
0000148C                           704          
0000148C  0882 0007                705          BCLR    #7,D2
00001490  0882 0008                706          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001494                           707          
00001494  6100 0414                708          BSR     EAHELPER611
00001498                           709          
00001498  43F9 00001FB6            710          LEA     NEWLINE,A1
0000149E  103C 000E                711          MOVE.B  #14,D0          * Start a new line
000014A2  4E4F                     712          TRAP    #15
000014A4                           713          
000014A4  6000 0006                714          BRA     DONE0100
000014A8                           715          
000014A8                           716  UNKNOWN0100 *dont know what it is
000014A8  6100 085E                717          BSR     UNKNOWNOP
000014AC                           718          
000014AC                           719  DONE0100
000014AC  4C9F 0303                720          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000014B0  4E75                     721          RTS
000014B2                           722          
000014B2  6000 FC90                723          BRA     ITERATION
000014B6                           724  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014B6                           725  *-----------------------------------------------------------------------------        
000014B6                           726          
000014B6                           727          
000014B6                           728  
000014B6                           729  *-----------------------------------------------------------------------------
000014B6                           730  *-----------------------------------------------------------------------------
000014B6                           731  * NAME: OP_0101   (SUBQ)
000014B6                           732  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000014B6                           733  * PRE-CONDITION:  xyz
000014B6                           734  * POST-CONDITION: All registers return to their previous state, and the output
000014B6                           735  *                 goes to the output console for reading the raw data or the
000014B6                           736  *                 actual instruction.
000014B6                           737  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000014B6                           738  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014B6                           739  OP0101
000014B6  48A7 FFC0                740          MOVEM   D0-D7/A0-A1,-(A7) * Push values to the stack to save
000014BA                           741  
000014BA  CC7C 0100                742          AND     #%0000000100000000, D6  * Baby-Bitmask for the 8th digit.
000014BE  0C46 0100                743          CMPI    #%0000000100000000, D6  * Is the 8th digit a 1?
000014C2  6700 005A                744          BEQ     UNKNOWN0101             * If so, unknown op
000014C6                           745        
000014C6  0C46 0100                746          CMPI    #%0000000100000000, D6  * Is the size 11, an unsupported value?
000014CA  6700 0052                747          BEQ     UNKNOWN0101             * If so, unknown op
000014CE                           748            
000014CE                           749          * Verified SUBQ at this point
000014CE  43F9 00001FD9            750          LEA     SUBQOP,A1           * Print out SUBQ
000014D4  103C 000E                751          MOVE.B  #14,D0              * Trap #14 to print out
000014D8  4E4F                     752          TRAP    #15                 * Perform Trap #14
000014DA                           753                          
000014DA  6100 0766                754          BSR     SIZE67              * Print out size
000014DE                           755          
000014DE  43F9 0000205B            756          LEA     IMD,A1              * Formatting
000014E4  103C 000E                757          MOVE.B  #14,D0              * Trap #14 prints out space
000014E8  4E4F                     758          TRAP    #15                 * Perform Trap #14
000014EA                           759          
000014EA  3C3C 0009                760          MOVE.W  #9, D6              * Prep lower value for bitmask
000014EE  3E3C 000B                761          MOVE.W  #11,D7              * Prep upper value for bitmask
000014F2  6100 0A7E                762          BSR     BITMASK             * Finalize bitmask setup
000014F6  CC42                     763          AND     D2,D6               * Apply bitmask
000014F8                           764          
000014F8  6100 09C6                765          BSR     PRINTDATA911        * Special op for immediate in bits 9->11
000014FC                           766            
000014FC  43F9 0000205D            767          LEA     COMMA,A1            * Formatting
00001502  103C 000E                768          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001506  4E4F                     769          TRAP    #15                 * Perform Trap #14
00001508                           770          
00001508  6100 03E2                771          BSR     EAHELPER05          * Print out the Effective Address
0000150C                           772          
0000150C  43F9 00001FB6            773          LEA     NEWLINE,A1          * Formatting
00001512  103C 000E                774          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001516  4E4F                     775          TRAP    #15                 * Perform Trap #14
00001518                           776          
00001518  4C9F 03FF                777          MOVEM   (A7)+,D0-D7/A0-A1   * Pop off the stack to return our registers
0000151C  4E75                     778          RTS
0000151E                           779      
0000151E                           780  UNKNOWN0101
0000151E  6100 07E8                781          BSR     UNKNOWNOP
00001522  4E75                     782          RTS
00001524                           783  
00001524                           784  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001524                           785  *-----------------------------------------------------------------------------
00001524                           786  
00001524                           787  
00001524                           788  
00001524                           789  *-----------------------------------------------------------------------------
00001524                           790  *-----------------------------------------------------------------------------
00001524                           791  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
00001524                           792  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001524                           793  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
00001524                           794  *                 in the instruction and determines what the bits match to a
00001524                           795  *                 given condition code. If the 8 bit offset is $00, or $FF,
00001524                           796  *                 this signifies a word or long offset (for $00 and $FF
00001524                           797  *                 respectively). The 8 bit offset is in 2's comp. form, and
00001524                           798  *                 should be un-done, then plus or minus to the current
00001524                           799  *                 program counter (PC) to get the actual memory label to
00001524                           800  *                 output to console. The word offset signal eats an
00001524                           801  *                 additional 16 bits and the long offset eats an additional
00001524                           802  *                 32 bits. The word/long offset are for memory alignment.
00001524                           803  * POST-CONDITION: All registers return to their previous state, and the output
00001524                           804  *                 goes to the output console for reading the raw data or the
00001524                           805  *                 actual instruction.
00001524                           806  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001524                           807  *                 A1 (output)
00001524                           808  * CONDITIONS TABLE:
00001524                           809  *                Condition Names  - Mnemonic - Condition Code
00001524                           810  *                --------------------------------------------
00001524                           811  *                True             -    T     - 0000
00001524                           812  *                False            -    F     - 0001
00001524                           813  *                Higher           -    HI    - 0010
00001524                           814  *                Lower or Same    -    LS    - 0011
00001524                           815  *                Carry Clear      -    CC    - 0100
00001524                           816  *                Carry Set        -    CS    - 0101
00001524                           817  *                Not Equal        -    NE    - 0110
00001524                           818  *                Equal            -    EQ    - 0111
00001524                           819  *                Overflow Clear   -    VC    - 1000
00001524                           820  *                Overflow Set     -    VS    - 1001
00001524                           821  *                Plus             -    PL    - 1010
00001524                           822  *                Minus            -    MI    - 1011
00001524                           823  *                Greater or Equal -    GE    - 1100
00001524                           824  *                Less Than        -    LT    - 1101
00001524                           825  *                Greater Than     -    GT    - 1110
00001524                           826  *                Less or Equal    -    LE    - 1111
00001524                           827  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001524                           828  OP0110
00001524  48A7 C0C0                829          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
00001528                           830          
00001528                           831          * Ready four bits to help distinguish op's with the 0110 prefix
00001528  3C3C 0000                832          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
0000152C                           833                                        * BITMASK sub-routine call)
0000152C  3E3C 0007                834          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001530                           835                                        * BITMASK sub-routine call)
00001530                           836                                        
00001530                           837          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001530  6100 0A40                838          BSR     BITMASK               * Call BITMASK sub-routine
00001534                           839                                        * Returns a bitmask in D6
00001534                           840          
00001534  CC42                     841          AND     D2,D6                 * And the index op, which was pre-loaded
00001536                           842                                        * in the main memory loop with the bitmask
00001536                           843                                        * to use to determine what case we need.
00001536                           844          
00001536                           845          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
00001536                           846          * $00 == word offset, $FF == long offset
00001536                           847       ***CMPI    #%0000000000000000,D6
00001536                           848       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
00001536                           849       ***
00001536                           850       ***CMPI    #%0000000011111111,D6
00001536                           851       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
00001536                           852          
00001536                           853          * IF PASSED BOTH CMPI CHECKS (ABOVE),
00001536                           854          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
00001536                           855          
00001536  3C3C 0009                856          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
0000153A  3E3C 000B                857          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
0000153E                           858                                        
0000153E                           859          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
0000153E  6100 0A32                860          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
00001542  CC42                     861          AND     D2,D6   * apply the BITMASK
00001544                           862          
00001544                           863          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001544  0C46 0400                864          CMPI    #%0000010000000000,D6
00001548  6700 002A                865          BEQ     OP_BCC
0000154C                           866          
0000154C                           867          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
0000154C  0C46 0500                868          CMPI    #%0000010100000000,D6
00001550  6700 002C                869          BEQ     OP_BCS
00001554                           870          
00001554                           871          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001554  0C46 0C00                872          CMPI    #%0000110000000000,D6
00001558  6700 002E                873          BEQ     OP_BGE
0000155C                           874          
0000155C                           875          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
0000155C  0C46 0D00                876          CMPI    #%0000110100000000,D6
00001560  6700 0030                877          BEQ     OP_BLT
00001564                           878          
00001564                           879          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
00001564  0C46 0800                880          CMPI    #%0000100000000000,D6
00001568  6700 0032                881          BEQ     OP_BVC
0000156C                           882          
0000156C                           883          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
0000156C                           884          * NOTE: A branch to the immediately following instruction automatically
0000156C                           885          *       uses the 16-bit displacement format because the 8-bit displacement
0000156C                           886          *       field contains $00 zero offset
0000156C                           887          * http://68k.hax.com/BRA
0000156C                           888          * NOTE2 ---> Does this mean, there should be no checks when debugging
0000156C                           889          *            for word/long offsets?
0000156C  0C46 0000                890          CMPI    #%0000000000000000,D6
00001570  6700 0034                891          BEQ     OP_BRA
00001574                           892          
00001574                           893          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
00001574                           894          ; call raw data print out sub routine
00001574                           895  
00001574                           896  OP_BCC
00001574  43F9 00002019            897          LEA     OP_BCC_MSG,A1
0000157A  6000 0034                898          BRA     OP_BRANCHES_PRINT
0000157E                           899  OP_BCS
0000157E  43F9 0000201E            900          LEA     OP_BCS_MSG,A1
00001584  6000 002A                901          BRA     OP_BRANCHES_PRINT
00001588                           902  OP_BGE
00001588  43F9 00002023            903          LEA     OP_BGE_MSG,A1
0000158E  6000 0020                904          BRA     OP_BRANCHES_PRINT
00001592                           905  OP_BLT
00001592  43F9 00002028            906          LEA     OP_BLT_MSG,A1
00001598  6000 0016                907          BRA     OP_BRANCHES_PRINT
0000159C                           908  OP_BVC
0000159C  43F9 0000202D            909          LEA     OP_BVC_MSG,A1
000015A2  6000 000C                910          BRA     OP_BRANCHES_PRINT
000015A6                           911  OP_BRA
000015A6  43F9 00002032            912          LEA     OP_BRA_MSG,A1
000015AC  6000 0002                913          BRA     OP_BRANCHES_PRINT
000015B0                           914  
000015B0                           915  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000015B0                           916          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000015B0                           917          * assemble output to console
000015B0                           918  OP_BRANCHES_PRINT
000015B0  103C 000E                919          MOVE.B  #14,D0 * print instruction op
000015B4  4E4F                     920          TRAP    #15
000015B6                           921          
000015B6  43F9 00002011            922          LEA     DATA,A1
000015BC  103C 000E                923          MOVE.B  #14,D0 * print raw data hex of the LABEL
000015C0  4E4F                     924          TRAP    #15
000015C2                           925          
000015C2  1A1A                     926          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
000015C4  2845                     927          MOVE.L  D5,A4 * ready the 8bits into a4
000015C6  43D4                     928          LEA     (A4),A1 * ready the a4 into a1 for print
000015C8  103C 000E                929          MOVE.B  #14,D0 * print the 8bit addr
000015CC  4E4F                     930          TRAP    #15
000015CE                           931  
000015CE  6000 0002                932          BRA     BCC_END
000015D2                           933  
000015D2                           934  BCC_END * reload the memory, call RTS
000015D2  4C9F 0303                935          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000015D6  4E75                     936          RTS
000015D8                           937  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015D8                           938  *-----------------------------------------------------------------------------
000015D8                           939  
000015D8                           940  
000015D8                           941  
000015D8                           942  *-----------------------------------------------------------------------------
000015D8                           943  *-----------------------------------------------------------------------------
000015D8                           944  * NAME: OP_0111   ()
000015D8                           945  * DESCRIPTION:    OP code 0111 is not supported. 
000015D8                           946  * PRE-CONDITION:  
000015D8                           947  * POST-CONDITION: 
000015D8                           948  * REGISTERS:
000015D8                           949  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015D8                           950  OP0111
000015D8  6100 072E                951      BSR     UNKNOWNOP
000015DC  4E75                     952      RTS
000015DE                           953  
000015DE                           954  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015DE                           955  *-----------------------------------------------------------------------------
000015DE                           956  
000015DE                           957  
000015DE                           958  
000015DE                           959  *-----------------------------------------------------------------------------
000015DE                           960  *-----------------------------------------------------------------------------
000015DE                           961  * NAME: OP_1000   (DIVS, OR)
000015DE                           962  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015DE                           963  * PRE-CONDITION:  xyz
000015DE                           964  * POST-CONDITION: All registers return to their previous state, and the output
000015DE                           965  *                 goes to the output console for reading the raw data or the
000015DE                           966  *                 actual instruction.
000015DE                           967  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015DE                           968  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015DE                           969  OP1000
000015DE                           970          * Saving values to the stack
000015DE  48A7 FFC0                971          MOVEM   D0-D7/A0-A1,-(A7)
000015E2                           972  
000015E2                           973          * Check if the EA Mode is 001 since both DIVS and OR do not support it
000015E2  3C3C 0003                974          MOVE.W  #3, D6              * Prep lower value for bitmask
000015E6  3E3C 0005                975          MOVE.W  #5, D7              * Prep upper value for bitmask
000015EA  6100 0986                976          BSR     BITMASK             * Finalize bitmask setup
000015EE  CC42                     977          AND     D2,D6               * Apply bitmask
000015F0                           978          
000015F0  0C46 0008                979          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
000015F4  6700 0712                980          BEQ     UNKNOWNOP                 * If so, the op is not supported
000015F8                           981          
000015F8                           982          * Checking for DIVS
000015F8  3C3C 0006                983          MOVE.W  #6, D6              * Prep lower value for bitmask
000015FC  3E3C 0008                984          MOVE.W  #8, D7              * Prep upper value for bitmask
00001600  6100 0970                985          BSR     BITMASK             * Finalize bitmask setup
00001604  CC42                     986          AND     D2,D6               * Apply bitmask
00001606                           987          
00001606  0C46 01C0                988          CMPI    #%0000000111000000, D6  * Are we DIVS?
0000160A  6600 0050                989          BNE     NOTDIVS                 * If not, branch to see if it's OR
0000160E                           990          
0000160E  43F9 00001FB9            991          LEA     DIVSOP,A1           * We found DIVS
00001614  103C 000E                992          MOVE.B  #14,D0              * Trap #14 prints out the data
00001618  4E4F                     993          TRAP    #15                 * Perform Trap #14
0000161A                           994          
0000161A  43F9 00002057            995          LEA     SPACE,A1            * formatting
00001620  103C 000E                996          MOVE.B  #14,D0              * Trap #14 prints out space
00001624  4E4F                     997          TRAP    #15                 * Perform Trap #14
00001626                           998          
00001626  4243                     999          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
00001628  08C3 0000               1000          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
0000162C                          1001                                      * to indicate a potential immediate of size word
0000162C                          1002          
0000162C  6100 02BE               1003          BSR     EAHELPER05          * Print out data. TODO: DOESN'T WORK.
00001630                          1004  
00001630  43F9 0000205D           1005          LEA     COMMA,A1            * formatting
00001636  103C 000E               1006          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000163A  4E4F                    1007          TRAP    #15                 * Perform Trap #14
0000163C                          1008          
0000163C                          1009          * bit manipulation is needed to make the outlier DIVS work
0000163C                          1010          * with the generic EAHELPER611
0000163C  0882 0006               1011          BCLR    #6,D2
00001640  0882 0007               1012          BCLR    #7,D2
00001644  0882 0008               1013          BCLR    #8,D2
00001648                          1014          
00001648                          1015          * the above bits were cleared so that eahelper05 knows the destination
00001648                          1016          * is a data register.
00001648                          1017          
00001648  6100 0260               1018          BSR     EAHELPER611 
0000164C                          1019  
0000164C  43F9 00001FB6           1020          LEA     NEWLINE,A1          * We found DIVS
00001652  103C 000E               1021          MOVE.B  #14,D0              * Trap #14 prints out the data
00001656  4E4F                    1022          TRAP    #15                 * Perform Trap #14
00001658                          1023          
00001658  6000 0012               1024          BRA     OP1000END
0000165C                          1025          
0000165C                          1026  NOTDIVS * It is confirmed OR at this point
0000165C  43F9 00001FED           1027          LEA     OROP,A1         * We found OR
00001662  103C 000E               1028          MOVE.B  #14,D0          * Trap #14 prints out the data
00001666  4E4F                    1029          TRAP    #15             * Perform Trap #14
00001668                          1030          *================================================================
00001668                          1031          * todo, move the size of the operation into the leading bits of D5
00001668                          1032          * before subroutine call
00001668  6100 0240               1033          BSR     EAHELPER611
0000166C                          1034  
0000166C                          1035  OP1000END
0000166C  4C9F 03FF               1036          MOVEM   (A7)+,D0-D7/A0-A1
00001670  4E75                    1037          RTS
00001672                          1038  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001672                          1039  *-----------------------------------------------------------------------------
00001672                          1040  
00001672                          1041  
00001672                          1042  
00001672                          1043  *-----------------------------------------------------------------------------
00001672                          1044  *-----------------------------------------------------------------------------
00001672                          1045  * NAME: OP_1001   (SUB)
00001672                          1046  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001672                          1047  * PRE-CONDITION:  xyz
00001672                          1048  * POST-CONDITION: All registers return to their previous state, and the output
00001672                          1049  *                 goes to the output console for reading the raw data or the
00001672                          1050  *                 actual instruction.
00001672                          1051  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001672                          1052  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001672                          1053  OP1001
00001672                          1054  
00001672                          1055  
00001672                          1056  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001672                          1057  *-----------------------------------------------------------------------------
00001672                          1058  
00001672                          1059  
00001672                          1060  
00001672                          1061  *-----------------------------------------------------------------------------
00001672                          1062  *-----------------------------------------------------------------------------
00001672                          1063  * NAME: OP_1010   ()
00001672                          1064  * DESCRIPTION:    a
00001672                          1065  * PRE-CONDITION:  b
00001672                          1066  * POST-CONDITION: c
00001672                          1067  * REGISTERS:      d
00001672                          1068  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001672                          1069  OP1010
00001672                          1070  
00001672  6100 0694               1071      BSR     UNKNOWNOP
00001676  4E75                    1072      RTS
00001678                          1073  
00001678                          1074  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001678                          1075  *-----------------------------------------------------------------------------
00001678                          1076  
00001678                          1077  
00001678                          1078  
00001678                          1079  *-----------------------------------------------------------------------------
00001678                          1080  *-----------------------------------------------------------------------------
00001678                          1081  * NAME: OP_1011   (EOR, CMP)
00001678                          1082  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001678                          1083  * PRE-CONDITION:  xyz
00001678                          1084  * POST-CONDITION: All registers return to their previous state, and the output
00001678                          1085  *                 goes to the output console for reading the raw data or the
00001678                          1086  *                 actual instruction.
00001678                          1087  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001678                          1088  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001678                          1089  OP1011
00001678                          1090  
00001678  6100 068E               1091      BSR     UNKNOWNOP
0000167C  4E75                    1092      RTS
0000167E                          1093  
0000167E                          1094  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000167E                          1095  *-----------------------------------------------------------------------------
0000167E                          1096  
0000167E                          1097  
0000167E                          1098  
0000167E                          1099  *-----------------------------------------------------------------------------
0000167E                          1100  *-----------------------------------------------------------------------------
0000167E                          1101  * NAME: OP_1100   (MULS)
0000167E                          1102  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000167E                          1103  * PRE-CONDITION:  xyz
0000167E                          1104  * POST-CONDITION: All registers return to their previous state, and the output
0000167E                          1105  *                 goes to the output console for reading the raw data or the
0000167E                          1106  *                 actual instruction.
0000167E                          1107  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000167E                          1108  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000167E                          1109  OP1100
0000167E  48A7 FFC0               1110          MOVEM   D0-D7/A0-A1,-(A7)   * Saving values to the stack
00001682                          1111  
00001682                          1112          * Check if the EA Mode is 001 since MULS does not support it
00001682  3C3C 0003               1113          MOVE.W  #3, D6              * Prep lower value for bitmask
00001686  3E3C 0005               1114          MOVE.W  #5, D7              * Prep upper value for bitmask
0000168A  6100 08E6               1115          BSR     BITMASK             * Finalize bitmask setup
0000168E  CC42                    1116          AND     D2,D6               * Apply bitmask
00001690                          1117          
00001690  0C46 0008               1118          CMPI    #%0000000000001000, D6    * Is the mode 001, an unsupported mode?
00001694  6700 0068               1119          BEQ     UNKNOWN1100               * If so, the op is not supported
00001698                          1120          
00001698  3C3C 0006               1121          MOVE.W  #6, D6              * Prep lower value for bitmask
0000169C  3E3C 0008               1122          MOVE.W  #8, D7              * Prep upper value for bitmask
000016A0  6100 08D0               1123          BSR     BITMASK             * Finalize bitmask setup
000016A4  CC42                    1124          AND     D2,D6               * Apply bitmask
000016A6                          1125          
000016A6  0C46 01C0               1126          CMPI    #%0000000111000000, D6  * Are we MULS?
000016AA  6600 0052               1127          BNE     UNKNOWN1100             * If not, it is an unknown op
000016AE                          1128          
000016AE  43F9 00001FE8           1129          LEA     MULSOP,A1           * We found MULS
000016B4  103C 000E               1130          MOVE.B  #14,D0              * Trap #14 prints out the data
000016B8  4E4F                    1131          TRAP    #15                 * Perform Trap #14
000016BA                          1132          
000016BA  43F9 00002057           1133          LEA     SPACE,A1            * formatting
000016C0  103C 000E               1134          MOVE.B  #14,D0              * Trap #14 prints out space
000016C4  4E4F                    1135          TRAP    #15                 * Perform Trap #14
000016C6                          1136          
000016C6  4243                    1137          CLR     D3                  * clear D3, it is a parameter
000016C8  08C3 0000               1138          BSET    #0,D3               * of EAHELPER05 to indicate size
000016CC                          1139          
000016CC  6100 021E               1140          BSR     EAHELPER05          * Print out data
000016D0                          1141  
000016D0  43F9 0000205D           1142          LEA     COMMA,A1            * formatting
000016D6  103C 000E               1143          MOVE.B  #14,D0              * Trap #14 prints out a comma
000016DA  4E4F                    1144          TRAP    #15                 * Perform Trap #14
000016DC                          1145          
000016DC  0882 0006               1146          BCLR    #6,D2               * Bit manipulation is 
000016E0  0882 0007               1147          BCLR    #7,D2               * necessary in order to make
000016E4  0882 0008               1148          BCLR    #8,D2               * EAHELPER611 work generically
000016E8                          1149          
000016E8  6100 01C0               1150          BSR     EAHELPER611         * Print out EA
000016EC                          1151  
000016EC  43F9 00001FB6           1152          LEA     NEWLINE,A1          * Formatting
000016F2  103C 000E               1153          MOVE.B  #14,D0              * Trap #14 prints out the data
000016F6  4E4F                    1154          TRAP    #15                 * Perform Trap #14
000016F8                          1155          
000016F8  4C9F 03FF               1156          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
000016FC  4E75                    1157          RTS                         * Return to main
000016FE                          1158          
000016FE                          1159  UNKNOWN1100
000016FE  6100 0608               1160          BSR     UNKNOWNOP
00001702                          1161       
00001702  4C9F 03FF               1162          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
00001706  4E75                    1163          RTS                         * Return to main
00001708                          1164          
00001708                          1165  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001708                          1166  *-----------------------------------------------------------------------------
00001708                          1167  
00001708                          1168  
00001708                          1169  
00001708                          1170  *-----------------------------------------------------------------------------
00001708                          1171  *-----------------------------------------------------------------------------
00001708                          1172  * NAME: OP_1101   (ADD, ADDA)
00001708                          1173  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001708                          1174  * PRE-CONDITION:  xyz
00001708                          1175  * POST-CONDITION: All registers return to their previous state, and the output
00001708                          1176  *                 goes to the output console for reading the raw data or the
00001708                          1177  *                 actual instruction.
00001708                          1178  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001708                          1179  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001708                          1180  OP1101
00001708                          1181  
00001708  6100 05FE               1182      BSR     UNKNOWNOP
0000170C  4E75                    1183      RTS
0000170E                          1184  
0000170E                          1185  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000170E                          1186  *-----------------------------------------------------------------------------
0000170E                          1187  
0000170E                          1188  
0000170E                          1189  
0000170E                          1190  *-----------------------------------------------------------------------------
0000170E                          1191  *-----------------------------------------------------------------------------
0000170E                          1192  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
0000170E                          1193  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000170E                          1194  * PRE-CONDITION:  xyz
0000170E                          1195  * POST-CONDITION: All registers return to their previous state, and the output
0000170E                          1196  *                 goes to the output console for reading the raw data or the
0000170E                          1197  *                 actual instruction.
0000170E                          1198  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000170E                          1199  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000170E                          1200  OP1110
0000170E                          1201  
0000170E  48A7 FFC0               1202      MOVEM   D0-D7/A0-A1,-(A7)   * Caller saved
00001712                          1203  
00001712  7C03                    1204      MOVE.L  #3,D6
00001714  7E04                    1205      MOVE.L  #4,D7
00001716                          1206      
00001716  6100 085A               1207      BSR     BITMASK * generate a bitmask for the 3 and 4 bits
0000171A                          1208      
0000171A  CC82                    1209      AND.L   D2,D6
0000171C                          1210      
0000171C  0C46 0008               1211      CMPI    #%0000000000001000,D6 *is it a logical shift
00001720  6700 001A               1212      BEQ     LS
00001724                          1213      
00001724  0C46 0000               1214      CMPI    #%0000000000000000,D6 *is it an arithmatic shift
00001728  6700 0048               1215      BEQ     AS
0000172C                          1216      
0000172C  0C46 0018               1217      CMPI    #%0000000000011000,D6 *is it a rorate?
00001730  6700 0076               1218      BEQ     RO
00001734                          1219  
00001734  6100 05D2               1220      BSR     UNKNOWNOP *if nothing above, we don't know what it is
00001738  6000 0158               1221      BRA     ENDOP1110
0000173C                          1222      
0000173C                          1223  LS
0000173C  7C08                    1224      MOVE.L  #8,D6
0000173E  7E08                    1225      MOVE.L  #8,D7
00001740                          1226      
00001740  6100 0830               1227      BSR     BITMASK
00001744                          1228      
00001744  CC82                    1229      AND.L   D2,D6
00001746                          1230      
00001746  0C46 0000               1231      CMPI    #0,D6 * is it a left shift?
0000174A  6700 0016               1232      BEQ     LSR
0000174E                          1233      
0000174E  6000 0002               1234      BRA     LSL * if not a left shift, must be right
00001752                          1235  
00001752                          1236  LSL
00001752                          1237  
00001752  43F9 00001FF9           1238      LEA     LSLOP,A1            * formatting
00001758  103C 000E               1239      MOVE.B  #14,D0              * Trap #14 prints out LSL
0000175C  4E4F                    1240      TRAP    #15                 * Perform Trap #14
0000175E                          1241      
0000175E  6000 007E               1242      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001762                          1243                                  * prints the registers and imm data
00001762                          1244  LSR
00001762                          1245  
00001762  43F9 00001FFD           1246      LEA     LSROP,A1            * formatting
00001768  103C 000E               1247      MOVE.B  #14,D0              * Trap #14 prints out LSR
0000176C  4E4F                    1248      TRAP    #15                 * Perform Trap #14
0000176E                          1249      
0000176E  6000 006E               1250      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001772                          1251                                  * prints the registers and imm data
00001772                          1252  
00001772                          1253  AS
00001772  7C08                    1254      MOVE.L  #8,D6
00001774  7E08                    1255      MOVE.L  #8,D7
00001776                          1256      
00001776  6100 07FA               1257      BSR     BITMASK
0000177A                          1258      
0000177A  CC82                    1259      AND.L   D2,D6
0000177C                          1260      
0000177C  0C46 0000               1261      CMPI    #0,D6 * is it a left shift?
00001780  6700 0016               1262      BEQ     ASR
00001784                          1263      
00001784  6000 0002               1264      BRA     ASL * if not a left shift, must be right
00001788                          1265      
00001788                          1266  ASL
00001788                          1267  
00001788  43F9 00002001           1268      LEA     ASLOP,A1            * formatting
0000178E  103C 000E               1269      MOVE.B  #14,D0              * Trap #14 prints out ASL
00001792  4E4F                    1270      TRAP    #15                 * Perform Trap #14
00001794                          1271      
00001794  6000 0048               1272      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001798                          1273                                  * prints the registers and imm data
00001798                          1274  ASR
00001798                          1275  
00001798  43F9 00002005           1276      LEA     ASROP,A1            * formatting
0000179E  103C 000E               1277      MOVE.B  #14,D0              * Trap #14 prints out ASR
000017A2  4E4F                    1278      TRAP    #15                 * Perform Trap #14
000017A4                          1279      
000017A4  6000 0038               1280      BRA     OP1110GENERIC       * a generic part of OP1110 that
000017A8                          1281                                  * prints the registers and imm data
000017A8                          1282  RO
000017A8  7C08                    1283      MOVE.L  #8,D6
000017AA  7E08                    1284      MOVE.L  #8,D7
000017AC                          1285      
000017AC  6100 07C4               1286      BSR     BITMASK
000017B0                          1287      
000017B0  CC82                    1288      AND.L   D2,D6
000017B2                          1289      
000017B2  0C46 0000               1290      CMPI    #0,D6 * is it a left shift?
000017B6  6700 0016               1291      BEQ     ROR
000017BA                          1292      
000017BA  6000 0002               1293      BRA     ROL * if not a left shift, must be right
000017BE                          1294  
000017BE                          1295  ROL
000017BE                          1296  
000017BE  43F9 00002009           1297      LEA     ROLOP,A1            * formatting
000017C4  103C 000E               1298      MOVE.B  #14,D0              * Trap #14 prints out ROL
000017C8  4E4F                    1299      TRAP    #15                 * Perform Trap #14
000017CA                          1300      
000017CA  6000 0012               1301      BRA     OP1110GENERIC       * a generic part of OP1110 that
000017CE                          1302                                  * prints the registers and imm data
000017CE                          1303  ROR
000017CE                          1304  
000017CE  43F9 0000200D           1305      LEA     ROROP,A1            * formatting
000017D4  103C 000E               1306      MOVE.B  #14,D0              * Trap #14 prints out ROR
000017D8  4E4F                    1307      TRAP    #15                 * Perform Trap #14
000017DA                          1308      
000017DA  6000 0002               1309      BRA     OP1110GENERIC       * a generic part of OP1110 that
000017DE                          1310                                  * prints the registers and imm data
000017DE                          1311  
000017DE                          1312  OP1110GENERIC
000017DE                          1313  
000017DE  6100 0462               1314      BSR     SIZE67
000017E2                          1315      
000017E2  7C05                    1316      MOVE.L  #5,D6
000017E4  7E05                    1317      MOVE.L  #5,D7
000017E6                          1318      
000017E6  6100 078A               1319      BSR     BITMASK
000017EA                          1320      
000017EA  CC82                    1321      AND.L   D2,D6
000017EC                          1322      
000017EC  0C46 0020               1323      CMPI    #%0000000000100000,D6   *is it a data reg?
000017F0  6700 0074               1324      BEQ     OP1110DATAREG
000017F4                          1325      
000017F4  43F9 0000205B           1326      LEA     IMD,A1              * formatting
000017FA  103C 000E               1327      MOVE.B  #14,D0              * Trap #14 prints out pound #
000017FE  4E4F                    1328      TRAP    #15                 * Perform Trap #14
00001800                          1329      
00001800  7C09                    1330      MOVE.L  #9,D6
00001802  7E0B                    1331      MOVE.L  #11,D7
00001804                          1332      
00001804  6100 076C               1333      BSR     BITMASK
00001808                          1334      
00001808  CC82                    1335      AND.L   D2,D6
0000180A                          1336      
0000180A  0C46 0000               1337      CMPI    #0,D6 * special case, if zero print #8 not #0
0000180E  6700 002E               1338      BEQ     OP1110IMMEIGHT
00001812                          1339      
00001812  E08E                    1340      LSR.L   #8,D6
00001814  E28E                    1341      LSR.L   #1,D6
00001816                          1342      
00001816  2206                    1343      MOVE.L  D6,D1              * formatting
00001818  103C 0003               1344      MOVE.B  #3,D0              * Trap #14 prints out the number in D1
0000181C  4E4F                    1345      TRAP    #15                * Perform Trap #14
0000181E                          1346      
0000181E  43F9 0000205D           1347      LEA     COMMA,A1            * formatting
00001824  103C 000E               1348      MOVE.B  #14,D0              * Trap #14 prints out comma
00001828  4E4F                    1349      TRAP    #15                 * Perform Trap #1
0000182A                          1350      
0000182A                          1351      * in order to use the eahlpers, we need to do some bit manipulation
0000182A                          1352      * clearing the bits below lets our helper know that the mode is Dn
0000182A  0882 0003               1353      BCLR    #3,D2
0000182E  0882 0004               1354      BCLR    #4,D2
00001832  0882 0005               1355      BCLR    #5,D2
00001836                          1356      
00001836  6100 00B4               1357      BSR     EAHELPER05
0000183A                          1358      
0000183A  6000 0056               1359      BRA     ENDOP1110
0000183E                          1360      
0000183E                          1361  OP1110IMMEIGHT
0000183E                          1362  
0000183E  7208                    1363      MOVE.L  #8,D1              * formatting
00001840  103C 0003               1364      MOVE.B  #3,D0              * Trap #14 prints out the number in D1
00001844  4E4F                    1365      TRAP    #15                * Perform Trap #14
00001846                          1366      
00001846  43F9 0000205D           1367      LEA     COMMA,A1            * formatting
0000184C  103C 000E               1368      MOVE.B  #14,D0              * Trap #14 prints out comma
00001850  4E4F                    1369      TRAP    #15                 * Perform Trap #1
00001852                          1370      
00001852                          1371      * in order to use the eahlpers, we need to do some bit manipulation
00001852                          1372      * clearing the bits below lets our helper know that the mode is Dn
00001852  0882 0003               1373      BCLR    #3,D2
00001856  0882 0004               1374      BCLR    #4,D2
0000185A  0882 0005               1375      BCLR    #5,D2
0000185E                          1376      
0000185E  6100 008C               1377      BSR     EAHELPER05
00001862                          1378      
00001862  6000 002E               1379      BRA     ENDOP1110
00001866                          1380  
00001866                          1381  OP1110DATAREG
00001866                          1382  
00001866                          1383      * in order to use the eahlpers, we need to do some bit manipulation
00001866                          1384      * clearing the bits below lets our helper know that the mode is Dn
00001866  0882 0003               1385      BCLR    #3,D2
0000186A  0882 0004               1386      BCLR    #4,D2
0000186E  0882 0005               1387      BCLR    #5,D2
00001872  0882 0006               1388      BCLR    #6,D2
00001876  0882 0007               1389      BCLR    #7,D2
0000187A  0882 0008               1390      BCLR    #8,D2
0000187E                          1391      
0000187E  6100 002A               1392      BSR     EAHELPER611
00001882                          1393      
00001882  43F9 0000205D           1394      LEA     COMMA,A1            * formatting
00001888  103C 000E               1395      MOVE.B  #14,D0              * Trap #14 prints out comma
0000188C  4E4F                    1396      TRAP    #15                 * Perform Trap #14
0000188E                          1397      
0000188E  6100 005C               1398      BSR     EAHELPER05
00001892                          1399  
00001892                          1400  ENDOP1110
00001892                          1401  
00001892  43F9 00001FB6           1402      LEA     NEWLINE,A1          * formatting
00001898  103C 000E               1403      MOVE.B  #14,D0              * Trap #14 prints out a new line
0000189C  4E4F                    1404      TRAP    #15                 * Perform Trap #14
0000189E                          1405      
0000189E  4C9F 03FF               1406      MOVEM   (A7)+,D0-D7/A0-A1   * Caller saved
000018A2  4E75                    1407      RTS
000018A4                          1408  
000018A4                          1409  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018A4                          1410  *-----------------------------------------------------------------------------
000018A4                          1411  
000018A4                          1412  
000018A4                          1413  
000018A4                          1414  *-----------------------------------------------------------------------------
000018A4                          1415  *-----------------------------------------------------------------------------
000018A4                          1416  * NAME: OP_1111   ()
000018A4                          1417  * DESCRIPTION:    a
000018A4                          1418  * PRE-CONDITION:  b
000018A4                          1419  * POST-CONDITION: c
000018A4                          1420  * REGISTERS:      d
000018A4                          1421  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018A4                          1422  OP1111
000018A4                          1423  
000018A4  6100 0462               1424      BSR     UNKNOWNOP
000018A8  4E75                    1425      RTS
000018AA                          1426  
000018AA                          1427  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018AA                          1428  *-----------------------------------------------------------------------------
000018AA                          1429  
000018AA                          1430  
000018AA                          1431  
000018AA                          1432  *-----------------------------------------------------------------------------
000018AA                          1433  *-----------------------------------------------------------------------------
000018AA                          1434  * NAME:           EAHELPER611
000018AA                          1435  * DESCRIPTION:    a
000018AA                          1436  * PRE-CONDITION:  D2 contains the instruction to print modes for.
000018AA                          1437  *                 D5 contains the size of the data to be printed
000018AA                          1438  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
000018AA                          1439  *                 EAHELPER05 to print.
000018AA                          1440  * REGISTERS:      a
000018AA                          1441  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018AA                          1442  EAHELPER611
000018AA  48A7 FFC0               1443      MOVEM  D0-D7/A0-A1,-(A7)    * Push values onto stack
000018AE                          1444      
000018AE  3C3C 0006               1445      MOVE.W  #6, D6              * Prep lower value for bitmask
000018B2  3E3C 0008               1446      MOVE.W  #8, D7              * Prep upper value for bitmask
000018B6  6100 06BA               1447      BSR     BITMASK             * Finalize bitmask setup
000018BA  CC42                    1448      AND     D2,D6               * Apply bitmask
000018BC                          1449      
000018BC                          1450      * to move the mode where EAHELPER50 can process it
000018BC  7C06                    1451      MOVE.L  #6,D6       * Prep lower value of bitmask
000018BE  7E08                    1452      MOVE.L  #8,D7       * Prep upper value of bitmask
000018C0  6100 06B0               1453      BSR     BITMASK     * Create bitmask
000018C4  CC42                    1454      AND     D2,D6       * Apply bitmask
000018C6                          1455      
000018C6  4243                    1456      CLR     D3      * prep D3 to store values
000018C8  3606                    1457      MOVE.W  D6,D3   * store bitmasked value in D3
000018CA  E64B                    1458      LSR     #3,D3   * move bits 6-8 to 3-5
000018CC                          1459      
000018CC                          1460      * to move the register where EAHELPER50 can process it
000018CC  7C09                    1461      MOVE.L  #9,D6   * Prep lower value for bitmask
000018CE  7E0B                    1462      MOVE.L  #11,D7  * Prep upper value for bitmask
000018D0  6100 06A0               1463      BSR     BITMASK * create bitmask
000018D4  CC42                    1464      AND     D2,D6   * apply bitmask
000018D6                          1465      
000018D6  4244                    1466      CLR     D4      * prep D3 to store values
000018D8  3806                    1467      MOVE.W  D6,D4   * store bitmasked value in D3
000018DA                          1468      
000018DA  E04C                    1469      LSR     #8,D4   * move bits 9-11 to 0-2
000018DC  E24C                    1470      LSR     #1,D4   * move bits 9-11 to 0-2
000018DE                          1471    
000018DE  8684                    1472      OR.L    D4,D3   * combind the register and mode
000018E0  2403                    1473      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
000018E2                          1474      
000018E2  6100 0008               1475      BSR     EAHELPER05
000018E6                          1476      
000018E6                          1477  ENDEAHELPER611
000018E6                          1478      
000018E6  4C9F 03FF               1479      MOVEM  (A7)+,D0-D7/A0-A1    * Revert back
000018EA  4E75                    1480      RTS
000018EC                          1481  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018EC                          1482  *-----------------------------------------------------------------------------
000018EC                          1483  
000018EC                          1484  
000018EC                          1485  
000018EC                          1486  *-----------------------------------------------------------------------------
000018EC                          1487  *-----------------------------------------------------------------------------
000018EC                          1488  * NAME:           EAHELPER05
000018EC                          1489  * DESCRIPTION:    a
000018EC                          1490  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
000018EC                          1491  *                 this sub-routine helper for operations that only have one
000018EC                          1492  *                 mode register.
000018EC                          1493  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
000018EC                          1494  * REGISTERS:      a
000018EC                          1495  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018EC                          1496  EAHELPER05
000018EC                          1497      * todo: add code for printing immediate values
000018EC                          1498      
000018EC  48A7 FFC0               1499      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000018F0                          1500      
000018F0  7C03                    1501      MOVE.L  #3,D6
000018F2  7E05                    1502      MOVE.L  #5,D7
000018F4                          1503      
000018F4  6100 067C               1504      BSR     BITMASK * generate a bitmask to identify the mode
000018F8                          1505      
000018F8  CC42                    1506      AND     D2,D6   * mask off the parts of D2 we don't need
000018FA                          1507      
000018FA  2A06                    1508      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
000018FC                          1509      
000018FC  0C46 0000               1510      CMPI    #%0000000000000000,D6 * is it data register direct?
00001900  6600 000A               1511      BNE     NOTDATAREG
00001904                          1512      
00001904  6100 013C               1513      BSR     MODE_DN
00001908                          1514       
00001908  6000 0132               1515      BRA     ENDEAHELPER05
0000190C                          1516      
0000190C                          1517  NOTDATAREG * address register direct
0000190C                          1518      
0000190C  0C46 0008               1519      CMPI    #%0000000000001000,D6 * is it address register direct?
00001910  6600 000A               1520      BNE     NOTADRDIRECT
00001914                          1521      
00001914  6100 022C               1522      BSR     MODE_AN * simply prints out the address register
00001918                          1523       
00001918  6000 0122               1524      BRA     ENDEAHELPER05
0000191C                          1525      
0000191C                          1526  NOTADRDIRECT * address register indirect
0000191C                          1527          
0000191C  0C46 0010               1528      CMPI    #%0000000000010000,D6 * is it address register indirect?
00001920  6600 0022               1529      BNE     NOTADRINDIRECT
00001924                          1530      
00001924  43F9 0000205F           1531      LEA     OBRACK,A1       * Load '('
0000192A  303C 000E               1532      MOVE.W  #14,D0          * Trap #14 to display message
0000192E  4E4F                    1533      TRAP    #15             * Perform #14
00001930                          1534          
00001930                          1535  
00001930  6100 0210               1536      BSR     MODE_AN * print out an address register
00001934                          1537      
00001934  43F9 00002061           1538      LEA     CBRACK,A1       * Load ')'
0000193A  303C 000E               1539      MOVE.W  #14,D0          * Trap #14 to display message
0000193E  4E4F                    1540      TRAP    #15             * Perform #14
00001940                          1541       
00001940  6000 00FA               1542      BRA     ENDEAHELPER05
00001944                          1543      
00001944                          1544  NOTADRINDIRECT * address register indirect, post increment
00001944                          1545      
00001944  0C46 0018               1546      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
00001948  6600 002E               1547      BNE     NOTADRINDIRECTPOST
0000194C                          1548      
0000194C  43F9 0000205F           1549      LEA     OBRACK,A1       * Load '('
00001952  303C 000E               1550      MOVE.W  #14,D0          * Trap #14 to display message
00001956  4E4F                    1551      TRAP    #15             * Perform #14
00001958                          1552          
00001958                          1553  
00001958  6100 01E8               1554      BSR     MODE_AN * print out an address register
0000195C                          1555      
0000195C  43F9 00002061           1556      LEA     CBRACK,A1       * Load ')'
00001962  303C 000E               1557      MOVE.W  #14,D0          * Trap #14 to display message
00001966  4E4F                    1558      TRAP    #15             * Perform #14
00001968                          1559      
00001968  43F9 00002063           1560      LEA     PLUS,A1       * Load '+'
0000196E  303C 000E               1561      MOVE.W  #14,D0          * Trap #14 to display message
00001972  4E4F                    1562      TRAP    #15             * Perform #14
00001974                          1563       
00001974  6000 00C6               1564      BRA     ENDEAHELPER05
00001978                          1565      
00001978                          1566  NOTADRINDIRECTPOST * address register indirect, pre decrement
00001978                          1567      
00001978  0C46 0020               1568      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
0000197C  6600 002E               1569      BNE     NOTADRINDIRECTPRE
00001980                          1570      
00001980  43F9 00002065           1571      LEA     MINUS,A1       * Load '-'
00001986  303C 000E               1572      MOVE.W  #14,D0          * Trap #14 to display message
0000198A  4E4F                    1573      TRAP    #15             * Perform #14
0000198C                          1574      
0000198C  43F9 0000205F           1575      LEA     OBRACK,A1       * Load '('
00001992  303C 000E               1576      MOVE.W  #14,D0          * Trap #14 to display message
00001996  4E4F                    1577      TRAP    #15             * Perform #14
00001998                          1578          
00001998                          1579  
00001998  6100 01A8               1580      BSR     MODE_AN * print out an address register
0000199C                          1581      
0000199C  43F9 00002061           1582      LEA     CBRACK,A1       * Load ')'
000019A2  303C 000E               1583      MOVE.W  #14,D0          * Trap #14 to display message
000019A6  4E4F                    1584      TRAP    #15             * Perform #14
000019A8                          1585       
000019A8  6000 0092               1586      BRA     ENDEAHELPER05
000019AC                          1587  
000019AC                          1588  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
000019AC                          1589  
000019AC  0C46 0038               1590      CMPI    #%0000000000111000,D6 * is it immediate?
000019B0  6600 0086               1591      BNE     NOTIMMEDIATE
000019B4                          1592  
000019B4  0C43 0001               1593      CMPI    #1,D3 * is it a byte?
000019B8  6600 0028               1594      BNE     NOTIMMBYTE
000019BC                          1595      
000019BC  43F9 0000205B           1596      LEA     IMD,A1 *print out the '#' indicating an immediate value
000019C2  103C 000E               1597      MOVE.B  #14,D0
000019C6  4E4F                    1598      TRAP    #15
000019C8                          1599      
000019C8  3C3C 0000               1600      MOVE.W  #0, D6              * Prep lower value for bitmask
000019CC  3E3C 0007               1601      MOVE.W  #7, D7              * Prep upper value for bitmask
000019D0  6100 05A0               1602      BSR     BITMASK             * Finalize bitmask setup
000019D4                          1603          
000019D4  321A                    1604      MOVE.W  (A2)+,D1
000019D6                          1605      
000019D6  C286                    1606      AND.L     D6,D1
000019D8                          1607          
000019D8  103C 0003               1608      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000019DC  4E4F                    1609      TRAP    #15      * Perform Trap #3
000019DE                          1610      
000019DE  6000 005C               1611      BRA     ENDEAHELPER05
000019E2                          1612  
000019E2                          1613  NOTIMMBYTE
000019E2                          1614      
000019E2  0C43 0002               1615      CMPI    #2,D3 * is it a word?
000019E6  6600 0028               1616      BNE     NOTIMMWORD
000019EA                          1617      
000019EA  43F9 0000205B           1618      LEA     IMD,A1 *print out the '#' indicating an immediate value
000019F0  103C 000E               1619      MOVE.B  #14,D0
000019F4  4E4F                    1620      TRAP    #15
000019F6                          1621      
000019F6  3C3C 0000               1622      MOVE.W  #0, D6              * Prep lower value for bitmask
000019FA  3E3C 000F               1623      MOVE.W  #15, D7             * Prep upper value for bitmask
000019FE  6100 0572               1624      BSR     BITMASK             * Finalize bitmask setup
00001A02                          1625          
00001A02  321A                    1626      MOVE.W  (A2)+,D1
00001A04                          1627      
00001A04  C286                    1628      AND.L     D6,D1               * Apply bitmask
00001A06                          1629          
00001A06  103C 0003               1630      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A0A  4E4F                    1631      TRAP    #15      * Perform Trap #3
00001A0C                          1632      
00001A0C  6000 002E               1633      BRA     ENDEAHELPER05
00001A10                          1634      
00001A10                          1635  NOTIMMWORD
00001A10  0C43 0003               1636      CMPI    #3,D3 * is it a long?
00001A14  6600 0022               1637      BNE     NOTIMMEDIATE
00001A18                          1638      
00001A18  43F9 0000205B           1639      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001A1E  103C 000E               1640      MOVE.B  #14,D0
00001A22  4E4F                    1641      TRAP    #15
00001A24                          1642          
00001A24  221A                    1643      MOVE.L  (A2)+,D1
00001A26                          1644          
00001A26  103C 0003               1645      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A2A  4E4F                    1646      TRAP    #15      * Perform Trap #3
00001A2C                          1647      
00001A2C  321A                    1648      MOVE.W  (A2)+,D1
00001A2E                          1649          
00001A2E  103C 0003               1650      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A32  4E4F                    1651      TRAP    #15      * Perform Trap #3
00001A34                          1652      
00001A34  6000 0006               1653      BRA     ENDEAHELPER05
00001A38                          1654  
00001A38                          1655  NOTIMMEDIATE    
00001A38                          1656  
00001A38                          1657  
00001A38  6100 02CE               1658      BSR     UNKNOWNOP
00001A3C                          1659      
00001A3C                          1660  ENDEAHELPER05
00001A3C  4C9F 03FF               1661      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001A40  4E75                    1662      RTS
00001A42                          1663  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A42                          1664  *-----------------------------------------------------------------------------
00001A42                          1665  
00001A42                          1666  
00001A42                          1667  
00001A42                          1668  *-----------------------------------------------------------------------------
00001A42                          1669  *-----------------------------------------------------------------------------
00001A42                          1670  * NAME:           MODE_DN
00001A42                          1671  * DESCRIPTION:    Generalize the EA part of the project.
00001A42                          1672  * PRE-CONDITION:  The mode must have been correctly identified. All modes
00001A42                          1673  *                 must be called by RTS.
00001A42                          1674  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
00001A42                          1675  *                 called it.
00001A42                          1676  * REGISTERS:      a
00001A42                          1677  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A42                          1678  * ---> Dn
00001A42                          1679  MODE_DN
00001A42  48A7 FFC0               1680          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001A46                          1681  
00001A46  3C3C 0000               1682          MOVE.W  #0, D6              * Prep lower value for bitmask
00001A4A  3E3C 0002               1683          MOVE.W  #2, D7              * Prep upper value for bitmask
00001A4E  6100 0522               1684          BSR     BITMASK             * Finalize bitmask setup
00001A52  CC42                    1685          AND     D2,D6               * Apply bitmask
00001A54                          1686          
00001A54  0C46 0000               1687          CMPI    #%000000000000000, D6   * Data Register D0?
00001A58  6600 000A               1688          BNE     NOTD0
00001A5C                          1689          
00001A5C  6100 0074               1690          BSR     PRINTD0
00001A60  6000 006A               1691          BRA     ENDMODE_DN
00001A64                          1692  NOTD0      
00001A64  0C46 0001               1693          CMPI    #%000000000000001, D6   * Data Register D1?
00001A68  6600 000A               1694          BNE     NOTD1
00001A6C                          1695          
00001A6C  6100 0072               1696          BSR     PRINTD1
00001A70  6000 005A               1697          BRA     ENDMODE_DN
00001A74                          1698  NOTD1
00001A74  0C46 0002               1699          CMPI    #%000000000000010, D6   * Data Register D2?
00001A78  6600 000A               1700          BNE     NOTD2
00001A7C                          1701          
00001A7C  6100 0070               1702          BSR     PRINTD2
00001A80  6000 004A               1703          BRA     ENDMODE_DN
00001A84                          1704  NOTD2
00001A84  0C46 0003               1705          CMPI    #%000000000000011, D6   * Data Register D3?
00001A88  6600 000A               1706          BNE     NOTD3
00001A8C                          1707          
00001A8C  6100 006E               1708          BSR     PRINTD3
00001A90  6000 003A               1709          BRA     ENDMODE_DN
00001A94                          1710  NOTD3
00001A94  0C46 0004               1711          CMPI    #%000000000000100, D6   * Data Register D4?
00001A98  6600 000A               1712          BNE     NOTD4
00001A9C                          1713          
00001A9C  6100 006C               1714          BSR     PRINTD4
00001AA0  6000 002A               1715          BRA     ENDMODE_DN
00001AA4                          1716  NOTD4
00001AA4  0C46 0005               1717          CMPI    #%000000000000101, D6   * Data Register D5?
00001AA8  6600 000A               1718          BNE     NOTD5
00001AAC                          1719          
00001AAC  6100 006A               1720          BSR     PRINTD5
00001AB0  6000 001A               1721          BRA     ENDMODE_DN
00001AB4                          1722  NOTD5
00001AB4  0C46 0006               1723          CMPI    #%000000000000110, D6   * Data Register D6?
00001AB8  6600 000A               1724          BNE     NOTD6
00001ABC                          1725          
00001ABC  6100 0068               1726          BSR     PRINTD6
00001AC0  6000 000A               1727          BRA     ENDMODE_DN
00001AC4                          1728  NOTD6
00001AC4  6100 006E               1729          BSR     PRINTD7
00001AC8  6000 0002               1730          BRA     ENDMODE_DN
00001ACC                          1731          
00001ACC                          1732  ENDMODE_DN
00001ACC  4C9F 03FF               1733          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001AD0  4E75                    1734          RTS
00001AD2                          1735  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AD2                          1736  *-----------------------------------------------------------------------------
00001AD2                          1737  
00001AD2                          1738  
00001AD2                          1739  
00001AD2                          1740  *-----------------------------------------------------------------------------
00001AD2                          1741  *-----------------------------------------------------------------------------
00001AD2                          1742  * NAME:           PRINTD0
00001AD2                          1743  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
00001AD2                          1744  * PRE-CONDITION:  a
00001AD2                          1745  * POST-CONDITION: a
00001AD2                          1746  * REGISTERS:      a
00001AD2                          1747  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AD2                          1748  PRINTD0
00001AD2  43F9 0000208B           1749          LEA     __D0, A1        * Load 'D0'
00001AD8  103C 000E               1750          MOVE.B  #14, D0         * Load Trap #14 to print out
00001ADC  4E4F                    1751          TRAP    #15             * Perform Trap #14
00001ADE  4E75                    1752          RTS
00001AE0                          1753  PRINTD1
00001AE0  43F9 0000208E           1754          LEA     __D1, A1        * Load 'D1'
00001AE6  103C 000E               1755          MOVE.B  #14, D0         * Load Trap #14 to print out
00001AEA  4E4F                    1756          TRAP    #15             * Perform Trap #14
00001AEC  4E75                    1757          RTS      
00001AEE                          1758  PRINTD2
00001AEE  43F9 00002091           1759          LEA     __D2, A1        * Load 'D2'
00001AF4  103C 000E               1760          MOVE.B  #14, D0         * Load Trap #14 to print out
00001AF8  4E4F                    1761          TRAP    #15             * Perform Trap #14
00001AFA  4E75                    1762          RTS      
00001AFC                          1763  PRINTD3
00001AFC  43F9 00002094           1764          LEA     __D3, A1        * Load 'D3'
00001B02  103C 000E               1765          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B06  4E4F                    1766          TRAP    #15             * Perform Trap #14
00001B08  4E75                    1767          RTS      
00001B0A                          1768  PRINTD4
00001B0A  43F9 00002097           1769          LEA     __D4, A1        * Load 'D4'
00001B10  103C 000E               1770          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B14  4E4F                    1771          TRAP    #15             * Perform Trap #14
00001B16  4E75                    1772          RTS       
00001B18                          1773  PRINTD5
00001B18  43F9 0000209A           1774          LEA     __D5, A1        * Load 'D5'
00001B1E  103C 000E               1775          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B22  4E4F                    1776          TRAP    #15             * Perform Trap #14
00001B24  4E75                    1777          RTS      
00001B26                          1778  PRINTD6
00001B26  43F9 0000209D           1779          LEA     __D6, A1        * Load 'D6'
00001B2C  103C 000E               1780          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B30  4E4F                    1781          TRAP    #15             * Perform Trap #14
00001B32  4E75                    1782          RTS
00001B34                          1783  PRINTD7
00001B34  43F9 000020A0           1784          LEA     __D7, A1        * Load 'D7'
00001B3A  103C 000E               1785          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B3E  4E4F                    1786          TRAP    #15             * Perform Trap #14
00001B40  4E75                    1787          RTS
00001B42                          1788  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B42                          1789  *-----------------------------------------------------------------------------
00001B42                          1790  
00001B42                          1791  
00001B42                          1792  
00001B42                          1793  *-----------------------------------------------------------------------------
00001B42                          1794  *-----------------------------------------------------------------------------
00001B42                          1795  * NAME:           MODE_AN
00001B42                          1796  * DESCRIPTION:    Simply chooses to print A0-A7.
00001B42                          1797  * PRE-CONDITION:  a
00001B42                          1798  * POST-CONDITION: a
00001B42                          1799  * REGISTERS:      a
00001B42                          1800  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B42                          1801  MODE_AN
00001B42  48A7 FFC0               1802          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
00001B46                          1803  
00001B46  3C3C 0000               1804          MOVE.W  #0, D6              * Prep lower value for bitmask
00001B4A  3E3C 0002               1805          MOVE.W  #2, D7              * Prep upper value for bitmask
00001B4E  6100 0422               1806          BSR     BITMASK             * Finalize bitmask setup
00001B52  CC42                    1807          AND     D2,D6               * Apply bitmask
00001B54                          1808          
00001B54  0C46 0000               1809          CMPI    #%000000000000000, D6   * Address Register A0?
00001B58  6600 000A               1810          BNE     NOTA0
00001B5C                          1811          
00001B5C  6100 0074               1812          BSR     PRINTA0
00001B60                          1813          
00001B60  6000 006A               1814          BRA     ENDMODE_AN
00001B64                          1815  NOTA0      
00001B64  0C46 0001               1816          CMPI    #%000000000000001, D6   * Address Register A1?
00001B68  6600 000A               1817          BNE     NOTA1
00001B6C                          1818          
00001B6C  6100 0072               1819          BSR     PRINTA1
00001B70                          1820          
00001B70  6000 005A               1821          BRA     ENDMODE_AN
00001B74                          1822  NOTA1
00001B74  0C46 0002               1823          CMPI    #%000000000000010, D6   * Address Register A2?
00001B78  6600 000A               1824          BNE     NOTA2
00001B7C                          1825          
00001B7C  6100 0070               1826          BSR     PRINTA2
00001B80                          1827          
00001B80  6000 004A               1828          BRA     ENDMODE_AN
00001B84                          1829  NOTA2
00001B84  0C46 0003               1830          CMPI    #%000000000000011, D6   * Address Register A3?
00001B88  6600 000A               1831          BNE     NOTA3
00001B8C                          1832          
00001B8C  6100 006E               1833          BSR     PRINTA3
00001B90                          1834          
00001B90  6000 003A               1835          BRA     ENDMODE_AN
00001B94                          1836  NOTA3
00001B94  0C46 0004               1837          CMPI    #%000000000000100, D6   * Address Register A4?
00001B98  6600 000A               1838          BNE     NOTA4
00001B9C                          1839          
00001B9C  6100 006C               1840          BSR     PRINTA4
00001BA0                          1841          
00001BA0  6000 002A               1842          BRA     ENDMODE_AN
00001BA4                          1843  NOTA4
00001BA4  0C46 0005               1844          CMPI    #%000000000000101, D6   * Address Register A5?
00001BA8  6600 000A               1845          BNE     NOTA5
00001BAC                          1846          
00001BAC  6100 006A               1847          BSR     PRINTA5
00001BB0                          1848          
00001BB0  6000 001A               1849          BRA     ENDMODE_AN
00001BB4                          1850  NOTA5
00001BB4  0C46 0006               1851          CMPI    #%000000000000110, D6   * Address Register A6?
00001BB8  6600 000A               1852          BNE     NOTA6
00001BBC                          1853          
00001BBC  6100 0068               1854          BSR     PRINTA6
00001BC0                          1855          
00001BC0  6000 000A               1856          BRA     ENDMODE_AN
00001BC4                          1857  NOTA6
00001BC4  6100 006E               1858          BSR     PRINTA7
00001BC8                          1859          
00001BC8  6000 0002               1860          BRA     ENDMODE_AN
00001BCC                          1861  ENDMODE_AN
00001BCC  4C9F 03FF               1862          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
00001BD0  4E75                    1863          RTS
00001BD2                          1864  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001BD2                          1865  *-----------------------------------------------------------------------------
00001BD2                          1866  
00001BD2                          1867  
00001BD2                          1868  
00001BD2                          1869  *-----------------------------------------------------------------------------
00001BD2                          1870  *-----------------------------------------------------------------------------
00001BD2                          1871  * NAME:           PRINTA0
00001BD2                          1872  * DESCRIPTION:    Simply print out the address register.
00001BD2                          1873  * PRE-CONDITION:  a
00001BD2                          1874  * POST-CONDITION: a
00001BD2                          1875  * REGISTERS:      a
00001BD2                          1876  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001BD2                          1877  PRINTA0
00001BD2  43F9 00002073           1878          LEA     __A0, A1        * Load 'A0'
00001BD8  103C 000E               1879          MOVE.B  #14, D0         * Load Trap #14 to print out
00001BDC  4E4F                    1880          TRAP    #15             * Perform Trap #14
00001BDE  4E75                    1881          RTS
00001BE0                          1882  
00001BE0                          1883  PRINTA1
00001BE0  43F9 00002076           1884          LEA     __A1, A1        * Load 'A1'
00001BE6  103C 000E               1885          MOVE.B  #14, D0         * Load Trap #14 to print out
00001BEA  4E4F                    1886          TRAP    #15             * Perform Trap #14
00001BEC  4E75                    1887          RTS
00001BEE                          1888          
00001BEE                          1889  PRINTA2
00001BEE  43F9 00002079           1890          LEA     __A2, A1        * Load 'A2'
00001BF4  103C 000E               1891          MOVE.B  #14, D0         * Load Trap #14 to print out
00001BF8  4E4F                    1892          TRAP    #15             * Perform Trap #14
00001BFA  4E75                    1893          RTS
00001BFC                          1894  
00001BFC                          1895  PRINTA3
00001BFC  43F9 0000207C           1896          LEA     __A3, A1        * Load 'A3'
00001C02  103C 000E               1897          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C06  4E4F                    1898          TRAP    #15             * Perform Trap #14
00001C08  4E75                    1899          RTS
00001C0A                          1900  
00001C0A                          1901  PRINTA4
00001C0A  43F9 0000207F           1902          LEA     __A4, A1        * Load 'A4'
00001C10  103C 000E               1903          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C14  4E4F                    1904          TRAP    #15             * Perform Trap #14
00001C16  4E75                    1905          RTS
00001C18                          1906  
00001C18                          1907  PRINTA5
00001C18  43F9 00002082           1908          LEA     __A5, A1        * Load 'A5'
00001C1E  103C 000E               1909          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C22  4E4F                    1910          TRAP    #15             * Perform Trap #14
00001C24  4E75                    1911          RTS
00001C26                          1912  
00001C26                          1913  PRINTA6
00001C26  43F9 00002085           1914          LEA     __A6, A1        * Load 'A6'
00001C2C  103C 000E               1915          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C30  4E4F                    1916          TRAP    #15             * Perform Trap #14
00001C32  4E75                    1917          RTS
00001C34                          1918  
00001C34                          1919  PRINTA7
00001C34  43F9 00002088           1920          LEA     __A7, A1        * Load 'A7'
00001C3A  103C 000E               1921          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C3E  4E4F                    1922          TRAP    #15             * Perform Trap #14
00001C40  4E75                    1923          RTS
00001C42                          1924  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C42                          1925  *-----------------------------------------------------------------------------
00001C42                          1926  
00001C42                          1927  
00001C42                          1928  
00001C42                          1929  *-----------------------------------------------------------------------------
00001C42                          1930  *-----------------------------------------------------------------------------
00001C42                          1931  * NAME:           SIZE67
00001C42                          1932  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001C42                          1933  * PRE-CONDITION:  a
00001C42                          1934  * POST-CONDITION: a
00001C42                          1935  * REGISTERS:      a
00001C42                          1936  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C42                          1937  SIZE67
00001C42  48A7 FFFE               1938          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001C46  3C3C 0006               1939          MOVE.W  #6, D6              * Prep lower value for bitmask
00001C4A  3E3C 0007               1940          MOVE.W  #7, D7              * Prep upper value for bitmask
00001C4E  6100 0322               1941          BSR     BITMASK             * Finalize bitmask setup
00001C52  CC42                    1942          AND     D2,D6               * Apply bitmask     
00001C54                          1943  
00001C54  0C46 0000               1944          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001C58  6600 000A               1945          BNE     NOT67BYTE
00001C5C                          1946          
00001C5C  6100 0080               1947          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001C60  6000 001E               1948          BRA     END67
00001C64                          1949  NOT67BYTE        
00001C64  0C46 0040               1950          CMPI    #%0000000001000000, D6   * is it a WORD?
00001C68  6600 000A               1951          BNE     NOT67WORD
00001C6C                          1952          
00001C6C  6100 007E               1953          BSR     PRINTWORD               * Branch to handle WORD sizes
00001C70  6000 000E               1954          BRA     END67
00001C74                          1955  NOT67WORD
00001C74  0C46 0080               1956          CMPI    #%0000000010000000, D6   * is it a LONG?
00001C78  6600 0006               1957          BNE     END67
00001C7C                          1958          
00001C7C  6100 007C               1959          BSR     PRINTLONG               * Branch to handle LONG sizes
00001C80                          1960  END67
00001C80  4C9F 7FFF               1961          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001C84  4E75                    1962          RTS                             * Return. Size handling is finished.
00001C86                          1963  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C86                          1964  *-----------------------------------------------------------------------------
00001C86                          1965  
00001C86                          1966  
00001C86                          1967  
00001C86                          1968  *-----------------------------------------------------------------------------
00001C86                          1969  *-----------------------------------------------------------------------------
00001C86                          1970  * NAME:           SIZE68
00001C86                          1971  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
00001C86                          1972  * PRE-CONDITION:  a
00001C86                          1973  * POST-CONDITION: a
00001C86                          1974  * REGISTERS:      a
00001C86                          1975  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C86                          1976  SIZE68
00001C86                          1977          * finish later, need to follow the same format as SIZE67
00001C86                          1978          
00001C86                          1979          
00001C86  48A7 FFFE               1980          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001C8A  3C3C 0006               1981          MOVE.W  #6, D6              * Prep lower value for bitmask
00001C8E  3E3C 0008               1982          MOVE.W  #8, D7              * Prep upper value for bitmask
00001C92  6100 02DE               1983          BSR     BITMASK             * Finalize bitmask setup
00001C96  CC42                    1984          AND     D2,D6               * Apply bitmask          
00001C98                          1985          
00001C98  0C46 0000               1986          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001C9C  6100 0040               1987          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001CA0  0C46 0100               1988          CMPI    #%0000000100000000, D6   * is it a BYTE?
00001CA4  6100 0038               1989          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001CA8                          1990        
00001CA8  0C46 0040               1991          CMPI    #%0000000001000000, D6   * is it a WORD?
00001CAC  6100 003E               1992          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001CB0  0C46 0140               1993          CMPI    #%0000000101000000, D6   * is it a WORD?
00001CB4  6100 0036               1994          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001CB8  0C46 00C0               1995          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
00001CBC  6100 002E               1996          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001CC0                          1997  
00001CC0  0C46 0080               1998          CMPI    #%0000000010000000, D6   * is it a LONG?
00001CC4  6100 0034               1999          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001CC8  0C46 0180               2000          CMPI    #%0000000110000000, D6   * is it a LONG?
00001CCC  6100 002C               2001          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001CD0  0C46 01C0               2002          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001CD4  6100 0024               2003          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001CD8                          2004  
00001CD8  4C9F 7FFF               2005          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001CDC  4E75                    2006          RTS                             * Return. Size handling is finished.
00001CDE                          2007  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001CDE                          2008  *-----------------------------------------------------------------------------
00001CDE                          2009  
00001CDE                          2010  
00001CDE                          2011  
00001CDE                          2012  *-----------------------------------------------------------------------------
00001CDE                          2013  *-----------------------------------------------------------------------------
00001CDE                          2014  * NAME:           PRINTBYTE
00001CDE                          2015  * DESCRIPTION:    a
00001CDE                          2016  * PRE-CONDITION:  a
00001CDE                          2017  * POST-CONDITION: a
00001CDE                          2018  * REGISTERS:      a
00001CDE                          2019  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001CDE                          2020  PRINTBYTE
00001CDE  43F9 00002067           2021          LEA     __B,A1      * Load '.B ' into A1
00001CE4  103C 000E               2022          MOVE.B  #14,D0      * Trap #14 setup to print
00001CE8  4E4F                    2023          TRAP    #15         * Perform Trap #14
00001CEA  4E75                    2024          RTS                 * Return to SIZE67/SIZE68
00001CEC                          2025          
00001CEC                          2026  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001CEC                          2027  *-----------------------------------------------------------------------------
00001CEC                          2028  
00001CEC                          2029  
00001CEC                          2030  
00001CEC                          2031  *-----------------------------------------------------------------------------
00001CEC                          2032  *-----------------------------------------------------------------------------
00001CEC                          2033  * NAME:           PRINTWORD
00001CEC                          2034  * DESCRIPTION:    a
00001CEC                          2035  * PRE-CONDITION:  a
00001CEC                          2036  * POST-CONDITION: a
00001CEC                          2037  * REGISTERS:      a
00001CEC                          2038  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001CEC                          2039  PRINTWORD
00001CEC  43F9 0000206B           2040          LEA     __W,A1      * Load '.W ' into A1
00001CF2  103C 000E               2041          MOVE.B  #14,D0      * Trap #14 setup to print
00001CF6  4E4F                    2042          TRAP    #15         * Perform Trap #14
00001CF8  4E75                    2043          RTS                 * Return to SIZE67/SIZE68
00001CFA                          2044          
00001CFA                          2045  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001CFA                          2046  *-----------------------------------------------------------------------------
00001CFA                          2047  
00001CFA                          2048  
00001CFA                          2049  
00001CFA                          2050  *-----------------------------------------------------------------------------
00001CFA                          2051  *-----------------------------------------------------------------------------
00001CFA                          2052  * NAME:           PRINTLONG
00001CFA                          2053  * DESCRIPTION:    a
00001CFA                          2054  * PRE-CONDITION:  a
00001CFA                          2055  * POST-CONDITION: a
00001CFA                          2056  * REGISTERS:      a
00001CFA                          2057  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001CFA                          2058  PRINTLONG
00001CFA  43F9 0000206F           2059          LEA     __L,A1      * Load '.L ' into A1
00001D00  103C 000E               2060          MOVE.B  #14,D0      * Trap #14 setup to print
00001D04  4E4F                    2061          TRAP    #15         * Perform Trap #14
00001D06  4E75                    2062          RTS                 * Return to SIZE67/SIZE68
00001D08                          2063          
00001D08                          2064  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D08                          2065  *-----------------------------------------------------------------------------
00001D08                          2066  
00001D08                          2067  
00001D08                          2068  
00001D08                          2069  *-----------------------------------------------------------------------------
00001D08                          2070  *-----------------------------------------------------------------------------
00001D08                          2071  * NAME:           UNKNOWNOP
00001D08                          2072  * DESCRIPTION:    a
00001D08                          2073  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001D08                          2074  *                 identified as an unknown operation.
00001D08                          2075  * POST-CONDITION: D2 is no longer the opcode.
00001D08                          2076  * REGISTERS:      a
00001D08                          2077  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D08                          2078  UNKNOWNOP
00001D08  220A                    2079          MOVE.L  A2,D1   * prep the add to print
00001D0A                          2080          
00001D0A  5581                    2081          SUB.L   #2,D1   * off by two error due to post increment correct
00001D0C                          2082          
00001D0C  2602                    2083          MOVE.L  D2,D3   * save the opcode to print
00001D0E                          2084          
00001D0E  7410                    2085          MOVE.L  #16,D2  * set the base to 16
00001D10                          2086          
00001D10  700F                    2087          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001D12  4E4F                    2088          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001D14                          2089          
00001D14  43F9 00002011           2090          LEA     DATA,A1 * load " DATA $" into register A1
00001D1A  700E                    2091          MOVE.L  #14,D0  * print the string stored in A1
00001D1C  4E4F                    2092          TRAP    #15
00001D1E                          2093          
00001D1E  2203                    2094          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001D20                          2095          
00001D20  103C 000F               2096          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001D24  4E4F                    2097          TRAP    #15      * Perform Trap #3
00001D26                          2098  
00001D26  43F9 00001FB6           2099          LEA     NEWLINE,A1 * load newline into register A1
00001D2C  700E                    2100          MOVE.L  #14,D0  * print the string stored in A1
00001D2E  4E4F                    2101          TRAP    #15
00001D30                          2102  
00001D30  4E75                    2103          RTS
00001D32                          2104  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D32                          2105  *-----------------------------------------------------------------------------
00001D32                          2106  
00001D32                          2107  
00001D32                          2108  
00001D32                          2109  *-----------------------------------------------------------------------------
00001D32                          2110  *-----------------------------------------------------------------------------
00001D32                          2111  * NAME: Print ASCII hex char
00001D32                          2112  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
00001D32                          2113  * PRE-CONDITION:  A6 contains the register for memory to print.
00001D32                          2114  *                 This parameter would be pre-loaded by, for example:
00001D32                          2115  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001D32                          2116  *                 D6 contains the loops to do (number of bytes).
00001D32                          2117  * POST-CONDITION: 
00001D32                          2118  * REGISTERS:      
00001D32                          2119  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D32                          2120  PRINT_ASCII_HEX_CHAR
00001D32  48E7 FFFC               2121      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001D36  4285                    2122      CLR.L       D5
00001D38                          2123      
00001D38                          2124      * fence post check (if-statement, check if 0 > chars)
00001D38  0C06 0000               2125      CMPI.B      #0,D6
00001D3C  6700 017C               2126      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001D40                          2127      
00001D40                          2128  *    MOVE.L      A6,D4
00001D40  2E0E                    2129      MOVE.L      A6,D7
00001D42                          2130  PRINT_ASCII_LOOP
00001D42                          2131  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001D42                          2132  *    MOVE.L      D4,D7 * make a mutable copy
00001D42  E99F                    2133      ROL.L       #4,D7 * roll to next spot
00001D44  48E7 0100               2134      MOVEM.L     D7,-(A7) * save D7
00001D48                          2135  
00001D48  0287 0000000F           2136      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001D4E                          2137      
00001D4E  0C87 00000000           2138      CMPI.L      #0,D7
00001D54  6D00 0164               2139      BLT         INVALID_ASCII_INPUT
00001D58                          2140  
00001D58  0C87 0000000F           2141      CMPI.L      #15,D7
00001D5E  6E00 015A               2142      BGT         INVALID_ASCII_INPUT
00001D62                          2143  
00001D62                          2144      * this might be faster... to do later, after entire assignment done
00001D62                          2145       * CMPI.L      #9,D7
00001D62                          2146       * BLE         PRINT_ASCII_0_TO_9
00001D62                          2147  
00001D62  0C87 00000000           2148      CMPI.L      #0,D7
00001D68  6700 0098               2149      BEQ         PRINT_ASCII_0
00001D6C  0C87 00000001           2150      CMPI.L      #1,D7
00001D72  6700 0098               2151      BEQ         PRINT_ASCII_1
00001D76  0C87 00000002           2152      CMPI.L      #2,D7
00001D7C  6700 0098               2153      BEQ         PRINT_ASCII_2
00001D80  0C87 00000003           2154      CMPI.L      #3,D7
00001D86  6700 0098               2155      BEQ         PRINT_ASCII_3
00001D8A  0C87 00000004           2156      CMPI.L      #4,D7
00001D90  6700 0098               2157      BEQ         PRINT_ASCII_4
00001D94  0C87 00000005           2158      CMPI.L      #5,D7
00001D9A  6700 0098               2159      BEQ         PRINT_ASCII_5
00001D9E  0C87 00000006           2160      CMPI.L      #6,D7
00001DA4  6700 0098               2161      BEQ         PRINT_ASCII_6
00001DA8  0C87 00000007           2162      CMPI.L      #7,D7
00001DAE  6700 0098               2163      BEQ         PRINT_ASCII_7
00001DB2  0C87 00000008           2164      CMPI.L      #8,D7
00001DB8  6700 0098               2165      BEQ         PRINT_ASCII_8
00001DBC  0C87 00000009           2166      CMPI.L      #9,D7
00001DC2  6700 0098               2167      BEQ         PRINT_ASCII_9
00001DC6  0C87 0000000A           2168      CMPI.L      #10,D7
00001DCC  6700 0098               2169      BEQ         PRINT_ASCII_A
00001DD0  0C87 0000000B           2170      CMPI.L      #11,D7
00001DD6  6700 0098               2171      BEQ         PRINT_ASCII_B
00001DDA  0C87 0000000C           2172      CMPI.L      #12,D7
00001DE0  6700 0098               2173      BEQ         PRINT_ASCII_C
00001DE4  0C87 0000000D           2174      CMPI.L      #13,D7
00001DEA  6700 0098               2175      BEQ         PRINT_ASCII_D
00001DEE  0C87 0000000E           2176      CMPI.L      #14,D7
00001DF4  6700 0098               2177      BEQ         PRINT_ASCII_E
00001DF8  0C87 0000000F           2178      CMPI.L      #15,D7
00001DFE  6700 0098               2179      BEQ         PRINT_ASCII_F
00001E02                          2180  PRINT_ASCII_0
00001E02  43F9 00002037           2181      LEA         ASCII_0,A1
00001E08  6000 0098               2182      BRA         PRINT_ASCII_CHAR
00001E0C                          2183  PRINT_ASCII_1
00001E0C  43F9 00002039           2184      LEA         ASCII_1,A1
00001E12  6000 008E               2185      BRA         PRINT_ASCII_CHAR
00001E16                          2186  PRINT_ASCII_2
00001E16  43F9 0000203B           2187      LEA         ASCII_2,A1
00001E1C  6000 0084               2188      BRA         PRINT_ASCII_CHAR
00001E20                          2189  PRINT_ASCII_3
00001E20  43F9 0000203D           2190      LEA         ASCII_3,A1
00001E26  6000 007A               2191      BRA         PRINT_ASCII_CHAR
00001E2A                          2192  PRINT_ASCII_4
00001E2A  43F9 0000203F           2193      LEA         ASCII_4,A1
00001E30  6000 0070               2194      BRA         PRINT_ASCII_CHAR
00001E34                          2195  PRINT_ASCII_5
00001E34  43F9 00002041           2196      LEA         ASCII_5,A1
00001E3A  6000 0066               2197      BRA         PRINT_ASCII_CHAR
00001E3E                          2198  PRINT_ASCII_6
00001E3E  43F9 00002043           2199      LEA         ASCII_6,A1
00001E44  6000 005C               2200      BRA         PRINT_ASCII_CHAR
00001E48                          2201  PRINT_ASCII_7
00001E48  43F9 00002045           2202      LEA         ASCII_7,A1
00001E4E  6000 0052               2203      BRA         PRINT_ASCII_CHAR
00001E52                          2204  PRINT_ASCII_8
00001E52  43F9 00002047           2205      LEA         ASCII_8,A1
00001E58  6000 0048               2206      BRA         PRINT_ASCII_CHAR
00001E5C                          2207  PRINT_ASCII_9
00001E5C  43F9 00002049           2208      LEA         ASCII_9,A1
00001E62  6000 003E               2209      BRA         PRINT_ASCII_CHAR
00001E66                          2210  PRINT_ASCII_A
00001E66  43F9 0000204B           2211      LEA         ASCII_A,A1
00001E6C  6000 0034               2212      BRA         PRINT_ASCII_CHAR
00001E70                          2213  PRINT_ASCII_B
00001E70  43F9 0000204D           2214      LEA         ASCII_B,A1
00001E76  6000 002A               2215      BRA         PRINT_ASCII_CHAR
00001E7A                          2216  PRINT_ASCII_C
00001E7A  43F9 0000204F           2217      LEA         ASCII_C,A1
00001E80  6000 0020               2218      BRA         PRINT_ASCII_CHAR
00001E84                          2219  PRINT_ASCII_D
00001E84  43F9 00002051           2220      LEA         ASCII_D,A1
00001E8A  6000 0016               2221      BRA         PRINT_ASCII_CHAR
00001E8E                          2222  PRINT_ASCII_E
00001E8E  43F9 00002053           2223      LEA         ASCII_E,A1
00001E94  6000 000C               2224      BRA         PRINT_ASCII_CHAR
00001E98                          2225  PRINT_ASCII_F
00001E98  43F9 00002055           2226      LEA         ASCII_F,A1
00001E9E  6000 0002               2227      BRA         PRINT_ASCII_CHAR
00001EA2                          2228  PRINT_ASCII_CHAR
00001EA2  103C 000E               2229      MOVE.B      #14,D0
00001EA6  4E4F                    2230      TRAP        #15
00001EA8                          2231      
00001EA8  5205                    2232      ADD.B       #1,D5 * loop until counter stops
00001EAA  BA06                    2233      CMP.B       D6,D5
00001EAC  6C00 000C               2234      BGE         PRINT_ASCII_FINISH
00001EB0                          2235      
00001EB0  4287                    2236      CLR.L       D7
00001EB2  4CDF 0080               2237      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001EB6                          2238      
00001EB6  6000 FE8A               2239      BRA         PRINT_ASCII_LOOP
00001EBA                          2240  INVALID_ASCII_INPUT
00001EBA                          2241  PRINT_ASCII_FINISH
00001EBA  4CDF 3FFF               2242      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001EBE  4E75                    2243      RTS
00001EC0                          2244      
00001EC0                          2245  PRINTDATA911
00001EC0  0C46 0E00               2246      CMPI    #%0000111000000000, D6   * Print 7
00001EC4  6700 003C               2247      BEQ     PRINT7   
00001EC8  0C46 0C00               2248      CMPI    #%0000110000000000, D6   * Print 6
00001ECC  6700 0042               2249      BEQ     PRINT6
00001ED0  0C46 0A00               2250      CMPI    #%0000101000000000, D6   * Print 5
00001ED4  6700 0048               2251      BEQ     PRINT5
00001ED8  0C46 0800               2252      CMPI    #%0000100000000000, D6   * Print 4
00001EDC  6700 004E               2253      BEQ     PRINT4 
00001EE0  0C46 0600               2254      CMPI    #%0000011000000000, D6   * Print 3
00001EE4  6700 0054               2255      BEQ     PRINT3    
00001EE8  0C46 0400               2256      CMPI    #%0000010000000000, D6   * Print 2
00001EEC  6700 005A               2257      BEQ     PRINT2   
00001EF0  0C46 0200               2258      CMPI    #%0000001000000000, D6   * Print 1
00001EF4  6700 0060               2259      BEQ     PRINT1     
00001EF8  0C46 0000               2260      CMPI    #%0000000000000000, D6   * Print 0
00001EFC  6700 0066               2261      BEQ     PRINT8
00001F00                          2262      
00001F00  4E75                    2263      RTS                             * Fail case  
00001F02                          2264      
00001F02                          2265  PRINT7
00001F02  43F9 00002045           2266      LEA     ASCII_7, A1
00001F08  103C 000E               2267      MOVE.B      #14,D0
00001F0C  4E4F                    2268      TRAP        #15
00001F0E  4E75                    2269      RTS
00001F10                          2270      
00001F10                          2271  PRINT6
00001F10  43F9 00002043           2272      LEA     ASCII_6, A1
00001F16  103C 000E               2273      MOVE.B      #14,D0
00001F1A  4E4F                    2274      TRAP        #15
00001F1C  4E75                    2275      RTS
00001F1E                          2276      
00001F1E                          2277  PRINT5
00001F1E  43F9 00002041           2278      LEA     ASCII_5, A1
00001F24  103C 000E               2279      MOVE.B      #14,D0
00001F28  4E4F                    2280      TRAP        #15
00001F2A  4E75                    2281      RTS
00001F2C                          2282      
00001F2C                          2283  PRINT4
00001F2C  43F9 0000203F           2284      LEA     ASCII_4, A1
00001F32  103C 000E               2285      MOVE.B      #14,D0
00001F36  4E4F                    2286      TRAP        #15
00001F38  4E75                    2287      RTS
00001F3A                          2288      
00001F3A                          2289  PRINT3
00001F3A  43F9 0000203D           2290      LEA     ASCII_3, A1
00001F40  103C 000E               2291      MOVE.B      #14,D0
00001F44  4E4F                    2292      TRAP        #15
00001F46  4E75                    2293      RTS
00001F48                          2294      
00001F48                          2295  PRINT2
00001F48  43F9 0000203B           2296      LEA     ASCII_2, A1
00001F4E  103C 000E               2297      MOVE.B      #14,D0
00001F52  4E4F                    2298      TRAP        #15
00001F54  4E75                    2299      RTS
00001F56                          2300      
00001F56                          2301  PRINT1
00001F56  43F9 00002039           2302      LEA     ASCII_1, A1
00001F5C  103C 000E               2303      MOVE.B      #14,D0
00001F60  4E4F                    2304      TRAP        #15
00001F62  4E75                    2305      RTS
00001F64                          2306          
00001F64                          2307  PRINT8
00001F64  43F9 00002047           2308      LEA     ASCII_8, A1
00001F6A  103C 000E               2309      MOVE.B      #14,D0
00001F6E  4E4F                    2310      TRAP        #15
00001F70  4E75                    2311      RTS
00001F72                          2312  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001F72                          2313  *-----------------------------------------------------------------------------
00001F72                          2314  
00001F72                          2315  
00001F72                          2316  
00001F72                          2317  *-----------------------------------------------------------------------------
00001F72                          2318  *-----------------------------------------------------------------------------
00001F72                          2319  * NAME: Bitmask
00001F72                          2320  * DESCRIPTION:    Masks bits in a data register.
00001F72                          2321  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001F72                          2322  *                 the ending bit.  For example, a starting bit of decimal
00001F72                          2323  *                 value 0 and an ending bit of decimal value 3 will mask the
00001F72                          2324  *                 bits 0, 1, 2, and 3.
00001F72                          2325  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001F72                          2326  * REGISTERS:      D5,D6,D7
00001F72                          2327  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001F72                          2328  BITMASK
00001F72  3F05                    2329          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001F74  4245                    2330          CLR     D5          * clear D5 so we can use it
00001F76                          2331  LOOPBIT 
00001F76  0DC5                    2332          BSET    D6,D5       * set the D6th bit in D5 to 1
00001F78  5246                    2333          ADD     #1,D6       * increment D6
00001F7A                          2334  
00001F7A  BC47                    2335          CMP     D7,D6       * have we finished?
00001F7C  6E00 0004               2336          BGT     BITMASKDONE * yes
00001F80  60F4                    2337          BRA     LOOPBIT     * no, iterate again
00001F82                          2338  
00001F82                          2339  BITMASKDONE
00001F82  2C05                    2340          MOVE.L  D5,D6
00001F84  3A1F                    2341          MOVE    (A7)+,D5    * restore D5
00001F86  4E75                    2342          RTS
00001F88                          2343  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001F88                          2344  *-----------------------------------------------------------------------------
00001F88                          2345  
00001F88                          2346  
00001F88                          2347  
00001F88                          2348  *-----------------------------------------------------------------------------
00001F88                          2349  *-----------------------------------------------------------------------------
00001F88                          2350  * SECTION: Constants/variables used throughout the program.
00001F88                          2351  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001F88                          2352  * ---> GENERAL
00001F88  =0000000D               2353  CR          EQU     $0D
00001F88  =0000000A               2354  LF          EQU     $0A
00001F88= 45 4E 54 45 52 20 ...   2355  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001FA0= 45 4E 54 45 52 20 ...   2356  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001FB6= 0D 0A 00                2357  NEWLINE     DC.B    CR,LF,0
00001FB9                          2358  * ---> OPS
00001FB9= 44 49 56 53 00          2359  DIVSOP      DC.B    'DIVS',0
00001FBE= 4E 4F 50 00             2360  NOOPERATION DC.B    'NOP',0
00001FC2= 4E 45 47 00             2361  NEGOP       DC.B    'NEG',0
00001FC6= 4D 4F 56 45 00          2362  MOVEOP      DC.B    'MOVE',0
00001FCB= 4D 4F 56 45 4D 00       2363  MOVEMOP     DC.B    'MOVEM',0
00001FD1= 4A 53 52 00             2364  JSROP       DC.B    'JSR',0
00001FD5= 52 54 53 00             2365  RTSOP       DC.B    'RTS',0
00001FD9= 53 55 42 51 00          2366  SUBQOP      DC.B    'SUBQ',0
00001FDE= 4C 45 41 00             2367  LEAOP       DC.B    'LEA',0
00001FE2= 42 43 4C 52 20 00       2368  BCLROP      DC.B    'BCLR ',0
00001FE8= 4D 55 4C 53 00          2369  MULSOP      DC.B    'MULS',0
00001FED= 4F 52 00                2370  OROP        DC.B    'OR',0
00001FF0= 4F 52 49 00             2371  ORIOP       DC.B    'ORI',0
00001FF4= 43 4D 50 49 00          2372  CMPIOP      DC.B    'CMPI',0
00001FF9= 4C 53 4C 00             2373  LSLOP       DC.B    'LSL',0
00001FFD= 4C 53 52 00             2374  LSROP       DC.B    'LSR',0
00002001= 41 53 4C 00             2375  ASLOP       DC.B    'ASL',0
00002005= 41 53 52 00             2376  ASROP       DC.B    'ASR',0
00002009= 52 4F 4C 00             2377  ROLOP       DC.B    'ROL',0
0000200D= 52 4F 52 00             2378  ROROP       DC.B    'ROR',0
00002011= 20 44 41 54 41 20 ...   2379  DATA        DC.B    ' DATA $',0
00002019= 42 43 43 20 00          2380  OP_BCC_MSG  DC.B    'BCC ',0
0000201E= 42 43 53 20 00          2381  OP_BCS_MSG  DC.B    'BCS ',0
00002023= 42 47 45 20 00          2382  OP_BGE_MSG  DC.B    'BGE ',0
00002028= 42 4C 54 20 00          2383  OP_BLT_MSG  DC.B    'BLT ',0
0000202D= 42 56 43 20 00          2384  OP_BVC_MSG  DC.B    'BVC ',0
00002032= 42 52 41 20 00          2385  OP_BRA_MSG  DC.B    'BRA ',0
00002037                          2386  * ---> HEX CHARS
00002037= 30 00                   2387  ASCII_0     DC.B    '0',0
00002039= 31 00                   2388  ASCII_1     DC.B    '1',0
0000203B= 32 00                   2389  ASCII_2     DC.B    '2',0
0000203D= 33 00                   2390  ASCII_3     DC.B    '3',0
0000203F= 34 00                   2391  ASCII_4     DC.B    '4',0
00002041= 35 00                   2392  ASCII_5     DC.B    '5',0
00002043= 36 00                   2393  ASCII_6     DC.B    '6',0
00002045= 37 00                   2394  ASCII_7     DC.B    '7',0
00002047= 38 00                   2395  ASCII_8     DC.B    '8',0
00002049= 39 00                   2396  ASCII_9     DC.B    '9',0
0000204B= 41 00                   2397  ASCII_A     DC.B    'A',0
0000204D= 42 00                   2398  ASCII_B     DC.B    'B',0
0000204F= 43 00                   2399  ASCII_C     DC.B    'C',0
00002051= 44 00                   2400  ASCII_D     DC.B    'D',0
00002053= 45 00                   2401  ASCII_E     DC.B    'E',0
00002055= 46 00                   2402  ASCII_F     DC.B    'F',0
00002057                          2403  * ---> SPECIAL CHARACTERS
00002057= 20 00                   2404  SPACE       DC.B    ' ',0
00002059= 24 00                   2405  DOLLAR      DC.B    '$',0
0000205B= 23 00                   2406  IMD         DC.B    '#',0
0000205D= 2C 00                   2407  COMMA       DC.B    ',',0
0000205F= 28 00                   2408  OBRACK      DC.B    '(',0
00002061= 29 00                   2409  CBRACK      DC.B    ')',0
00002063= 2B 00                   2410  PLUS        DC.B    '+',0
00002065= 2D 00                   2411  MINUS       DC.B    '-',0
00002067                          2412  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00002067= 2E 42 20 00             2413  __B         DC.B    '.B ',0
0000206B= 2E 57 20 00             2414  __W         DC.B    '.W ',0
0000206F= 2E 4C 20 00             2415  __L         DC.B    '.L ',0
00002073                          2416  * ---> ADDRESS REGISTERS A0-A7
00002073= 41 30 00                2417  __A0        DC.B   'A0',0
00002076= 41 31 00                2418  __A1        DC.B   'A1',0    
00002079= 41 32 00                2419  __A2        DC.B   'A2',0
0000207C= 41 33 00                2420  __A3        DC.B   'A3',0
0000207F= 41 34 00                2421  __A4        DC.B   'A4',0
00002082= 41 35 00                2422  __A5        DC.B   'A5',0
00002085= 41 36 00                2423  __A6        DC.B   'A6',0
00002088= 41 37 00                2424  __A7        DC.B   'A7',0
0000208B                          2425  * ---> DATA REGISTERS D0-D7
0000208B= 44 30 00                2426  __D0        DC.B   'D0',0
0000208E= 44 31 00                2427  __D1        DC.B   'D1',0
00002091= 44 32 00                2428  __D2        DC.B   'D2',0
00002094= 44 33 00                2429  __D3        DC.B   'D3',0
00002097= 44 34 00                2430  __D4        DC.B   'D4',0
0000209A= 44 35 00                2431  __D5        DC.B   'D5',0
0000209D= 44 36 00                2432  __D6        DC.B   'D6',0
000020A0= 44 37 00                2433  __D7        DC.B   'D7',0
000020A3                          2434  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000020A3                          2435  *-----------------------------------------------------------------------------
000020A3                          2436  
000020A3                          2437  
000020A3                          2438  
000020A3                          2439  *-----------------------------------------------------------------------------
000020A3                          2440  *-----------------------------------------------------------------------------
000020A3                          2441  * SECTION: Sample program to run, then attempt testing disassembly on.
000020A3                          2442  * STARTING: 16384
000020A3                          2443  * ENDING:   16420
000020A3                          2444  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2445      ORG $4000
00004000                          2446      
00004000  4E71                    2447      NOP
00004002  103C 009A               2448      MOVE.B   #%10011010, D0
00004006  123C 00A9               2449      MOVE.B   #%10101001, D1
0000400A  D200                    2450      ADD.B    D0,D1
0000400C  48A7 4000               2451      MOVEM    D1,-(A7)
00004010  43F8 1FD1               2452      LEA      JSROP,A1
00004014  4467                    2453      NEG.W    -(A7)
00004016  4EB9 00004046           2454      JSR      END
0000401C  81FC 0001               2455      DIVS    #1, D0
00004020  0181                    2456      BCLR    D0, D1
00004022  CFFC 0003               2457      MULS.W  #3, D7
00004026  CFC0                    2458      MULS    D0, D7
00004028  C5D9                    2459      MULS    (A1)+, D2
0000402A  5146                    2460      SUBQ    #8, D6
0000402C  5F81                    2461      SUBQ.L  #7, D1
0000402E  0041 0004               2462      ORI     #4, D1
00004032  E389                    2463      LSL.L   #1,D1
00004034  E489                    2464      LSR.L   #2,D1
00004036  E781                    2465      ASL.L   #3,D1
00004038  E881                    2466      ASR.L   #4,D1
0000403A  EB99                    2467      ROL.L   #5,D1
0000403C  E099                    2468      ROR.L   #8,D1
0000403E  6000 0006               2469      BRA     END
00004042  6700 0002               2470      BEQ     END
00004046                          2471  
00004046                          2472  END
00004046  4E75                    2473      RTS
00004048                          2474      
00004048                          2475  RLLYEND
00004048                          2476      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AS                  1772
ASCII_0             2037
ASCII_1             2039
ASCII_2             203B
ASCII_3             203D
ASCII_4             203F
ASCII_5             2041
ASCII_6             2043
ASCII_7             2045
ASCII_8             2047
ASCII_9             2049
ASCII_A             204B
ASCII_B             204D
ASCII_C             204F
ASCII_D             2051
ASCII_E             2053
ASCII_F             2055
ASL                 1788
ASLOP               2001
ASR                 1798
ASROP               2005
BCC_END             15D2
BCLROP              1FE2
BITMASK             1F72
BITMASKDONE         1F82
CBRACK              2061
CMPIOP              1FF4
COMMA               205D
CR                  D
DATA                2011
DIVSOP              1FB9
DOLLAR              2059
DONE0100            14AC
EAHELPER05          18EC
EAHELPER611         18AA
END                 4046
END0000             1240
END67               1C80
ENDEAHELPER05       1A3C
ENDEAHELPER611      18E6
ENDMODE_AN          1BCC
ENDMODE_DN          1ACC
ENDOP0001           12A6
ENDOP1110           1892
HEX_VALUE_MASK_LONG  F
IMD                 205B
INVALID_ASCII_INPUT  1EBA
ITERATION           1144
JSROP               1FD1
LEAOP               1FDE
LF                  A
LOOP                103A
LOOPBIT             1F76
LOOPUNKNOWNOP       1140
LS                  173C
LSL                 1752
LSLOP               1FF9
LSR                 1762
LSROP               1FFD
MINUS               2065
MODE_AN             1B42
MODE_DN             1A42
MOVEMOP             1FCB
MOVEOP              1FC6
MSGEND              1FA0
MSGSTART            1F88
MULSOP              1FE8
NEGOP               1FC2
NEWLINE             1FB6
NOOPERATION         1FBE
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           1C64
NOT67WORD           1C74
NOTA0               1B64
NOTA1               1B74
NOTA2               1B84
NOTA3               1B94
NOTA4               1BA4
NOTA5               1BB4
NOTA6               1BC4
NOTADRDIRECT        191C
NOTADRINDIRECT      1944
NOTADRINDIRECTPOST  1978
NOTADRINDIRECTPRE   19AC
NOTBCLR             11CE
NOTD0               1A64
NOTD1               1A74
NOTD2               1A84
NOTD3               1A94
NOTD4               1AA4
NOTD5               1AB4
NOTD6               1AC4
NOTDATAREG          190C
NOTDIVS             165C
NOTIMMBYTE          19E2
NOTIMMEDIATE        1A38
NOTIMMWORD          1A10
NOTJSR              13A4
NOTMOVEM            1356
NOTNEG              1332
NOTNOP              12DC
NOTORI              1234
NOTRTS              13C6
OBRACK              205F
OP0000              1150
OP0001              1246
OP0010              12AC
OP0011              12B2
OP0100              12C0
OP0101              14B6
OP0110              1524
OP0111              15D8
OP1000              15DE
OP1000END           166C
OP1001              1672
OP1010              1672
OP1011              1678
OP1100              167E
OP1101              1708
OP1110              170E
OP1110DATAREG       1866
OP1110GENERIC       17DE
OP1110IMMEIGHT      183E
OP1111              18A4
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              1574
OP_BCC_MSG          2019
OP_BCS              157E
OP_BCS_MSG          201E
OP_BGE              1588
OP_BGE_MSG          2023
OP_BLT              1592
OP_BLT_MSG          2028
OP_BRA              15A6
OP_BRANCHES_PRINT   15B0
OP_BRA_MSG          2032
OP_BVC              159C
OP_BVC_MSG          202D
ORIOP               1FF0
OROP                1FED
PLUS                2063
PRINT1              1F56
PRINT2              1F48
PRINT3              1F3A
PRINT4              1F2C
PRINT5              1F1E
PRINT6              1F10
PRINT7              1F02
PRINT8              1F64
PRINTA0             1BD2
PRINTA1             1BE0
PRINTA2             1BEE
PRINTA3             1BFC
PRINTA4             1C0A
PRINTA5             1C18
PRINTA6             1C26
PRINTA7             1C34
PRINTBYTE           1CDE
PRINTD0             1AD2
PRINTD1             1AE0
PRINTD2             1AEE
PRINTD3             1AFC
PRINTD4             1B0A
PRINTD5             1B18
PRINTD6             1B26
PRINTD7             1B34
PRINTDATA911        1EC0
PRINTLONG           1CFA
PRINTWORD           1CEC
PRINT_ASCII_0       1E02
PRINT_ASCII_1       1E0C
PRINT_ASCII_2       1E16
PRINT_ASCII_3       1E20
PRINT_ASCII_4       1E2A
PRINT_ASCII_5       1E34
PRINT_ASCII_6       1E3E
PRINT_ASCII_7       1E48
PRINT_ASCII_8       1E52
PRINT_ASCII_9       1E5C
PRINT_ASCII_A       1E66
PRINT_ASCII_B       1E70
PRINT_ASCII_C       1E7A
PRINT_ASCII_CHAR    1EA2
PRINT_ASCII_D       1E84
PRINT_ASCII_E       1E8E
PRINT_ASCII_F       1E98
PRINT_ASCII_FINISH  1EBA
PRINT_ASCII_HEX_CHAR  1D32
PRINT_ASCII_LOOP    1D42
RLLYEND             4048
RO                  17A8
ROL                 17BE
ROLOP               2009
ROR                 17CE
ROROP               200D
RTSOP               1FD5
SIZE67              1C42
SIZE68              1C86
SPACE               2057
START               1000
SUBQOP              1FD9
TWOWORDLEA          1456
UNKNOWN0000         123C
UNKNOWN0100         14A8
UNKNOWN0101         151E
UNKNOWN1100         16FE
UNKNOWNOP           1D08
UNKNOWNOP0001       12A2
__A0                2073
__A1                2076
__A2                2079
__A3                207C
__A4                207F
__A5                2082
__A6                2085
__A7                2088
__B                 2067
__D0                208B
__D1                208E
__D2                2091
__D3                2094
__D4                2097
__D5                209A
__D6                209D
__D7                20A0
__L                 206F
__W                 206B
