00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 8:35:53 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001D70             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001D88             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001D9E             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0D22                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 01EC                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 0242                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 0238                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 0236                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 041C                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 0476                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 051A                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 0510                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 0594                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 0584                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 057A                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 0570                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 0566                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 055C                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 0552                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 09AE                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2EE6                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 FFC0                212          MOVEM   D0-D7/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0BFC                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162                           218          * TODO: Consider static  AND dynamic BCLR.
00001162                           219          * Only works for Dynamic right now
00001162  0C46 0180                220          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0066                221          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           222          
0000116A  3C3C 0003                223          MOVE.W  #3, D6              * Prep lower value for bitmask
0000116E  3E3C 0005                224          MOVE.W  #5, D7              * Prep upper value for bitmask
00001172  6100 0BE6                225          BSR     BITMASK             * Finalize bitmask setup
00001176  CC42                     226          AND     D2,D6               * Apply bitmask
00001178                           227          
00001178                           228          * Checking for unsupported mode
00001178  0C46 0008                229          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000117C  6700 00BE                230          BEQ     UNKNOWN0000             * If so, branch to other OP0000 functions
00001180                           231          
00001180                           232          * Confirmed BCLR at this point
00001180  43F9 00001DCA            233          LEA     BCLROP,A1           * We found BCLR
00001186  103C 000E                234          MOVE.B  #14,D0              * Trap #14 prints out the data
0000118A  4E4F                     235          TRAP    #15                 * Perform Trap #14
0000118C                           236  
0000118C  43F9 00001E22            237          LEA     SPACE,A1            * Formatting
00001192  103C 000E                238          MOVE.B  #14,D0              * Trap #14 prints out space
00001196  4E4F                     239          TRAP    #15                 * Perform Trap #14
00001198                           240          
00001198                           241          * Set up for printing out the Register
00001198  0882 0006                242          BCLR    #6,D2               * Clear bit 6
0000119C  0882 0007                243          BCLR    #7,D2               * Clear bit 7
000011A0  0882 0008                244          BCLR    #8,D2               * Clear bit 8
000011A4                           245          
000011A4  6100 04EC                246          BSR     EAHELPER611         * Print out Register
000011A8                           247  
000011A8  43F9 00001E28            248          LEA     COMMA,A1            * formatting
000011AE  103C 000E                249          MOVE.B  #14,D0              * Trap #14 prints out a comma
000011B2  4E4F                     250          TRAP    #15                 * Perform Trap #14
000011B4                           251          
000011B4  4243                     252          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000011B6  08C3 0000                253          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000011BA                           254      
000011BA  6100 0518                255          BSR     EAHELPER05          * Print out data.
000011BE                           256          
000011BE  43F9 00001D9E            257          LEA     NEWLINE,A1          * Formatting
000011C4  103C 000E                258          MOVE.B  #14,D0              * Trap #14 prints out the data
000011C8  4E4F                     259          TRAP    #15                 * Perform Trap #14
000011CA                           260          
000011CA  6000 0074                261          BRA     END0000             * Found the op, move to next iteration
000011CE                           262          
000011CE                           263  NOTBCLR * Possible options left are ORI or CMPI
000011CE  3C3C 0009                264          MOVE.W  #9, D6              * Prep lower value for bitmask
000011D2  3E3C 000B                265          MOVE.W  #11, D7             * Prep upper value for bitmask
000011D6  6100 0B82                266          BSR     BITMASK             * Finalize bitmask setup
000011DA  CC42                     267          AND     D2,D6               * Apply bitmask
000011DC                           268          
000011DC  0C46 0000                269          CMPI    #%0000000000000000, D6   * Are we possibly ORI?
000011E0  6600 0052                270          BNE     NOTORI                   * If not, branch to NOTORI
000011E4                           271          
000011E4                           272          * Size check to see if unsupported ORI mode
000011E4  3C3C 0006                273          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E8  3E3C 0007                274          MOVE.W  #7, D7              * Prep upper value for bitmask
000011EC  6100 0B6C                275          BSR     BITMASK             * Finalize bitmask setup
000011F0  CC42                     276          AND     D2,D6               * Apply bitmask
000011F2                           277          
000011F2  0C46 00C0                278          CMPI    #%0000000011000000, D6  * Are bits 6,7 == 1,1?
000011F6  6700 0044                279          BEQ     UNKNOWN0000             * If so, unknown op. 
000011FA                           280          
000011FA                           281          * Mode check to see if unsupported ORI mode
000011FA  3C3C 0003                282          MOVE.W  #3, D6              * Prep lower value for bitmask
000011FE  3E3C 0005                283          MOVE.W  #5, D7              * Prep upper value for bitmask
00001202  6100 0B56                284          BSR     BITMASK             * Finalize bitmask setup
00001206  CC42                     285          AND     D2,D6               * Apply bitmask
00001208                           286          
00001208  0C46 0008                287          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000120C  6700 002E                288          BEQ     UNKNOWN0000             * If so, unknown op. 
00001210                           289          
00001210                           290          * Confirmed ORI at this point
00001210                           291          * TODO: Get the immediate data following the instruction and print it out
00001210  43F9 00001DD3            292          LEA     ORIOP, A1           * Load 'ORI' into the output window
00001216  103C 000E                293          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
0000121A  4E4F                     294          TRAP    #15                 * Perform Trap #14
0000121C                           295          
0000121C  6100 080C                296          BSR     SIZE67              * Print the size
00001220  6100 04B2                297          BSR     EAHELPER05          * Print out the EA
00001224                           298          
00001224  43F9 00001D9E            299          LEA     NEWLINE,A1          * Formatting
0000122A  103C 000E                300          MOVE.B  #14,D0              * Trap #14 prints out the data
0000122E  4E4F                     301          TRAP    #15                 * Perform Trap #14
00001230                           302          
00001230  6000 000E                303          BRA     END0000             * Done with op. Move to next iteration
00001234                           304          
00001234                           305  NOTORI  * Possible option left is CMPI
00001234  0C46 0C00                306          CMPI    #%0000110000000000, D6  * Are we CMPI?
00001238  6600 0002                307          BNE     UNKNOWN0000             * If not, unknown op
0000123C                           308          
0000123C                           309          * TODO: Continue checking for CMPI validity
0000123C                           310          
0000123C                           311  UNKNOWN0000
0000123C  6100 08B2                312          BSR     UNKNOWNOP       * Unknown op
00001240                           313          
00001240                           314  END0000          
00001240  4C9F 03FF                315         MOVEM   (A7)+,D0-D7/A0-A1   * Push values to the stack to save
00001244  4E75                     316         RTS
00001246                           317  
00001246                           318  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001246                           319  *-----------------------------------------------------------------------------
00001246                           320  
00001246                           321  
00001246                           322  
00001246                           323  *-----------------------------------------------------------------------------
00001246                           324  *-----------------------------------------------------------------------------
00001246                           325  * NAME: OP_0001   (MOVE.B)
00001246                           326  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001246                           327  * PRE-CONDITION:  xyz
00001246                           328  * POST-CONDITION: All registers return to their previous state, and the output
00001246                           329  *                 goes to the output console for reading the raw data or the
00001246                           330  *                 actual instruction.
00001246                           331  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001246                           332  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001246                           333  OP0001  
00001246  48A7 FFC0                334          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
0000124A  3C3C 0006                335          MOVE.W  #6, D6              * Prep lower value for bitmask
0000124E  3E3C 0008                336          MOVE.W  #8, D7              * Prep upper value for bitmask
00001252  6100 0B06                337          BSR     BITMASK             * Finalize bitmask setup
00001256  CC42                     338          AND     D2,D6               * Apply bitmask
00001258                           339          
00001258                           340          * I may have fucked off this part, sorry - Caleb
00001258                           341          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
00001258                           342          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
00001258                           343          
00001258  43F9 00001DAE            344          LEA     MOVEOP,A1   * Put 'MOVE' into the window
0000125E  103C 000E                345          MOVE.B  #14,D0      * Trap #14 to print out
00001262  4E4F                     346          TRAP    #15         * Perform Trap #14
00001264                           347          
00001264                           348          *-----------------------------------------------------------
00001264                           349          * the following code is to move the size bits into the
00001264                           350          * 0-1 positions of D3 so that eahelper05 case use that as a "parameter"
00001264                           351          * for eahelper05
00001264                           352          
00001264  3C3C 000C                353          MOVE.W  #12, D6              * Prep lower value for bitmask
00001268  3E3C 000D                354          MOVE.W  #13, D7              * Prep upper value for bitmask
0000126C  6100 0AEC                355          BSR     BITMASK             * Finalize bitmask setup
00001270                           356          
00001270  CC42                     357          AND     D2,D6
00001272                           358          
00001272  E04E                     359          LSR     #8,D6
00001274  E84E                     360          LSR     #4,D6
00001276                           361          
00001276  4243                     362          CLR     D3
00001278                           363          
00001278  1606                     364          MOVE.B  D6,D3
0000127A                           365          
0000127A                           366          *---------------------------------------------------------------
0000127A                           367          
0000127A                           368          
0000127A  6100 07AE                369          BSR     SIZE67
0000127E  6100 0454                370          BSR     EAHELPER05
00001282                           371          
00001282  43F9 00001E28            372          LEA     COMMA,A1
00001288  103C 000E                373          MOVE.B  #14,D0
0000128C  4E4F                     374          TRAP    #15
0000128E                           375          
0000128E  6100 0402                376          BSR     EAHELPER611
00001292                           377          
00001292  43F9 00001D9E            378          LEA     NEWLINE,A1
00001298  103C 000E                379          MOVE.B  #14,D0
0000129C  4E4F                     380          TRAP    #15
0000129E                           381          
0000129E  6000 0006                382          BRA     ENDOP0001
000012A2                           383          *LEA     __B,A1      * Put '.B' into the window
000012A2                           384          *MOVE.B  #14,D0      * Trap #14 to print out
000012A2                           385          *TRAP    #15         * Perform Trap #14
000012A2                           386          
000012A2                           387  UNKNOWNOP0001
000012A2                           388  
000012A2  6100 084C                389          BSR     UNKNOWNOP
000012A6                           390          
000012A6                           391  ENDOP0001
000012A6                           392  
000012A6  4C9F 03FF                393          MOVEM (A7)+,D0-D7/A0-A1
000012AA  4E75                     394          RTS        
000012AC                           395          
000012AC                           396          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
000012AC                           397  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012AC                           398  *-----------------------------------------------------------------------------
000012AC                           399  
000012AC                           400  
000012AC                           401  
000012AC                           402  *-----------------------------------------------------------------------------
000012AC                           403  *-----------------------------------------------------------------------------
000012AC                           404  * NAME: OP_0010   (MOVE.L, MOVEA.L)
000012AC                           405  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012AC                           406  * PRE-CONDITION:  xyz
000012AC                           407  * POST-CONDITION: All registers return to their previous state, and the output
000012AC                           408  *                 goes to the output console for reading the raw data or the
000012AC                           409  *                 actual instruction.
000012AC                           410  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012AC                           411  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012AC                           412  OP0010
000012AC                           413  
000012AC  6100 0842                414      BSR     UNKNOWNOP
000012B0  4E75                     415      RTS
000012B2                           416  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012B2                           417  *-----------------------------------------------------------------------------
000012B2                           418  
000012B2                           419  
000012B2                           420  
000012B2                           421  *-----------------------------------------------------------------------------
000012B2                           422  *-----------------------------------------------------------------------------
000012B2                           423  * NAME: OP_0011   (MOVE.W, MOVEA.W)
000012B2                           424  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012B2                           425  * PRE-CONDITION:  xyz
000012B2                           426  * POST-CONDITION: All registers return to their previous state, and the output
000012B2                           427  *                 goes to the output console for reading the raw data or the
000012B2                           428  *                 actual instruction.
000012B2                           429  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012B2                           430  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012B2                           431  OP0011
000012B2  48A7 FFFE                432      MOVEM   D0-D7/A0-A6, -(A7)
000012B6                           433      
000012B6                           434      *MOVE.W  #6,D6
000012B6                           435      *MOVE.W  #8,D7
000012B6                           436      
000012B6                           437      *BSR     BITMASK
000012B6                           438      
000012B6                           439      *AND.W   D2,D6
000012B6                           440      
000012B6                           441      *CMP     #%0000000001000000,D6
000012B6                           442      *BNE     NEXT15
000012B6                           443      *BSR     * for MOVEA.W
000012B6                           444      
000012B6  4C9F 7FFF                445      MOVEM   (A7)+,D0-D7/A0-A6
000012BA                           446      
000012BA  6100 0834                447      BSR     UNKNOWNOP
000012BE  4E75                     448      RTS
000012C0                           449  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012C0                           450  *-----------------------------------------------------------------------------
000012C0                           451  
000012C0                           452  
000012C0                           453  
000012C0                           454  *-----------------------------------------------------------------------------
000012C0                           455  *-----------------------------------------------------------------------------
000012C0                           456  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
000012C0                           457  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012C0                           458  * PRE-CONDITION:  xyz
000012C0                           459  * POST-CONDITION: All registers return to their previous state, and the output
000012C0                           460  *                 goes to the output console for reading the raw data or the
000012C0                           461  *                 actual instruction.
000012C0                           462  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012C0                           463  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012C0                           464  OP0100  
000012C0                           465          * TODO: movem
000012C0                           466  
000012C0  48A7 C0C0                467          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000012C4                           468          
000012C4                           469          *NOP
000012C4  0C42 4E71                470          CMPI    #%0100111001110001,D2
000012C8  6600 0012                471          BNE     NOTNOP
000012CC                           472          
000012CC  43F9 00001DA6            473          LEA     NOOPERATION,A1
000012D2  103C 000D                474          MOVE.B  #13,D0          * Print a newline
000012D6  4E4F                     475          TRAP    #15
000012D8                           476          
000012D8  6000 01D2                477          BRA     DONE0100 *we found it, move on to the next iteration
000012DC                           478  NOTNOP *NEG
000012DC                           479          
000012DC                           480          * prep values for BITMASK subroutine
000012DC  7C08                     481          MOVE.L  #8,D6
000012DE  7E0B                     482          MOVE.L  #11,D7
000012E0                           483          
000012E0  6100 0A78                484          BSR     BITMASK
000012E4                           485          
000012E4  CC42                     486          AND     D2,D6                   * apply bitmask
000012E6                           487          
000012E6  0C46 0400                488          CMPI    #%0000010000000000,D6   * are we NEG?
000012EA  6600 0046                489          BNE     NOTNEG                  * not neg
000012EE                           490          
000012EE  7C03                     491          MOVE.L  #3,D6
000012F0  7E05                     492          MOVE.L  #5,D7
000012F2                           493          
000012F2  6100 0A66                494          BSR     BITMASK * generate a bitmask to be used to check mode
000012F6                           495          
000012F6  0C46 0008                496          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
000012FA  6700 01AC                497          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
000012FE                           498          
000012FE  0C46 0028                499          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001302  6700 01A4                500          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
00001306                           501          
00001306  0C46 0030                502          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000130A  6700 019C                503          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
0000130E                           504        
0000130E                           505          * it is NEG, print
0000130E  43F9 00001DAA            506          LEA     NEGOP,A1
00001314  103C 000E                507          MOVE.B  #14,D0
00001318  4E4F                     508          TRAP    #15
0000131A                           509          
0000131A  6100 070E                510          BSR     SIZE67
0000131E                           511          
0000131E  6100 03B4                512          BSR     EAHELPER05
00001322                           513          
00001322  43F9 00001D9E            514          LEA     NEWLINE,A1
00001328  103C 000E                515          MOVE.B  #14,D0
0000132C  4E4F                     516          TRAP    #15
0000132E                           517          
0000132E  6000 017C                518          BRA     DONE0100 * we found the op, move to next iteration
00001332                           519          
00001332                           520  NOTNEG *MOVEM
00001332                           521  
00001332                           522          * prep values for BITMASK subroutine
00001332  7C07                     523          MOVE.L  #7,D6
00001334  7E09                     524          MOVE.L  #9,D7
00001336                           525          
00001336  6100 0A22                526          BSR     BITMASK
0000133A                           527          
0000133A  CC42                     528          AND     D2,D6   * apply bitmask
0000133C                           529          
0000133C  0C46 0080                530          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001340  6600 0014                531          BNE     NOTMOVEM          * it is not MOVEM
00001344                           532          
00001344                           533          * make sure it is a valid size and mode for MOVEM
00001344                           534          
00001344                           535          * it is MOVEM
00001344  43F9 00001DB3            536          LEA     MOVEMOP,A1
0000134A  103C 000D                537          MOVE.B  #13,D0          * Print a newline
0000134E  4E4F                     538          TRAP    #15
00001350                           539          
00001350                           540          * probably needs its own special code for printing the rest due to uniqueness of movem
00001350                           541          
00001350  341A                     542          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001352                           543          
00001352  6000 0158                544          BRA     DONE0100          * we found and printed, move on to the next iteration
00001356                           545          
00001356                           546  NOTMOVEM *JSR
00001356                           547          * prep values for BITMASK subroutine
00001356  7C06                     548          MOVE.L  #6,D6
00001358  7E08                     549          MOVE.L  #8,D7
0000135A                           550          
0000135A  6100 09FE                551          BSR     BITMASK
0000135E                           552          
0000135E  CC42                     553          AND     D2,D6   * apply bitmask
00001360                           554          
00001360  0C46 0080                555          CMPI    #%0000000010000000,D6
00001364  6600 003E                556          BNE     NOTJSR          * it's not JSR
00001368                           557          
00001368  43F9 00001DB9            558          LEA     JSROP,A1
0000136E  103C 000E                559          MOVE.B  #14,D0          * Print a newline and JSR
00001372  4E4F                     560          TRAP    #15
00001374                           561          
00001374  43F9 00001E22            562          LEA     SPACE,A1
0000137A  103C 000E                563          MOVE.B  #14,D0          * Print a newline and JSR
0000137E  4E4F                     564          TRAP    #15
00001380                           565          
00001380                           566          * print out where we are jumping to
00001380                           567          
00001380  341A                     568          MOVE.W  (A2)+,D2 * read in the next word of the instruction 
00001382                           569          
00001382  2202                     570          MOVE.L  D2,D1   * save the opcode to print
00001384                           571          
00001384  7410                     572          MOVE.L  #16,D2  * set the base to 16
00001386                           573          
00001386  700F                     574          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001388  4E4F                     575          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000138A                           576          
0000138A  341A                     577          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000138C                           578          
0000138C  2202                     579          MOVE.L  D2,D1   * save the opcode to print
0000138E                           580          
0000138E  7410                     581          MOVE.L  #16,D2  * set the base to 16
00001390                           582          
00001390  700F                     583          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001392  4E4F                     584          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001394                           585          
00001394  43F9 00001D9E            586          LEA     NEWLINE,A1
0000139A  103C 000E                587          MOVE.B  #14,D0          * Print a newline
0000139E  4E4F                     588          TRAP    #15
000013A0                           589          
000013A0  6000 010A                590          BRA     DONE0100          * we already found instruction, next iteration
000013A4                           591  NOTJSR *RTS
000013A4                           592  
000013A4                           593          * prep values for BITMASK subroutine
000013A4  7C06                     594          MOVE.L  #6,D6
000013A6  7E08                     595          MOVE.L  #8,D7
000013A8                           596          
000013A8  6100 09B0                597          BSR     BITMASK
000013AC                           598          
000013AC  CC42                     599          AND     D2,D6   * apply bitmask
000013AE                           600          
000013AE  0C46 0040                601          CMPI    #%0000000001000000,D6
000013B2  6600 0012                602          BNE     NOTRTS          * it's not RTS
000013B6                           603          
000013B6  43F9 00001DBD            604          LEA     RTSOP,A1
000013BC  103C 000D                605          MOVE.B  #13,D0          * Print a newline and RTS
000013C0  4E4F                     606          TRAP    #15
000013C2                           607          
000013C2  6000 00E8                608          BRA     DONE0100          * we already found instruction, next iteration
000013C6                           609  NOTRTS  *LEA
000013C6                           610         
000013C6                           611          * prep values for BITMASK subroutine
000013C6  7C06                     612          MOVE.L  #6,D6
000013C8  7E08                     613          MOVE.L  #8,D7
000013CA                           614          
000013CA  6100 098E                615          BSR     BITMASK
000013CE                           616          
000013CE  CC42                     617          AND     D2,D6   * apply bitmask
000013D0                           618          
000013D0  0C46 01C0                619          CMPI    #%0000000111000000,D6
000013D4  6600 00D2                620          BNE     UNKNOWN0100          * it's not LEA, we dont know what it is
000013D8                           621          
000013D8                           622          * prep values for BITMASK subroutine
000013D8  7C03                     623          MOVE.L  #3,D6
000013DA  7E05                     624          MOVE.L  #5,D7
000013DC                           625          
000013DC  6100 097C                626          BSR     BITMASK
000013E0                           627          
000013E0  CC42                     628          AND     D2,D6   * apply bitmask
000013E2                           629          
000013E2  0C46 0008                630          CMPI    #%0000000000001000,D6
000013E6  6700 00C0                631          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013EA                           632          
000013EA  0C46 0018                633          CMPI    #%0000000000011000,D6
000013EE  6700 00B8                634          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013F2                           635          
000013F2  0C46 0020                636          CMPI    #%0000000000100000,D6
000013F6  6700 00B0                637          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013FA                           638          
000013FA  0C46 0028                639          CMPI    #%0000000000101000,D6
000013FE  6700 00A8                640          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001402                           641          
00001402  0C46 0030                642          CMPI    #%0000000000110000,D6
00001406  6700 00A0                643          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
0000140A                           644          
0000140A  0C46 0038                645          CMPI    #%0000000000111000,D6
0000140E  6700 0046                646          BEQ     TWOWORDLEA          * it's not LEA, we dont know what it is
00001412                           647          
00001412                           648          * check to make sure it is a supported mode and size
00001412                           649          
00001412  43F9 00001DC6            650          LEA     LEAOP,A1
00001418  103C 000E                651          MOVE.B  #14,D0          * Print LEA
0000141C  4E4F                     652          TRAP    #15
0000141E                           653          
0000141E  0882 0007                654          BCLR    #7,D2
00001422  0882 0008                655          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001426                           656          
00001426  43F9 00001E22            657          LEA     SPACE,A1
0000142C  103C 000E                658          MOVE.B  #14,D0          * Print SPACE
00001430  4E4F                     659          TRAP    #15
00001432                           660          
00001432  6100 02A0                661          BSR     EAHELPER05
00001436                           662          
00001436  43F9 00001E28            663          LEA     COMMA,A1
0000143C  103C 000E                664          MOVE.B  #14,D0          * Print COMMA
00001440  4E4F                     665          TRAP    #15
00001442                           666          
00001442  6100 024E                667          BSR     EAHELPER611
00001446                           668          
00001446  43F9 00001D9E            669          LEA     NEWLINE,A1
0000144C  103C 000E                670          MOVE.B  #14,D0          * Start a new line
00001450  4E4F                     671          TRAP    #15
00001452                           672          
00001452                           673          
00001452                           674          * call EA helper
00001452                           675          * MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001452                           676                  
00001452  6000 0058                677          BRA     DONE0100          * we already found instruction, next iteration
00001456                           678          
00001456                           679  TWOWORDLEA
00001456                           680  
00001456  43F9 00001DC6            681          LEA     LEAOP,A1
0000145C  103C 000E                682          MOVE.B  #14,D0   * Print LEA
00001460  4E4F                     683          TRAP    #15
00001462                           684          
00001462  43F9 00001E22            685          LEA     SPACE,A1
00001468  103C 000E                686          MOVE.B  #14,D0   * Print SPACE
0000146C  4E4F                     687          TRAP    #15
0000146E                           688  
0000146E  321A                     689          MOVE.W  (A2)+,D1
00001470                           690          
00001470  7C00                     691          MOVE.L  #0,D6
00001472  7E0F                     692          MOVE.L  #15,D7
00001474                           693          
00001474  6100 08E4                694          BSR     BITMASK
00001478                           695          
00001478  C286                     696          AND.L   D6,D1   * shave off bad info
0000147A                           697          
0000147A  103C 0003                698          MOVE.B  #3,D0   * Print the address which was the source
0000147E  4E4F                     699          TRAP    #15
00001480                           700          
00001480  43F9 00001E28            701          LEA     COMMA,A1
00001486  103C 000E                702          MOVE.B  #14,D0  * Print COMMA
0000148A  4E4F                     703          TRAP    #15
0000148C                           704          
0000148C  0882 0007                705          BCLR    #7,D2
00001490  0882 0008                706          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001494                           707          
00001494  6100 01FC                708          BSR     EAHELPER611
00001498                           709          
00001498  43F9 00001D9E            710          LEA     NEWLINE,A1
0000149E  103C 000E                711          MOVE.B  #14,D0          * Start a new line
000014A2  4E4F                     712          TRAP    #15
000014A4                           713          
000014A4  6000 0006                714          BRA     DONE0100
000014A8                           715          
000014A8                           716  UNKNOWN0100 *dont know what it is
000014A8  6100 0646                717          BSR     UNKNOWNOP
000014AC                           718          
000014AC                           719  DONE0100
000014AC  4C9F 0303                720          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000014B0  4E75                     721          RTS
000014B2                           722          
000014B2  6000 FC90                723          BRA     ITERATION
000014B6                           724  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014B6                           725  *-----------------------------------------------------------------------------        
000014B6                           726          
000014B6                           727          
000014B6                           728  
000014B6                           729  *-----------------------------------------------------------------------------
000014B6                           730  *-----------------------------------------------------------------------------
000014B6                           731  * NAME: OP_0101   (SUBQ)
000014B6                           732  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000014B6                           733  * PRE-CONDITION:  xyz
000014B6                           734  * POST-CONDITION: All registers return to their previous state, and the output
000014B6                           735  *                 goes to the output console for reading the raw data or the
000014B6                           736  *                 actual instruction.
000014B6                           737  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000014B6                           738  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014B6                           739  OP0101
000014B6  48A7 FFC0                740          MOVEM   D0-D7/A0-A1,-(A7) * Push values to the stack to save
000014BA                           741  
000014BA  CC7C 0100                742          AND     #%0000000100000000, D6  * Baby-Bitmask for the 8th digit.
000014BE  0C46 0100                743          CMPI    #%0000000100000000, D6  * Is the 8th digit a 1?
000014C2  6700 004C                744          BEQ     UNKNOWN0101             * If so, unknown op
000014C6                           745        
000014C6  0C46 0100                746          CMPI    #%0000000100000000, D6  * Is the size 11, an unsupported value?
000014CA  6700 0044                747          BEQ     UNKNOWN0101             * If so, unknown op
000014CE                           748            
000014CE                           749          * Verified SUBQ at this point
000014CE  43F9 00001DC1            750          LEA     SUBQOP,A1           * Print out SUBQ
000014D4  103C 000E                751          MOVE.B  #14,D0              * Trap #14 to print out
000014D8  4E4F                     752          TRAP    #15                 * Perform Trap #14
000014DA                           753                          
000014DA  6100 054E                754          BSR     SIZE67              * Print out size
000014DE                           755          
000014DE  43F9 00001E26            756          LEA     IMD,A1              * Formatting
000014E4  103C 000E                757          MOVE.B  #14,D0              * Trap #14 prints out space
000014E8  4E4F                     758          TRAP    #15                 * Perform Trap #14
000014EA                           759          
000014EA  3C3C 0009                760          MOVE.W  #9, D6              * Prep lower value for bitmask
000014EE  3E3C 000B                761          MOVE.W  #11,D7              * Prep upper value for bitmask
000014F2  6100 0866                762          BSR     BITMASK             * Finalize bitmask setup
000014F6  CC42                     763          AND     D2,D6               * Apply bitmask
000014F8                           764          
000014F8  6100 07AE                765          BSR     PRINTDATA911        * Special op for immediate in bits 9->11
000014FC                           766            
000014FC  43F9 00001E28            767          LEA     COMMA,A1            * Formatting
00001502  103C 000E                768          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001506  4E4F                     769          TRAP    #15                 * Perform Trap #14
00001508                           770          
00001508  6100 01CA                771          BSR     EAHELPER05          * Print out the Effective Address
0000150C                           772          
0000150C  6000 000C                773          BRA     DONE0101            * Done identifying OP
00001510                           774      
00001510                           775  UNKNOWN0101
00001510  4C9F 03FF                776          MOVEM   (A7)+,D0-D7/A0-A1   * Pop off the stack to return our registers
00001514  6100 05DA                777          BSR     UNKNOWNOP
00001518  4E75                     778          RTS
0000151A                           779          
0000151A                           780  DONE0101
0000151A  4C9F 03FF                781          MOVEM   (A7)+,D0-D7/A0-A1   * Pop off the stack to return our registers
0000151E  4E75                     782          RTS
00001520                           783  
00001520                           784  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001520                           785  *-----------------------------------------------------------------------------
00001520                           786  
00001520                           787  
00001520                           788  
00001520                           789  *-----------------------------------------------------------------------------
00001520                           790  *-----------------------------------------------------------------------------
00001520                           791  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
00001520                           792  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001520                           793  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
00001520                           794  *                 in the instruction and determines what the bits match to a
00001520                           795  *                 given condition code. If the 8 bit offset is $00, or $FF,
00001520                           796  *                 this signifies a word or long offset (for $00 and $FF
00001520                           797  *                 respectively). The 8 bit offset is in 2's comp. form, and
00001520                           798  *                 should be un-done, then plus or minus to the current
00001520                           799  *                 program counter (PC) to get the actual memory label to
00001520                           800  *                 output to console. The word offset signal eats an
00001520                           801  *                 additional 16 bits and the long offset eats an additional
00001520                           802  *                 32 bits. The word/long offset are for memory alignment.
00001520                           803  * POST-CONDITION: All registers return to their previous state, and the output
00001520                           804  *                 goes to the output console for reading the raw data or the
00001520                           805  *                 actual instruction.
00001520                           806  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001520                           807  *                 A1 (output)
00001520                           808  * CONDITIONS TABLE:
00001520                           809  *                Condition Names  - Mnemonic - Condition Code
00001520                           810  *                --------------------------------------------
00001520                           811  *                True             -    T     - 0000
00001520                           812  *                False            -    F     - 0001
00001520                           813  *                Higher           -    HI    - 0010
00001520                           814  *                Lower or Same    -    LS    - 0011
00001520                           815  *                Carry Clear      -    CC    - 0100
00001520                           816  *                Carry Set        -    CS    - 0101
00001520                           817  *                Not Equal        -    NE    - 0110
00001520                           818  *                Equal            -    EQ    - 0111
00001520                           819  *                Overflow Clear   -    VC    - 1000
00001520                           820  *                Overflow Set     -    VS    - 1001
00001520                           821  *                Plus             -    PL    - 1010
00001520                           822  *                Minus            -    MI    - 1011
00001520                           823  *                Greater or Equal -    GE    - 1100
00001520                           824  *                Less Than        -    LT    - 1101
00001520                           825  *                Greater Than     -    GT    - 1110
00001520                           826  *                Less or Equal    -    LE    - 1111
00001520                           827  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001520                           828  OP0110
00001520  48A7 C0C0                829          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
00001524                           830          
00001524                           831          * Ready four bits to help distinguish op's with the 0110 prefix
00001524  3C3C 0000                832          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
00001528                           833                                        * BITMASK sub-routine call)
00001528  3E3C 0007                834          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
0000152C                           835                                        * BITMASK sub-routine call)
0000152C                           836                                        
0000152C                           837          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
0000152C  6100 082C                838          BSR     BITMASK               * Call BITMASK sub-routine
00001530                           839                                        * Returns a bitmask in D6
00001530                           840          
00001530  CC42                     841          AND     D2,D6                 * And the index op, which was pre-loaded
00001532                           842                                        * in the main memory loop with the bitmask
00001532                           843                                        * to use to determine what case we need.
00001532                           844          
00001532                           845          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
00001532                           846          * $00 == word offset, $FF == long offset
00001532                           847       ***CMPI    #%0000000000000000,D6
00001532                           848       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
00001532                           849       ***
00001532                           850       ***CMPI    #%0000000011111111,D6
00001532                           851       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
00001532                           852          
00001532                           853          * IF PASSED BOTH CMPI CHECKS (ABOVE),
00001532                           854          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
00001532                           855          
00001532  3C3C 0009                856          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
00001536  3E3C 000B                857          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
0000153A                           858                                        
0000153A                           859          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
0000153A  6100 081E                860          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
0000153E  CC42                     861          AND     D2,D6   * apply the BITMASK
00001540                           862          
00001540                           863          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001540  0C46 0400                864          CMPI    #%0000010000000000,D6
00001544  6700 002A                865          BEQ     OP_BCC
00001548                           866          
00001548                           867          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
00001548  0C46 0500                868          CMPI    #%0000010100000000,D6
0000154C  6700 002C                869          BEQ     OP_BCS
00001550                           870          
00001550                           871          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001550  0C46 0C00                872          CMPI    #%0000110000000000,D6
00001554  6700 002E                873          BEQ     OP_BGE
00001558                           874          
00001558                           875          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
00001558  0C46 0D00                876          CMPI    #%0000110100000000,D6
0000155C  6700 0030                877          BEQ     OP_BLT
00001560                           878          
00001560                           879          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
00001560  0C46 0800                880          CMPI    #%0000100000000000,D6
00001564  6700 0032                881          BEQ     OP_BVC
00001568                           882          
00001568                           883          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
00001568                           884          * NOTE: A branch to the immediately following instruction automatically
00001568                           885          *       uses the 16-bit displacement format because the 8-bit displacement
00001568                           886          *       field contains $00 zero offset
00001568                           887          * http://68k.hax.com/BRA
00001568                           888          * NOTE2 ---> Does this mean, there should be no checks when debugging
00001568                           889          *            for word/long offsets?
00001568  0C46 0000                890          CMPI    #%0000000000000000,D6
0000156C  6700 0034                891          BEQ     OP_BRA
00001570                           892          
00001570                           893          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
00001570                           894          ; call raw data print out sub routine
00001570                           895  
00001570                           896  OP_BCC
00001570  43F9 00001DE4            897          LEA     OP_BCC_MSG,A1
00001576  6000 0034                898          BRA     OP_BRANCHES_PRINT
0000157A                           899  OP_BCS
0000157A  43F9 00001DE9            900          LEA     OP_BCS_MSG,A1
00001580  6000 002A                901          BRA     OP_BRANCHES_PRINT
00001584                           902  OP_BGE
00001584  43F9 00001DEE            903          LEA     OP_BGE_MSG,A1
0000158A  6000 0020                904          BRA     OP_BRANCHES_PRINT
0000158E                           905  OP_BLT
0000158E  43F9 00001DF3            906          LEA     OP_BLT_MSG,A1
00001594  6000 0016                907          BRA     OP_BRANCHES_PRINT
00001598                           908  OP_BVC
00001598  43F9 00001DF8            909          LEA     OP_BVC_MSG,A1
0000159E  6000 000C                910          BRA     OP_BRANCHES_PRINT
000015A2                           911  OP_BRA
000015A2  43F9 00001DFD            912          LEA     OP_BRA_MSG,A1
000015A8  6000 0002                913          BRA     OP_BRANCHES_PRINT
000015AC                           914  
000015AC                           915  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000015AC                           916          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000015AC                           917          * assemble output to console
000015AC                           918  OP_BRANCHES_PRINT
000015AC  103C 000E                919          MOVE.B  #14,D0 * print instruction op
000015B0  4E4F                     920          TRAP    #15
000015B2                           921          
000015B2  43F9 00001DDC            922          LEA     DATA,A1
000015B8  103C 000E                923          MOVE.B  #14,D0 * print raw data hex of the LABEL
000015BC  4E4F                     924          TRAP    #15
000015BE                           925          
000015BE  1A1A                     926          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
000015C0  2845                     927          MOVE.L  D5,A4 * ready the 8bits into a4
000015C2  43D4                     928          LEA     (A4),A1 * ready the a4 into a1 for print
000015C4  103C 000E                929          MOVE.B  #14,D0 * print the 8bit addr
000015C8  4E4F                     930          TRAP    #15
000015CA                           931  
000015CA  6000 0002                932          BRA     BCC_END
000015CE                           933  
000015CE                           934  BCC_END * reload the memory, call RTS
000015CE  4C9F 0303                935          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000015D2  4E75                     936          RTS
000015D4                           937  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015D4                           938  *-----------------------------------------------------------------------------
000015D4                           939  
000015D4                           940  
000015D4                           941  
000015D4                           942  *-----------------------------------------------------------------------------
000015D4                           943  *-----------------------------------------------------------------------------
000015D4                           944  * NAME: OP_0111   ()
000015D4                           945  * DESCRIPTION:    OP code 0111 is not supported. 
000015D4                           946  * PRE-CONDITION:  
000015D4                           947  * POST-CONDITION: 
000015D4                           948  * REGISTERS:
000015D4                           949  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015D4                           950  OP0111
000015D4  6100 051A                951      BSR     UNKNOWNOP
000015D8  4E75                     952      RTS
000015DA                           953  
000015DA                           954  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015DA                           955  *-----------------------------------------------------------------------------
000015DA                           956  
000015DA                           957  
000015DA                           958  
000015DA                           959  *-----------------------------------------------------------------------------
000015DA                           960  *-----------------------------------------------------------------------------
000015DA                           961  * NAME: OP_1000   (DIVS, OR)
000015DA                           962  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015DA                           963  * PRE-CONDITION:  xyz
000015DA                           964  * POST-CONDITION: All registers return to their previous state, and the output
000015DA                           965  *                 goes to the output console for reading the raw data or the
000015DA                           966  *                 actual instruction.
000015DA                           967  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015DA                           968  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015DA                           969  OP1000
000015DA                           970          * Saving values to the stack
000015DA  48A7 FFC0                971          MOVEM   D0-D7/A0-A1,-(A7)
000015DE                           972  
000015DE                           973          * Check if the EA Mode is 001 since both DIVS and OR do not support it
000015DE  3C3C 0003                974          MOVE.W  #3, D6              * Prep lower value for bitmask
000015E2  3E3C 0005                975          MOVE.W  #5, D7              * Prep upper value for bitmask
000015E6  6100 0772                976          BSR     BITMASK             * Finalize bitmask setup
000015EA  CC42                     977          AND     D2,D6               * Apply bitmask
000015EC                           978          
000015EC  0C46 0008                979          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
000015F0  6700 04FE                980          BEQ     UNKNOWNOP                 * If so, the op is not supported
000015F4                           981          
000015F4                           982          * Checking for DIVS
000015F4  3C3C 0006                983          MOVE.W  #6, D6              * Prep lower value for bitmask
000015F8  3E3C 0008                984          MOVE.W  #8, D7              * Prep upper value for bitmask
000015FC  6100 075C                985          BSR     BITMASK             * Finalize bitmask setup
00001600  CC42                     986          AND     D2,D6               * Apply bitmask
00001602                           987          
00001602  0C46 01C0                988          CMPI    #%0000000111000000, D6  * Are we DIVS?
00001606  6600 0050                989          BNE     NOTDIVS                 * If not, branch to see if it's OR
0000160A                           990          
0000160A  43F9 00001DA1            991          LEA     DIVSOP,A1           * We found DIVS
00001610  103C 000E                992          MOVE.B  #14,D0              * Trap #14 prints out the data
00001614  4E4F                     993          TRAP    #15                 * Perform Trap #14
00001616                           994          
00001616  43F9 00001E22            995          LEA     SPACE,A1            * formatting
0000161C  103C 000E                996          MOVE.B  #14,D0              * Trap #14 prints out space
00001620  4E4F                     997          TRAP    #15                 * Perform Trap #14
00001622                           998          
00001622  4243                     999          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
00001624  08C3 0000               1000          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
00001628                          1001                                      * to indicate a potential immediate of size word
00001628                          1002          
00001628  6100 00AA               1003          BSR     EAHELPER05          * Print out data. TODO: DOESN'T WORK.
0000162C                          1004  
0000162C  43F9 00001E28           1005          LEA     COMMA,A1            * formatting
00001632  103C 000E               1006          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001636  4E4F                    1007          TRAP    #15                 * Perform Trap #14
00001638                          1008          
00001638                          1009          * bit manipulation is needed to make the outlier DIVS work
00001638                          1010          * with the generic EAHELPER611
00001638  0882 0006               1011          BCLR    #6,D2
0000163C  0882 0007               1012          BCLR    #7,D2
00001640  0882 0008               1013          BCLR    #8,D2
00001644                          1014          
00001644                          1015          * the above bits were cleared so that eahelper05 knows the destination
00001644                          1016          * is a data register.
00001644                          1017          
00001644  6100 004C               1018          BSR     EAHELPER611 
00001648                          1019  
00001648  43F9 00001D9E           1020          LEA     NEWLINE,A1          * We found DIVS
0000164E  103C 000E               1021          MOVE.B  #14,D0              * Trap #14 prints out the data
00001652  4E4F                    1022          TRAP    #15                 * Perform Trap #14
00001654                          1023          
00001654  6000 0012               1024          BRA     OP1000END
00001658                          1025          
00001658                          1026  NOTDIVS * It is confirmed OR at this point
00001658  43F9 00001DD0           1027          LEA     OROP,A1         * We found OR
0000165E  103C 000E               1028          MOVE.B  #14,D0          * Trap #14 prints out the data
00001662  4E4F                    1029          TRAP    #15             * Perform Trap #14
00001664                          1030          *================================================================
00001664                          1031          * todo, move the size of the operation into the leading bits of D5
00001664                          1032          * before subroutine call
00001664  6100 002C               1033          BSR     EAHELPER611
00001668                          1034  
00001668                          1035  OP1000END
00001668  4C9F 03FF               1036          MOVEM   (A7)+,D0-D7/A0-A1
0000166C  4E75                    1037          RTS
0000166E                          1038  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000166E                          1039  *-----------------------------------------------------------------------------
0000166E                          1040  
0000166E                          1041  
0000166E                          1042  
0000166E                          1043  *-----------------------------------------------------------------------------
0000166E                          1044  *-----------------------------------------------------------------------------
0000166E                          1045  * NAME: OP_1001   (SUB)
0000166E                          1046  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000166E                          1047  * PRE-CONDITION:  xyz
0000166E                          1048  * POST-CONDITION: All registers return to their previous state, and the output
0000166E                          1049  *                 goes to the output console for reading the raw data or the
0000166E                          1050  *                 actual instruction.
0000166E                          1051  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000166E                          1052  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000166E                          1053  OP1001
0000166E                          1054  
0000166E                          1055  
0000166E                          1056  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000166E                          1057  *-----------------------------------------------------------------------------
0000166E                          1058  
0000166E                          1059  
0000166E                          1060  
0000166E                          1061  *-----------------------------------------------------------------------------
0000166E                          1062  *-----------------------------------------------------------------------------
0000166E                          1063  * NAME: OP_1010   ()
0000166E                          1064  * DESCRIPTION:    a
0000166E                          1065  * PRE-CONDITION:  b
0000166E                          1066  * POST-CONDITION: c
0000166E                          1067  * REGISTERS:      d
0000166E                          1068  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000166E                          1069  OP1010
0000166E                          1070  
0000166E  6100 0480               1071      BSR     UNKNOWNOP
00001672  4E75                    1072      RTS
00001674                          1073  
00001674                          1074  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001674                          1075  *-----------------------------------------------------------------------------
00001674                          1076  
00001674                          1077  
00001674                          1078  
00001674                          1079  *-----------------------------------------------------------------------------
00001674                          1080  *-----------------------------------------------------------------------------
00001674                          1081  * NAME: OP_1011   (EOR, CMP)
00001674                          1082  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001674                          1083  * PRE-CONDITION:  xyz
00001674                          1084  * POST-CONDITION: All registers return to their previous state, and the output
00001674                          1085  *                 goes to the output console for reading the raw data or the
00001674                          1086  *                 actual instruction.
00001674                          1087  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001674                          1088  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001674                          1089  OP1011
00001674                          1090  
00001674  6100 047A               1091      BSR     UNKNOWNOP
00001678  4E75                    1092      RTS
0000167A                          1093  
0000167A                          1094  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000167A                          1095  *-----------------------------------------------------------------------------
0000167A                          1096  
0000167A                          1097  
0000167A                          1098  
0000167A                          1099  *-----------------------------------------------------------------------------
0000167A                          1100  *-----------------------------------------------------------------------------
0000167A                          1101  * NAME: OP_1100   (MULS)
0000167A                          1102  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000167A                          1103  * PRE-CONDITION:  xyz
0000167A                          1104  * POST-CONDITION: All registers return to their previous state, and the output
0000167A                          1105  *                 goes to the output console for reading the raw data or the
0000167A                          1106  *                 actual instruction.
0000167A                          1107  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000167A                          1108  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000167A                          1109  OP1100
0000167A                          1110  
0000167A  6100 0474               1111      BSR     UNKNOWNOP
0000167E  4E75                    1112      RTS
00001680                          1113  
00001680                          1114  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001680                          1115  *-----------------------------------------------------------------------------
00001680                          1116  
00001680                          1117  
00001680                          1118  
00001680                          1119  *-----------------------------------------------------------------------------
00001680                          1120  *-----------------------------------------------------------------------------
00001680                          1121  * NAME: OP_1101   (ADD, ADDA)
00001680                          1122  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001680                          1123  * PRE-CONDITION:  xyz
00001680                          1124  * POST-CONDITION: All registers return to their previous state, and the output
00001680                          1125  *                 goes to the output console for reading the raw data or the
00001680                          1126  *                 actual instruction.
00001680                          1127  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001680                          1128  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001680                          1129  OP1101
00001680                          1130  
00001680  6100 046E               1131      BSR     UNKNOWNOP
00001684  4E75                    1132      RTS
00001686                          1133  
00001686                          1134  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001686                          1135  *-----------------------------------------------------------------------------
00001686                          1136  
00001686                          1137  
00001686                          1138  
00001686                          1139  *-----------------------------------------------------------------------------
00001686                          1140  *-----------------------------------------------------------------------------
00001686                          1141  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
00001686                          1142  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001686                          1143  * PRE-CONDITION:  xyz
00001686                          1144  * POST-CONDITION: All registers return to their previous state, and the output
00001686                          1145  *                 goes to the output console for reading the raw data or the
00001686                          1146  *                 actual instruction.
00001686                          1147  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001686                          1148  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001686                          1149  OP1110
00001686                          1150  
00001686  6100 0468               1151      BSR     UNKNOWNOP
0000168A  4E75                    1152      RTS
0000168C                          1153  
0000168C                          1154  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000168C                          1155  *-----------------------------------------------------------------------------
0000168C                          1156  
0000168C                          1157  
0000168C                          1158  
0000168C                          1159  *-----------------------------------------------------------------------------
0000168C                          1160  *-----------------------------------------------------------------------------
0000168C                          1161  * NAME: OP_1111   ()
0000168C                          1162  * DESCRIPTION:    a
0000168C                          1163  * PRE-CONDITION:  b
0000168C                          1164  * POST-CONDITION: c
0000168C                          1165  * REGISTERS:      d
0000168C                          1166  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000168C                          1167  OP1111
0000168C                          1168  
0000168C  6100 0462               1169      BSR     UNKNOWNOP
00001690  4E75                    1170      RTS
00001692                          1171  
00001692                          1172  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001692                          1173  *-----------------------------------------------------------------------------
00001692                          1174  
00001692                          1175  
00001692                          1176  
00001692                          1177  *-----------------------------------------------------------------------------
00001692                          1178  *-----------------------------------------------------------------------------
00001692                          1179  * NAME:           EAHELPER611
00001692                          1180  * DESCRIPTION:    a
00001692                          1181  * PRE-CONDITION:  D2 contains the instruction to print modes for.
00001692                          1182  *                 D5 contains the size of the data to be printed
00001692                          1183  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
00001692                          1184  *                 EAHELPER05 to print.
00001692                          1185  * REGISTERS:      a
00001692                          1186  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001692                          1187  EAHELPER611
00001692  48A7 FFC0               1188      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
00001696                          1189      
00001696  3C3C 0006               1190      MOVE.W  #6, D6              * Prep lower value for bitmask
0000169A  3E3C 0008               1191      MOVE.W  #8, D7              * Prep upper value for bitmask
0000169E  6100 06BA               1192      BSR     BITMASK             * Finalize bitmask setup
000016A2  CC42                    1193      AND     D2,D6               * Apply bitmask
000016A4                          1194      
000016A4                          1195      * to move the mode where EAHELPER50 can process it
000016A4  7C06                    1196      MOVE.L  #6,D6
000016A6  7E08                    1197      MOVE.L  #8,D7
000016A8                          1198      
000016A8  6100 06B0               1199      BSR     BITMASK * create bitmask
000016AC                          1200      
000016AC  CC42                    1201      AND     D2,D6   * apply bitmask
000016AE                          1202      
000016AE  4243                    1203      CLR     D3      * prep D3 to store values
000016B0                          1204      
000016B0  3606                    1205      MOVE.W  D6,D3   * store bitmasked value in D3
000016B2                          1206      
000016B2  E64B                    1207      LSR     #3,D3   * move bits 6-8 to 3-5
000016B4                          1208      
000016B4                          1209      * to move the register where EAHELPER50 can process it
000016B4  7C09                    1210      MOVE.L  #9,D6   *prep registers to create bitmask
000016B6  7E0B                    1211      MOVE.L  #11,D7
000016B8                          1212      
000016B8  6100 06A0               1213      BSR     BITMASK * create bitmask
000016BC                          1214      
000016BC  CC42                    1215      AND     D2,D6   * apply bitmask
000016BE                          1216      
000016BE  4244                    1217      CLR     D4      * prep D3 to store values
000016C0                          1218      
000016C0  3806                    1219      MOVE.W  D6,D4   * store bitmasked value in D3
000016C2                          1220      
000016C2  E04C                    1221      LSR     #8,D4   * move bits 9-11 to 0-2
000016C4  E24C                    1222      LSR     #1,D4   * move bits 9-11 to 0-2
000016C6                          1223      
000016C6  8684                    1224      OR.L    D4,D3   * combind the register and mode
000016C8                          1225      
000016C8  2403                    1226      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
000016CA                          1227      
000016CA  6100 0008               1228      BSR     EAHELPER05
000016CE                          1229      
000016CE                          1230  ENDEAHELPER611
000016CE                          1231      
000016CE  4C9F 03FF               1232      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
000016D2                          1233      
000016D2  4E75                    1234      RTS
000016D4                          1235  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000016D4                          1236  *-----------------------------------------------------------------------------
000016D4                          1237  
000016D4                          1238  
000016D4                          1239  
000016D4                          1240  *-----------------------------------------------------------------------------
000016D4                          1241  *-----------------------------------------------------------------------------
000016D4                          1242  * NAME:           EAHELPER05
000016D4                          1243  * DESCRIPTION:    a
000016D4                          1244  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
000016D4                          1245  *                 this sub-routine helper for operations that only have one
000016D4                          1246  *                 mode register.
000016D4                          1247  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
000016D4                          1248  * REGISTERS:      a
000016D4                          1249  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000016D4                          1250  EAHELPER05
000016D4                          1251      * todo: add code for printing immediate values
000016D4                          1252      
000016D4  48A7 FFC0               1253      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000016D8                          1254      
000016D8  7C03                    1255      MOVE.L  #3,D6
000016DA  7E05                    1256      MOVE.L  #5,D7
000016DC                          1257      
000016DC  6100 067C               1258      BSR     BITMASK * generate a bitmask to identify the mode
000016E0                          1259      
000016E0  CC42                    1260      AND     D2,D6   * mask off the parts of D2 we don't need
000016E2                          1261      
000016E2  2A06                    1262      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
000016E4                          1263      
000016E4  0C46 0000               1264      CMPI    #%0000000000000000,D6 * is it data register direct?
000016E8  6600 000A               1265      BNE     NOTDATAREG
000016EC                          1266      
000016EC  6100 013C               1267      BSR     MODE_DN
000016F0                          1268       
000016F0  6000 0132               1269      BRA     ENDEAHELPER05
000016F4                          1270      
000016F4                          1271  NOTDATAREG * address register direct
000016F4                          1272      
000016F4  0C46 0008               1273      CMPI    #%0000000000001000,D6 * is it address register direct?
000016F8  6600 000A               1274      BNE     NOTADRDIRECT
000016FC                          1275      
000016FC  6100 022C               1276      BSR     MODE_AN * simply prints out the address register
00001700                          1277       
00001700  6000 0122               1278      BRA     ENDEAHELPER05
00001704                          1279      
00001704                          1280  NOTADRDIRECT * address register indirect
00001704                          1281          
00001704  0C46 0010               1282      CMPI    #%0000000000010000,D6 * is it address register indirect?
00001708  6600 0022               1283      BNE     NOTADRINDIRECT
0000170C                          1284      
0000170C  43F9 00001E2A           1285      LEA     OBRACK,A1       * Load '('
00001712  303C 000E               1286      MOVE.W  #14,D0          * Trap #14 to display message
00001716  4E4F                    1287      TRAP    #15             * Perform #14
00001718                          1288          
00001718                          1289  
00001718  6100 0210               1290      BSR     MODE_AN * print out an address register
0000171C                          1291      
0000171C  43F9 00001E2C           1292      LEA     CBRACK,A1       * Load ')'
00001722  303C 000E               1293      MOVE.W  #14,D0          * Trap #14 to display message
00001726  4E4F                    1294      TRAP    #15             * Perform #14
00001728                          1295       
00001728  6000 00FA               1296      BRA     ENDEAHELPER05
0000172C                          1297      
0000172C                          1298  NOTADRINDIRECT * address register indirect, post increment
0000172C                          1299      
0000172C  0C46 0018               1300      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
00001730  6600 002E               1301      BNE     NOTADRINDIRECTPOST
00001734                          1302      
00001734  43F9 00001E2A           1303      LEA     OBRACK,A1       * Load '('
0000173A  303C 000E               1304      MOVE.W  #14,D0          * Trap #14 to display message
0000173E  4E4F                    1305      TRAP    #15             * Perform #14
00001740                          1306          
00001740                          1307  
00001740  6100 01E8               1308      BSR     MODE_AN * print out an address register
00001744                          1309      
00001744  43F9 00001E2C           1310      LEA     CBRACK,A1       * Load ')'
0000174A  303C 000E               1311      MOVE.W  #14,D0          * Trap #14 to display message
0000174E  4E4F                    1312      TRAP    #15             * Perform #14
00001750                          1313      
00001750  43F9 00001E2E           1314      LEA     PLUS,A1       * Load '+'
00001756  303C 000E               1315      MOVE.W  #14,D0          * Trap #14 to display message
0000175A  4E4F                    1316      TRAP    #15             * Perform #14
0000175C                          1317       
0000175C  6000 00C6               1318      BRA     ENDEAHELPER05
00001760                          1319      
00001760                          1320  NOTADRINDIRECTPOST * address register indirect, pre decrement
00001760                          1321      
00001760  0C46 0020               1322      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
00001764  6600 002E               1323      BNE     NOTADRINDIRECTPRE
00001768                          1324      
00001768  43F9 00001E30           1325      LEA     MINUS,A1       * Load '-'
0000176E  303C 000E               1326      MOVE.W  #14,D0          * Trap #14 to display message
00001772  4E4F                    1327      TRAP    #15             * Perform #14
00001774                          1328      
00001774  43F9 00001E2A           1329      LEA     OBRACK,A1       * Load '('
0000177A  303C 000E               1330      MOVE.W  #14,D0          * Trap #14 to display message
0000177E  4E4F                    1331      TRAP    #15             * Perform #14
00001780                          1332          
00001780                          1333  
00001780  6100 01A8               1334      BSR     MODE_AN * print out an address register
00001784                          1335      
00001784  43F9 00001E2C           1336      LEA     CBRACK,A1       * Load ')'
0000178A  303C 000E               1337      MOVE.W  #14,D0          * Trap #14 to display message
0000178E  4E4F                    1338      TRAP    #15             * Perform #14
00001790                          1339       
00001790  6000 0092               1340      BRA     ENDEAHELPER05
00001794                          1341  
00001794                          1342  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
00001794                          1343  
00001794  0C46 0038               1344      CMPI    #%0000000000111000,D6 * is it immediate?
00001798  6600 0086               1345      BNE     NOTIMMEDIATE
0000179C                          1346  
0000179C  0C43 0001               1347      CMPI    #1,D3 * is it a byte?
000017A0  6600 0028               1348      BNE     NOTIMMBYTE
000017A4                          1349      
000017A4  43F9 00001E26           1350      LEA     IMD,A1 *print out the '#' indicating an immediate value
000017AA  103C 000E               1351      MOVE.B  #14,D0
000017AE  4E4F                    1352      TRAP    #15
000017B0                          1353      
000017B0  3C3C 0000               1354      MOVE.W  #0, D6              * Prep lower value for bitmask
000017B4  3E3C 0007               1355      MOVE.W  #7, D7              * Prep upper value for bitmask
000017B8  6100 05A0               1356      BSR     BITMASK             * Finalize bitmask setup
000017BC                          1357          
000017BC  321A                    1358      MOVE.W  (A2)+,D1
000017BE                          1359      
000017BE  C286                    1360      AND.L     D6,D1
000017C0                          1361          
000017C0  103C 0003               1362      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000017C4  4E4F                    1363      TRAP    #15      * Perform Trap #3
000017C6                          1364      
000017C6  6000 005C               1365      BRA     ENDEAHELPER05
000017CA                          1366  
000017CA                          1367  NOTIMMBYTE
000017CA                          1368      
000017CA  0C43 0002               1369      CMPI    #2,D3 * is it a word?
000017CE  6600 0028               1370      BNE     NOTIMMWORD
000017D2                          1371      
000017D2  43F9 00001E26           1372      LEA     IMD,A1 *print out the '#' indicating an immediate value
000017D8  103C 000E               1373      MOVE.B  #14,D0
000017DC  4E4F                    1374      TRAP    #15
000017DE                          1375      
000017DE  3C3C 0000               1376      MOVE.W  #0, D6              * Prep lower value for bitmask
000017E2  3E3C 000F               1377      MOVE.W  #15, D7             * Prep upper value for bitmask
000017E6  6100 0572               1378      BSR     BITMASK             * Finalize bitmask setup
000017EA                          1379          
000017EA  321A                    1380      MOVE.W  (A2)+,D1
000017EC                          1381      
000017EC  C286                    1382      AND.L     D6,D1               * Apply bitmask
000017EE                          1383          
000017EE  103C 0003               1384      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000017F2  4E4F                    1385      TRAP    #15      * Perform Trap #3
000017F4                          1386      
000017F4  6000 002E               1387      BRA     ENDEAHELPER05
000017F8                          1388      
000017F8                          1389  NOTIMMWORD
000017F8  0C43 0003               1390      CMPI    #3,D3 * is it a long?
000017FC  6600 0022               1391      BNE     NOTIMMEDIATE
00001800                          1392      
00001800  43F9 00001E26           1393      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001806  103C 000E               1394      MOVE.B  #14,D0
0000180A  4E4F                    1395      TRAP    #15
0000180C                          1396          
0000180C  221A                    1397      MOVE.L  (A2)+,D1
0000180E                          1398          
0000180E  103C 0003               1399      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001812  4E4F                    1400      TRAP    #15      * Perform Trap #3
00001814                          1401      
00001814  321A                    1402      MOVE.W  (A2)+,D1
00001816                          1403          
00001816  103C 0003               1404      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000181A  4E4F                    1405      TRAP    #15      * Perform Trap #3
0000181C                          1406      
0000181C  6000 0006               1407      BRA     ENDEAHELPER05
00001820                          1408  
00001820                          1409  NOTIMMEDIATE    
00001820                          1410  
00001820                          1411  
00001820  6100 02CE               1412      BSR     UNKNOWNOP
00001824                          1413      
00001824                          1414  ENDEAHELPER05
00001824  4C9F 03FF               1415      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001828  4E75                    1416      RTS
0000182A                          1417  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000182A                          1418  *-----------------------------------------------------------------------------
0000182A                          1419  
0000182A                          1420  
0000182A                          1421  
0000182A                          1422  *-----------------------------------------------------------------------------
0000182A                          1423  *-----------------------------------------------------------------------------
0000182A                          1424  * NAME:           MODE_DN
0000182A                          1425  * DESCRIPTION:    Generalize the EA part of the project.
0000182A                          1426  * PRE-CONDITION:  The mode must have been correctly identified. All modes
0000182A                          1427  *                 must be called by RTS.
0000182A                          1428  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
0000182A                          1429  *                 called it.
0000182A                          1430  * REGISTERS:      a
0000182A                          1431  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000182A                          1432  * ---> Dn
0000182A                          1433  MODE_DN
0000182A  48A7 FFC0               1434          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
0000182E                          1435  
0000182E  3C3C 0000               1436          MOVE.W  #0, D6              * Prep lower value for bitmask
00001832  3E3C 0002               1437          MOVE.W  #2, D7              * Prep upper value for bitmask
00001836  6100 0522               1438          BSR     BITMASK             * Finalize bitmask setup
0000183A  CC42                    1439          AND     D2,D6               * Apply bitmask
0000183C                          1440          
0000183C  0C46 0000               1441          CMPI    #%000000000000000, D6   * Data Register D0?
00001840  6600 000A               1442          BNE     NOTD0
00001844                          1443          
00001844  6100 0074               1444          BSR     PRINTD0
00001848  6000 006A               1445          BRA     ENDMODE_DN
0000184C                          1446  NOTD0      
0000184C  0C46 0001               1447          CMPI    #%000000000000001, D6   * Data Register D1?
00001850  6600 000A               1448          BNE     NOTD1
00001854                          1449          
00001854  6100 0072               1450          BSR     PRINTD1
00001858  6000 005A               1451          BRA     ENDMODE_DN
0000185C                          1452  NOTD1
0000185C  0C46 0002               1453          CMPI    #%000000000000010, D6   * Data Register D2?
00001860  6600 000A               1454          BNE     NOTD2
00001864                          1455          
00001864  6100 0070               1456          BSR     PRINTD2
00001868  6000 004A               1457          BRA     ENDMODE_DN
0000186C                          1458  NOTD2
0000186C  0C46 0003               1459          CMPI    #%000000000000011, D6   * Data Register D3?
00001870  6600 000A               1460          BNE     NOTD3
00001874                          1461          
00001874  6100 006E               1462          BSR     PRINTD3
00001878  6000 003A               1463          BRA     ENDMODE_DN
0000187C                          1464  NOTD3
0000187C  0C46 0004               1465          CMPI    #%000000000000100, D6   * Data Register D4?
00001880  6600 000A               1466          BNE     NOTD4
00001884                          1467          
00001884  6100 006C               1468          BSR     PRINTD4
00001888  6000 002A               1469          BRA     ENDMODE_DN
0000188C                          1470  NOTD4
0000188C  0C46 0005               1471          CMPI    #%000000000000101, D6   * Data Register D5?
00001890  6600 000A               1472          BNE     NOTD5
00001894                          1473          
00001894  6100 006A               1474          BSR     PRINTD5
00001898  6000 001A               1475          BRA     ENDMODE_DN
0000189C                          1476  NOTD5
0000189C  0C46 0006               1477          CMPI    #%000000000000110, D6   * Data Register D6?
000018A0  6600 000A               1478          BNE     NOTD6
000018A4                          1479          
000018A4  6100 0068               1480          BSR     PRINTD6
000018A8  6000 000A               1481          BRA     ENDMODE_DN
000018AC                          1482  NOTD6
000018AC  6100 006E               1483          BSR     PRINTD7
000018B0  6000 0002               1484          BRA     ENDMODE_DN
000018B4                          1485          
000018B4                          1486  ENDMODE_DN
000018B4  4C9F 03FF               1487          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
000018B8  4E75                    1488          RTS
000018BA                          1489  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018BA                          1490  *-----------------------------------------------------------------------------
000018BA                          1491  
000018BA                          1492  
000018BA                          1493  
000018BA                          1494  *-----------------------------------------------------------------------------
000018BA                          1495  *-----------------------------------------------------------------------------
000018BA                          1496  * NAME:           PRINTD0
000018BA                          1497  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
000018BA                          1498  * PRE-CONDITION:  a
000018BA                          1499  * POST-CONDITION: a
000018BA                          1500  * REGISTERS:      a
000018BA                          1501  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018BA                          1502  PRINTD0
000018BA  43F9 00001E56           1503          LEA     __D0, A1        * Load 'D0'
000018C0  103C 000E               1504          MOVE.B  #14, D0         * Load Trap #14 to print out
000018C4  4E4F                    1505          TRAP    #15             * Perform Trap #14
000018C6  4E75                    1506          RTS
000018C8                          1507  PRINTD1
000018C8  43F9 00001E59           1508          LEA     __D1, A1        * Load 'D1'
000018CE  103C 000E               1509          MOVE.B  #14, D0         * Load Trap #14 to print out
000018D2  4E4F                    1510          TRAP    #15             * Perform Trap #14
000018D4  4E75                    1511          RTS      
000018D6                          1512  PRINTD2
000018D6  43F9 00001E5C           1513          LEA     __D2, A1        * Load 'D2'
000018DC  103C 000E               1514          MOVE.B  #14, D0         * Load Trap #14 to print out
000018E0  4E4F                    1515          TRAP    #15             * Perform Trap #14
000018E2  4E75                    1516          RTS      
000018E4                          1517  PRINTD3
000018E4  43F9 00001E5F           1518          LEA     __D3, A1        * Load 'D3'
000018EA  103C 000E               1519          MOVE.B  #14, D0         * Load Trap #14 to print out
000018EE  4E4F                    1520          TRAP    #15             * Perform Trap #14
000018F0  4E75                    1521          RTS      
000018F2                          1522  PRINTD4
000018F2  43F9 00001E62           1523          LEA     __D4, A1        * Load 'D4'
000018F8  103C 000E               1524          MOVE.B  #14, D0         * Load Trap #14 to print out
000018FC  4E4F                    1525          TRAP    #15             * Perform Trap #14
000018FE  4E75                    1526          RTS       
00001900                          1527  PRINTD5
00001900  43F9 00001E65           1528          LEA     __D5, A1        * Load 'D5'
00001906  103C 000E               1529          MOVE.B  #14, D0         * Load Trap #14 to print out
0000190A  4E4F                    1530          TRAP    #15             * Perform Trap #14
0000190C  4E75                    1531          RTS      
0000190E                          1532  PRINTD6
0000190E  43F9 00001E68           1533          LEA     __D6, A1        * Load 'D6'
00001914  103C 000E               1534          MOVE.B  #14, D0         * Load Trap #14 to print out
00001918  4E4F                    1535          TRAP    #15             * Perform Trap #14
0000191A  4E75                    1536          RTS
0000191C                          1537  PRINTD7
0000191C  43F9 00001E6B           1538          LEA     __D7, A1        * Load 'D7'
00001922  103C 000E               1539          MOVE.B  #14, D0         * Load Trap #14 to print out
00001926  4E4F                    1540          TRAP    #15             * Perform Trap #14
00001928  4E75                    1541          RTS
0000192A                          1542  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000192A                          1543  *-----------------------------------------------------------------------------
0000192A                          1544  
0000192A                          1545  
0000192A                          1546  
0000192A                          1547  *-----------------------------------------------------------------------------
0000192A                          1548  *-----------------------------------------------------------------------------
0000192A                          1549  * NAME:           MODE_AN
0000192A                          1550  * DESCRIPTION:    Simply chooses to print A0-A7.
0000192A                          1551  * PRE-CONDITION:  a
0000192A                          1552  * POST-CONDITION: a
0000192A                          1553  * REGISTERS:      a
0000192A                          1554  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000192A                          1555  MODE_AN
0000192A  48A7 FFC0               1556          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
0000192E                          1557  
0000192E  3C3C 0000               1558          MOVE.W  #0, D6              * Prep lower value for bitmask
00001932  3E3C 0002               1559          MOVE.W  #2, D7              * Prep upper value for bitmask
00001936  6100 0422               1560          BSR     BITMASK             * Finalize bitmask setup
0000193A  CC42                    1561          AND     D2,D6               * Apply bitmask
0000193C                          1562          
0000193C  0C46 0000               1563          CMPI    #%000000000000000, D6   * Address Register A0?
00001940  6600 000A               1564          BNE     NOTA0
00001944                          1565          
00001944  6100 0074               1566          BSR     PRINTA0
00001948                          1567          
00001948  6000 006A               1568          BRA     ENDMODE_AN
0000194C                          1569  NOTA0      
0000194C  0C46 0001               1570          CMPI    #%000000000000001, D6   * Address Register A1?
00001950  6600 000A               1571          BNE     NOTA1
00001954                          1572          
00001954  6100 0072               1573          BSR     PRINTA1
00001958                          1574          
00001958  6000 005A               1575          BRA     ENDMODE_AN
0000195C                          1576  NOTA1
0000195C  0C46 0002               1577          CMPI    #%000000000000010, D6   * Address Register A2?
00001960  6600 000A               1578          BNE     NOTA2
00001964                          1579          
00001964  6100 0070               1580          BSR     PRINTA2
00001968                          1581          
00001968  6000 004A               1582          BRA     ENDMODE_AN
0000196C                          1583  NOTA2
0000196C  0C46 0003               1584          CMPI    #%000000000000011, D6   * Address Register A3?
00001970  6600 000A               1585          BNE     NOTA3
00001974                          1586          
00001974  6100 006E               1587          BSR     PRINTA3
00001978                          1588          
00001978  6000 003A               1589          BRA     ENDMODE_AN
0000197C                          1590  NOTA3
0000197C  0C46 0004               1591          CMPI    #%000000000000100, D6   * Address Register A4?
00001980  6600 000A               1592          BNE     NOTA4
00001984                          1593          
00001984  6100 006C               1594          BSR     PRINTA4
00001988                          1595          
00001988  6000 002A               1596          BRA     ENDMODE_AN
0000198C                          1597  NOTA4
0000198C  0C46 0005               1598          CMPI    #%000000000000101, D6   * Address Register A5?
00001990  6600 000A               1599          BNE     NOTA5
00001994                          1600          
00001994  6100 006A               1601          BSR     PRINTA5
00001998                          1602          
00001998  6000 001A               1603          BRA     ENDMODE_AN
0000199C                          1604  NOTA5
0000199C  0C46 0006               1605          CMPI    #%000000000000110, D6   * Address Register A6?
000019A0  6600 000A               1606          BNE     NOTA6
000019A4                          1607          
000019A4  6100 0068               1608          BSR     PRINTA6
000019A8                          1609          
000019A8  6000 000A               1610          BRA     ENDMODE_AN
000019AC                          1611  NOTA6
000019AC  6100 006E               1612          BSR     PRINTA7
000019B0                          1613          
000019B0  6000 0002               1614          BRA     ENDMODE_AN
000019B4                          1615  ENDMODE_AN
000019B4  4C9F 03FF               1616          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
000019B8  4E75                    1617          RTS
000019BA                          1618  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019BA                          1619  *-----------------------------------------------------------------------------
000019BA                          1620  
000019BA                          1621  
000019BA                          1622  
000019BA                          1623  *-----------------------------------------------------------------------------
000019BA                          1624  *-----------------------------------------------------------------------------
000019BA                          1625  * NAME:           PRINTA0
000019BA                          1626  * DESCRIPTION:    Simply print out the address register.
000019BA                          1627  * PRE-CONDITION:  a
000019BA                          1628  * POST-CONDITION: a
000019BA                          1629  * REGISTERS:      a
000019BA                          1630  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019BA                          1631  PRINTA0
000019BA  43F9 00001E3E           1632          LEA     __A0, A1        * Load 'A0'
000019C0  103C 000E               1633          MOVE.B  #14, D0         * Load Trap #14 to print out
000019C4  4E4F                    1634          TRAP    #15             * Perform Trap #14
000019C6  4E75                    1635          RTS
000019C8                          1636  
000019C8                          1637  PRINTA1
000019C8  43F9 00001E41           1638          LEA     __A1, A1        * Load 'A1'
000019CE  103C 000E               1639          MOVE.B  #14, D0         * Load Trap #14 to print out
000019D2  4E4F                    1640          TRAP    #15             * Perform Trap #14
000019D4  4E75                    1641          RTS
000019D6                          1642          
000019D6                          1643  PRINTA2
000019D6  43F9 00001E44           1644          LEA     __A2, A1        * Load 'A2'
000019DC  103C 000E               1645          MOVE.B  #14, D0         * Load Trap #14 to print out
000019E0  4E4F                    1646          TRAP    #15             * Perform Trap #14
000019E2  4E75                    1647          RTS
000019E4                          1648  
000019E4                          1649  PRINTA3
000019E4  43F9 00001E47           1650          LEA     __A3, A1        * Load 'A3'
000019EA  103C 000E               1651          MOVE.B  #14, D0         * Load Trap #14 to print out
000019EE  4E4F                    1652          TRAP    #15             * Perform Trap #14
000019F0  4E75                    1653          RTS
000019F2                          1654  
000019F2                          1655  PRINTA4
000019F2  43F9 00001E4A           1656          LEA     __A4, A1        * Load 'A4'
000019F8  103C 000E               1657          MOVE.B  #14, D0         * Load Trap #14 to print out
000019FC  4E4F                    1658          TRAP    #15             * Perform Trap #14
000019FE  4E75                    1659          RTS
00001A00                          1660  
00001A00                          1661  PRINTA5
00001A00  43F9 00001E4D           1662          LEA     __A5, A1        * Load 'A5'
00001A06  103C 000E               1663          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A0A  4E4F                    1664          TRAP    #15             * Perform Trap #14
00001A0C  4E75                    1665          RTS
00001A0E                          1666  
00001A0E                          1667  PRINTA6
00001A0E  43F9 00001E50           1668          LEA     __A6, A1        * Load 'A6'
00001A14  103C 000E               1669          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A18  4E4F                    1670          TRAP    #15             * Perform Trap #14
00001A1A  4E75                    1671          RTS
00001A1C                          1672  
00001A1C                          1673  PRINTA7
00001A1C  43F9 00001E53           1674          LEA     __A7, A1        * Load 'A7'
00001A22  103C 000E               1675          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A26  4E4F                    1676          TRAP    #15             * Perform Trap #14
00001A28  4E75                    1677          RTS
00001A2A                          1678  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A2A                          1679  *-----------------------------------------------------------------------------
00001A2A                          1680  
00001A2A                          1681  
00001A2A                          1682  
00001A2A                          1683  *-----------------------------------------------------------------------------
00001A2A                          1684  *-----------------------------------------------------------------------------
00001A2A                          1685  * NAME:           SIZE67
00001A2A                          1686  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001A2A                          1687  * PRE-CONDITION:  a
00001A2A                          1688  * POST-CONDITION: a
00001A2A                          1689  * REGISTERS:      a
00001A2A                          1690  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A2A                          1691  SIZE67
00001A2A  48A7 FFFE               1692          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001A2E  3C3C 0006               1693          MOVE.W  #6, D6              * Prep lower value for bitmask
00001A32  3E3C 0007               1694          MOVE.W  #7, D7              * Prep upper value for bitmask
00001A36  6100 0322               1695          BSR     BITMASK             * Finalize bitmask setup
00001A3A  CC42                    1696          AND     D2,D6               * Apply bitmask     
00001A3C                          1697  
00001A3C  0C46 0000               1698          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001A40  6600 000A               1699          BNE     NOT67BYTE
00001A44                          1700          
00001A44  6100 0080               1701          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001A48  6000 001E               1702          BRA     END67
00001A4C                          1703  NOT67BYTE        
00001A4C  0C46 0040               1704          CMPI    #%0000000001000000, D6   * is it a WORD?
00001A50  6600 000A               1705          BNE     NOT67WORD
00001A54                          1706          
00001A54  6100 007E               1707          BSR     PRINTWORD               * Branch to handle WORD sizes
00001A58  6000 000E               1708          BRA     END67
00001A5C                          1709  NOT67WORD
00001A5C  0C46 0080               1710          CMPI    #%0000000010000000, D6   * is it a LONG?
00001A60  6600 0006               1711          BNE     END67
00001A64                          1712          
00001A64  6100 007C               1713          BSR     PRINTLONG               * Branch to handle LONG sizes
00001A68                          1714  END67
00001A68  4C9F 7FFF               1715          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001A6C  4E75                    1716          RTS                             * Return. Size handling is finished.
00001A6E                          1717  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A6E                          1718  *-----------------------------------------------------------------------------
00001A6E                          1719  
00001A6E                          1720  
00001A6E                          1721  
00001A6E                          1722  *-----------------------------------------------------------------------------
00001A6E                          1723  *-----------------------------------------------------------------------------
00001A6E                          1724  * NAME:           SIZE68
00001A6E                          1725  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
00001A6E                          1726  * PRE-CONDITION:  a
00001A6E                          1727  * POST-CONDITION: a
00001A6E                          1728  * REGISTERS:      a
00001A6E                          1729  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A6E                          1730  SIZE68
00001A6E                          1731          * finish later, need to follow the same format as SIZE67
00001A6E                          1732          
00001A6E                          1733          
00001A6E  48A7 FFFE               1734          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001A72  3C3C 0006               1735          MOVE.W  #6, D6              * Prep lower value for bitmask
00001A76  3E3C 0008               1736          MOVE.W  #8, D7              * Prep upper value for bitmask
00001A7A  6100 02DE               1737          BSR     BITMASK             * Finalize bitmask setup
00001A7E  CC42                    1738          AND     D2,D6               * Apply bitmask          
00001A80                          1739          
00001A80  0C46 0000               1740          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001A84  6100 0040               1741          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001A88  0C46 0100               1742          CMPI    #%0000000100000000, D6   * is it a BYTE?
00001A8C  6100 0038               1743          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001A90                          1744        
00001A90  0C46 0040               1745          CMPI    #%0000000001000000, D6   * is it a WORD?
00001A94  6100 003E               1746          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001A98  0C46 0140               1747          CMPI    #%0000000101000000, D6   * is it a WORD?
00001A9C  6100 0036               1748          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001AA0  0C46 00C0               1749          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
00001AA4  6100 002E               1750          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001AA8                          1751  
00001AA8  0C46 0080               1752          CMPI    #%0000000010000000, D6   * is it a LONG?
00001AAC  6100 0034               1753          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001AB0  0C46 0180               1754          CMPI    #%0000000110000000, D6   * is it a LONG?
00001AB4  6100 002C               1755          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001AB8  0C46 01C0               1756          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001ABC  6100 0024               1757          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001AC0                          1758  
00001AC0  4C9F 7FFF               1759          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001AC4  4E75                    1760          RTS                             * Return. Size handling is finished.
00001AC6                          1761  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AC6                          1762  *-----------------------------------------------------------------------------
00001AC6                          1763  
00001AC6                          1764  
00001AC6                          1765  
00001AC6                          1766  *-----------------------------------------------------------------------------
00001AC6                          1767  *-----------------------------------------------------------------------------
00001AC6                          1768  * NAME:           PRINTBYTE
00001AC6                          1769  * DESCRIPTION:    a
00001AC6                          1770  * PRE-CONDITION:  a
00001AC6                          1771  * POST-CONDITION: a
00001AC6                          1772  * REGISTERS:      a
00001AC6                          1773  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AC6                          1774  PRINTBYTE
00001AC6  43F9 00001E32           1775          LEA     __B,A1      * Load '.B ' into A1
00001ACC  103C 000E               1776          MOVE.B  #14,D0      * Trap #14 setup to print
00001AD0  4E4F                    1777          TRAP    #15         * Perform Trap #14
00001AD2  4E75                    1778          RTS                 * Return to SIZE67/SIZE68
00001AD4                          1779          
00001AD4                          1780  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AD4                          1781  *-----------------------------------------------------------------------------
00001AD4                          1782  
00001AD4                          1783  
00001AD4                          1784  
00001AD4                          1785  *-----------------------------------------------------------------------------
00001AD4                          1786  *-----------------------------------------------------------------------------
00001AD4                          1787  * NAME:           PRINTWORD
00001AD4                          1788  * DESCRIPTION:    a
00001AD4                          1789  * PRE-CONDITION:  a
00001AD4                          1790  * POST-CONDITION: a
00001AD4                          1791  * REGISTERS:      a
00001AD4                          1792  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AD4                          1793  PRINTWORD
00001AD4  43F9 00001E36           1794          LEA     __W,A1      * Load '.W ' into A1
00001ADA  103C 000E               1795          MOVE.B  #14,D0      * Trap #14 setup to print
00001ADE  4E4F                    1796          TRAP    #15         * Perform Trap #14
00001AE0  4E75                    1797          RTS                 * Return to SIZE67/SIZE68
00001AE2                          1798          
00001AE2                          1799  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AE2                          1800  *-----------------------------------------------------------------------------
00001AE2                          1801  
00001AE2                          1802  
00001AE2                          1803  
00001AE2                          1804  *-----------------------------------------------------------------------------
00001AE2                          1805  *-----------------------------------------------------------------------------
00001AE2                          1806  * NAME:           PRINTLONG
00001AE2                          1807  * DESCRIPTION:    a
00001AE2                          1808  * PRE-CONDITION:  a
00001AE2                          1809  * POST-CONDITION: a
00001AE2                          1810  * REGISTERS:      a
00001AE2                          1811  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AE2                          1812  PRINTLONG
00001AE2  43F9 00001E3A           1813          LEA     __L,A1      * Load '.L ' into A1
00001AE8  103C 000E               1814          MOVE.B  #14,D0      * Trap #14 setup to print
00001AEC  4E4F                    1815          TRAP    #15         * Perform Trap #14
00001AEE  4E75                    1816          RTS                 * Return to SIZE67/SIZE68
00001AF0                          1817          
00001AF0                          1818  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AF0                          1819  *-----------------------------------------------------------------------------
00001AF0                          1820  
00001AF0                          1821  
00001AF0                          1822  
00001AF0                          1823  *-----------------------------------------------------------------------------
00001AF0                          1824  *-----------------------------------------------------------------------------
00001AF0                          1825  * NAME:           UNKNOWNOP
00001AF0                          1826  * DESCRIPTION:    a
00001AF0                          1827  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001AF0                          1828  *                 identified as an unknown operation.
00001AF0                          1829  * POST-CONDITION: D2 is no longer the opcode.
00001AF0                          1830  * REGISTERS:      a
00001AF0                          1831  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AF0                          1832  UNKNOWNOP
00001AF0  220A                    1833          MOVE.L  A2,D1   * prep the add to print
00001AF2                          1834          
00001AF2  5581                    1835          SUB.L   #2,D1   * off by two error due to post increment correct
00001AF4                          1836          
00001AF4  2602                    1837          MOVE.L  D2,D3   * save the opcode to print
00001AF6                          1838          
00001AF6  7410                    1839          MOVE.L  #16,D2  * set the base to 16
00001AF8                          1840          
00001AF8  700F                    1841          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001AFA  4E4F                    1842          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001AFC                          1843          
00001AFC  43F9 00001DDC           1844          LEA     DATA,A1 * load " DATA $" into register A1
00001B02  700E                    1845          MOVE.L  #14,D0  * print the string stored in A1
00001B04  4E4F                    1846          TRAP    #15
00001B06                          1847          
00001B06  2203                    1848          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001B08                          1849          
00001B08  103C 000F               1850          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001B0C  4E4F                    1851          TRAP    #15      * Perform Trap #3
00001B0E                          1852  
00001B0E  43F9 00001D9E           1853          LEA     NEWLINE,A1 * load newline into register A1
00001B14  700E                    1854          MOVE.L  #14,D0  * print the string stored in A1
00001B16  4E4F                    1855          TRAP    #15
00001B18                          1856  
00001B18  4E75                    1857          RTS
00001B1A                          1858  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B1A                          1859  *-----------------------------------------------------------------------------
00001B1A                          1860  
00001B1A                          1861  
00001B1A                          1862  
00001B1A                          1863  *-----------------------------------------------------------------------------
00001B1A                          1864  *-----------------------------------------------------------------------------
00001B1A                          1865  * NAME: Print ASCII hex char
00001B1A                          1866  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
00001B1A                          1867  * PRE-CONDITION:  A6 contains the register for memory to print.
00001B1A                          1868  *                 This parameter would be pre-loaded by, for example:
00001B1A                          1869  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001B1A                          1870  *                 D6 contains the loops to do (number of bytes).
00001B1A                          1871  * POST-CONDITION: 
00001B1A                          1872  * REGISTERS:      
00001B1A                          1873  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B1A                          1874  PRINT_ASCII_HEX_CHAR
00001B1A  48E7 FFFC               1875      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001B1E  4285                    1876      CLR.L       D5
00001B20                          1877      
00001B20                          1878      * fence post check (if-statement, check if 0 > chars)
00001B20  0C06 0000               1879      CMPI.B      #0,D6
00001B24  6700 017C               1880      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001B28                          1881      
00001B28                          1882  *    MOVE.L      A6,D4
00001B28  2E0E                    1883      MOVE.L      A6,D7
00001B2A                          1884  PRINT_ASCII_LOOP
00001B2A                          1885  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001B2A                          1886  *    MOVE.L      D4,D7 * make a mutable copy
00001B2A  E99F                    1887      ROL.L       #4,D7 * roll to next spot
00001B2C  48E7 0100               1888      MOVEM.L     D7,-(A7) * save D7
00001B30                          1889  
00001B30  0287 0000000F           1890      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001B36                          1891      
00001B36  0C87 00000000           1892      CMPI.L      #0,D7
00001B3C  6D00 0164               1893      BLT         INVALID_ASCII_INPUT
00001B40                          1894  
00001B40  0C87 0000000F           1895      CMPI.L      #15,D7
00001B46  6E00 015A               1896      BGT         INVALID_ASCII_INPUT
00001B4A                          1897  
00001B4A                          1898      * this might be faster... to do later, after entire assignment done
00001B4A                          1899       * CMPI.L      #9,D7
00001B4A                          1900       * BLE         PRINT_ASCII_0_TO_9
00001B4A                          1901  
00001B4A  0C87 00000000           1902      CMPI.L      #0,D7
00001B50  6700 0098               1903      BEQ         PRINT_ASCII_0
00001B54  0C87 00000001           1904      CMPI.L      #1,D7
00001B5A  6700 0098               1905      BEQ         PRINT_ASCII_1
00001B5E  0C87 00000002           1906      CMPI.L      #2,D7
00001B64  6700 0098               1907      BEQ         PRINT_ASCII_2
00001B68  0C87 00000003           1908      CMPI.L      #3,D7
00001B6E  6700 0098               1909      BEQ         PRINT_ASCII_3
00001B72  0C87 00000004           1910      CMPI.L      #4,D7
00001B78  6700 0098               1911      BEQ         PRINT_ASCII_4
00001B7C  0C87 00000005           1912      CMPI.L      #5,D7
00001B82  6700 0098               1913      BEQ         PRINT_ASCII_5
00001B86  0C87 00000006           1914      CMPI.L      #6,D7
00001B8C  6700 0098               1915      BEQ         PRINT_ASCII_6
00001B90  0C87 00000007           1916      CMPI.L      #7,D7
00001B96  6700 0098               1917      BEQ         PRINT_ASCII_7
00001B9A  0C87 00000008           1918      CMPI.L      #8,D7
00001BA0  6700 0098               1919      BEQ         PRINT_ASCII_8
00001BA4  0C87 00000009           1920      CMPI.L      #9,D7
00001BAA  6700 0098               1921      BEQ         PRINT_ASCII_9
00001BAE  0C87 0000000A           1922      CMPI.L      #10,D7
00001BB4  6700 0098               1923      BEQ         PRINT_ASCII_A
00001BB8  0C87 0000000B           1924      CMPI.L      #11,D7
00001BBE  6700 0098               1925      BEQ         PRINT_ASCII_B
00001BC2  0C87 0000000C           1926      CMPI.L      #12,D7
00001BC8  6700 0098               1927      BEQ         PRINT_ASCII_C
00001BCC  0C87 0000000D           1928      CMPI.L      #13,D7
00001BD2  6700 0098               1929      BEQ         PRINT_ASCII_D
00001BD6  0C87 0000000E           1930      CMPI.L      #14,D7
00001BDC  6700 0098               1931      BEQ         PRINT_ASCII_E
00001BE0  0C87 0000000F           1932      CMPI.L      #15,D7
00001BE6  6700 0098               1933      BEQ         PRINT_ASCII_F
00001BEA                          1934  PRINT_ASCII_0
00001BEA  43F9 00001E02           1935      LEA         ASCII_0,A1
00001BF0  6000 0098               1936      BRA         PRINT_ASCII_CHAR
00001BF4                          1937  PRINT_ASCII_1
00001BF4  43F9 00001E04           1938      LEA         ASCII_1,A1
00001BFA  6000 008E               1939      BRA         PRINT_ASCII_CHAR
00001BFE                          1940  PRINT_ASCII_2
00001BFE  43F9 00001E06           1941      LEA         ASCII_2,A1
00001C04  6000 0084               1942      BRA         PRINT_ASCII_CHAR
00001C08                          1943  PRINT_ASCII_3
00001C08  43F9 00001E08           1944      LEA         ASCII_3,A1
00001C0E  6000 007A               1945      BRA         PRINT_ASCII_CHAR
00001C12                          1946  PRINT_ASCII_4
00001C12  43F9 00001E0A           1947      LEA         ASCII_4,A1
00001C18  6000 0070               1948      BRA         PRINT_ASCII_CHAR
00001C1C                          1949  PRINT_ASCII_5
00001C1C  43F9 00001E0C           1950      LEA         ASCII_5,A1
00001C22  6000 0066               1951      BRA         PRINT_ASCII_CHAR
00001C26                          1952  PRINT_ASCII_6
00001C26  43F9 00001E0E           1953      LEA         ASCII_6,A1
00001C2C  6000 005C               1954      BRA         PRINT_ASCII_CHAR
00001C30                          1955  PRINT_ASCII_7
00001C30  43F9 00001E10           1956      LEA         ASCII_7,A1
00001C36  6000 0052               1957      BRA         PRINT_ASCII_CHAR
00001C3A                          1958  PRINT_ASCII_8
00001C3A  43F9 00001E12           1959      LEA         ASCII_8,A1
00001C40  6000 0048               1960      BRA         PRINT_ASCII_CHAR
00001C44                          1961  PRINT_ASCII_9
00001C44  43F9 00001E14           1962      LEA         ASCII_9,A1
00001C4A  6000 003E               1963      BRA         PRINT_ASCII_CHAR
00001C4E                          1964  PRINT_ASCII_A
00001C4E  43F9 00001E16           1965      LEA         ASCII_A,A1
00001C54  6000 0034               1966      BRA         PRINT_ASCII_CHAR
00001C58                          1967  PRINT_ASCII_B
00001C58  43F9 00001E18           1968      LEA         ASCII_B,A1
00001C5E  6000 002A               1969      BRA         PRINT_ASCII_CHAR
00001C62                          1970  PRINT_ASCII_C
00001C62  43F9 00001E1A           1971      LEA         ASCII_C,A1
00001C68  6000 0020               1972      BRA         PRINT_ASCII_CHAR
00001C6C                          1973  PRINT_ASCII_D
00001C6C  43F9 00001E1C           1974      LEA         ASCII_D,A1
00001C72  6000 0016               1975      BRA         PRINT_ASCII_CHAR
00001C76                          1976  PRINT_ASCII_E
00001C76  43F9 00001E1E           1977      LEA         ASCII_E,A1
00001C7C  6000 000C               1978      BRA         PRINT_ASCII_CHAR
00001C80                          1979  PRINT_ASCII_F
00001C80  43F9 00001E20           1980      LEA         ASCII_F,A1
00001C86  6000 0002               1981      BRA         PRINT_ASCII_CHAR
00001C8A                          1982  PRINT_ASCII_CHAR
00001C8A  103C 000E               1983      MOVE.B      #14,D0
00001C8E  4E4F                    1984      TRAP        #15
00001C90                          1985      
00001C90  5205                    1986      ADD.B       #1,D5 * loop until counter stops
00001C92  BA06                    1987      CMP.B       D6,D5
00001C94  6C00 000C               1988      BGE         PRINT_ASCII_FINISH
00001C98                          1989      
00001C98  4287                    1990      CLR.L       D7
00001C9A  4CDF 0080               1991      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001C9E                          1992      
00001C9E  6000 FE8A               1993      BRA         PRINT_ASCII_LOOP
00001CA2                          1994  INVALID_ASCII_INPUT
00001CA2                          1995  PRINT_ASCII_FINISH
00001CA2  4CDF 3FFF               1996      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001CA6  4E75                    1997      RTS
00001CA8                          1998      
00001CA8                          1999  PRINTDATA911
00001CA8  0C46 0E00               2000      CMPI    #%0000111000000000, D6   * Print 7
00001CAC  6700 003C               2001      BEQ     PRINT7   
00001CB0  0C46 0C00               2002      CMPI    #%0000110000000000, D6   * Print 6
00001CB4  6700 0042               2003      BEQ     PRINT6
00001CB8  0C46 0A00               2004      CMPI    #%0000101000000000, D6   * Print 5
00001CBC  6700 0048               2005      BEQ     PRINT5
00001CC0  0C46 0800               2006      CMPI    #%0000100000000000, D6   * Print 4
00001CC4  6700 004E               2007      BEQ     PRINT4 
00001CC8  0C46 0600               2008      CMPI    #%0000011000000000, D6   * Print 3
00001CCC  6700 0054               2009      BEQ     PRINT3    
00001CD0  0C46 0400               2010      CMPI    #%0000010000000000, D6   * Print 2
00001CD4  6700 005A               2011      BEQ     PRINT2   
00001CD8  0C46 0200               2012      CMPI    #%0000001000000000, D6   * Print 1
00001CDC  6700 0060               2013      BEQ     PRINT1     
00001CE0  0C46 0000               2014      CMPI    #%0000000000000000, D6   * Print 0
00001CE4  6700 0066               2015      BEQ     PRINT8
00001CE8                          2016      
00001CE8  4E75                    2017      RTS                             * Fail case  
00001CEA                          2018      
00001CEA                          2019  PRINT7
00001CEA  43F9 00001E10           2020      LEA     ASCII_7, A1
00001CF0  103C 000E               2021      MOVE.B      #14,D0
00001CF4  4E4F                    2022      TRAP        #15
00001CF6  4E75                    2023      RTS
00001CF8                          2024      
00001CF8                          2025  PRINT6
00001CF8  43F9 00001E0E           2026      LEA     ASCII_6, A1
00001CFE  103C 000E               2027      MOVE.B      #14,D0
00001D02  4E4F                    2028      TRAP        #15
00001D04  4E75                    2029      RTS
00001D06                          2030      
00001D06                          2031  PRINT5
00001D06  43F9 00001E0C           2032      LEA     ASCII_5, A1
00001D0C  103C 000E               2033      MOVE.B      #14,D0
00001D10  4E4F                    2034      TRAP        #15
00001D12  4E75                    2035      RTS
00001D14                          2036      
00001D14                          2037  PRINT4
00001D14  43F9 00001E0A           2038      LEA     ASCII_4, A1
00001D1A  103C 000E               2039      MOVE.B      #14,D0
00001D1E  4E4F                    2040      TRAP        #15
00001D20  4E75                    2041      RTS
00001D22                          2042      
00001D22                          2043  PRINT3
00001D22  43F9 00001E08           2044      LEA     ASCII_3, A1
00001D28  103C 000E               2045      MOVE.B      #14,D0
00001D2C  4E4F                    2046      TRAP        #15
00001D2E  4E75                    2047      RTS
00001D30                          2048      
00001D30                          2049  PRINT2
00001D30  43F9 00001E06           2050      LEA     ASCII_2, A1
00001D36  103C 000E               2051      MOVE.B      #14,D0
00001D3A  4E4F                    2052      TRAP        #15
00001D3C  4E75                    2053      RTS
00001D3E                          2054      
00001D3E                          2055  PRINT1
00001D3E  43F9 00001E04           2056      LEA     ASCII_1, A1
00001D44  103C 000E               2057      MOVE.B      #14,D0
00001D48  4E4F                    2058      TRAP        #15
00001D4A  4E75                    2059      RTS
00001D4C                          2060          
00001D4C                          2061  PRINT8
00001D4C  43F9 00001E12           2062      LEA     ASCII_8, A1
00001D52  103C 000E               2063      MOVE.B      #14,D0
00001D56  4E4F                    2064      TRAP        #15
00001D58  4E75                    2065      RTS
00001D5A                          2066  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D5A                          2067  *-----------------------------------------------------------------------------
00001D5A                          2068  
00001D5A                          2069  
00001D5A                          2070  
00001D5A                          2071  *-----------------------------------------------------------------------------
00001D5A                          2072  *-----------------------------------------------------------------------------
00001D5A                          2073  * NAME: Bitmask
00001D5A                          2074  * DESCRIPTION:    Masks bits in a data register.
00001D5A                          2075  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001D5A                          2076  *                 the ending bit.  For example, a starting bit of decimal
00001D5A                          2077  *                 value 0 and an ending bit of decimal value 3 will mask the
00001D5A                          2078  *                 bits 0, 1, 2, and 3.
00001D5A                          2079  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001D5A                          2080  * REGISTERS:      D5,D6,D7
00001D5A                          2081  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D5A                          2082  BITMASK
00001D5A  3F05                    2083          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001D5C  4245                    2084          CLR     D5          * clear D5 so we can use it
00001D5E                          2085  LOOPBIT 
00001D5E  0DC5                    2086          BSET    D6,D5       * set the D6th bit in D5 to 1
00001D60  5246                    2087          ADD     #1,D6       * increment D6
00001D62                          2088  
00001D62  BC47                    2089          CMP     D7,D6       * have we finished?
00001D64  6E00 0004               2090          BGT     BITMASKDONE * yes
00001D68  60F4                    2091          BRA     LOOPBIT     * no, iterate again
00001D6A                          2092  
00001D6A                          2093  BITMASKDONE
00001D6A  2C05                    2094          MOVE.L  D5,D6
00001D6C  3A1F                    2095          MOVE    (A7)+,D5    * restore D5
00001D6E  4E75                    2096          RTS
00001D70                          2097  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D70                          2098  *-----------------------------------------------------------------------------
00001D70                          2099  
00001D70                          2100  
00001D70                          2101  
00001D70                          2102  *-----------------------------------------------------------------------------
00001D70                          2103  *-----------------------------------------------------------------------------
00001D70                          2104  * SECTION: Constants/variables used throughout the program.
00001D70                          2105  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D70                          2106  * ---> GENERAL
00001D70  =0000000D               2107  CR          EQU     $0D
00001D70  =0000000A               2108  LF          EQU     $0A
00001D70= 45 4E 54 45 52 20 ...   2109  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001D88= 45 4E 54 45 52 20 ...   2110  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001D9E= 0D 0A 00                2111  NEWLINE     DC.B    CR,LF,0
00001DA1                          2112  * ---> OPS
00001DA1= 44 49 56 53 00          2113  DIVSOP      DC.B    'DIVS',0
00001DA6= 4E 4F 50 00             2114  NOOPERATION DC.B    'NOP',0
00001DAA= 4E 45 47 00             2115  NEGOP       DC.B    'NEG',0
00001DAE= 4D 4F 56 45 00          2116  MOVEOP      DC.B    'MOVE',0
00001DB3= 4D 4F 56 45 4D 00       2117  MOVEMOP     DC.B    'MOVEM',0
00001DB9= 4A 53 52 00             2118  JSROP       DC.B    'JSR',0
00001DBD= 52 54 53 00             2119  RTSOP       DC.B    'RTS',0
00001DC1= 53 55 42 51 00          2120  SUBQOP      DC.B    'SUBQ',0
00001DC6= 4C 45 41 00             2121  LEAOP       DC.B    'LEA',0
00001DCA= 42 43 4C 52 20 00       2122  BCLROP      DC.B    'BCLR ',0
00001DD0= 4F 52 00                2123  OROP        DC.B    'OR',0
00001DD3= 4F 52 49 00             2124  ORIOP       DC.B    'ORI',0
00001DD7= 43 4D 50 49 00          2125  CMPIOP      DC.B    'CMPI',0
00001DDC= 20 44 41 54 41 20 ...   2126  DATA        DC.B    ' DATA $',0
00001DE4= 42 43 43 20 00          2127  OP_BCC_MSG  DC.B    'BCC ',0
00001DE9= 42 43 53 20 00          2128  OP_BCS_MSG  DC.B    'BCS ',0
00001DEE= 42 47 45 20 00          2129  OP_BGE_MSG  DC.B    'BGE ',0
00001DF3= 42 4C 54 20 00          2130  OP_BLT_MSG  DC.B    'BLT ',0
00001DF8= 42 56 43 20 00          2131  OP_BVC_MSG  DC.B    'BVC ',0
00001DFD= 42 52 41 20 00          2132  OP_BRA_MSG  DC.B    'BRA ',0
00001E02                          2133  * ---> HEX CHARS
00001E02= 30 00                   2134  ASCII_0     DC.B    '0',0
00001E04= 31 00                   2135  ASCII_1     DC.B    '1',0
00001E06= 32 00                   2136  ASCII_2     DC.B    '2',0
00001E08= 33 00                   2137  ASCII_3     DC.B    '3',0
00001E0A= 34 00                   2138  ASCII_4     DC.B    '4',0
00001E0C= 35 00                   2139  ASCII_5     DC.B    '5',0
00001E0E= 36 00                   2140  ASCII_6     DC.B    '6',0
00001E10= 37 00                   2141  ASCII_7     DC.B    '7',0
00001E12= 38 00                   2142  ASCII_8     DC.B    '8',0
00001E14= 39 00                   2143  ASCII_9     DC.B    '9',0
00001E16= 41 00                   2144  ASCII_A     DC.B    'A',0
00001E18= 42 00                   2145  ASCII_B     DC.B    'B',0
00001E1A= 43 00                   2146  ASCII_C     DC.B    'C',0
00001E1C= 44 00                   2147  ASCII_D     DC.B    'D',0
00001E1E= 45 00                   2148  ASCII_E     DC.B    'E',0
00001E20= 46 00                   2149  ASCII_F     DC.B    'F',0
00001E22                          2150  * ---> SPECIAL CHARACTERS
00001E22= 20 00                   2151  SPACE       DC.B    ' ',0
00001E24= 24 00                   2152  DOLLAR      DC.B    '$',0
00001E26= 23 00                   2153  IMD         DC.B    '#',0
00001E28= 2C 00                   2154  COMMA       DC.B    ',',0
00001E2A= 28 00                   2155  OBRACK      DC.B    '(',0
00001E2C= 29 00                   2156  CBRACK      DC.B    ')',0
00001E2E= 2B 00                   2157  PLUS        DC.B    '+',0
00001E30= 2D 00                   2158  MINUS       DC.B    '-',0
00001E32                          2159  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001E32= 2E 42 20 00             2160  __B         DC.B    '.B ',0
00001E36= 2E 57 20 00             2161  __W         DC.B    '.W ',0
00001E3A= 2E 4C 20 00             2162  __L         DC.B    '.L ',0
00001E3E                          2163  * ---> ADDRESS REGISTERS A0-A7
00001E3E= 41 30 00                2164  __A0        DC.B   'A0',0
00001E41= 41 31 00                2165  __A1        DC.B   'A1',0    
00001E44= 41 32 00                2166  __A2        DC.B   'A2',0
00001E47= 41 33 00                2167  __A3        DC.B   'A3',0
00001E4A= 41 34 00                2168  __A4        DC.B   'A4',0
00001E4D= 41 35 00                2169  __A5        DC.B   'A5',0
00001E50= 41 36 00                2170  __A6        DC.B   'A6',0
00001E53= 41 37 00                2171  __A7        DC.B   'A7',0
00001E56                          2172  * ---> DATA REGISTERS D0-D7
00001E56= 44 30 00                2173  __D0        DC.B   'D0',0
00001E59= 44 31 00                2174  __D1        DC.B   'D1',0
00001E5C= 44 32 00                2175  __D2        DC.B   'D2',0
00001E5F= 44 33 00                2176  __D3        DC.B   'D3',0
00001E62= 44 34 00                2177  __D4        DC.B   'D4',0
00001E65= 44 35 00                2178  __D5        DC.B   'D5',0
00001E68= 44 36 00                2179  __D6        DC.B   'D6',0
00001E6B= 44 37 00                2180  __D7        DC.B   'D7',0
00001E6E                          2181  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001E6E                          2182  *-----------------------------------------------------------------------------
00001E6E                          2183  
00001E6E                          2184  
00001E6E                          2185  
00001E6E                          2186  *-----------------------------------------------------------------------------
00001E6E                          2187  *-----------------------------------------------------------------------------
00001E6E                          2188  * SECTION: Sample program to run, then attempt testing disassembly on.
00001E6E                          2189  * STARTING: 16384
00001E6E                          2190  * ENDING:   16420
00001E6E                          2191  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2192      ORG $4000
00004000                          2193      
00004000  4E71                    2194      NOP
00004002  103C 009A               2195      MOVE.B   #%10011010, D0
00004006  123C 00A9               2196      MOVE.B   #%10101001, D1
0000400A  D200                    2197      ADD.B    D0,D1
0000400C  48A7 4000               2198      MOVEM    D1,-(A7)
00004010  43F8 1DB9               2199      LEA      JSROP,A1
00004014  4467                    2200      NEG.W    -(A7)
00004016  4EB9 00004030           2201      JSR      END
0000401C  81FC 0001               2202      DIVS    #1, D0
00004020  0181                    2203      BCLR    D0, D1
00004022  5181                    2204      SUBQ.L  #8, D1
00004024  0041 0004               2205      ORI     #4, D1
00004028  6000 0006               2206      BRA     END
0000402C  6700 0002               2207      BEQ     END
00004030                          2208  
00004030                          2209  END
00004030  4E75                    2210      RTS
00004032                          2211      
00004032                          2212  RLLYEND
00004032                          2213      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1E02
ASCII_1             1E04
ASCII_2             1E06
ASCII_3             1E08
ASCII_4             1E0A
ASCII_5             1E0C
ASCII_6             1E0E
ASCII_7             1E10
ASCII_8             1E12
ASCII_9             1E14
ASCII_A             1E16
ASCII_B             1E18
ASCII_C             1E1A
ASCII_D             1E1C
ASCII_E             1E1E
ASCII_F             1E20
BCC_END             15CE
BCLROP              1DCA
BITMASK             1D5A
BITMASKDONE         1D6A
CBRACK              1E2C
CMPIOP              1DD7
COMMA               1E28
CR                  D
DATA                1DDC
DIVSOP              1DA1
DOLLAR              1E24
DONE0100            14AC
DONE0101            151A
EAHELPER05          16D4
EAHELPER611         1692
END                 4030
END0000             1240
END67               1A68
ENDEAHELPER05       1824
ENDEAHELPER611      16CE
ENDMODE_AN          19B4
ENDMODE_DN          18B4
ENDOP0001           12A6
HEX_VALUE_MASK_LONG  F
IMD                 1E26
INVALID_ASCII_INPUT  1CA2
ITERATION           1144
JSROP               1DB9
LEAOP               1DC6
LF                  A
LOOP                103A
LOOPBIT             1D5E
LOOPUNKNOWNOP       1140
MINUS               1E30
MODE_AN             192A
MODE_DN             182A
MOVEMOP             1DB3
MOVEOP              1DAE
MSGEND              1D88
MSGSTART            1D70
NEGOP               1DAA
NEWLINE             1D9E
NOOPERATION         1DA6
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           1A4C
NOT67WORD           1A5C
NOTA0               194C
NOTA1               195C
NOTA2               196C
NOTA3               197C
NOTA4               198C
NOTA5               199C
NOTA6               19AC
NOTADRDIRECT        1704
NOTADRINDIRECT      172C
NOTADRINDIRECTPOST  1760
NOTADRINDIRECTPRE   1794
NOTBCLR             11CE
NOTD0               184C
NOTD1               185C
NOTD2               186C
NOTD3               187C
NOTD4               188C
NOTD5               189C
NOTD6               18AC
NOTDATAREG          16F4
NOTDIVS             1658
NOTIMMBYTE          17CA
NOTIMMEDIATE        1820
NOTIMMWORD          17F8
NOTJSR              13A4
NOTMOVEM            1356
NOTNEG              1332
NOTNOP              12DC
NOTORI              1234
NOTRTS              13C6
OBRACK              1E2A
OP0000              1150
OP0001              1246
OP0010              12AC
OP0011              12B2
OP0100              12C0
OP0101              14B6
OP0110              1520
OP0111              15D4
OP1000              15DA
OP1000END           1668
OP1001              166E
OP1010              166E
OP1011              1674
OP1100              167A
OP1101              1680
OP1110              1686
OP1111              168C
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              1570
OP_BCC_MSG          1DE4
OP_BCS              157A
OP_BCS_MSG          1DE9
OP_BGE              1584
OP_BGE_MSG          1DEE
OP_BLT              158E
OP_BLT_MSG          1DF3
OP_BRA              15A2
OP_BRANCHES_PRINT   15AC
OP_BRA_MSG          1DFD
OP_BVC              1598
OP_BVC_MSG          1DF8
ORIOP               1DD3
OROP                1DD0
PLUS                1E2E
PRINT1              1D3E
PRINT2              1D30
PRINT3              1D22
PRINT4              1D14
PRINT5              1D06
PRINT6              1CF8
PRINT7              1CEA
PRINT8              1D4C
PRINTA0             19BA
PRINTA1             19C8
PRINTA2             19D6
PRINTA3             19E4
PRINTA4             19F2
PRINTA5             1A00
PRINTA6             1A0E
PRINTA7             1A1C
PRINTBYTE           1AC6
PRINTD0             18BA
PRINTD1             18C8
PRINTD2             18D6
PRINTD3             18E4
PRINTD4             18F2
PRINTD5             1900
PRINTD6             190E
PRINTD7             191C
PRINTDATA911        1CA8
PRINTLONG           1AE2
PRINTWORD           1AD4
PRINT_ASCII_0       1BEA
PRINT_ASCII_1       1BF4
PRINT_ASCII_2       1BFE
PRINT_ASCII_3       1C08
PRINT_ASCII_4       1C12
PRINT_ASCII_5       1C1C
PRINT_ASCII_6       1C26
PRINT_ASCII_7       1C30
PRINT_ASCII_8       1C3A
PRINT_ASCII_9       1C44
PRINT_ASCII_A       1C4E
PRINT_ASCII_B       1C58
PRINT_ASCII_C       1C62
PRINT_ASCII_CHAR    1C8A
PRINT_ASCII_D       1C6C
PRINT_ASCII_E       1C76
PRINT_ASCII_F       1C80
PRINT_ASCII_FINISH  1CA2
PRINT_ASCII_HEX_CHAR  1B1A
PRINT_ASCII_LOOP    1B2A
RLLYEND             4032
RTSOP               1DBD
SIZE67              1A2A
SIZE68              1A6E
SPACE               1E22
START               1000
SUBQOP              1DC1
TWOWORDLEA          1456
UNKNOWN0000         123C
UNKNOWN0100         14A8
UNKNOWN0101         1510
UNKNOWNOP           1AF0
UNKNOWNOP0001       12A2
__A0                1E3E
__A1                1E41
__A2                1E44
__A3                1E47
__A4                1E4A
__A5                1E4D
__A6                1E50
__A7                1E53
__B                 1E32
__D0                1E56
__D1                1E59
__D2                1E5C
__D3                1E5F
__D4                1E62
__D5                1E65
__D6                1E68
__D7                1E6B
__L                 1E3A
__W                 1E36
