00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 9:38:32 AM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001DF2             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001E0A             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001E20             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0DA4                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 01EC                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 0242                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 0238                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 0236                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 041C                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 047A                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 051E                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 0514                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 0598                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 0588                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 057E                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 0574                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 05E8                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 05DE                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 05D4                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 0A30                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2EF0                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 FFC0                212          MOVEM   D0-D7/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0C7E                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162                           218          * TODO: Consider static  AND dynamic BCLR.
00001162                           219          * Only works for Dynamic right now
00001162  0C46 0180                220          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0066                221          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           222          
0000116A  3C3C 0003                223          MOVE.W  #3, D6              * Prep lower value for bitmask
0000116E  3E3C 0005                224          MOVE.W  #5, D7              * Prep upper value for bitmask
00001172  6100 0C68                225          BSR     BITMASK             * Finalize bitmask setup
00001176  CC42                     226          AND     D2,D6               * Apply bitmask
00001178                           227          
00001178                           228          * Checking for unsupported mode
00001178  0C46 0008                229          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000117C  6700 00BE                230          BEQ     UNKNOWN0000             * If so, branch to other OP0000 functions
00001180                           231          
00001180                           232          * Confirmed BCLR at this point
00001180  43F9 00001E4C            233          LEA     BCLROP,A1           * We found BCLR
00001186  103C 000E                234          MOVE.B  #14,D0              * Trap #14 prints out the data
0000118A  4E4F                     235          TRAP    #15                 * Perform Trap #14
0000118C                           236  
0000118C  43F9 00001EA9            237          LEA     SPACE,A1            * Formatting
00001192  103C 000E                238          MOVE.B  #14,D0              * Trap #14 prints out space
00001196  4E4F                     239          TRAP    #15                 * Perform Trap #14
00001198                           240          
00001198                           241          * Set up for printing out the Register
00001198  0882 0006                242          BCLR    #6,D2               * Clear bit 6
0000119C  0882 0007                243          BCLR    #7,D2               * Clear bit 7
000011A0  0882 0008                244          BCLR    #8,D2               * Clear bit 8
000011A4                           245          
000011A4  6100 056E                246          BSR     EAHELPER611         * Print out Register
000011A8                           247  
000011A8  43F9 00001EAF            248          LEA     COMMA,A1            * formatting
000011AE  103C 000E                249          MOVE.B  #14,D0              * Trap #14 prints out a comma
000011B2  4E4F                     250          TRAP    #15                 * Perform Trap #14
000011B4                           251          
000011B4  4243                     252          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000011B6  08C3 0000                253          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000011BA                           254      
000011BA  6100 059A                255          BSR     EAHELPER05          * Print out data.
000011BE                           256          
000011BE  43F9 00001E20            257          LEA     NEWLINE,A1          * Formatting
000011C4  103C 000E                258          MOVE.B  #14,D0              * Trap #14 prints out the data
000011C8  4E4F                     259          TRAP    #15                 * Perform Trap #14
000011CA                           260          
000011CA  6000 0074                261          BRA     END0000             * Found the op, move to next iteration
000011CE                           262          
000011CE                           263  NOTBCLR * Possible options left are ORI or CMPI
000011CE  3C3C 0009                264          MOVE.W  #9, D6              * Prep lower value for bitmask
000011D2  3E3C 000B                265          MOVE.W  #11, D7             * Prep upper value for bitmask
000011D6  6100 0C04                266          BSR     BITMASK             * Finalize bitmask setup
000011DA  CC42                     267          AND     D2,D6               * Apply bitmask
000011DC                           268          
000011DC  0C46 0000                269          CMPI    #%0000000000000000, D6   * Are we possibly ORI?
000011E0  6600 0052                270          BNE     NOTORI                   * If not, branch to NOTORI
000011E4                           271          
000011E4                           272          * Size check to see if unsupported ORI mode
000011E4  3C3C 0006                273          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E8  3E3C 0007                274          MOVE.W  #7, D7              * Prep upper value for bitmask
000011EC  6100 0BEE                275          BSR     BITMASK             * Finalize bitmask setup
000011F0  CC42                     276          AND     D2,D6               * Apply bitmask
000011F2                           277          
000011F2  0C46 00C0                278          CMPI    #%0000000011000000, D6  * Are bits 6,7 == 1,1?
000011F6  6700 0044                279          BEQ     UNKNOWN0000             * If so, unknown op. 
000011FA                           280          
000011FA                           281          * Mode check to see if unsupported ORI mode
000011FA  3C3C 0003                282          MOVE.W  #3, D6              * Prep lower value for bitmask
000011FE  3E3C 0005                283          MOVE.W  #5, D7              * Prep upper value for bitmask
00001202  6100 0BD8                284          BSR     BITMASK             * Finalize bitmask setup
00001206  CC42                     285          AND     D2,D6               * Apply bitmask
00001208                           286          
00001208  0C46 0008                287          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000120C  6700 002E                288          BEQ     UNKNOWN0000             * If so, unknown op. 
00001210                           289          
00001210                           290          * Confirmed ORI at this point
00001210                           291          * TODO: Get the immediate data following the instruction and print it out
00001210  43F9 00001E5A            292          LEA     ORIOP, A1           * Load 'ORI' into the output window
00001216  103C 000E                293          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
0000121A  4E4F                     294          TRAP    #15                 * Perform Trap #14
0000121C                           295          
0000121C  6100 088E                296          BSR     SIZE67              * Print the size
00001220  6100 0534                297          BSR     EAHELPER05          * Print out the EA
00001224                           298          
00001224  43F9 00001E20            299          LEA     NEWLINE,A1          * Formatting
0000122A  103C 000E                300          MOVE.B  #14,D0              * Trap #14 prints out the data
0000122E  4E4F                     301          TRAP    #15                 * Perform Trap #14
00001230                           302          
00001230  6000 000E                303          BRA     END0000             * Done with op. Move to next iteration
00001234                           304          
00001234                           305  NOTORI  * Possible option left is CMPI
00001234  0C46 0C00                306          CMPI    #%0000110000000000, D6  * Are we CMPI?
00001238  6600 0002                307          BNE     UNKNOWN0000             * If not, unknown op
0000123C                           308          
0000123C                           309          * TODO: Continue checking for CMPI validity
0000123C                           310          
0000123C                           311  UNKNOWN0000
0000123C  6100 0934                312          BSR     UNKNOWNOP       * Unknown op
00001240                           313          
00001240                           314  END0000          
00001240  4C9F 03FF                315         MOVEM   (A7)+,D0-D7/A0-A1   * Push values to the stack to save
00001244  4E75                     316         RTS
00001246                           317  
00001246                           318  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001246                           319  *-----------------------------------------------------------------------------
00001246                           320  
00001246                           321  
00001246                           322  
00001246                           323  *-----------------------------------------------------------------------------
00001246                           324  *-----------------------------------------------------------------------------
00001246                           325  * NAME: OP_0001   (MOVE.B)
00001246                           326  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001246                           327  * PRE-CONDITION:  xyz
00001246                           328  * POST-CONDITION: All registers return to their previous state, and the output
00001246                           329  *                 goes to the output console for reading the raw data or the
00001246                           330  *                 actual instruction.
00001246                           331  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001246                           332  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001246                           333  OP0001  
00001246  48A7 FFC0                334          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
0000124A  3C3C 0006                335          MOVE.W  #6, D6              * Prep lower value for bitmask
0000124E  3E3C 0008                336          MOVE.W  #8, D7              * Prep upper value for bitmask
00001252  6100 0B88                337          BSR     BITMASK             * Finalize bitmask setup
00001256  CC42                     338          AND     D2,D6               * Apply bitmask
00001258                           339          
00001258                           340          * I may have fucked off this part, sorry - Caleb
00001258                           341          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
00001258                           342          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
00001258                           343          
00001258  43F9 00001E30            344          LEA     MOVEOP,A1   * Put 'MOVE' into the window
0000125E  103C 000E                345          MOVE.B  #14,D0      * Trap #14 to print out
00001262  4E4F                     346          TRAP    #15         * Perform Trap #14
00001264                           347          
00001264                           348          *-----------------------------------------------------------
00001264                           349          * the following code is to move the size bits into the
00001264                           350          * 0-1 positions of D3 so that eahelper05 case use that as a "parameter"
00001264                           351          * for eahelper05
00001264                           352          
00001264  3C3C 000C                353          MOVE.W  #12, D6              * Prep lower value for bitmask
00001268  3E3C 000D                354          MOVE.W  #13, D7              * Prep upper value for bitmask
0000126C  6100 0B6E                355          BSR     BITMASK             * Finalize bitmask setup
00001270                           356          
00001270  CC42                     357          AND     D2,D6
00001272                           358          
00001272  E04E                     359          LSR     #8,D6
00001274  E84E                     360          LSR     #4,D6
00001276                           361          
00001276  4243                     362          CLR     D3
00001278                           363          
00001278  1606                     364          MOVE.B  D6,D3
0000127A                           365          
0000127A                           366          *---------------------------------------------------------------
0000127A                           367          
0000127A                           368          
0000127A  6100 0830                369          BSR     SIZE67
0000127E  6100 04D6                370          BSR     EAHELPER05
00001282                           371          
00001282  43F9 00001EAF            372          LEA     COMMA,A1
00001288  103C 000E                373          MOVE.B  #14,D0
0000128C  4E4F                     374          TRAP    #15
0000128E                           375          
0000128E  6100 0484                376          BSR     EAHELPER611
00001292                           377          
00001292  43F9 00001E20            378          LEA     NEWLINE,A1
00001298  103C 000E                379          MOVE.B  #14,D0
0000129C  4E4F                     380          TRAP    #15
0000129E                           381          
0000129E  6000 0006                382          BRA     ENDOP0001
000012A2                           383          *LEA     __B,A1      * Put '.B' into the window
000012A2                           384          *MOVE.B  #14,D0      * Trap #14 to print out
000012A2                           385          *TRAP    #15         * Perform Trap #14
000012A2                           386          
000012A2                           387  UNKNOWNOP0001
000012A2                           388  
000012A2  6100 08CE                389          BSR     UNKNOWNOP
000012A6                           390          
000012A6                           391  ENDOP0001
000012A6                           392  
000012A6  4C9F 03FF                393          MOVEM (A7)+,D0-D7/A0-A1
000012AA  4E75                     394          RTS        
000012AC                           395          
000012AC                           396          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
000012AC                           397  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012AC                           398  *-----------------------------------------------------------------------------
000012AC                           399  
000012AC                           400  
000012AC                           401  
000012AC                           402  *-----------------------------------------------------------------------------
000012AC                           403  *-----------------------------------------------------------------------------
000012AC                           404  * NAME: OP_0010   (MOVE.L, MOVEA.L)
000012AC                           405  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012AC                           406  * PRE-CONDITION:  xyz
000012AC                           407  * POST-CONDITION: All registers return to their previous state, and the output
000012AC                           408  *                 goes to the output console for reading the raw data or the
000012AC                           409  *                 actual instruction.
000012AC                           410  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012AC                           411  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012AC                           412  OP0010
000012AC                           413  
000012AC  6100 08C4                414      BSR     UNKNOWNOP
000012B0  4E75                     415      RTS
000012B2                           416  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012B2                           417  *-----------------------------------------------------------------------------
000012B2                           418  
000012B2                           419  
000012B2                           420  
000012B2                           421  *-----------------------------------------------------------------------------
000012B2                           422  *-----------------------------------------------------------------------------
000012B2                           423  * NAME: OP_0011   (MOVE.W, MOVEA.W)
000012B2                           424  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012B2                           425  * PRE-CONDITION:  xyz
000012B2                           426  * POST-CONDITION: All registers return to their previous state, and the output
000012B2                           427  *                 goes to the output console for reading the raw data or the
000012B2                           428  *                 actual instruction.
000012B2                           429  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012B2                           430  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012B2                           431  OP0011
000012B2  48A7 FFFE                432      MOVEM   D0-D7/A0-A6, -(A7)
000012B6                           433      
000012B6                           434      *MOVE.W  #6,D6
000012B6                           435      *MOVE.W  #8,D7
000012B6                           436      
000012B6                           437      *BSR     BITMASK
000012B6                           438      
000012B6                           439      *AND.W   D2,D6
000012B6                           440      
000012B6                           441      *CMP     #%0000000001000000,D6
000012B6                           442      *BNE     NEXT15
000012B6                           443      *BSR     * for MOVEA.W
000012B6                           444      
000012B6  4C9F 7FFF                445      MOVEM   (A7)+,D0-D7/A0-A6
000012BA                           446      
000012BA  6100 08B6                447      BSR     UNKNOWNOP
000012BE  4E75                     448      RTS
000012C0                           449  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012C0                           450  *-----------------------------------------------------------------------------
000012C0                           451  
000012C0                           452  
000012C0                           453  
000012C0                           454  *-----------------------------------------------------------------------------
000012C0                           455  *-----------------------------------------------------------------------------
000012C0                           456  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
000012C0                           457  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012C0                           458  * PRE-CONDITION:  xyz
000012C0                           459  * POST-CONDITION: All registers return to their previous state, and the output
000012C0                           460  *                 goes to the output console for reading the raw data or the
000012C0                           461  *                 actual instruction.
000012C0                           462  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012C0                           463  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012C0                           464  OP0100  
000012C0                           465          * TODO: movem
000012C0                           466  
000012C0  48A7 C0C0                467          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000012C4                           468          
000012C4                           469          *NOP
000012C4  0C42 4E71                470          CMPI    #%0100111001110001,D2
000012C8  6600 0012                471          BNE     NOTNOP
000012CC                           472          
000012CC  43F9 00001E28            473          LEA     NOOPERATION,A1
000012D2  103C 000D                474          MOVE.B  #13,D0          * Print a newline
000012D6  4E4F                     475          TRAP    #15
000012D8                           476          
000012D8  6000 01D2                477          BRA     DONE0100 *we found it, move on to the next iteration
000012DC                           478  NOTNOP *NEG
000012DC                           479          
000012DC                           480          * prep values for BITMASK subroutine
000012DC  7C08                     481          MOVE.L  #8,D6
000012DE  7E0B                     482          MOVE.L  #11,D7
000012E0                           483          
000012E0  6100 0AFA                484          BSR     BITMASK
000012E4                           485          
000012E4  CC42                     486          AND     D2,D6                   * apply bitmask
000012E6                           487          
000012E6  0C46 0400                488          CMPI    #%0000010000000000,D6   * are we NEG?
000012EA  6600 0046                489          BNE     NOTNEG                  * not neg
000012EE                           490          
000012EE  7C03                     491          MOVE.L  #3,D6
000012F0  7E05                     492          MOVE.L  #5,D7
000012F2                           493          
000012F2  6100 0AE8                494          BSR     BITMASK * generate a bitmask to be used to check mode
000012F6                           495          
000012F6  0C46 0008                496          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
000012FA  6700 01AC                497          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
000012FE                           498          
000012FE  0C46 0028                499          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001302  6700 01A4                500          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
00001306                           501          
00001306  0C46 0030                502          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000130A  6700 019C                503          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
0000130E                           504        
0000130E                           505          * it is NEG, print
0000130E  43F9 00001E2C            506          LEA     NEGOP,A1
00001314  103C 000E                507          MOVE.B  #14,D0
00001318  4E4F                     508          TRAP    #15
0000131A                           509          
0000131A  6100 0790                510          BSR     SIZE67
0000131E                           511          
0000131E  6100 0436                512          BSR     EAHELPER05
00001322                           513          
00001322  43F9 00001E20            514          LEA     NEWLINE,A1
00001328  103C 000E                515          MOVE.B  #14,D0
0000132C  4E4F                     516          TRAP    #15
0000132E                           517          
0000132E  6000 017C                518          BRA     DONE0100 * we found the op, move to next iteration
00001332                           519          
00001332                           520  NOTNEG *MOVEM
00001332                           521  
00001332                           522          * prep values for BITMASK subroutine
00001332  7C07                     523          MOVE.L  #7,D6
00001334  7E09                     524          MOVE.L  #9,D7
00001336                           525          
00001336  6100 0AA4                526          BSR     BITMASK
0000133A                           527          
0000133A  CC42                     528          AND     D2,D6   * apply bitmask
0000133C                           529          
0000133C  0C46 0080                530          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001340  6600 0014                531          BNE     NOTMOVEM          * it is not MOVEM
00001344                           532          
00001344                           533          * make sure it is a valid size and mode for MOVEM
00001344                           534          
00001344                           535          * it is MOVEM
00001344  43F9 00001E35            536          LEA     MOVEMOP,A1
0000134A  103C 000D                537          MOVE.B  #13,D0          * Print a newline
0000134E  4E4F                     538          TRAP    #15
00001350                           539          
00001350                           540          * probably needs its own special code for printing the rest due to uniqueness of movem
00001350                           541          
00001350  341A                     542          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001352                           543          
00001352  6000 0158                544          BRA     DONE0100          * we found and printed, move on to the next iteration
00001356                           545          
00001356                           546  NOTMOVEM *JSR
00001356                           547          * prep values for BITMASK subroutine
00001356  7C06                     548          MOVE.L  #6,D6
00001358  7E08                     549          MOVE.L  #8,D7
0000135A                           550          
0000135A  6100 0A80                551          BSR     BITMASK
0000135E                           552          
0000135E  CC42                     553          AND     D2,D6   * apply bitmask
00001360                           554          
00001360  0C46 0080                555          CMPI    #%0000000010000000,D6
00001364  6600 003E                556          BNE     NOTJSR          * it's not JSR
00001368                           557          
00001368  43F9 00001E3B            558          LEA     JSROP,A1
0000136E  103C 000E                559          MOVE.B  #14,D0          * Print a newline and JSR
00001372  4E4F                     560          TRAP    #15
00001374                           561          
00001374  43F9 00001EA9            562          LEA     SPACE,A1
0000137A  103C 000E                563          MOVE.B  #14,D0          * Print a newline and JSR
0000137E  4E4F                     564          TRAP    #15
00001380                           565          
00001380                           566          * print out where we are jumping to
00001380                           567          
00001380  341A                     568          MOVE.W  (A2)+,D2 * read in the next word of the instruction 
00001382                           569          
00001382  2202                     570          MOVE.L  D2,D1   * save the opcode to print
00001384                           571          
00001384  7410                     572          MOVE.L  #16,D2  * set the base to 16
00001386                           573          
00001386  700F                     574          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001388  4E4F                     575          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000138A                           576          
0000138A  341A                     577          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000138C                           578          
0000138C  2202                     579          MOVE.L  D2,D1   * save the opcode to print
0000138E                           580          
0000138E  7410                     581          MOVE.L  #16,D2  * set the base to 16
00001390                           582          
00001390  700F                     583          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001392  4E4F                     584          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001394                           585          
00001394  43F9 00001E20            586          LEA     NEWLINE,A1
0000139A  103C 000E                587          MOVE.B  #14,D0          * Print a newline
0000139E  4E4F                     588          TRAP    #15
000013A0                           589          
000013A0  6000 010A                590          BRA     DONE0100          * we already found instruction, next iteration
000013A4                           591  NOTJSR *RTS
000013A4                           592  
000013A4                           593          * prep values for BITMASK subroutine
000013A4  7C06                     594          MOVE.L  #6,D6
000013A6  7E08                     595          MOVE.L  #8,D7
000013A8                           596          
000013A8  6100 0A32                597          BSR     BITMASK
000013AC                           598          
000013AC  CC42                     599          AND     D2,D6   * apply bitmask
000013AE                           600          
000013AE  0C46 0040                601          CMPI    #%0000000001000000,D6
000013B2  6600 0012                602          BNE     NOTRTS          * it's not RTS
000013B6                           603          
000013B6  43F9 00001E3F            604          LEA     RTSOP,A1
000013BC  103C 000D                605          MOVE.B  #13,D0          * Print a newline and RTS
000013C0  4E4F                     606          TRAP    #15
000013C2                           607          
000013C2  6000 00E8                608          BRA     DONE0100          * we already found instruction, next iteration
000013C6                           609  NOTRTS  *LEA
000013C6                           610         
000013C6                           611          * prep values for BITMASK subroutine
000013C6  7C06                     612          MOVE.L  #6,D6
000013C8  7E08                     613          MOVE.L  #8,D7
000013CA                           614          
000013CA  6100 0A10                615          BSR     BITMASK
000013CE                           616          
000013CE  CC42                     617          AND     D2,D6   * apply bitmask
000013D0                           618          
000013D0  0C46 01C0                619          CMPI    #%0000000111000000,D6
000013D4  6600 00D2                620          BNE     UNKNOWN0100          * it's not LEA, we dont know what it is
000013D8                           621          
000013D8                           622          * prep values for BITMASK subroutine
000013D8  7C03                     623          MOVE.L  #3,D6
000013DA  7E05                     624          MOVE.L  #5,D7
000013DC                           625          
000013DC  6100 09FE                626          BSR     BITMASK
000013E0                           627          
000013E0  CC42                     628          AND     D2,D6   * apply bitmask
000013E2                           629          
000013E2  0C46 0008                630          CMPI    #%0000000000001000,D6
000013E6  6700 00C0                631          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013EA                           632          
000013EA  0C46 0018                633          CMPI    #%0000000000011000,D6
000013EE  6700 00B8                634          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013F2                           635          
000013F2  0C46 0020                636          CMPI    #%0000000000100000,D6
000013F6  6700 00B0                637          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013FA                           638          
000013FA  0C46 0028                639          CMPI    #%0000000000101000,D6
000013FE  6700 00A8                640          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001402                           641          
00001402  0C46 0030                642          CMPI    #%0000000000110000,D6
00001406  6700 00A0                643          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
0000140A                           644          
0000140A  0C46 0038                645          CMPI    #%0000000000111000,D6
0000140E  6700 0046                646          BEQ     TWOWORDLEA          * it's not LEA, we dont know what it is
00001412                           647          
00001412                           648          * check to make sure it is a supported mode and size
00001412                           649          
00001412  43F9 00001E48            650          LEA     LEAOP,A1
00001418  103C 000E                651          MOVE.B  #14,D0          * Print LEA
0000141C  4E4F                     652          TRAP    #15
0000141E                           653          
0000141E  0882 0007                654          BCLR    #7,D2
00001422  0882 0008                655          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001426                           656          
00001426  43F9 00001EA9            657          LEA     SPACE,A1
0000142C  103C 000E                658          MOVE.B  #14,D0          * Print SPACE
00001430  4E4F                     659          TRAP    #15
00001432                           660          
00001432  6100 0322                661          BSR     EAHELPER05
00001436                           662          
00001436  43F9 00001EAF            663          LEA     COMMA,A1
0000143C  103C 000E                664          MOVE.B  #14,D0          * Print COMMA
00001440  4E4F                     665          TRAP    #15
00001442                           666          
00001442  6100 02D0                667          BSR     EAHELPER611
00001446                           668          
00001446  43F9 00001E20            669          LEA     NEWLINE,A1
0000144C  103C 000E                670          MOVE.B  #14,D0          * Start a new line
00001450  4E4F                     671          TRAP    #15
00001452                           672          
00001452                           673          
00001452                           674          * call EA helper
00001452                           675          * MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001452                           676                  
00001452  6000 0058                677          BRA     DONE0100          * we already found instruction, next iteration
00001456                           678          
00001456                           679  TWOWORDLEA
00001456                           680  
00001456  43F9 00001E48            681          LEA     LEAOP,A1
0000145C  103C 000E                682          MOVE.B  #14,D0   * Print LEA
00001460  4E4F                     683          TRAP    #15
00001462                           684          
00001462  43F9 00001EA9            685          LEA     SPACE,A1
00001468  103C 000E                686          MOVE.B  #14,D0   * Print SPACE
0000146C  4E4F                     687          TRAP    #15
0000146E                           688  
0000146E  321A                     689          MOVE.W  (A2)+,D1
00001470                           690          
00001470  7C00                     691          MOVE.L  #0,D6
00001472  7E0F                     692          MOVE.L  #15,D7
00001474                           693          
00001474  6100 0966                694          BSR     BITMASK
00001478                           695          
00001478  C286                     696          AND.L   D6,D1   * shave off bad info
0000147A                           697          
0000147A  103C 0003                698          MOVE.B  #3,D0   * Print the address which was the source
0000147E  4E4F                     699          TRAP    #15
00001480                           700          
00001480  43F9 00001EAF            701          LEA     COMMA,A1
00001486  103C 000E                702          MOVE.B  #14,D0  * Print COMMA
0000148A  4E4F                     703          TRAP    #15
0000148C                           704          
0000148C  0882 0007                705          BCLR    #7,D2
00001490  0882 0008                706          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
00001494                           707          
00001494  6100 027E                708          BSR     EAHELPER611
00001498                           709          
00001498  43F9 00001E20            710          LEA     NEWLINE,A1
0000149E  103C 000E                711          MOVE.B  #14,D0          * Start a new line
000014A2  4E4F                     712          TRAP    #15
000014A4                           713          
000014A4  6000 0006                714          BRA     DONE0100
000014A8                           715          
000014A8                           716  UNKNOWN0100 *dont know what it is
000014A8  6100 06C8                717          BSR     UNKNOWNOP
000014AC                           718          
000014AC                           719  DONE0100
000014AC  4C9F 0303                720          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000014B0  4E75                     721          RTS
000014B2                           722          
000014B2  6000 FC90                723          BRA     ITERATION
000014B6                           724  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014B6                           725  *-----------------------------------------------------------------------------        
000014B6                           726          
000014B6                           727          
000014B6                           728  
000014B6                           729  *-----------------------------------------------------------------------------
000014B6                           730  *-----------------------------------------------------------------------------
000014B6                           731  * NAME: OP_0101   (SUBQ)
000014B6                           732  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000014B6                           733  * PRE-CONDITION:  xyz
000014B6                           734  * POST-CONDITION: All registers return to their previous state, and the output
000014B6                           735  *                 goes to the output console for reading the raw data or the
000014B6                           736  *                 actual instruction.
000014B6                           737  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000014B6                           738  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014B6                           739  OP0101
000014B6  48A7 FFC0                740          MOVEM   D0-D7/A0-A1,-(A7) * Push values to the stack to save
000014BA                           741  
000014BA  CC7C 0100                742          AND     #%0000000100000000, D6  * Baby-Bitmask for the 8th digit.
000014BE  0C46 0100                743          CMPI    #%0000000100000000, D6  * Is the 8th digit a 1?
000014C2  6700 005A                744          BEQ     UNKNOWN0101             * If so, unknown op
000014C6                           745        
000014C6  0C46 0100                746          CMPI    #%0000000100000000, D6  * Is the size 11, an unsupported value?
000014CA  6700 0052                747          BEQ     UNKNOWN0101             * If so, unknown op
000014CE                           748            
000014CE                           749          * Verified SUBQ at this point
000014CE  43F9 00001E43            750          LEA     SUBQOP,A1           * Print out SUBQ
000014D4  103C 000E                751          MOVE.B  #14,D0              * Trap #14 to print out
000014D8  4E4F                     752          TRAP    #15                 * Perform Trap #14
000014DA                           753                          
000014DA  6100 05D0                754          BSR     SIZE67              * Print out size
000014DE                           755          
000014DE  43F9 00001EAD            756          LEA     IMD,A1              * Formatting
000014E4  103C 000E                757          MOVE.B  #14,D0              * Trap #14 prints out space
000014E8  4E4F                     758          TRAP    #15                 * Perform Trap #14
000014EA                           759          
000014EA  3C3C 0009                760          MOVE.W  #9, D6              * Prep lower value for bitmask
000014EE  3E3C 000B                761          MOVE.W  #11,D7              * Prep upper value for bitmask
000014F2  6100 08E8                762          BSR     BITMASK             * Finalize bitmask setup
000014F6  CC42                     763          AND     D2,D6               * Apply bitmask
000014F8                           764          
000014F8  6100 0830                765          BSR     PRINTDATA911        * Special op for immediate in bits 9->11
000014FC                           766            
000014FC  43F9 00001EAF            767          LEA     COMMA,A1            * Formatting
00001502  103C 000E                768          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001506  4E4F                     769          TRAP    #15                 * Perform Trap #14
00001508                           770          
00001508  6100 024C                771          BSR     EAHELPER05          * Print out the Effective Address
0000150C                           772          
0000150C  43F9 00001E20            773          LEA     NEWLINE,A1          * Formatting
00001512  103C 000E                774          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001516  4E4F                     775          TRAP    #15                 * Perform Trap #14
00001518                           776          
00001518  4C9F 03FF                777          MOVEM   (A7)+,D0-D7/A0-A1   * Pop off the stack to return our registers
0000151C  4E75                     778          RTS
0000151E                           779      
0000151E                           780  UNKNOWN0101
0000151E  6100 0652                781          BSR     UNKNOWNOP
00001522  4E75                     782          RTS
00001524                           783  
00001524                           784  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001524                           785  *-----------------------------------------------------------------------------
00001524                           786  
00001524                           787  
00001524                           788  
00001524                           789  *-----------------------------------------------------------------------------
00001524                           790  *-----------------------------------------------------------------------------
00001524                           791  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
00001524                           792  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001524                           793  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
00001524                           794  *                 in the instruction and determines what the bits match to a
00001524                           795  *                 given condition code. If the 8 bit offset is $00, or $FF,
00001524                           796  *                 this signifies a word or long offset (for $00 and $FF
00001524                           797  *                 respectively). The 8 bit offset is in 2's comp. form, and
00001524                           798  *                 should be un-done, then plus or minus to the current
00001524                           799  *                 program counter (PC) to get the actual memory label to
00001524                           800  *                 output to console. The word offset signal eats an
00001524                           801  *                 additional 16 bits and the long offset eats an additional
00001524                           802  *                 32 bits. The word/long offset are for memory alignment.
00001524                           803  * POST-CONDITION: All registers return to their previous state, and the output
00001524                           804  *                 goes to the output console for reading the raw data or the
00001524                           805  *                 actual instruction.
00001524                           806  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001524                           807  *                 A1 (output)
00001524                           808  * CONDITIONS TABLE:
00001524                           809  *                Condition Names  - Mnemonic - Condition Code
00001524                           810  *                --------------------------------------------
00001524                           811  *                True             -    T     - 0000
00001524                           812  *                False            -    F     - 0001
00001524                           813  *                Higher           -    HI    - 0010
00001524                           814  *                Lower or Same    -    LS    - 0011
00001524                           815  *                Carry Clear      -    CC    - 0100
00001524                           816  *                Carry Set        -    CS    - 0101
00001524                           817  *                Not Equal        -    NE    - 0110
00001524                           818  *                Equal            -    EQ    - 0111
00001524                           819  *                Overflow Clear   -    VC    - 1000
00001524                           820  *                Overflow Set     -    VS    - 1001
00001524                           821  *                Plus             -    PL    - 1010
00001524                           822  *                Minus            -    MI    - 1011
00001524                           823  *                Greater or Equal -    GE    - 1100
00001524                           824  *                Less Than        -    LT    - 1101
00001524                           825  *                Greater Than     -    GT    - 1110
00001524                           826  *                Less or Equal    -    LE    - 1111
00001524                           827  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001524                           828  OP0110
00001524  48A7 C0C0                829          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
00001528                           830          
00001528                           831          * Ready four bits to help distinguish op's with the 0110 prefix
00001528  3C3C 0000                832          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
0000152C                           833                                        * BITMASK sub-routine call)
0000152C  3E3C 0007                834          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001530                           835                                        * BITMASK sub-routine call)
00001530                           836                                        
00001530                           837          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001530  6100 08AA                838          BSR     BITMASK               * Call BITMASK sub-routine
00001534                           839                                        * Returns a bitmask in D6
00001534                           840          
00001534  CC42                     841          AND     D2,D6                 * And the index op, which was pre-loaded
00001536                           842                                        * in the main memory loop with the bitmask
00001536                           843                                        * to use to determine what case we need.
00001536                           844          
00001536                           845          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
00001536                           846          * $00 == word offset, $FF == long offset
00001536                           847       ***CMPI    #%0000000000000000,D6
00001536                           848       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
00001536                           849       ***
00001536                           850       ***CMPI    #%0000000011111111,D6
00001536                           851       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
00001536                           852          
00001536                           853          * IF PASSED BOTH CMPI CHECKS (ABOVE),
00001536                           854          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
00001536                           855          
00001536  3C3C 0009                856          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
0000153A  3E3C 000B                857          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
0000153E                           858                                        
0000153E                           859          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
0000153E  6100 089C                860          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
00001542  CC42                     861          AND     D2,D6   * apply the BITMASK
00001544                           862          
00001544                           863          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001544  0C46 0400                864          CMPI    #%0000010000000000,D6
00001548  6700 002A                865          BEQ     OP_BCC
0000154C                           866          
0000154C                           867          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
0000154C  0C46 0500                868          CMPI    #%0000010100000000,D6
00001550  6700 002C                869          BEQ     OP_BCS
00001554                           870          
00001554                           871          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001554  0C46 0C00                872          CMPI    #%0000110000000000,D6
00001558  6700 002E                873          BEQ     OP_BGE
0000155C                           874          
0000155C                           875          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
0000155C  0C46 0D00                876          CMPI    #%0000110100000000,D6
00001560  6700 0030                877          BEQ     OP_BLT
00001564                           878          
00001564                           879          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
00001564  0C46 0800                880          CMPI    #%0000100000000000,D6
00001568  6700 0032                881          BEQ     OP_BVC
0000156C                           882          
0000156C                           883          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
0000156C                           884          * NOTE: A branch to the immediately following instruction automatically
0000156C                           885          *       uses the 16-bit displacement format because the 8-bit displacement
0000156C                           886          *       field contains $00 zero offset
0000156C                           887          * http://68k.hax.com/BRA
0000156C                           888          * NOTE2 ---> Does this mean, there should be no checks when debugging
0000156C                           889          *            for word/long offsets?
0000156C  0C46 0000                890          CMPI    #%0000000000000000,D6
00001570  6700 0034                891          BEQ     OP_BRA
00001574                           892          
00001574                           893          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
00001574                           894          ; call raw data print out sub routine
00001574                           895  
00001574                           896  OP_BCC
00001574  43F9 00001E6B            897          LEA     OP_BCC_MSG,A1
0000157A  6000 0034                898          BRA     OP_BRANCHES_PRINT
0000157E                           899  OP_BCS
0000157E  43F9 00001E70            900          LEA     OP_BCS_MSG,A1
00001584  6000 002A                901          BRA     OP_BRANCHES_PRINT
00001588                           902  OP_BGE
00001588  43F9 00001E75            903          LEA     OP_BGE_MSG,A1
0000158E  6000 0020                904          BRA     OP_BRANCHES_PRINT
00001592                           905  OP_BLT
00001592  43F9 00001E7A            906          LEA     OP_BLT_MSG,A1
00001598  6000 0016                907          BRA     OP_BRANCHES_PRINT
0000159C                           908  OP_BVC
0000159C  43F9 00001E7F            909          LEA     OP_BVC_MSG,A1
000015A2  6000 000C                910          BRA     OP_BRANCHES_PRINT
000015A6                           911  OP_BRA
000015A6  43F9 00001E84            912          LEA     OP_BRA_MSG,A1
000015AC  6000 0002                913          BRA     OP_BRANCHES_PRINT
000015B0                           914  
000015B0                           915  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000015B0                           916          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000015B0                           917          * assemble output to console
000015B0                           918  OP_BRANCHES_PRINT
000015B0  103C 000E                919          MOVE.B  #14,D0 * print instruction op
000015B4  4E4F                     920          TRAP    #15
000015B6                           921          
000015B6  43F9 00001E63            922          LEA     DATA,A1
000015BC  103C 000E                923          MOVE.B  #14,D0 * print raw data hex of the LABEL
000015C0  4E4F                     924          TRAP    #15
000015C2                           925          
000015C2  1A1A                     926          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
000015C4  2845                     927          MOVE.L  D5,A4 * ready the 8bits into a4
000015C6  43D4                     928          LEA     (A4),A1 * ready the a4 into a1 for print
000015C8  103C 000E                929          MOVE.B  #14,D0 * print the 8bit addr
000015CC  4E4F                     930          TRAP    #15
000015CE                           931  
000015CE  6000 0002                932          BRA     BCC_END
000015D2                           933  
000015D2                           934  BCC_END * reload the memory, call RTS
000015D2  4C9F 0303                935          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000015D6  4E75                     936          RTS
000015D8                           937  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015D8                           938  *-----------------------------------------------------------------------------
000015D8                           939  
000015D8                           940  
000015D8                           941  
000015D8                           942  *-----------------------------------------------------------------------------
000015D8                           943  *-----------------------------------------------------------------------------
000015D8                           944  * NAME: OP_0111   ()
000015D8                           945  * DESCRIPTION:    OP code 0111 is not supported. 
000015D8                           946  * PRE-CONDITION:  
000015D8                           947  * POST-CONDITION: 
000015D8                           948  * REGISTERS:
000015D8                           949  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015D8                           950  OP0111
000015D8  6100 0598                951      BSR     UNKNOWNOP
000015DC  4E75                     952      RTS
000015DE                           953  
000015DE                           954  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015DE                           955  *-----------------------------------------------------------------------------
000015DE                           956  
000015DE                           957  
000015DE                           958  
000015DE                           959  *-----------------------------------------------------------------------------
000015DE                           960  *-----------------------------------------------------------------------------
000015DE                           961  * NAME: OP_1000   (DIVS, OR)
000015DE                           962  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015DE                           963  * PRE-CONDITION:  xyz
000015DE                           964  * POST-CONDITION: All registers return to their previous state, and the output
000015DE                           965  *                 goes to the output console for reading the raw data or the
000015DE                           966  *                 actual instruction.
000015DE                           967  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015DE                           968  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015DE                           969  OP1000
000015DE                           970          * Saving values to the stack
000015DE  48A7 FFC0                971          MOVEM   D0-D7/A0-A1,-(A7)
000015E2                           972  
000015E2                           973          * Check if the EA Mode is 001 since both DIVS and OR do not support it
000015E2  3C3C 0003                974          MOVE.W  #3, D6              * Prep lower value for bitmask
000015E6  3E3C 0005                975          MOVE.W  #5, D7              * Prep upper value for bitmask
000015EA  6100 07F0                976          BSR     BITMASK             * Finalize bitmask setup
000015EE  CC42                     977          AND     D2,D6               * Apply bitmask
000015F0                           978          
000015F0  0C46 0008                979          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
000015F4  6700 057C                980          BEQ     UNKNOWNOP                 * If so, the op is not supported
000015F8                           981          
000015F8                           982          * Checking for DIVS
000015F8  3C3C 0006                983          MOVE.W  #6, D6              * Prep lower value for bitmask
000015FC  3E3C 0008                984          MOVE.W  #8, D7              * Prep upper value for bitmask
00001600  6100 07DA                985          BSR     BITMASK             * Finalize bitmask setup
00001604  CC42                     986          AND     D2,D6               * Apply bitmask
00001606                           987          
00001606  0C46 01C0                988          CMPI    #%0000000111000000, D6  * Are we DIVS?
0000160A  6600 0050                989          BNE     NOTDIVS                 * If not, branch to see if it's OR
0000160E                           990          
0000160E  43F9 00001E23            991          LEA     DIVSOP,A1           * We found DIVS
00001614  103C 000E                992          MOVE.B  #14,D0              * Trap #14 prints out the data
00001618  4E4F                     993          TRAP    #15                 * Perform Trap #14
0000161A                           994          
0000161A  43F9 00001EA9            995          LEA     SPACE,A1            * formatting
00001620  103C 000E                996          MOVE.B  #14,D0              * Trap #14 prints out space
00001624  4E4F                     997          TRAP    #15                 * Perform Trap #14
00001626                           998          
00001626  4243                     999          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
00001628  08C3 0000               1000          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
0000162C                          1001                                      * to indicate a potential immediate of size word
0000162C                          1002          
0000162C  6100 0128               1003          BSR     EAHELPER05          * Print out data. TODO: DOESN'T WORK.
00001630                          1004  
00001630  43F9 00001EAF           1005          LEA     COMMA,A1            * formatting
00001636  103C 000E               1006          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000163A  4E4F                    1007          TRAP    #15                 * Perform Trap #14
0000163C                          1008          
0000163C                          1009          * bit manipulation is needed to make the outlier DIVS work
0000163C                          1010          * with the generic EAHELPER611
0000163C  0882 0006               1011          BCLR    #6,D2
00001640  0882 0007               1012          BCLR    #7,D2
00001644  0882 0008               1013          BCLR    #8,D2
00001648                          1014          
00001648                          1015          * the above bits were cleared so that eahelper05 knows the destination
00001648                          1016          * is a data register.
00001648                          1017          
00001648  6100 00CA               1018          BSR     EAHELPER611 
0000164C                          1019  
0000164C  43F9 00001E20           1020          LEA     NEWLINE,A1          * We found DIVS
00001652  103C 000E               1021          MOVE.B  #14,D0              * Trap #14 prints out the data
00001656  4E4F                    1022          TRAP    #15                 * Perform Trap #14
00001658                          1023          
00001658  6000 0012               1024          BRA     OP1000END
0000165C                          1025          
0000165C                          1026  NOTDIVS * It is confirmed OR at this point
0000165C  43F9 00001E57           1027          LEA     OROP,A1         * We found OR
00001662  103C 000E               1028          MOVE.B  #14,D0          * Trap #14 prints out the data
00001666  4E4F                    1029          TRAP    #15             * Perform Trap #14
00001668                          1030          *================================================================
00001668                          1031          * todo, move the size of the operation into the leading bits of D5
00001668                          1032          * before subroutine call
00001668  6100 00AA               1033          BSR     EAHELPER611
0000166C                          1034  
0000166C                          1035  OP1000END
0000166C  4C9F 03FF               1036          MOVEM   (A7)+,D0-D7/A0-A1
00001670  4E75                    1037          RTS
00001672                          1038  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001672                          1039  *-----------------------------------------------------------------------------
00001672                          1040  
00001672                          1041  
00001672                          1042  
00001672                          1043  *-----------------------------------------------------------------------------
00001672                          1044  *-----------------------------------------------------------------------------
00001672                          1045  * NAME: OP_1001   (SUB)
00001672                          1046  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001672                          1047  * PRE-CONDITION:  xyz
00001672                          1048  * POST-CONDITION: All registers return to their previous state, and the output
00001672                          1049  *                 goes to the output console for reading the raw data or the
00001672                          1050  *                 actual instruction.
00001672                          1051  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001672                          1052  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001672                          1053  OP1001
00001672                          1054  
00001672                          1055  
00001672                          1056  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001672                          1057  *-----------------------------------------------------------------------------
00001672                          1058  
00001672                          1059  
00001672                          1060  
00001672                          1061  *-----------------------------------------------------------------------------
00001672                          1062  *-----------------------------------------------------------------------------
00001672                          1063  * NAME: OP_1010   ()
00001672                          1064  * DESCRIPTION:    a
00001672                          1065  * PRE-CONDITION:  b
00001672                          1066  * POST-CONDITION: c
00001672                          1067  * REGISTERS:      d
00001672                          1068  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001672                          1069  OP1010
00001672                          1070  
00001672  6100 04FE               1071      BSR     UNKNOWNOP
00001676  4E75                    1072      RTS
00001678                          1073  
00001678                          1074  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001678                          1075  *-----------------------------------------------------------------------------
00001678                          1076  
00001678                          1077  
00001678                          1078  
00001678                          1079  *-----------------------------------------------------------------------------
00001678                          1080  *-----------------------------------------------------------------------------
00001678                          1081  * NAME: OP_1011   (EOR, CMP)
00001678                          1082  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001678                          1083  * PRE-CONDITION:  xyz
00001678                          1084  * POST-CONDITION: All registers return to their previous state, and the output
00001678                          1085  *                 goes to the output console for reading the raw data or the
00001678                          1086  *                 actual instruction.
00001678                          1087  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001678                          1088  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001678                          1089  OP1011
00001678                          1090  
00001678  6100 04F8               1091      BSR     UNKNOWNOP
0000167C  4E75                    1092      RTS
0000167E                          1093  
0000167E                          1094  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000167E                          1095  *-----------------------------------------------------------------------------
0000167E                          1096  
0000167E                          1097  
0000167E                          1098  
0000167E                          1099  *-----------------------------------------------------------------------------
0000167E                          1100  *-----------------------------------------------------------------------------
0000167E                          1101  * NAME: OP_1100   (MULS)
0000167E                          1102  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000167E                          1103  * PRE-CONDITION:  xyz
0000167E                          1104  * POST-CONDITION: All registers return to their previous state, and the output
0000167E                          1105  *                 goes to the output console for reading the raw data or the
0000167E                          1106  *                 actual instruction.
0000167E                          1107  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000167E                          1108  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000167E                          1109  OP1100
0000167E  48A7 FFC0               1110          MOVEM   D0-D7/A0-A1,-(A7)   * Saving values to the stack
00001682                          1111  
00001682                          1112          * Check if the EA Mode is 001 since MULS does not support it
00001682  3C3C 0003               1113          MOVE.W  #3, D6              * Prep lower value for bitmask
00001686  3E3C 0005               1114          MOVE.W  #5, D7              * Prep upper value for bitmask
0000168A  6100 0750               1115          BSR     BITMASK             * Finalize bitmask setup
0000168E  CC42                    1116          AND     D2,D6               * Apply bitmask
00001690                          1117          
00001690  0C46 0008               1118          CMPI    #%0000000000001000, D6    * Is the mode 001, an unsupported mode?
00001694  6700 0068               1119          BEQ     UNKNOWN1100               * If so, the op is not supported
00001698                          1120          
00001698  3C3C 0006               1121          MOVE.W  #6, D6              * Prep lower value for bitmask
0000169C  3E3C 0008               1122          MOVE.W  #8, D7              * Prep upper value for bitmask
000016A0  6100 073A               1123          BSR     BITMASK             * Finalize bitmask setup
000016A4  CC42                    1124          AND     D2,D6               * Apply bitmask
000016A6                          1125          
000016A6  0C46 01C0               1126          CMPI    #%0000000111000000, D6  * Are we MULS?
000016AA  6600 0052               1127          BNE     UNKNOWN1100             * If not, it is an unknown op
000016AE                          1128          
000016AE  43F9 00001E52           1129          LEA     MULSOP,A1           * We found MULS
000016B4  103C 000E               1130          MOVE.B  #14,D0              * Trap #14 prints out the data
000016B8  4E4F                    1131          TRAP    #15                 * Perform Trap #14
000016BA                          1132          
000016BA  43F9 00001EA9           1133          LEA     SPACE,A1            * formatting
000016C0  103C 000E               1134          MOVE.B  #14,D0              * Trap #14 prints out space
000016C4  4E4F                    1135          TRAP    #15                 * Perform Trap #14
000016C6                          1136          
000016C6  4243                    1137          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000016C8  08C3 0000               1138          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000016CC                          1139                                      * to indicate a potential immediate of size word
000016CC                          1140          
000016CC  6100 0088               1141          BSR     EAHELPER05          * Print out data
000016D0                          1142  
000016D0  43F9 00001EAF           1143          LEA     COMMA,A1            * formatting
000016D6  103C 000E               1144          MOVE.B  #14,D0              * Trap #14 prints out a comma
000016DA  4E4F                    1145          TRAP    #15                 * Perform Trap #14
000016DC                          1146          
000016DC  0882 0006               1147          BCLR    #6,D2               * Bit manipulation is 
000016E0  0882 0007               1148          BCLR    #7,D2               * necessary in order to make
000016E4  0882 0008               1149          BCLR    #8,D2               * EAHELPER611 work, generically
000016E8                          1150          
000016E8  6100 002A               1151          BSR     EAHELPER611         * Print out EA
000016EC                          1152  
000016EC  43F9 00001E20           1153          LEA     NEWLINE,A1          * Formatting
000016F2  103C 000E               1154          MOVE.B  #14,D0              * Trap #14 prints out the data
000016F6  4E4F                    1155          TRAP    #15                 * Perform Trap #14
000016F8                          1156          
000016F8  4C9F 03FF               1157          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
000016FC  4E75                    1158          RTS
000016FE                          1159          
000016FE                          1160  UNKNOWN1100
000016FE  6100 0472               1161          BSR     UNKNOWNOP
00001702                          1162          
00001702                          1163  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001702                          1164  *-----------------------------------------------------------------------------
00001702                          1165  
00001702                          1166  
00001702                          1167  
00001702                          1168  *-----------------------------------------------------------------------------
00001702                          1169  *-----------------------------------------------------------------------------
00001702                          1170  * NAME: OP_1101   (ADD, ADDA)
00001702                          1171  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001702                          1172  * PRE-CONDITION:  xyz
00001702                          1173  * POST-CONDITION: All registers return to their previous state, and the output
00001702                          1174  *                 goes to the output console for reading the raw data or the
00001702                          1175  *                 actual instruction.
00001702                          1176  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001702                          1177  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001702                          1178  OP1101
00001702                          1179  
00001702  6100 046E               1180      BSR     UNKNOWNOP
00001706  4E75                    1181      RTS
00001708                          1182  
00001708                          1183  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001708                          1184  *-----------------------------------------------------------------------------
00001708                          1185  
00001708                          1186  
00001708                          1187  
00001708                          1188  *-----------------------------------------------------------------------------
00001708                          1189  *-----------------------------------------------------------------------------
00001708                          1190  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
00001708                          1191  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001708                          1192  * PRE-CONDITION:  xyz
00001708                          1193  * POST-CONDITION: All registers return to their previous state, and the output
00001708                          1194  *                 goes to the output console for reading the raw data or the
00001708                          1195  *                 actual instruction.
00001708                          1196  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001708                          1197  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001708                          1198  OP1110
00001708                          1199  
00001708  6100 0468               1200      BSR     UNKNOWNOP
0000170C  4E75                    1201      RTS
0000170E                          1202  
0000170E                          1203  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000170E                          1204  *-----------------------------------------------------------------------------
0000170E                          1205  
0000170E                          1206  
0000170E                          1207  
0000170E                          1208  *-----------------------------------------------------------------------------
0000170E                          1209  *-----------------------------------------------------------------------------
0000170E                          1210  * NAME: OP_1111   ()
0000170E                          1211  * DESCRIPTION:    a
0000170E                          1212  * PRE-CONDITION:  b
0000170E                          1213  * POST-CONDITION: c
0000170E                          1214  * REGISTERS:      d
0000170E                          1215  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000170E                          1216  OP1111
0000170E                          1217  
0000170E  6100 0462               1218      BSR     UNKNOWNOP
00001712  4E75                    1219      RTS
00001714                          1220  
00001714                          1221  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001714                          1222  *-----------------------------------------------------------------------------
00001714                          1223  
00001714                          1224  
00001714                          1225  
00001714                          1226  *-----------------------------------------------------------------------------
00001714                          1227  *-----------------------------------------------------------------------------
00001714                          1228  * NAME:           EAHELPER611
00001714                          1229  * DESCRIPTION:    a
00001714                          1230  * PRE-CONDITION:  D2 contains the instruction to print modes for.
00001714                          1231  *                 D5 contains the size of the data to be printed
00001714                          1232  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
00001714                          1233  *                 EAHELPER05 to print.
00001714                          1234  * REGISTERS:      a
00001714                          1235  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001714                          1236  EAHELPER611
00001714  48A7 FFC0               1237      MOVEM  D0-D7/A0-A1,-(A7)    * Push values onto stack
00001718                          1238      
00001718  3C3C 0006               1239      MOVE.W  #6, D6              * Prep lower value for bitmask
0000171C  3E3C 0008               1240      MOVE.W  #8, D7              * Prep upper value for bitmask
00001720  6100 06BA               1241      BSR     BITMASK             * Finalize bitmask setup
00001724  CC42                    1242      AND     D2,D6               * Apply bitmask
00001726                          1243      
00001726                          1244      * to move the mode where EAHELPER50 can process it
00001726  7C06                    1245      MOVE.L  #6,D6       * Prep lower value of bitmask
00001728  7E08                    1246      MOVE.L  #8,D7       * Prep upper value of bitmask
0000172A  6100 06B0               1247      BSR     BITMASK     * Create bitmask
0000172E  CC42                    1248      AND     D2,D6       * Apply bitmask
00001730                          1249      
00001730  4243                    1250      CLR     D3      * prep D3 to store values
00001732  3606                    1251      MOVE.W  D6,D3   * store bitmasked value in D3
00001734  E64B                    1252      LSR     #3,D3   * move bits 6-8 to 3-5
00001736                          1253      
00001736                          1254      * to move the register where EAHELPER50 can process it
00001736  7C09                    1255      MOVE.L  #9,D6   * Prep lower value for bitmask
00001738  7E0B                    1256      MOVE.L  #11,D7  * Prep upper value for bitmask
0000173A  6100 06A0               1257      BSR     BITMASK * create bitmask
0000173E  CC42                    1258      AND     D2,D6   * apply bitmask
00001740                          1259      
00001740  4244                    1260      CLR     D4      * prep D3 to store values
00001742  3806                    1261      MOVE.W  D6,D4   * store bitmasked value in D3
00001744                          1262      
00001744  E04C                    1263      LSR     #8,D4   * move bits 9-11 to 0-2
00001746  E24C                    1264      LSR     #1,D4   * move bits 9-11 to 0-2
00001748                          1265    
00001748  8684                    1266      OR.L    D4,D3   * combind the register and mode
0000174A  2403                    1267      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
0000174C                          1268      
0000174C  6100 0008               1269      BSR     EAHELPER05
00001750                          1270      
00001750                          1271  ENDEAHELPER611
00001750                          1272      
00001750  4C9F 03FF               1273      MOVEM  (A7)+,D0-D7/A0-A1    * Revert back
00001754  4E75                    1274      RTS
00001756                          1275  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001756                          1276  *-----------------------------------------------------------------------------
00001756                          1277  
00001756                          1278  
00001756                          1279  
00001756                          1280  *-----------------------------------------------------------------------------
00001756                          1281  *-----------------------------------------------------------------------------
00001756                          1282  * NAME:           EAHELPER05
00001756                          1283  * DESCRIPTION:    a
00001756                          1284  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
00001756                          1285  *                 this sub-routine helper for operations that only have one
00001756                          1286  *                 mode register.
00001756                          1287  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
00001756                          1288  * REGISTERS:      a
00001756                          1289  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001756                          1290  EAHELPER05
00001756                          1291      * todo: add code for printing immediate values
00001756                          1292      
00001756  48A7 FFC0               1293      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
0000175A                          1294      
0000175A  7C03                    1295      MOVE.L  #3,D6
0000175C  7E05                    1296      MOVE.L  #5,D7
0000175E                          1297      
0000175E  6100 067C               1298      BSR     BITMASK * generate a bitmask to identify the mode
00001762                          1299      
00001762  CC42                    1300      AND     D2,D6   * mask off the parts of D2 we don't need
00001764                          1301      
00001764  2A06                    1302      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
00001766                          1303      
00001766  0C46 0000               1304      CMPI    #%0000000000000000,D6 * is it data register direct?
0000176A  6600 000A               1305      BNE     NOTDATAREG
0000176E                          1306      
0000176E  6100 013C               1307      BSR     MODE_DN
00001772                          1308       
00001772  6000 0132               1309      BRA     ENDEAHELPER05
00001776                          1310      
00001776                          1311  NOTDATAREG * address register direct
00001776                          1312      
00001776  0C46 0008               1313      CMPI    #%0000000000001000,D6 * is it address register direct?
0000177A  6600 000A               1314      BNE     NOTADRDIRECT
0000177E                          1315      
0000177E  6100 022C               1316      BSR     MODE_AN * simply prints out the address register
00001782                          1317       
00001782  6000 0122               1318      BRA     ENDEAHELPER05
00001786                          1319      
00001786                          1320  NOTADRDIRECT * address register indirect
00001786                          1321          
00001786  0C46 0010               1322      CMPI    #%0000000000010000,D6 * is it address register indirect?
0000178A  6600 0022               1323      BNE     NOTADRINDIRECT
0000178E                          1324      
0000178E  43F9 00001EB1           1325      LEA     OBRACK,A1       * Load '('
00001794  303C 000E               1326      MOVE.W  #14,D0          * Trap #14 to display message
00001798  4E4F                    1327      TRAP    #15             * Perform #14
0000179A                          1328          
0000179A                          1329  
0000179A  6100 0210               1330      BSR     MODE_AN * print out an address register
0000179E                          1331      
0000179E  43F9 00001EB3           1332      LEA     CBRACK,A1       * Load ')'
000017A4  303C 000E               1333      MOVE.W  #14,D0          * Trap #14 to display message
000017A8  4E4F                    1334      TRAP    #15             * Perform #14
000017AA                          1335       
000017AA  6000 00FA               1336      BRA     ENDEAHELPER05
000017AE                          1337      
000017AE                          1338  NOTADRINDIRECT * address register indirect, post increment
000017AE                          1339      
000017AE  0C46 0018               1340      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
000017B2  6600 002E               1341      BNE     NOTADRINDIRECTPOST
000017B6                          1342      
000017B6  43F9 00001EB1           1343      LEA     OBRACK,A1       * Load '('
000017BC  303C 000E               1344      MOVE.W  #14,D0          * Trap #14 to display message
000017C0  4E4F                    1345      TRAP    #15             * Perform #14
000017C2                          1346          
000017C2                          1347  
000017C2  6100 01E8               1348      BSR     MODE_AN * print out an address register
000017C6                          1349      
000017C6  43F9 00001EB3           1350      LEA     CBRACK,A1       * Load ')'
000017CC  303C 000E               1351      MOVE.W  #14,D0          * Trap #14 to display message
000017D0  4E4F                    1352      TRAP    #15             * Perform #14
000017D2                          1353      
000017D2  43F9 00001EB5           1354      LEA     PLUS,A1       * Load '+'
000017D8  303C 000E               1355      MOVE.W  #14,D0          * Trap #14 to display message
000017DC  4E4F                    1356      TRAP    #15             * Perform #14
000017DE                          1357       
000017DE  6000 00C6               1358      BRA     ENDEAHELPER05
000017E2                          1359      
000017E2                          1360  NOTADRINDIRECTPOST * address register indirect, pre decrement
000017E2                          1361      
000017E2  0C46 0020               1362      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
000017E6  6600 002E               1363      BNE     NOTADRINDIRECTPRE
000017EA                          1364      
000017EA  43F9 00001EB7           1365      LEA     MINUS,A1       * Load '-'
000017F0  303C 000E               1366      MOVE.W  #14,D0          * Trap #14 to display message
000017F4  4E4F                    1367      TRAP    #15             * Perform #14
000017F6                          1368      
000017F6  43F9 00001EB1           1369      LEA     OBRACK,A1       * Load '('
000017FC  303C 000E               1370      MOVE.W  #14,D0          * Trap #14 to display message
00001800  4E4F                    1371      TRAP    #15             * Perform #14
00001802                          1372          
00001802                          1373  
00001802  6100 01A8               1374      BSR     MODE_AN * print out an address register
00001806                          1375      
00001806  43F9 00001EB3           1376      LEA     CBRACK,A1       * Load ')'
0000180C  303C 000E               1377      MOVE.W  #14,D0          * Trap #14 to display message
00001810  4E4F                    1378      TRAP    #15             * Perform #14
00001812                          1379       
00001812  6000 0092               1380      BRA     ENDEAHELPER05
00001816                          1381  
00001816                          1382  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
00001816                          1383  
00001816  0C46 0038               1384      CMPI    #%0000000000111000,D6 * is it immediate?
0000181A  6600 0086               1385      BNE     NOTIMMEDIATE
0000181E                          1386  
0000181E  0C43 0001               1387      CMPI    #1,D3 * is it a byte?
00001822  6600 0028               1388      BNE     NOTIMMBYTE
00001826                          1389      
00001826  43F9 00001EAD           1390      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000182C  103C 000E               1391      MOVE.B  #14,D0
00001830  4E4F                    1392      TRAP    #15
00001832                          1393      
00001832  3C3C 0000               1394      MOVE.W  #0, D6              * Prep lower value for bitmask
00001836  3E3C 0007               1395      MOVE.W  #7, D7              * Prep upper value for bitmask
0000183A  6100 05A0               1396      BSR     BITMASK             * Finalize bitmask setup
0000183E                          1397          
0000183E  321A                    1398      MOVE.W  (A2)+,D1
00001840                          1399      
00001840  C286                    1400      AND.L     D6,D1
00001842                          1401          
00001842  103C 0003               1402      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001846  4E4F                    1403      TRAP    #15      * Perform Trap #3
00001848                          1404      
00001848  6000 005C               1405      BRA     ENDEAHELPER05
0000184C                          1406  
0000184C                          1407  NOTIMMBYTE
0000184C                          1408      
0000184C  0C43 0002               1409      CMPI    #2,D3 * is it a word?
00001850  6600 0028               1410      BNE     NOTIMMWORD
00001854                          1411      
00001854  43F9 00001EAD           1412      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000185A  103C 000E               1413      MOVE.B  #14,D0
0000185E  4E4F                    1414      TRAP    #15
00001860                          1415      
00001860  3C3C 0000               1416      MOVE.W  #0, D6              * Prep lower value for bitmask
00001864  3E3C 000F               1417      MOVE.W  #15, D7             * Prep upper value for bitmask
00001868  6100 0572               1418      BSR     BITMASK             * Finalize bitmask setup
0000186C                          1419          
0000186C  321A                    1420      MOVE.W  (A2)+,D1
0000186E                          1421      
0000186E  C286                    1422      AND.L     D6,D1               * Apply bitmask
00001870                          1423          
00001870  103C 0003               1424      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001874  4E4F                    1425      TRAP    #15      * Perform Trap #3
00001876                          1426      
00001876  6000 002E               1427      BRA     ENDEAHELPER05
0000187A                          1428      
0000187A                          1429  NOTIMMWORD
0000187A  0C43 0003               1430      CMPI    #3,D3 * is it a long?
0000187E  6600 0022               1431      BNE     NOTIMMEDIATE
00001882                          1432      
00001882  43F9 00001EAD           1433      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001888  103C 000E               1434      MOVE.B  #14,D0
0000188C  4E4F                    1435      TRAP    #15
0000188E                          1436          
0000188E  221A                    1437      MOVE.L  (A2)+,D1
00001890                          1438          
00001890  103C 0003               1439      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001894  4E4F                    1440      TRAP    #15      * Perform Trap #3
00001896                          1441      
00001896  321A                    1442      MOVE.W  (A2)+,D1
00001898                          1443          
00001898  103C 0003               1444      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000189C  4E4F                    1445      TRAP    #15      * Perform Trap #3
0000189E                          1446      
0000189E  6000 0006               1447      BRA     ENDEAHELPER05
000018A2                          1448  
000018A2                          1449  NOTIMMEDIATE    
000018A2                          1450  
000018A2                          1451  
000018A2  6100 02CE               1452      BSR     UNKNOWNOP
000018A6                          1453      
000018A6                          1454  ENDEAHELPER05
000018A6  4C9F 03FF               1455      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
000018AA  4E75                    1456      RTS
000018AC                          1457  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018AC                          1458  *-----------------------------------------------------------------------------
000018AC                          1459  
000018AC                          1460  
000018AC                          1461  
000018AC                          1462  *-----------------------------------------------------------------------------
000018AC                          1463  *-----------------------------------------------------------------------------
000018AC                          1464  * NAME:           MODE_DN
000018AC                          1465  * DESCRIPTION:    Generalize the EA part of the project.
000018AC                          1466  * PRE-CONDITION:  The mode must have been correctly identified. All modes
000018AC                          1467  *                 must be called by RTS.
000018AC                          1468  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
000018AC                          1469  *                 called it.
000018AC                          1470  * REGISTERS:      a
000018AC                          1471  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018AC                          1472  * ---> Dn
000018AC                          1473  MODE_DN
000018AC  48A7 FFC0               1474          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000018B0                          1475  
000018B0  3C3C 0000               1476          MOVE.W  #0, D6              * Prep lower value for bitmask
000018B4  3E3C 0002               1477          MOVE.W  #2, D7              * Prep upper value for bitmask
000018B8  6100 0522               1478          BSR     BITMASK             * Finalize bitmask setup
000018BC  CC42                    1479          AND     D2,D6               * Apply bitmask
000018BE                          1480          
000018BE  0C46 0000               1481          CMPI    #%000000000000000, D6   * Data Register D0?
000018C2  6600 000A               1482          BNE     NOTD0
000018C6                          1483          
000018C6  6100 0074               1484          BSR     PRINTD0
000018CA  6000 006A               1485          BRA     ENDMODE_DN
000018CE                          1486  NOTD0      
000018CE  0C46 0001               1487          CMPI    #%000000000000001, D6   * Data Register D1?
000018D2  6600 000A               1488          BNE     NOTD1
000018D6                          1489          
000018D6  6100 0072               1490          BSR     PRINTD1
000018DA  6000 005A               1491          BRA     ENDMODE_DN
000018DE                          1492  NOTD1
000018DE  0C46 0002               1493          CMPI    #%000000000000010, D6   * Data Register D2?
000018E2  6600 000A               1494          BNE     NOTD2
000018E6                          1495          
000018E6  6100 0070               1496          BSR     PRINTD2
000018EA  6000 004A               1497          BRA     ENDMODE_DN
000018EE                          1498  NOTD2
000018EE  0C46 0003               1499          CMPI    #%000000000000011, D6   * Data Register D3?
000018F2  6600 000A               1500          BNE     NOTD3
000018F6                          1501          
000018F6  6100 006E               1502          BSR     PRINTD3
000018FA  6000 003A               1503          BRA     ENDMODE_DN
000018FE                          1504  NOTD3
000018FE  0C46 0004               1505          CMPI    #%000000000000100, D6   * Data Register D4?
00001902  6600 000A               1506          BNE     NOTD4
00001906                          1507          
00001906  6100 006C               1508          BSR     PRINTD4
0000190A  6000 002A               1509          BRA     ENDMODE_DN
0000190E                          1510  NOTD4
0000190E  0C46 0005               1511          CMPI    #%000000000000101, D6   * Data Register D5?
00001912  6600 000A               1512          BNE     NOTD5
00001916                          1513          
00001916  6100 006A               1514          BSR     PRINTD5
0000191A  6000 001A               1515          BRA     ENDMODE_DN
0000191E                          1516  NOTD5
0000191E  0C46 0006               1517          CMPI    #%000000000000110, D6   * Data Register D6?
00001922  6600 000A               1518          BNE     NOTD6
00001926                          1519          
00001926  6100 0068               1520          BSR     PRINTD6
0000192A  6000 000A               1521          BRA     ENDMODE_DN
0000192E                          1522  NOTD6
0000192E  6100 006E               1523          BSR     PRINTD7
00001932  6000 0002               1524          BRA     ENDMODE_DN
00001936                          1525          
00001936                          1526  ENDMODE_DN
00001936  4C9F 03FF               1527          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
0000193A  4E75                    1528          RTS
0000193C                          1529  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000193C                          1530  *-----------------------------------------------------------------------------
0000193C                          1531  
0000193C                          1532  
0000193C                          1533  
0000193C                          1534  *-----------------------------------------------------------------------------
0000193C                          1535  *-----------------------------------------------------------------------------
0000193C                          1536  * NAME:           PRINTD0
0000193C                          1537  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
0000193C                          1538  * PRE-CONDITION:  a
0000193C                          1539  * POST-CONDITION: a
0000193C                          1540  * REGISTERS:      a
0000193C                          1541  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000193C                          1542  PRINTD0
0000193C  43F9 00001EDD           1543          LEA     __D0, A1        * Load 'D0'
00001942  103C 000E               1544          MOVE.B  #14, D0         * Load Trap #14 to print out
00001946  4E4F                    1545          TRAP    #15             * Perform Trap #14
00001948  4E75                    1546          RTS
0000194A                          1547  PRINTD1
0000194A  43F9 00001EE0           1548          LEA     __D1, A1        * Load 'D1'
00001950  103C 000E               1549          MOVE.B  #14, D0         * Load Trap #14 to print out
00001954  4E4F                    1550          TRAP    #15             * Perform Trap #14
00001956  4E75                    1551          RTS      
00001958                          1552  PRINTD2
00001958  43F9 00001EE3           1553          LEA     __D2, A1        * Load 'D2'
0000195E  103C 000E               1554          MOVE.B  #14, D0         * Load Trap #14 to print out
00001962  4E4F                    1555          TRAP    #15             * Perform Trap #14
00001964  4E75                    1556          RTS      
00001966                          1557  PRINTD3
00001966  43F9 00001EE6           1558          LEA     __D3, A1        * Load 'D3'
0000196C  103C 000E               1559          MOVE.B  #14, D0         * Load Trap #14 to print out
00001970  4E4F                    1560          TRAP    #15             * Perform Trap #14
00001972  4E75                    1561          RTS      
00001974                          1562  PRINTD4
00001974  43F9 00001EE9           1563          LEA     __D4, A1        * Load 'D4'
0000197A  103C 000E               1564          MOVE.B  #14, D0         * Load Trap #14 to print out
0000197E  4E4F                    1565          TRAP    #15             * Perform Trap #14
00001980  4E75                    1566          RTS       
00001982                          1567  PRINTD5
00001982  43F9 00001EEC           1568          LEA     __D5, A1        * Load 'D5'
00001988  103C 000E               1569          MOVE.B  #14, D0         * Load Trap #14 to print out
0000198C  4E4F                    1570          TRAP    #15             * Perform Trap #14
0000198E  4E75                    1571          RTS      
00001990                          1572  PRINTD6
00001990  43F9 00001EEF           1573          LEA     __D6, A1        * Load 'D6'
00001996  103C 000E               1574          MOVE.B  #14, D0         * Load Trap #14 to print out
0000199A  4E4F                    1575          TRAP    #15             * Perform Trap #14
0000199C  4E75                    1576          RTS
0000199E                          1577  PRINTD7
0000199E  43F9 00001EF2           1578          LEA     __D7, A1        * Load 'D7'
000019A4  103C 000E               1579          MOVE.B  #14, D0         * Load Trap #14 to print out
000019A8  4E4F                    1580          TRAP    #15             * Perform Trap #14
000019AA  4E75                    1581          RTS
000019AC                          1582  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019AC                          1583  *-----------------------------------------------------------------------------
000019AC                          1584  
000019AC                          1585  
000019AC                          1586  
000019AC                          1587  *-----------------------------------------------------------------------------
000019AC                          1588  *-----------------------------------------------------------------------------
000019AC                          1589  * NAME:           MODE_AN
000019AC                          1590  * DESCRIPTION:    Simply chooses to print A0-A7.
000019AC                          1591  * PRE-CONDITION:  a
000019AC                          1592  * POST-CONDITION: a
000019AC                          1593  * REGISTERS:      a
000019AC                          1594  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019AC                          1595  MODE_AN
000019AC  48A7 FFC0               1596          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
000019B0                          1597  
000019B0  3C3C 0000               1598          MOVE.W  #0, D6              * Prep lower value for bitmask
000019B4  3E3C 0002               1599          MOVE.W  #2, D7              * Prep upper value for bitmask
000019B8  6100 0422               1600          BSR     BITMASK             * Finalize bitmask setup
000019BC  CC42                    1601          AND     D2,D6               * Apply bitmask
000019BE                          1602          
000019BE  0C46 0000               1603          CMPI    #%000000000000000, D6   * Address Register A0?
000019C2  6600 000A               1604          BNE     NOTA0
000019C6                          1605          
000019C6  6100 0074               1606          BSR     PRINTA0
000019CA                          1607          
000019CA  6000 006A               1608          BRA     ENDMODE_AN
000019CE                          1609  NOTA0      
000019CE  0C46 0001               1610          CMPI    #%000000000000001, D6   * Address Register A1?
000019D2  6600 000A               1611          BNE     NOTA1
000019D6                          1612          
000019D6  6100 0072               1613          BSR     PRINTA1
000019DA                          1614          
000019DA  6000 005A               1615          BRA     ENDMODE_AN
000019DE                          1616  NOTA1
000019DE  0C46 0002               1617          CMPI    #%000000000000010, D6   * Address Register A2?
000019E2  6600 000A               1618          BNE     NOTA2
000019E6                          1619          
000019E6  6100 0070               1620          BSR     PRINTA2
000019EA                          1621          
000019EA  6000 004A               1622          BRA     ENDMODE_AN
000019EE                          1623  NOTA2
000019EE  0C46 0003               1624          CMPI    #%000000000000011, D6   * Address Register A3?
000019F2  6600 000A               1625          BNE     NOTA3
000019F6                          1626          
000019F6  6100 006E               1627          BSR     PRINTA3
000019FA                          1628          
000019FA  6000 003A               1629          BRA     ENDMODE_AN
000019FE                          1630  NOTA3
000019FE  0C46 0004               1631          CMPI    #%000000000000100, D6   * Address Register A4?
00001A02  6600 000A               1632          BNE     NOTA4
00001A06                          1633          
00001A06  6100 006C               1634          BSR     PRINTA4
00001A0A                          1635          
00001A0A  6000 002A               1636          BRA     ENDMODE_AN
00001A0E                          1637  NOTA4
00001A0E  0C46 0005               1638          CMPI    #%000000000000101, D6   * Address Register A5?
00001A12  6600 000A               1639          BNE     NOTA5
00001A16                          1640          
00001A16  6100 006A               1641          BSR     PRINTA5
00001A1A                          1642          
00001A1A  6000 001A               1643          BRA     ENDMODE_AN
00001A1E                          1644  NOTA5
00001A1E  0C46 0006               1645          CMPI    #%000000000000110, D6   * Address Register A6?
00001A22  6600 000A               1646          BNE     NOTA6
00001A26                          1647          
00001A26  6100 0068               1648          BSR     PRINTA6
00001A2A                          1649          
00001A2A  6000 000A               1650          BRA     ENDMODE_AN
00001A2E                          1651  NOTA6
00001A2E  6100 006E               1652          BSR     PRINTA7
00001A32                          1653          
00001A32  6000 0002               1654          BRA     ENDMODE_AN
00001A36                          1655  ENDMODE_AN
00001A36  4C9F 03FF               1656          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
00001A3A  4E75                    1657          RTS
00001A3C                          1658  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A3C                          1659  *-----------------------------------------------------------------------------
00001A3C                          1660  
00001A3C                          1661  
00001A3C                          1662  
00001A3C                          1663  *-----------------------------------------------------------------------------
00001A3C                          1664  *-----------------------------------------------------------------------------
00001A3C                          1665  * NAME:           PRINTA0
00001A3C                          1666  * DESCRIPTION:    Simply print out the address register.
00001A3C                          1667  * PRE-CONDITION:  a
00001A3C                          1668  * POST-CONDITION: a
00001A3C                          1669  * REGISTERS:      a
00001A3C                          1670  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A3C                          1671  PRINTA0
00001A3C  43F9 00001EC5           1672          LEA     __A0, A1        * Load 'A0'
00001A42  103C 000E               1673          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A46  4E4F                    1674          TRAP    #15             * Perform Trap #14
00001A48  4E75                    1675          RTS
00001A4A                          1676  
00001A4A                          1677  PRINTA1
00001A4A  43F9 00001EC8           1678          LEA     __A1, A1        * Load 'A1'
00001A50  103C 000E               1679          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A54  4E4F                    1680          TRAP    #15             * Perform Trap #14
00001A56  4E75                    1681          RTS
00001A58                          1682          
00001A58                          1683  PRINTA2
00001A58  43F9 00001ECB           1684          LEA     __A2, A1        * Load 'A2'
00001A5E  103C 000E               1685          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A62  4E4F                    1686          TRAP    #15             * Perform Trap #14
00001A64  4E75                    1687          RTS
00001A66                          1688  
00001A66                          1689  PRINTA3
00001A66  43F9 00001ECE           1690          LEA     __A3, A1        * Load 'A3'
00001A6C  103C 000E               1691          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A70  4E4F                    1692          TRAP    #15             * Perform Trap #14
00001A72  4E75                    1693          RTS
00001A74                          1694  
00001A74                          1695  PRINTA4
00001A74  43F9 00001ED1           1696          LEA     __A4, A1        * Load 'A4'
00001A7A  103C 000E               1697          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A7E  4E4F                    1698          TRAP    #15             * Perform Trap #14
00001A80  4E75                    1699          RTS
00001A82                          1700  
00001A82                          1701  PRINTA5
00001A82  43F9 00001ED4           1702          LEA     __A5, A1        * Load 'A5'
00001A88  103C 000E               1703          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A8C  4E4F                    1704          TRAP    #15             * Perform Trap #14
00001A8E  4E75                    1705          RTS
00001A90                          1706  
00001A90                          1707  PRINTA6
00001A90  43F9 00001ED7           1708          LEA     __A6, A1        * Load 'A6'
00001A96  103C 000E               1709          MOVE.B  #14, D0         * Load Trap #14 to print out
00001A9A  4E4F                    1710          TRAP    #15             * Perform Trap #14
00001A9C  4E75                    1711          RTS
00001A9E                          1712  
00001A9E                          1713  PRINTA7
00001A9E  43F9 00001EDA           1714          LEA     __A7, A1        * Load 'A7'
00001AA4  103C 000E               1715          MOVE.B  #14, D0         * Load Trap #14 to print out
00001AA8  4E4F                    1716          TRAP    #15             * Perform Trap #14
00001AAA  4E75                    1717          RTS
00001AAC                          1718  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AAC                          1719  *-----------------------------------------------------------------------------
00001AAC                          1720  
00001AAC                          1721  
00001AAC                          1722  
00001AAC                          1723  *-----------------------------------------------------------------------------
00001AAC                          1724  *-----------------------------------------------------------------------------
00001AAC                          1725  * NAME:           SIZE67
00001AAC                          1726  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001AAC                          1727  * PRE-CONDITION:  a
00001AAC                          1728  * POST-CONDITION: a
00001AAC                          1729  * REGISTERS:      a
00001AAC                          1730  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AAC                          1731  SIZE67
00001AAC  48A7 FFFE               1732          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001AB0  3C3C 0006               1733          MOVE.W  #6, D6              * Prep lower value for bitmask
00001AB4  3E3C 0007               1734          MOVE.W  #7, D7              * Prep upper value for bitmask
00001AB8  6100 0322               1735          BSR     BITMASK             * Finalize bitmask setup
00001ABC  CC42                    1736          AND     D2,D6               * Apply bitmask     
00001ABE                          1737  
00001ABE  0C46 0000               1738          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001AC2  6600 000A               1739          BNE     NOT67BYTE
00001AC6                          1740          
00001AC6  6100 0080               1741          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001ACA  6000 001E               1742          BRA     END67
00001ACE                          1743  NOT67BYTE        
00001ACE  0C46 0040               1744          CMPI    #%0000000001000000, D6   * is it a WORD?
00001AD2  6600 000A               1745          BNE     NOT67WORD
00001AD6                          1746          
00001AD6  6100 007E               1747          BSR     PRINTWORD               * Branch to handle WORD sizes
00001ADA  6000 000E               1748          BRA     END67
00001ADE                          1749  NOT67WORD
00001ADE  0C46 0080               1750          CMPI    #%0000000010000000, D6   * is it a LONG?
00001AE2  6600 0006               1751          BNE     END67
00001AE6                          1752          
00001AE6  6100 007C               1753          BSR     PRINTLONG               * Branch to handle LONG sizes
00001AEA                          1754  END67
00001AEA  4C9F 7FFF               1755          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001AEE  4E75                    1756          RTS                             * Return. Size handling is finished.
00001AF0                          1757  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AF0                          1758  *-----------------------------------------------------------------------------
00001AF0                          1759  
00001AF0                          1760  
00001AF0                          1761  
00001AF0                          1762  *-----------------------------------------------------------------------------
00001AF0                          1763  *-----------------------------------------------------------------------------
00001AF0                          1764  * NAME:           SIZE68
00001AF0                          1765  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
00001AF0                          1766  * PRE-CONDITION:  a
00001AF0                          1767  * POST-CONDITION: a
00001AF0                          1768  * REGISTERS:      a
00001AF0                          1769  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AF0                          1770  SIZE68
00001AF0                          1771          * finish later, need to follow the same format as SIZE67
00001AF0                          1772          
00001AF0                          1773          
00001AF0  48A7 FFFE               1774          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001AF4  3C3C 0006               1775          MOVE.W  #6, D6              * Prep lower value for bitmask
00001AF8  3E3C 0008               1776          MOVE.W  #8, D7              * Prep upper value for bitmask
00001AFC  6100 02DE               1777          BSR     BITMASK             * Finalize bitmask setup
00001B00  CC42                    1778          AND     D2,D6               * Apply bitmask          
00001B02                          1779          
00001B02  0C46 0000               1780          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001B06  6100 0040               1781          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001B0A  0C46 0100               1782          CMPI    #%0000000100000000, D6   * is it a BYTE?
00001B0E  6100 0038               1783          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001B12                          1784        
00001B12  0C46 0040               1785          CMPI    #%0000000001000000, D6   * is it a WORD?
00001B16  6100 003E               1786          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001B1A  0C46 0140               1787          CMPI    #%0000000101000000, D6   * is it a WORD?
00001B1E  6100 0036               1788          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001B22  0C46 00C0               1789          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
00001B26  6100 002E               1790          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001B2A                          1791  
00001B2A  0C46 0080               1792          CMPI    #%0000000010000000, D6   * is it a LONG?
00001B2E  6100 0034               1793          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001B32  0C46 0180               1794          CMPI    #%0000000110000000, D6   * is it a LONG?
00001B36  6100 002C               1795          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001B3A  0C46 01C0               1796          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001B3E  6100 0024               1797          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001B42                          1798  
00001B42  4C9F 7FFF               1799          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001B46  4E75                    1800          RTS                             * Return. Size handling is finished.
00001B48                          1801  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B48                          1802  *-----------------------------------------------------------------------------
00001B48                          1803  
00001B48                          1804  
00001B48                          1805  
00001B48                          1806  *-----------------------------------------------------------------------------
00001B48                          1807  *-----------------------------------------------------------------------------
00001B48                          1808  * NAME:           PRINTBYTE
00001B48                          1809  * DESCRIPTION:    a
00001B48                          1810  * PRE-CONDITION:  a
00001B48                          1811  * POST-CONDITION: a
00001B48                          1812  * REGISTERS:      a
00001B48                          1813  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B48                          1814  PRINTBYTE
00001B48  43F9 00001EB9           1815          LEA     __B,A1      * Load '.B ' into A1
00001B4E  103C 000E               1816          MOVE.B  #14,D0      * Trap #14 setup to print
00001B52  4E4F                    1817          TRAP    #15         * Perform Trap #14
00001B54  4E75                    1818          RTS                 * Return to SIZE67/SIZE68
00001B56                          1819          
00001B56                          1820  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B56                          1821  *-----------------------------------------------------------------------------
00001B56                          1822  
00001B56                          1823  
00001B56                          1824  
00001B56                          1825  *-----------------------------------------------------------------------------
00001B56                          1826  *-----------------------------------------------------------------------------
00001B56                          1827  * NAME:           PRINTWORD
00001B56                          1828  * DESCRIPTION:    a
00001B56                          1829  * PRE-CONDITION:  a
00001B56                          1830  * POST-CONDITION: a
00001B56                          1831  * REGISTERS:      a
00001B56                          1832  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B56                          1833  PRINTWORD
00001B56  43F9 00001EBD           1834          LEA     __W,A1      * Load '.W ' into A1
00001B5C  103C 000E               1835          MOVE.B  #14,D0      * Trap #14 setup to print
00001B60  4E4F                    1836          TRAP    #15         * Perform Trap #14
00001B62  4E75                    1837          RTS                 * Return to SIZE67/SIZE68
00001B64                          1838          
00001B64                          1839  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B64                          1840  *-----------------------------------------------------------------------------
00001B64                          1841  
00001B64                          1842  
00001B64                          1843  
00001B64                          1844  *-----------------------------------------------------------------------------
00001B64                          1845  *-----------------------------------------------------------------------------
00001B64                          1846  * NAME:           PRINTLONG
00001B64                          1847  * DESCRIPTION:    a
00001B64                          1848  * PRE-CONDITION:  a
00001B64                          1849  * POST-CONDITION: a
00001B64                          1850  * REGISTERS:      a
00001B64                          1851  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B64                          1852  PRINTLONG
00001B64  43F9 00001EC1           1853          LEA     __L,A1      * Load '.L ' into A1
00001B6A  103C 000E               1854          MOVE.B  #14,D0      * Trap #14 setup to print
00001B6E  4E4F                    1855          TRAP    #15         * Perform Trap #14
00001B70  4E75                    1856          RTS                 * Return to SIZE67/SIZE68
00001B72                          1857          
00001B72                          1858  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B72                          1859  *-----------------------------------------------------------------------------
00001B72                          1860  
00001B72                          1861  
00001B72                          1862  
00001B72                          1863  *-----------------------------------------------------------------------------
00001B72                          1864  *-----------------------------------------------------------------------------
00001B72                          1865  * NAME:           UNKNOWNOP
00001B72                          1866  * DESCRIPTION:    a
00001B72                          1867  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001B72                          1868  *                 identified as an unknown operation.
00001B72                          1869  * POST-CONDITION: D2 is no longer the opcode.
00001B72                          1870  * REGISTERS:      a
00001B72                          1871  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B72                          1872  UNKNOWNOP
00001B72  220A                    1873          MOVE.L  A2,D1   * prep the add to print
00001B74                          1874          
00001B74  5581                    1875          SUB.L   #2,D1   * off by two error due to post increment correct
00001B76                          1876          
00001B76  2602                    1877          MOVE.L  D2,D3   * save the opcode to print
00001B78                          1878          
00001B78  7410                    1879          MOVE.L  #16,D2  * set the base to 16
00001B7A                          1880          
00001B7A  700F                    1881          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001B7C  4E4F                    1882          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001B7E                          1883          
00001B7E  43F9 00001E63           1884          LEA     DATA,A1 * load " DATA $" into register A1
00001B84  700E                    1885          MOVE.L  #14,D0  * print the string stored in A1
00001B86  4E4F                    1886          TRAP    #15
00001B88                          1887          
00001B88  2203                    1888          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001B8A                          1889          
00001B8A  103C 000F               1890          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001B8E  4E4F                    1891          TRAP    #15      * Perform Trap #3
00001B90                          1892  
00001B90  43F9 00001E20           1893          LEA     NEWLINE,A1 * load newline into register A1
00001B96  700E                    1894          MOVE.L  #14,D0  * print the string stored in A1
00001B98  4E4F                    1895          TRAP    #15
00001B9A                          1896  
00001B9A  4E75                    1897          RTS
00001B9C                          1898  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B9C                          1899  *-----------------------------------------------------------------------------
00001B9C                          1900  
00001B9C                          1901  
00001B9C                          1902  
00001B9C                          1903  *-----------------------------------------------------------------------------
00001B9C                          1904  *-----------------------------------------------------------------------------
00001B9C                          1905  * NAME: Print ASCII hex char
00001B9C                          1906  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
00001B9C                          1907  * PRE-CONDITION:  A6 contains the register for memory to print.
00001B9C                          1908  *                 This parameter would be pre-loaded by, for example:
00001B9C                          1909  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001B9C                          1910  *                 D6 contains the loops to do (number of bytes).
00001B9C                          1911  * POST-CONDITION: 
00001B9C                          1912  * REGISTERS:      
00001B9C                          1913  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B9C                          1914  PRINT_ASCII_HEX_CHAR
00001B9C  48E7 FFFC               1915      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001BA0  4285                    1916      CLR.L       D5
00001BA2                          1917      
00001BA2                          1918      * fence post check (if-statement, check if 0 > chars)
00001BA2  0C06 0000               1919      CMPI.B      #0,D6
00001BA6  6700 017C               1920      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001BAA                          1921      
00001BAA                          1922  *    MOVE.L      A6,D4
00001BAA  2E0E                    1923      MOVE.L      A6,D7
00001BAC                          1924  PRINT_ASCII_LOOP
00001BAC                          1925  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001BAC                          1926  *    MOVE.L      D4,D7 * make a mutable copy
00001BAC  E99F                    1927      ROL.L       #4,D7 * roll to next spot
00001BAE  48E7 0100               1928      MOVEM.L     D7,-(A7) * save D7
00001BB2                          1929  
00001BB2  0287 0000000F           1930      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001BB8                          1931      
00001BB8  0C87 00000000           1932      CMPI.L      #0,D7
00001BBE  6D00 0164               1933      BLT         INVALID_ASCII_INPUT
00001BC2                          1934  
00001BC2  0C87 0000000F           1935      CMPI.L      #15,D7
00001BC8  6E00 015A               1936      BGT         INVALID_ASCII_INPUT
00001BCC                          1937  
00001BCC                          1938      * this might be faster... to do later, after entire assignment done
00001BCC                          1939       * CMPI.L      #9,D7
00001BCC                          1940       * BLE         PRINT_ASCII_0_TO_9
00001BCC                          1941  
00001BCC  0C87 00000000           1942      CMPI.L      #0,D7
00001BD2  6700 0098               1943      BEQ         PRINT_ASCII_0
00001BD6  0C87 00000001           1944      CMPI.L      #1,D7
00001BDC  6700 0098               1945      BEQ         PRINT_ASCII_1
00001BE0  0C87 00000002           1946      CMPI.L      #2,D7
00001BE6  6700 0098               1947      BEQ         PRINT_ASCII_2
00001BEA  0C87 00000003           1948      CMPI.L      #3,D7
00001BF0  6700 0098               1949      BEQ         PRINT_ASCII_3
00001BF4  0C87 00000004           1950      CMPI.L      #4,D7
00001BFA  6700 0098               1951      BEQ         PRINT_ASCII_4
00001BFE  0C87 00000005           1952      CMPI.L      #5,D7
00001C04  6700 0098               1953      BEQ         PRINT_ASCII_5
00001C08  0C87 00000006           1954      CMPI.L      #6,D7
00001C0E  6700 0098               1955      BEQ         PRINT_ASCII_6
00001C12  0C87 00000007           1956      CMPI.L      #7,D7
00001C18  6700 0098               1957      BEQ         PRINT_ASCII_7
00001C1C  0C87 00000008           1958      CMPI.L      #8,D7
00001C22  6700 0098               1959      BEQ         PRINT_ASCII_8
00001C26  0C87 00000009           1960      CMPI.L      #9,D7
00001C2C  6700 0098               1961      BEQ         PRINT_ASCII_9
00001C30  0C87 0000000A           1962      CMPI.L      #10,D7
00001C36  6700 0098               1963      BEQ         PRINT_ASCII_A
00001C3A  0C87 0000000B           1964      CMPI.L      #11,D7
00001C40  6700 0098               1965      BEQ         PRINT_ASCII_B
00001C44  0C87 0000000C           1966      CMPI.L      #12,D7
00001C4A  6700 0098               1967      BEQ         PRINT_ASCII_C
00001C4E  0C87 0000000D           1968      CMPI.L      #13,D7
00001C54  6700 0098               1969      BEQ         PRINT_ASCII_D
00001C58  0C87 0000000E           1970      CMPI.L      #14,D7
00001C5E  6700 0098               1971      BEQ         PRINT_ASCII_E
00001C62  0C87 0000000F           1972      CMPI.L      #15,D7
00001C68  6700 0098               1973      BEQ         PRINT_ASCII_F
00001C6C                          1974  PRINT_ASCII_0
00001C6C  43F9 00001E89           1975      LEA         ASCII_0,A1
00001C72  6000 0098               1976      BRA         PRINT_ASCII_CHAR
00001C76                          1977  PRINT_ASCII_1
00001C76  43F9 00001E8B           1978      LEA         ASCII_1,A1
00001C7C  6000 008E               1979      BRA         PRINT_ASCII_CHAR
00001C80                          1980  PRINT_ASCII_2
00001C80  43F9 00001E8D           1981      LEA         ASCII_2,A1
00001C86  6000 0084               1982      BRA         PRINT_ASCII_CHAR
00001C8A                          1983  PRINT_ASCII_3
00001C8A  43F9 00001E8F           1984      LEA         ASCII_3,A1
00001C90  6000 007A               1985      BRA         PRINT_ASCII_CHAR
00001C94                          1986  PRINT_ASCII_4
00001C94  43F9 00001E91           1987      LEA         ASCII_4,A1
00001C9A  6000 0070               1988      BRA         PRINT_ASCII_CHAR
00001C9E                          1989  PRINT_ASCII_5
00001C9E  43F9 00001E93           1990      LEA         ASCII_5,A1
00001CA4  6000 0066               1991      BRA         PRINT_ASCII_CHAR
00001CA8                          1992  PRINT_ASCII_6
00001CA8  43F9 00001E95           1993      LEA         ASCII_6,A1
00001CAE  6000 005C               1994      BRA         PRINT_ASCII_CHAR
00001CB2                          1995  PRINT_ASCII_7
00001CB2  43F9 00001E97           1996      LEA         ASCII_7,A1
00001CB8  6000 0052               1997      BRA         PRINT_ASCII_CHAR
00001CBC                          1998  PRINT_ASCII_8
00001CBC  43F9 00001E99           1999      LEA         ASCII_8,A1
00001CC2  6000 0048               2000      BRA         PRINT_ASCII_CHAR
00001CC6                          2001  PRINT_ASCII_9
00001CC6  43F9 00001E9B           2002      LEA         ASCII_9,A1
00001CCC  6000 003E               2003      BRA         PRINT_ASCII_CHAR
00001CD0                          2004  PRINT_ASCII_A
00001CD0  43F9 00001E9D           2005      LEA         ASCII_A,A1
00001CD6  6000 0034               2006      BRA         PRINT_ASCII_CHAR
00001CDA                          2007  PRINT_ASCII_B
00001CDA  43F9 00001E9F           2008      LEA         ASCII_B,A1
00001CE0  6000 002A               2009      BRA         PRINT_ASCII_CHAR
00001CE4                          2010  PRINT_ASCII_C
00001CE4  43F9 00001EA1           2011      LEA         ASCII_C,A1
00001CEA  6000 0020               2012      BRA         PRINT_ASCII_CHAR
00001CEE                          2013  PRINT_ASCII_D
00001CEE  43F9 00001EA3           2014      LEA         ASCII_D,A1
00001CF4  6000 0016               2015      BRA         PRINT_ASCII_CHAR
00001CF8                          2016  PRINT_ASCII_E
00001CF8  43F9 00001EA5           2017      LEA         ASCII_E,A1
00001CFE  6000 000C               2018      BRA         PRINT_ASCII_CHAR
00001D02                          2019  PRINT_ASCII_F
00001D02  43F9 00001EA7           2020      LEA         ASCII_F,A1
00001D08  6000 0002               2021      BRA         PRINT_ASCII_CHAR
00001D0C                          2022  PRINT_ASCII_CHAR
00001D0C  103C 000E               2023      MOVE.B      #14,D0
00001D10  4E4F                    2024      TRAP        #15
00001D12                          2025      
00001D12  5205                    2026      ADD.B       #1,D5 * loop until counter stops
00001D14  BA06                    2027      CMP.B       D6,D5
00001D16  6C00 000C               2028      BGE         PRINT_ASCII_FINISH
00001D1A                          2029      
00001D1A  4287                    2030      CLR.L       D7
00001D1C  4CDF 0080               2031      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001D20                          2032      
00001D20  6000 FE8A               2033      BRA         PRINT_ASCII_LOOP
00001D24                          2034  INVALID_ASCII_INPUT
00001D24                          2035  PRINT_ASCII_FINISH
00001D24  4CDF 3FFF               2036      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001D28  4E75                    2037      RTS
00001D2A                          2038      
00001D2A                          2039  PRINTDATA911
00001D2A  0C46 0E00               2040      CMPI    #%0000111000000000, D6   * Print 7
00001D2E  6700 003C               2041      BEQ     PRINT7   
00001D32  0C46 0C00               2042      CMPI    #%0000110000000000, D6   * Print 6
00001D36  6700 0042               2043      BEQ     PRINT6
00001D3A  0C46 0A00               2044      CMPI    #%0000101000000000, D6   * Print 5
00001D3E  6700 0048               2045      BEQ     PRINT5
00001D42  0C46 0800               2046      CMPI    #%0000100000000000, D6   * Print 4
00001D46  6700 004E               2047      BEQ     PRINT4 
00001D4A  0C46 0600               2048      CMPI    #%0000011000000000, D6   * Print 3
00001D4E  6700 0054               2049      BEQ     PRINT3    
00001D52  0C46 0400               2050      CMPI    #%0000010000000000, D6   * Print 2
00001D56  6700 005A               2051      BEQ     PRINT2   
00001D5A  0C46 0200               2052      CMPI    #%0000001000000000, D6   * Print 1
00001D5E  6700 0060               2053      BEQ     PRINT1     
00001D62  0C46 0000               2054      CMPI    #%0000000000000000, D6   * Print 0
00001D66  6700 0066               2055      BEQ     PRINT8
00001D6A                          2056      
00001D6A  4E75                    2057      RTS                             * Fail case  
00001D6C                          2058      
00001D6C                          2059  PRINT7
00001D6C  43F9 00001E97           2060      LEA     ASCII_7, A1
00001D72  103C 000E               2061      MOVE.B      #14,D0
00001D76  4E4F                    2062      TRAP        #15
00001D78  4E75                    2063      RTS
00001D7A                          2064      
00001D7A                          2065  PRINT6
00001D7A  43F9 00001E95           2066      LEA     ASCII_6, A1
00001D80  103C 000E               2067      MOVE.B      #14,D0
00001D84  4E4F                    2068      TRAP        #15
00001D86  4E75                    2069      RTS
00001D88                          2070      
00001D88                          2071  PRINT5
00001D88  43F9 00001E93           2072      LEA     ASCII_5, A1
00001D8E  103C 000E               2073      MOVE.B      #14,D0
00001D92  4E4F                    2074      TRAP        #15
00001D94  4E75                    2075      RTS
00001D96                          2076      
00001D96                          2077  PRINT4
00001D96  43F9 00001E91           2078      LEA     ASCII_4, A1
00001D9C  103C 000E               2079      MOVE.B      #14,D0
00001DA0  4E4F                    2080      TRAP        #15
00001DA2  4E75                    2081      RTS
00001DA4                          2082      
00001DA4                          2083  PRINT3
00001DA4  43F9 00001E8F           2084      LEA     ASCII_3, A1
00001DAA  103C 000E               2085      MOVE.B      #14,D0
00001DAE  4E4F                    2086      TRAP        #15
00001DB0  4E75                    2087      RTS
00001DB2                          2088      
00001DB2                          2089  PRINT2
00001DB2  43F9 00001E8D           2090      LEA     ASCII_2, A1
00001DB8  103C 000E               2091      MOVE.B      #14,D0
00001DBC  4E4F                    2092      TRAP        #15
00001DBE  4E75                    2093      RTS
00001DC0                          2094      
00001DC0                          2095  PRINT1
00001DC0  43F9 00001E8B           2096      LEA     ASCII_1, A1
00001DC6  103C 000E               2097      MOVE.B      #14,D0
00001DCA  4E4F                    2098      TRAP        #15
00001DCC  4E75                    2099      RTS
00001DCE                          2100          
00001DCE                          2101  PRINT8
00001DCE  43F9 00001E99           2102      LEA     ASCII_8, A1
00001DD4  103C 000E               2103      MOVE.B      #14,D0
00001DD8  4E4F                    2104      TRAP        #15
00001DDA  4E75                    2105      RTS
00001DDC                          2106  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001DDC                          2107  *-----------------------------------------------------------------------------
00001DDC                          2108  
00001DDC                          2109  
00001DDC                          2110  
00001DDC                          2111  *-----------------------------------------------------------------------------
00001DDC                          2112  *-----------------------------------------------------------------------------
00001DDC                          2113  * NAME: Bitmask
00001DDC                          2114  * DESCRIPTION:    Masks bits in a data register.
00001DDC                          2115  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001DDC                          2116  *                 the ending bit.  For example, a starting bit of decimal
00001DDC                          2117  *                 value 0 and an ending bit of decimal value 3 will mask the
00001DDC                          2118  *                 bits 0, 1, 2, and 3.
00001DDC                          2119  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001DDC                          2120  * REGISTERS:      D5,D6,D7
00001DDC                          2121  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001DDC                          2122  BITMASK
00001DDC  3F05                    2123          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001DDE  4245                    2124          CLR     D5          * clear D5 so we can use it
00001DE0                          2125  LOOPBIT 
00001DE0  0DC5                    2126          BSET    D6,D5       * set the D6th bit in D5 to 1
00001DE2  5246                    2127          ADD     #1,D6       * increment D6
00001DE4                          2128  
00001DE4  BC47                    2129          CMP     D7,D6       * have we finished?
00001DE6  6E00 0004               2130          BGT     BITMASKDONE * yes
00001DEA  60F4                    2131          BRA     LOOPBIT     * no, iterate again
00001DEC                          2132  
00001DEC                          2133  BITMASKDONE
00001DEC  2C05                    2134          MOVE.L  D5,D6
00001DEE  3A1F                    2135          MOVE    (A7)+,D5    * restore D5
00001DF0  4E75                    2136          RTS
00001DF2                          2137  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001DF2                          2138  *-----------------------------------------------------------------------------
00001DF2                          2139  
00001DF2                          2140  
00001DF2                          2141  
00001DF2                          2142  *-----------------------------------------------------------------------------
00001DF2                          2143  *-----------------------------------------------------------------------------
00001DF2                          2144  * SECTION: Constants/variables used throughout the program.
00001DF2                          2145  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001DF2                          2146  * ---> GENERAL
00001DF2  =0000000D               2147  CR          EQU     $0D
00001DF2  =0000000A               2148  LF          EQU     $0A
00001DF2= 45 4E 54 45 52 20 ...   2149  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001E0A= 45 4E 54 45 52 20 ...   2150  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001E20= 0D 0A 00                2151  NEWLINE     DC.B    CR,LF,0
00001E23                          2152  * ---> OPS
00001E23= 44 49 56 53 00          2153  DIVSOP      DC.B    'DIVS',0
00001E28= 4E 4F 50 00             2154  NOOPERATION DC.B    'NOP',0
00001E2C= 4E 45 47 00             2155  NEGOP       DC.B    'NEG',0
00001E30= 4D 4F 56 45 00          2156  MOVEOP      DC.B    'MOVE',0
00001E35= 4D 4F 56 45 4D 00       2157  MOVEMOP     DC.B    'MOVEM',0
00001E3B= 4A 53 52 00             2158  JSROP       DC.B    'JSR',0
00001E3F= 52 54 53 00             2159  RTSOP       DC.B    'RTS',0
00001E43= 53 55 42 51 00          2160  SUBQOP      DC.B    'SUBQ',0
00001E48= 4C 45 41 00             2161  LEAOP       DC.B    'LEA',0
00001E4C= 42 43 4C 52 20 00       2162  BCLROP      DC.B    'BCLR ',0
00001E52= 4D 55 4C 53 00          2163  MULSOP      DC.B    'MULS',0
00001E57= 4F 52 00                2164  OROP        DC.B    'OR',0
00001E5A= 4F 52 49 00             2165  ORIOP       DC.B    'ORI',0
00001E5E= 43 4D 50 49 00          2166  CMPIOP      DC.B    'CMPI',0
00001E63= 20 44 41 54 41 20 ...   2167  DATA        DC.B    ' DATA $',0
00001E6B= 42 43 43 20 00          2168  OP_BCC_MSG  DC.B    'BCC ',0
00001E70= 42 43 53 20 00          2169  OP_BCS_MSG  DC.B    'BCS ',0
00001E75= 42 47 45 20 00          2170  OP_BGE_MSG  DC.B    'BGE ',0
00001E7A= 42 4C 54 20 00          2171  OP_BLT_MSG  DC.B    'BLT ',0
00001E7F= 42 56 43 20 00          2172  OP_BVC_MSG  DC.B    'BVC ',0
00001E84= 42 52 41 20 00          2173  OP_BRA_MSG  DC.B    'BRA ',0
00001E89                          2174  * ---> HEX CHARS
00001E89= 30 00                   2175  ASCII_0     DC.B    '0',0
00001E8B= 31 00                   2176  ASCII_1     DC.B    '1',0
00001E8D= 32 00                   2177  ASCII_2     DC.B    '2',0
00001E8F= 33 00                   2178  ASCII_3     DC.B    '3',0
00001E91= 34 00                   2179  ASCII_4     DC.B    '4',0
00001E93= 35 00                   2180  ASCII_5     DC.B    '5',0
00001E95= 36 00                   2181  ASCII_6     DC.B    '6',0
00001E97= 37 00                   2182  ASCII_7     DC.B    '7',0
00001E99= 38 00                   2183  ASCII_8     DC.B    '8',0
00001E9B= 39 00                   2184  ASCII_9     DC.B    '9',0
00001E9D= 41 00                   2185  ASCII_A     DC.B    'A',0
00001E9F= 42 00                   2186  ASCII_B     DC.B    'B',0
00001EA1= 43 00                   2187  ASCII_C     DC.B    'C',0
00001EA3= 44 00                   2188  ASCII_D     DC.B    'D',0
00001EA5= 45 00                   2189  ASCII_E     DC.B    'E',0
00001EA7= 46 00                   2190  ASCII_F     DC.B    'F',0
00001EA9                          2191  * ---> SPECIAL CHARACTERS
00001EA9= 20 00                   2192  SPACE       DC.B    ' ',0
00001EAB= 24 00                   2193  DOLLAR      DC.B    '$',0
00001EAD= 23 00                   2194  IMD         DC.B    '#',0
00001EAF= 2C 00                   2195  COMMA       DC.B    ',',0
00001EB1= 28 00                   2196  OBRACK      DC.B    '(',0
00001EB3= 29 00                   2197  CBRACK      DC.B    ')',0
00001EB5= 2B 00                   2198  PLUS        DC.B    '+',0
00001EB7= 2D 00                   2199  MINUS       DC.B    '-',0
00001EB9                          2200  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001EB9= 2E 42 20 00             2201  __B         DC.B    '.B ',0
00001EBD= 2E 57 20 00             2202  __W         DC.B    '.W ',0
00001EC1= 2E 4C 20 00             2203  __L         DC.B    '.L ',0
00001EC5                          2204  * ---> ADDRESS REGISTERS A0-A7
00001EC5= 41 30 00                2205  __A0        DC.B   'A0',0
00001EC8= 41 31 00                2206  __A1        DC.B   'A1',0    
00001ECB= 41 32 00                2207  __A2        DC.B   'A2',0
00001ECE= 41 33 00                2208  __A3        DC.B   'A3',0
00001ED1= 41 34 00                2209  __A4        DC.B   'A4',0
00001ED4= 41 35 00                2210  __A5        DC.B   'A5',0
00001ED7= 41 36 00                2211  __A6        DC.B   'A6',0
00001EDA= 41 37 00                2212  __A7        DC.B   'A7',0
00001EDD                          2213  * ---> DATA REGISTERS D0-D7
00001EDD= 44 30 00                2214  __D0        DC.B   'D0',0
00001EE0= 44 31 00                2215  __D1        DC.B   'D1',0
00001EE3= 44 32 00                2216  __D2        DC.B   'D2',0
00001EE6= 44 33 00                2217  __D3        DC.B   'D3',0
00001EE9= 44 34 00                2218  __D4        DC.B   'D4',0
00001EEC= 44 35 00                2219  __D5        DC.B   'D5',0
00001EEF= 44 36 00                2220  __D6        DC.B   'D6',0
00001EF2= 44 37 00                2221  __D7        DC.B   'D7',0
00001EF5                          2222  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001EF5                          2223  *-----------------------------------------------------------------------------
00001EF5                          2224  
00001EF5                          2225  
00001EF5                          2226  
00001EF5                          2227  *-----------------------------------------------------------------------------
00001EF5                          2228  *-----------------------------------------------------------------------------
00001EF5                          2229  * SECTION: Sample program to run, then attempt testing disassembly on.
00001EF5                          2230  * STARTING: 16384
00001EF5                          2231  * ENDING:   16420
00001EF5                          2232  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2233      ORG $4000
00004000                          2234      
00004000  4E71                    2235      NOP
00004002  103C 009A               2236      MOVE.B   #%10011010, D0
00004006  123C 00A9               2237      MOVE.B   #%10101001, D1
0000400A  D200                    2238      ADD.B    D0,D1
0000400C  48A7 4000               2239      MOVEM    D1,-(A7)
00004010  43F8 1E3B               2240      LEA      JSROP,A1
00004014  4467                    2241      NEG.W    -(A7)
00004016  4EB9 0000403A           2242      JSR      END
0000401C  81FC 0001               2243      DIVS    #1, D0
00004020  0181                    2244      BCLR    D0, D1
00004022  CFFC 0003               2245      MULS.W  #3, D7
00004026  CFC0                    2246      MULS    D0, D7
00004028  C5D9                    2247      MULS    (A1)+, D2
0000402A  5146                    2248      SUBQ    #8, D6
0000402C  5F81                    2249      SUBQ.L  #7, D1
0000402E  0041 0004               2250      ORI     #4, D1
00004032  6000 0006               2251      BRA     END
00004036  6700 0002               2252      BEQ     END
0000403A                          2253  
0000403A                          2254  END
0000403A  4E75                    2255      RTS
0000403C                          2256      
0000403C                          2257  RLLYEND
0000403C                          2258      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1E89
ASCII_1             1E8B
ASCII_2             1E8D
ASCII_3             1E8F
ASCII_4             1E91
ASCII_5             1E93
ASCII_6             1E95
ASCII_7             1E97
ASCII_8             1E99
ASCII_9             1E9B
ASCII_A             1E9D
ASCII_B             1E9F
ASCII_C             1EA1
ASCII_D             1EA3
ASCII_E             1EA5
ASCII_F             1EA7
BCC_END             15D2
BCLROP              1E4C
BITMASK             1DDC
BITMASKDONE         1DEC
CBRACK              1EB3
CMPIOP              1E5E
COMMA               1EAF
CR                  D
DATA                1E63
DIVSOP              1E23
DOLLAR              1EAB
DONE0100            14AC
EAHELPER05          1756
EAHELPER611         1714
END                 403A
END0000             1240
END67               1AEA
ENDEAHELPER05       18A6
ENDEAHELPER611      1750
ENDMODE_AN          1A36
ENDMODE_DN          1936
ENDOP0001           12A6
HEX_VALUE_MASK_LONG  F
IMD                 1EAD
INVALID_ASCII_INPUT  1D24
ITERATION           1144
JSROP               1E3B
LEAOP               1E48
LF                  A
LOOP                103A
LOOPBIT             1DE0
LOOPUNKNOWNOP       1140
MINUS               1EB7
MODE_AN             19AC
MODE_DN             18AC
MOVEMOP             1E35
MOVEOP              1E30
MSGEND              1E0A
MSGSTART            1DF2
MULSOP              1E52
NEGOP               1E2C
NEWLINE             1E20
NOOPERATION         1E28
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           1ACE
NOT67WORD           1ADE
NOTA0               19CE
NOTA1               19DE
NOTA2               19EE
NOTA3               19FE
NOTA4               1A0E
NOTA5               1A1E
NOTA6               1A2E
NOTADRDIRECT        1786
NOTADRINDIRECT      17AE
NOTADRINDIRECTPOST  17E2
NOTADRINDIRECTPRE   1816
NOTBCLR             11CE
NOTD0               18CE
NOTD1               18DE
NOTD2               18EE
NOTD3               18FE
NOTD4               190E
NOTD5               191E
NOTD6               192E
NOTDATAREG          1776
NOTDIVS             165C
NOTIMMBYTE          184C
NOTIMMEDIATE        18A2
NOTIMMWORD          187A
NOTJSR              13A4
NOTMOVEM            1356
NOTNEG              1332
NOTNOP              12DC
NOTORI              1234
NOTRTS              13C6
OBRACK              1EB1
OP0000              1150
OP0001              1246
OP0010              12AC
OP0011              12B2
OP0100              12C0
OP0101              14B6
OP0110              1524
OP0111              15D8
OP1000              15DE
OP1000END           166C
OP1001              1672
OP1010              1672
OP1011              1678
OP1100              167E
OP1101              1702
OP1110              1708
OP1111              170E
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              1574
OP_BCC_MSG          1E6B
OP_BCS              157E
OP_BCS_MSG          1E70
OP_BGE              1588
OP_BGE_MSG          1E75
OP_BLT              1592
OP_BLT_MSG          1E7A
OP_BRA              15A6
OP_BRANCHES_PRINT   15B0
OP_BRA_MSG          1E84
OP_BVC              159C
OP_BVC_MSG          1E7F
ORIOP               1E5A
OROP                1E57
PLUS                1EB5
PRINT1              1DC0
PRINT2              1DB2
PRINT3              1DA4
PRINT4              1D96
PRINT5              1D88
PRINT6              1D7A
PRINT7              1D6C
PRINT8              1DCE
PRINTA0             1A3C
PRINTA1             1A4A
PRINTA2             1A58
PRINTA3             1A66
PRINTA4             1A74
PRINTA5             1A82
PRINTA6             1A90
PRINTA7             1A9E
PRINTBYTE           1B48
PRINTD0             193C
PRINTD1             194A
PRINTD2             1958
PRINTD3             1966
PRINTD4             1974
PRINTD5             1982
PRINTD6             1990
PRINTD7             199E
PRINTDATA911        1D2A
PRINTLONG           1B64
PRINTWORD           1B56
PRINT_ASCII_0       1C6C
PRINT_ASCII_1       1C76
PRINT_ASCII_2       1C80
PRINT_ASCII_3       1C8A
PRINT_ASCII_4       1C94
PRINT_ASCII_5       1C9E
PRINT_ASCII_6       1CA8
PRINT_ASCII_7       1CB2
PRINT_ASCII_8       1CBC
PRINT_ASCII_9       1CC6
PRINT_ASCII_A       1CD0
PRINT_ASCII_B       1CDA
PRINT_ASCII_C       1CE4
PRINT_ASCII_CHAR    1D0C
PRINT_ASCII_D       1CEE
PRINT_ASCII_E       1CF8
PRINT_ASCII_F       1D02
PRINT_ASCII_FINISH  1D24
PRINT_ASCII_HEX_CHAR  1B9C
PRINT_ASCII_LOOP    1BAC
RLLYEND             403C
RTSOP               1E3F
SIZE67              1AAC
SIZE68              1AF0
SPACE               1EA9
START               1000
SUBQOP              1E43
TWOWORDLEA          1456
UNKNOWN0000         123C
UNKNOWN0100         14A8
UNKNOWN0101         151E
UNKNOWN1100         16FE
UNKNOWNOP           1B72
UNKNOWNOP0001       12A2
__A0                1EC5
__A1                1EC8
__A2                1ECB
__A3                1ECE
__A4                1ED1
__A5                1ED4
__A6                1ED7
__A7                1EDA
__B                 1EB9
__D0                1EDD
__D1                1EE0
__D2                1EE3
__D3                1EE6
__D4                1EE9
__D5                1EEC
__D6                1EEF
__D7                1EF2
__L                 1EC1
__W                 1EBD
