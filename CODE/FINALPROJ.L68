00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/22/2014 3:26:52 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000                            51  
00000000                            52  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            53  
00001000                            54  START:  ORG    $1000            * first instruction of program
00001000                            55  
00001000                            56  * -----------------------------------
00001000                            57  * Starting and Ending Addresses
00001000                            58  * -----------------------------------
00001000                            59  
00001000                            60  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            61  
00001000                            62  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001094             63          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 64          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      65          TRAP    #15             * Perform #14
0000100C                            66          
0000100C                            67  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 68          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      69          TRAP    #15             * Perform #15
00001012                            70          
00001012                            71  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      72          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            73  
00001014                            74  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 000010AC             75          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 76          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      77          TRAP    #15             * Perform #14
00001020                            78          
00001020                            79  * GETS THE ENDING ADDRESS
00001020  103C 0004                 80          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      81          TRAP    #15             * Perform Trap #4
00001026  2A01                      82          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 000010C2             83          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            84          
0000102E  3E3C 000F                 85          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 86          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0030                 87          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A  3406                      88          MOVE.W  D6,D2           * move the bitmask to D2
0000103C                            89          
0000103C                            90  LOOP    
0000103C                            91          
0000103C                            92          * MOVE.W  #BITMASK,D2     * Load the bitmask into data register D2
0000103C  3F02                      93          MOVE    D2,-(A7)        * save the bitmask
0000103E  321A                      94          MOVE.W  (A2)+,D1        * Read an operation into D1
00001040  C441                      95          AND.W   D1,D2           * Apply this bitmask
00001042                            96          
00001042  B47C 4000                 97          CMP     #OP_0100,D2     * Does the operation start with 0100?
00001046  6600 000A                 98          BNE     NEXT16          * No, check next case
0000104A  6100 0032                 99          BSR     OP0100          * Branch to subroutine 0100
0000104E  6000 0008                100          BRA     ITERATION       * Move to next iteration of the loop
00001052                           101          
00001052                           102  NEXT16
00001052  103C 0003                103          MOVE.B  #3,D0           * Print out operation we don't recognize
00001056  4E4F                     104          TRAP    #15             * Perform Trap #3
00001058                           105          
00001058                           106  ITERATION
00001058  341F                     107          MOVE    (A7)+,D2        * restore the bitmask to its previous state
0000105A                           108  
0000105A  103C 000E                109          MOVE.B  #14,D0          * Print a newline
0000105E  4E4F                     110          TRAP    #15             * Perform Trap #14
00001060                           111  
00001060  BA4A                     112          CMP     A2,D5           * Compare the starting address to ending address
00001062  6700 2FAA                113          BEQ     END             * If they are equal, branch 
00001066  60D4                     114          BRA     LOOP            * Otherwise, branch back to LOOP
00001068                           115  
00001068                           116  * --- OP 0000 ------------------------------------------
00001068                           117  * FUNCTIONS     BCLR, ORI, CMPI
00001068                           118  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask. 
00001068                           119  * ADDR REG        
00001068                           120  * POST COND     All registers return to their previous state.
00001068                           121  * ------------------------------------------------------
00001068                           122  OP0000  * BCLR, ORI, CMPI
00001068                           123          * Compare 8th bit
00001068                           124          * If 8th bit is 1, go to BCLR
00001068                           125              * If bit 7 = 1 and 6 = 0, it is confirmed BCLR
00001068                           126                  * Check if mode and both registers is right
00001068                           127          * Now compare bits 9,10,11
00001068                           128              * If they're 000, go to ORI
00001068                           129                  * Check if size, mode, and register is right
00001068                           130              * If they're 110, go to CMPI
00001068                           131                  * Check if size, mode, and register is right
00001068                           132  
00001068                           133  * --- OP 0001 ------------------------------------------
00001068                           134  * FUNCTIONS     MOVE.B
00001068                           135  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001068                           136  * ADDR REG        
00001068                           137  * POST COND     All registers return to their previous state.
00001068                           138  * ------------------------------------------------------
00001068                           139  OP0001  * MOVE_BYTE,
00001068                           140  OP0010  * MOVE_LONG, MOVEA_LONG
00001068                           141  OP0011  * MOVE_WORD, MOVEA_WORD
00001068                           142  *OP0100 -> ALREADY MADE. NO_OP, MOVEM
00001068                           143  OP0101
00001068                           144  OP0110
00001068                           145  OP0111
00001068                           146  OP1000
00001068                           147  OP1001
00001068                           148  OP1010
00001068                           149  OP1011
00001068                           150  OP1100  * MULS,
00001068                           151  OP1101  * ADD, ADDA
00001068                           152  OP1110
00001068                           153  OP1111
00001068                           154  
00001068                           155   * --- BITMASK ----------------------------------------------------------------
00001068                           156   *@pre      D6 contains the starting bit you want masked, D7 the ending bit
00001068                           157   *
00001068                           158   *@post     D6 contains the bitmask, ready for use
00001068                           159   
00001068                           160  BITMASK
00001068  3F05                     161          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
0000106A  4245                     162          CLR     D5          * clear D5 so we can use it
0000106C                           163  LOOPBIT 
0000106C  0DC5                     164          BSET    D6,D5       * set the D6th bit in D5 to 1
0000106E  5246                     165          ADD     #1,D6       * increment D6
00001070                           166          
00001070  BC47                     167          CMP     D7,D6       * have we finished?
00001072  6E00 0004                168          BGT     BITMASKDONE * yes
00001076  60F4                     169          BRA     LOOPBIT     * no, iterate again
00001078                           170          
00001078                           171  BITMASKDONE
00001078                           172  
00001078  2C05                     173          MOVE.L  D5,D6
0000107A  3A1F                     174          MOVE    (A7)+,D5    * restore D5
0000107C  4E75                     175          RTS
0000107E                           176          
0000107E                           177   * --- OP0100 -----------------------------------------------------------------
0000107E                           178   * @pre      D2 contains the opcode
0000107E                           179   *
0000107E                           180   * @post     all registers are returned to their previous state
0000107E                           181  
0000107E                           182  OP0100                          * TODO: CONSIDER ALL 0100 OPERATIONS
0000107E  48A7 C0C0                183          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001082                           184          
00001082  43F9 000010C5            185          LEA     NOOPERATION,A1
00001088                           186          
00001088  103C 000E                187          MOVE.B  #14,D0          * Print a newline
0000108C  4E4F                     188          TRAP    #15
0000108E                           189          
0000108E  4C9F 0303                190          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001092                           191          
00001092  4E75                     192          RTS
00001094                           193  
00001094                           194   * ----------------------------------------------------------------------------
00001094                           195   * ----------------------------------------------------------------------------
00001094                           196   * Constants for printing information to the console
00001094                           197  
00001094  =0000000D                198  CR      EQU     $0D
00001094  =0000000A                199  LF      EQU     $0A
00001094= 45 4E 54 45 52 20 ...    200  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
000010AC= 45 4E 54 45 52 20 ...    201  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
000010C2= 0D 0A 00                 202  NEWLINE     DC.B    CR,LF,0
000010C5= 4E 4F 50 00              203  NOOPERATION DC.B    'NOP',0
000010C9                           204  
000010C9                           205   * ----------------------------------------------------------------------------
000010C9                           206   * ----------------------------------------------------------------------------
000010C9                           207   * Data defined constants
000010C9                           208   *   - B/W/L (representing Byte, Word, Long)
000010C9                           209   *   - A0-A7 (representing the 8 address registers)
000010C9                           210   *   - D0-D7 (representing the 8 data registers)
000010C9                           211   * ----------------------------------------------------------------------------
000010C9                           212  
000010C9= 42                       213  __B        DC.B    'B'
000010CA= 57                       214  __W        DC.B    'W'
000010CB= 4C                       215  __L        DC.B    'L'
000010CC                           216  
000010CC= 41 30                    217  __A0        DC.B   'A0'
000010CE= 41 31                    218  __A1        DC.B   'A1'    
000010D0= 41 32                    219  __A2        DC.B   'A2'
000010D2= 41 33                    220  __A3        DC.B   'A3'
000010D4= 41 34                    221  __A4        DC.B   'A4'
000010D6= 41 35                    222  __A5        DC.B   'A5'
000010D8= 41 36                    223  __A6        DC.B   'A6'
000010DA= 41 37                    224  __A7        DC.B   'A7'
000010DC                           225  
000010DC= 44 30                    226  __D0        DC.B   'D0'
000010DE= 44 31                    227  __D1        DC.B   'D1'
000010E0= 44 32                    228  __D2        DC.B   'D2'
000010E2= 44 33                    229  __D3        DC.B   'D3'
000010E4= 44 34                    230  __D4        DC.B   'D4'
000010E6= 44 35                    231  __D5        DC.B   'D5'
000010E8= 44 36                    232  __D6        DC.B   'D6'
000010EA= 44 37                    233  __D7        DC.B   'D7'
000010EC                           234   * ---------------------------------------------------------------------------
000010EC                           235   * End of definition segment
000010EC                           236   * ---------------------------------------------------------------------------
000010EC                           237   * ---------------------------------------------------------------------------
000010EC                           238  
000010EC                           239  * Put variables and constants here
000010EC                           240  
00004000                           241      ORG $4000
00004000                           242  
00004000  4E71                     243      NOP
00004002  103C 009A                244      MOVE.B   #%10011010, D0
00004006  123C 00A9                245      MOVE.B   #%10101001, D1
0000400A  D200                     246      ADD.B    D0,D1
0000400C  4E71                     247      NOP
0000400E                           248  
0000400E                           249  END
0000400E                           250      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BITMASK             1068
BITMASKDONE         1078
CR                  D
END                 400E
ITERATION           1058
LF                  A
LOOP                103C
LOOPBIT             106C
MSGEND              10AC
MSGSTART            1094
NEWLINE             10C2
NEXT16              1052
NOOPERATION         10C5
OP0000              1068
OP0001              1068
OP0010              1068
OP0011              1068
OP0100              107E
OP0101              1068
OP0110              1068
OP0111              1068
OP1000              1068
OP1001              1068
OP1010              1068
OP1011              1068
OP1100              1068
OP1101              1068
OP1110              1068
OP1111              1068
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
START               1000
__A0                10CC
__A1                10CE
__A2                10D0
__A3                10D2
__A4                10D4
__A5                10D6
__A6                10D8
__A7                10DA
__B                 10C9
__D0                10DC
__D1                10DE
__D2                10E0
__D3                10E2
__D4                10E4
__D5                10E6
__D6                10E8
__D7                10EA
__L                 10CB
__W                 10CA
