00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 11/26/2014 12:08:35 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000                            51  
00000000                            52  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            53  
00001000                            54  START:  ORG    $1000            * first instruction of program
00001000                            55  
00001000                            56  * -----------------------------------
00001000                            57  * Starting and Ending Addresses
00001000                            58  * -----------------------------------
00001000                            59  
00001000                            60  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            61  
00001000                            62  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 000013D0             63          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 64          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      65          TRAP    #15             * Perform #14
0000100C                            66          
0000100C                            67  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 68          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      69          TRAP    #15             * Perform #15
00001012                            70          
00001012                            71  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      72          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            73  
00001014                            74  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 000013E8             75          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 76          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      77          TRAP    #15             * Perform #14
00001020                            78          
00001020                            79  * GETS THE ENDING ADDRESS
00001020  103C 0004                 80          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      81          TRAP    #15             * Perform Trap #4
00001026  2A01                      82          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 000013FE             83          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            84          
0000102E  3E3C 000F                 85          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 86          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0382                 87          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            88          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            89          
0000103A                            90  LOOP    
0000103A                            91          
0000103A                            92          * MOVE.W  #BITMASK,D2     * Load the bitmask into data register D2
0000103A  3F06                      93          MOVE    D6,-(A7)        * save the bitmask
0000103C  341A                      94          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                      95          AND.W   D2,D6           * Apply this bitmask
00001040                            96          
00001040  BC7C 4000                 97          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001044  6600 0006                 98          BNE     NEXT            * No, check next case
00001048  6000 026C                 99          BRA     OP0100          * Branch to subroutine 0100
0000104C                           100          *BRA     ITERATION       * Move to next iteration of the loop
0000104C                           101          
0000104C                           102  NEXT
0000104C  6100 0342                103          BSR     UNKNOWNOP
00001050                           104          
00001050                           105  ITERATION
00001050  3C1F                     106          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001052                           107  
00001052                           108          *MOVE.B  #14,D0          * Print a newline
00001052                           109          *TRAP    #15             * Perform Trap #14
00001052                           110  
00001052  BA4A                     111          CMP     A2,D5           * Compare the starting address to ending address
00001054  6700 2FC6                112          BEQ     END             * If they are equal, branch 
00001058  60E0                     113          BRA     LOOP            * Otherwise, branch back to LOOP
0000105A                           114  
0000105A                           115  * --- OP 0000 ------------------------------------------
0000105A                           116  * FUNCTIONS     BCLR, ORI, CMPI
0000105A                           117  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask. 
0000105A                           118  * ADDR REG        
0000105A                           119  * POST COND     All registers return to their previous state.
0000105A                           120  * ------------------------------------------------------
0000105A                           121  OP0000
0000105A  48A7 C0C0                122   MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
0000105E  3C3C 0006                123          MOVE.W  #6, D6              * Prep lower value for bitmask
00001062  3E3C 0008                124          MOVE.W  #8, D7              * Prep upper value for bitmask
00001066  6100 0352                125          BSR     BITMASK             * Finalize bitmask setup
0000106A  CC42                     126          AND     D2,D6               * Apply bitmask
0000106C                           127          
0000106C  0C46 0180                128          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001070  6600 0012                129          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
00001074                           130          
00001074  43F9 0000141B            131          LEA     BCLROP,A1           * We found BCLR
0000107A  103C 000E                132          MOVE.B  #14,D0              * Trap #14 prints out the data
0000107E  4E4F                     133          TRAP    #15                 * Perform Trap #14
00001080  6000 0306                134          BRA     DONE              * Found the op, move to next iteration
00001084                           135  
00001084                           136  NOTBCLR * Possible options left are ORI or CMPI
00001084  3C3C 0009                137          MOVE.W  #9, D6              * Prep lower value for bitmask
00001088  3E3C 000B                138          MOVE.W  #11, D7             * Prep upper value for bitmask
0000108C  6100 032C                139          BSR     BITMASK             * Finalize bitmask setup
00001090  CC42                     140          AND     D2,D6               * Apply bitmask
00001092                           141          
00001092  0C46 0000                142          CMPI    #%0000000000000000, D6  * Are we ORI?
00001096  6700 000E                143          BEQ     ISORI                   * If ORI, branch to ISORI
0000109A                           144          
0000109A  0C46 0C00                145          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
0000109E  6700 0006                146          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
000010A2                           147          
000010A2  6600 02EC                148          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
000010A6                           149                                          * We don't deal too kindly with imposters.
000010A6                           150          
000010A6                           151  ISORI   * TODO
000010A6                           152          
000010A6                           153  
000010A6                           154  ISCMPI
000010A6  43F9 00001424            155          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000010AC  103C 000E                156          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000010B0  4E4F                     157          TRAP    #15                 * Perform Trap #14
000010B2                           158          
000010B2                           159          * Determine the Size
000010B2  3C3C 0006                160          MOVE.W  #6, D6              * Prep lower value for bitmask
000010B6  3E3C 0007                161          MOVE.W  #7, D7              * Prep upper value for bitmask
000010BA  6100 02FE                162          BSR     BITMASK             * Finalize bitmask setup
000010BE  CC42                     163          AND     D2,D6               * Apply bitmask
000010C0                           164          
000010C0  0C46 00C0                165          CMPI    #%0000000011000000, D6  * Imposter Op
000010C4  6700 02CA                166          BEQ     UNKNOWNOP               * Deal with the imposter
000010C8                           167          
000010C8  0C46 0000                168          CMPI    #%0000000000000000, D6  * The size is a BYTE
000010CC  6700 0012                169          BEQ     CMPIBYTE                * Branch to CMPI.B
000010D0                           170          
000010D0  0C46 0040                171          CMPI    #%0000000001000000, D6  * The size is a WORD
000010D4  6700 0032                172          BEQ     CMPIWORD                * Branch to CMPI.W
000010D8                           173          
000010D8  0C46 0080                174          CMPI    #%0000000010000000, D6  * The size is a LONG
000010DC  6700 0050                175          BEQ     CMPILONG                * Branch to CMPI.L
000010E0                           176          
000010E0                           177  CMPIBYTE
000010E0  43F9 00001433            178          LEA     __B, A1     * Load .B
000010E6  103C 000E                179          MOVE.B  #14, D0     * Print out data
000010EA  4E4F                     180          TRAP    #15         * Perform Trap #14
000010EC                           181          
000010EC  43F9 00001431            182          LEA     IMD, A1     * Load #
000010F2  103C 000E                183          MOVE.B  #14, D0     * Print out data
000010F6  4E4F                     184          TRAP    #15         * Perform Trap #14
000010F8                           185          
000010F8  361A                     186          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
000010FA  1203                     187          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
000010FC  3622                     188          MOVE.W  -(A2),D3    * Now go back
000010FE  103C 000E                189          MOVE.B  #14, D0     * Print out the data
00001102  4E4F                     190          TRAP    #15         * Perform Trap #14 
00001104                           191          
00001104  6000 004E                192          BRA     CMPIEA      * Branch to determine Effective Address
00001108                           193          
00001108                           194  CMPIWORD
00001108  43F9 00001435            195          LEA     __W, A1     * Load .W
0000110E  103C 000E                196          MOVE.B  #14, D0     * Print out data
00001112  4E4F                     197          TRAP    #15         * Perform Trap #14
00001114                           198          
00001114  43F9 00001431            199          LEA     IMD, A1     * Load #
0000111A  103C 000E                200          MOVE.B  #14, D0     * Print out data
0000111E  4E4F                     201          TRAP    #15         * Perform Trap #14
00001120                           202          
00001120  361A                     203          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001122  3222                     204          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
00001124  103C 000E                205          MOVE.B  #14, D0     * Print out the data
00001128  4E4F                     206          TRAP    #15         * Perform Trap #14
0000112A                           207          
0000112A                           208          
0000112A  6000 0028                209          BRA     CMPIEA      * Branch to determine Effective Address
0000112E                           210          
0000112E                           211  CMPILONG
0000112E  43F9 00001437            212          LEA     __L, A1     * Load .L
00001134  103C 000E                213          MOVE.B  #14, D0     * Print out data
00001138  4E4F                     214          TRAP    #15         * Perform Trap #14
0000113A                           215          
0000113A  43F9 00001431            216          LEA     IMD, A1     * Load #
00001140  103C 000E                217          MOVE.B  #14, D0     * Print out data
00001144  4E4F                     218          TRAP    #15         * Perform Trap #14
00001146                           219          
00001146  361A                     220          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001148  2222                     221          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
0000114A  103C 000E                222          MOVE.B  #14, D0     * Print out the data
0000114E  4E4F                     223          TRAP    #15         * Perform Trap #14
00001150                           224          
00001150  6000 0002                225          BRA     CMPIEA      * Branch to determine Effective Address
00001154                           226          
00001154                           227  CMPIEA
00001154                           228          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
00001154  43F9 00001432            229          LEA     COMMA, A1   * Load ,
0000115A  103C 000E                230          MOVE.B  #14, D0     * Print out data
0000115E  4E4F                     231          TRAP    #15         * Perform Trap #14
00001160                           232          
00001160  43F9 00001437            233          LEA     __L, A1     * Load .L
00001166  103C 000E                234          MOVE.B  #14, D0     * Print out data
0000116A  4E4F                     235          TRAP    #15         * Perform Trap #14
0000116C                           236          
0000116C                           237          * Determine the mode
0000116C  3C3C 0003                238          MOVE.W  #3, D6              * Prep lower value for bitmask
00001170  3E3C 0005                239          MOVE.W  #5, D7              * Prep upper value for bitmask
00001174  6100 0244                240          BSR     BITMASK             * Finalize bitmask setup
00001178  CC42                     241          AND     D2,D6               * Apply bitmask
0000117A                           242          
0000117A  0C46 0008                243          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
0000117E  6700 0210                244          BEQ     UNKNOWNOP               * Imposter op
00001182                           245          
00001182  0C46 0028                246          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
00001186  6700 0208                247          BEQ     UNKNOWNOP               * Imposter op
0000118A                           248          
0000118A  0C46 0030                249          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
0000118E  6700 0200                250          BEQ     UNKNOWNOP               * Imposter op
00001192                           251  
00001192  0C46 0038                252          CMPI    #%0000000000111000, D6  * Is the Mode 111?
00001196  6700 0028                253          BEQ     CMPIREG                 * Further investigation is needed
0000119A                           254          
0000119A                           255          * Mode is verified to be valid at this point
0000119A  0C46 0000                256          CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
0000119E  6100 003E                257          BSR     MODE_DN
000011A2                           258          
000011A2  0C46 0010                259          CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
000011A6  6100 00F6                260          BSR     MODE_IAN
000011AA                           261          
000011AA  0C46 0018                262          CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
000011AE  6100 00EE                263          BSR     MODE_IAN_POS
000011B2                           264          
000011B2  0C46 0000                265          CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
000011B6  6100 00E6                266          BSR     MODE_IAN_PRE
000011BA                           267          
000011BA                           268          * Reached End of CMPI. Everything has been printed out
000011BA  4C9F 0303                269          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000011BE  4E75                     270          RTS
000011C0                           271          
000011C0                           272  CMPIREG
000011C0  3C3C 0000                273          MOVE.W  #0, D6              * Prep lower value for bitmask
000011C4  3E3C 0002                274          MOVE.W  #2, D7              * Prep upper value for bitmask
000011C8  6100 01F0                275          BSR     BITMASK             * Finalize bitmask setup
000011CC  CC42                     276          AND     D2,D6               * Apply bitmask
000011CE                           277          
000011CE  0C46 0000                278          CMPI    #%0000000000000000, D6  * Is the Register 000?
000011D2  6700 000A                279          BEQ     CMPIREG000
000011D6                           280          
000011D6  0C46 0001                281          CMPI    #%0000000000000001, D6  * Is the Register 001?
000011DA  6700 0002                282          BEQ     CMPIREG001
000011DE                           283            
000011DE                           284  
000011DE                           285  CMPIREG000  * TODO (xxx).W for CMPI
000011DE                           286  
000011DE                           287  CMPIREG001  * TODO (xxx).L for CMPI
000011DE                           288          
000011DE                           289  * --- Effective Address --------------------------------
000011DE                           290  * PURPOSE       To generalize the EA part of the project.
000011DE                           291  * PRE CON       The Mode must have been correctly identified. All Modes must be called by RTS
000011DE                           292  * POST CON      After the EA, the entire op will head back to the BSR that called it.
000011DE                           293  * ------------------------------------------------------        
000011DE                           294  MODE_DN
000011DE  3C3C 0000                295          MOVE.W  #0, D6              * Prep lower value for bitmask
000011E2  3E3C 0002                296          MOVE.W  #2, D7              * Prep upper value for bitmask
000011E6  6100 01D2                297          BSR     BITMASK             * Finalize bitmask setup
000011EA  CC42                     298          AND     D2,D6               * Apply bitmask
000011EC                           299          
000011EC  0C46 0000                300          CMPI    #%000000000000000, D6   * Data Register D0?
000011F0  6100 003C                301          BSR     PRINTD0
000011F4  0C46 0001                302          CMPI    #%000000000000001, D6   * Data Register D1?
000011F8  6100 0042                303          BSR     PRINTD1
000011FC  0C46 0002                304          CMPI    #%000000000000010, D6   * Data Register D2?
00001200  6100 0048                305          BSR     PRINTD2
00001204  0C46 0003                306          CMPI    #%000000000000011, D6   * Data Register D3?
00001208  6100 004E                307          BSR     PRINTD3
0000120C  0C46 0004                308          CMPI    #%000000000000100, D6   * Data Register D4?
00001210  6100 0054                309          BSR     PRINTD4
00001214  0C46 0005                310          CMPI    #%000000000000101, D6   * Data Register D5?
00001218  6100 005A                311          BSR     PRINTD5
0000121C  0C46 0006                312          CMPI    #%000000000000110, D6   * Data Register D6?
00001220  6100 0060                313          BSR     PRINTD6
00001224  0C46 0007                314          CMPI    #%000000000000111, D6   * Data Register D7?
00001228  6100 0066                315          BSR     PRINTD7
0000122C                           316          
0000122C  4E75                     317          RTS     * Return to function to handle pointer advancing, RTS to main, etc.
0000122E                           318  
0000122E                           319  PRINTD0
0000122E  43F9 00001449            320          LEA     __D0, A1        * Load 'D0'
00001234  103C 000E                321          MOVE.B  #14, D0         * Load Trap #14 to print out
00001238  4E4F                     322          TRAP    #15             * Perform Trap #14
0000123A  4E75                     323          RTS
0000123C                           324          
0000123C                           325  PRINTD1
0000123C  43F9 0000144B            326          LEA     __D1, A1        * Load 'D1'
00001242  103C 000E                327          MOVE.B  #14, D0         * Load Trap #14 to print out
00001246  4E4F                     328          TRAP    #15             * Perform Trap #14
00001248  4E75                     329          RTS
0000124A                           330          
0000124A                           331  PRINTD2
0000124A  43F9 0000144D            332          LEA     __D2, A1        * Load 'D2'
00001250  103C 000E                333          MOVE.B  #14, D0         * Load Trap #14 to print out
00001254  4E4F                     334          TRAP    #15             * Perform Trap #14
00001256  4E75                     335          RTS
00001258                           336          
00001258                           337  PRINTD3
00001258  43F9 0000144F            338          LEA     __D3, A1        * Load 'D3'
0000125E  103C 000E                339          MOVE.B  #14, D0         * Load Trap #14 to print out
00001262  4E4F                     340          TRAP    #15             * Perform Trap #14
00001264  4E75                     341          RTS
00001266                           342          
00001266                           343  PRINTD4
00001266  43F9 00001451            344          LEA     __D4, A1        * Load 'D4'
0000126C  103C 000E                345          MOVE.B  #14, D0         * Load Trap #14 to print out
00001270  4E4F                     346          TRAP    #15             * Perform Trap #14
00001272  4E75                     347          RTS
00001274                           348          
00001274                           349  PRINTD5
00001274  43F9 00001453            350          LEA     __D5, A1        * Load 'D5'
0000127A  103C 000E                351          MOVE.B  #14, D0         * Load Trap #14 to print out
0000127E  4E4F                     352          TRAP    #15             * Perform Trap #14
00001280  4E75                     353          RTS
00001282                           354          
00001282                           355  PRINTD6
00001282  43F9 00001455            356          LEA     __D6, A1        * Load 'D6'
00001288  103C 000E                357          MOVE.B  #14, D0         * Load Trap #14 to print out
0000128C  4E4F                     358          TRAP    #15             * Perform Trap #14
0000128E  4E75                     359          RTS
00001290                           360          
00001290                           361  PRINTD7
00001290  43F9 00001457            362          LEA     __D7, A1        * Load 'D7'
00001296  103C 000E                363          MOVE.B  #14, D0         * Load Trap #14 to print out
0000129A  4E4F                     364          TRAP    #15             * Perform Trap #14
0000129C  4E75                     365          RTS
0000129E                           366          
0000129E                           367  MODE_AN
0000129E                           368  
0000129E                           369  MODE_IAN
0000129E                           370  MODE_IAN_POS
0000129E                           371  MODE_IAN_PRE
0000129E                           372  
0000129E                           373  * --- OP 0001 ------------------------------------------
0000129E                           374  * FUNCTIONS     MOVE.B
0000129E                           375  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
0000129E                           376  * ADDR REG        
0000129E                           377  * POST COND     All registers return to their previous state.
0000129E                           378  * ------------------------------------------------------
0000129E                           379  OP0001  
0000129E                           380  
0000129E                           381  
0000129E                           382  
0000129E                           383  
0000129E                           384  * --- OP 0010 ------------------------------------------
0000129E                           385  * FUNCTIONS     MOVE.L, MOVEA.L,
0000129E                           386  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
0000129E                           387  * ADDR REG        
0000129E                           388  * POST COND     All registers return to their previous state.
0000129E                           389  * ------------------------------------------------------
0000129E                           390  OP0010  
0000129E                           391  
0000129E                           392  
0000129E                           393  * --- OP 0011 ------------------------------------------
0000129E                           394  * FUNCTIONS     MOVE.W, MOVEA.W
0000129E                           395  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
0000129E                           396  * ADDR REG        
0000129E                           397  * POST COND     All registers return to their previous state.
0000129E                           398  * ------------------------------------------------------
0000129E                           399  OP0011
0000129E  48A7 FFFE                400      MOVEM   D0-D7/A0-A6, -(A7)
000012A2                           401      
000012A2  3C3C 0006                402      MOVE.W  #6,D6
000012A6  3E3C 0008                403      MOVE.W  #8,D7
000012AA                           404      
000012AA  6100 010E                405      BSR     BITMASK
000012AE                           406      
000012AE  CC42                     407      AND.W   D2,D6
000012B0                           408      
000012B0  BC7C 0040                409      CMP     #%0000000001000000,D6
000012B4                           410      *BNE     NEXT15
000012B4  61FE                     411      BSR     * for MOVEA.W
000012B6                           412  
000012B6                           413  
000012B6                           414  * --- OP 0100 ------------------------------------------
000012B6                           415  * FUNCTIONS     NO_OP, MOVEM, LEA, NEG, JSR, RTS
000012B6                           416  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
000012B6                           417  * ADDR REG        
000012B6                           418  * POST COND     All registers return to their previous state.
000012B6                           419  * ------------------------------------------------------
000012B6                           420  OP0100  * TODO: lea, jsr, rts
000012B6                           421  
000012B6  48A7 C0C0                422          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000012BA                           423          
000012BA                           424          *NOP
000012BA  0C42 4E71                425          CMPI    #%0100111001110001,D2
000012BE  6600 0012                426          BNE     NOTNOP
000012C2                           427          
000012C2  43F9 00001401            428          LEA     NOOPERATION,A1
000012C8  103C 000D                429          MOVE.B  #13,D0          * Print a newline
000012CC  4E4F                     430          TRAP    #15
000012CE                           431          
000012CE  6000 00B8                432          BRA     DONE *we found it, move on to the next iteration
000012D2                           433  NOTNOP *NEG
000012D2                           434          
000012D2                           435          * prep values for BITMASK subroutine
000012D2  7C08                     436          MOVE.L  #8,D6
000012D4  7E0B                     437          MOVE.L  #11,D7
000012D6                           438          
000012D6  6100 00E2                439          BSR     BITMASK
000012DA                           440          
000012DA  CC42                     441          AND     D2,D6                   * apply bitmask
000012DC                           442          
000012DC  0C46 0400                443          CMPI    #%0000010000000000,D6   * are we NEG?
000012E0  6600 0012                444          BNE     NOTNEG                  * not neg
000012E4                           445          
000012E4                           446          *check to make sure valid size and mode for movem
000012E4                           447        
000012E4                           448          * it is NEG, print
000012E4  43F9 00001405            449          LEA     NEGOP,A1
000012EA  103C 000E                450          MOVE.B  #14,D0
000012EE  4E4F                     451          TRAP    #15
000012F0                           452          
000012F0                           453          * call size and ea helpers
000012F0                           454          
000012F0  6000 0096                455          BRA     DONE * we found the op, move to next iteration
000012F4                           456          
000012F4                           457  NOTNEG *MOVEM
000012F4                           458  
000012F4                           459          * prep values for BITMASK subroutine
000012F4  7C07                     460          MOVE.L  #7,D6
000012F6  7E09                     461          MOVE.L  #9,D7
000012F8                           462          
000012F8  6100 00C0                463          BSR     BITMASK
000012FC                           464          
000012FC  CC42                     465          AND     D2,D6   * apply bitmask
000012FE                           466          
000012FE  0C46 0080                467          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001302  6600 0014                468          BNE     NOTMOVEM          * it is not MOVEM
00001306                           469          
00001306                           470          * make sure it is a valid size and mode for MOVEM
00001306                           471          
00001306                           472          * it is MOVEM
00001306  43F9 00001409            473          LEA     MOVEMOP,A1
0000130C  103C 000E                474          MOVE.B  #14,D0          * Print a newline
00001310  4E4F                     475          TRAP    #15
00001312                           476          
00001312                           477          * probably needs its own special code for printing the rest due to uniqueness of movem
00001312                           478          
00001312  341A                     479          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001314                           480          
00001314  6000 0072                481          BRA     DONE          * we found and printed, move on to the next iteration
00001318                           482          
00001318                           483  NOTMOVEM *JSR
00001318                           484          * prep values for BITMASK subroutine
00001318  7C06                     485          MOVE.L  #6,D6
0000131A  7E08                     486          MOVE.L  #8,D7
0000131C                           487          
0000131C  6100 009C                488          BSR     BITMASK
00001320                           489          
00001320  CC42                     490          AND     D2,D6   * apply bitmask
00001322                           491          
00001322  0C46 0080                492          CMPI    #%0000000010000000,D6
00001326  6600 0016                493          BNE     NOTJSR          * it's not JSR
0000132A                           494          
0000132A  43F9 0000140F            495          LEA     JSROP,A1
00001330  103C 000E                496          MOVE.B  #14,D0          * Print a newline and JSR
00001334  4E4F                     497          TRAP    #15
00001336                           498          
00001336                           499          * print out where we are jumping to
00001336                           500          
00001336  341A                     501          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001338  341A                     502          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000133A                           503          
0000133A  6000 004C                504          BRA     DONE          * we already found instruction, next iteration
0000133E                           505  NOTJSR *RTS
0000133E                           506  
0000133E                           507          * prep values for BITMASK subroutine
0000133E  7C06                     508          MOVE.L  #6,D6
00001340  7E08                     509          MOVE.L  #8,D7
00001342                           510          
00001342  6100 0076                511          BSR     BITMASK
00001346                           512          
00001346  CC42                     513          AND     D2,D6   * apply bitmask
00001348                           514          
00001348  0C46 0040                515          CMPI    #%0000000001000000,D6
0000134C  6600 0012                516          BNE     NOTRTS          * it's not RTS
00001350                           517          
00001350  43F9 00001413            518          LEA     RTSOP,A1
00001356  103C 000E                519          MOVE.B  #14,D0          * Print a newline and RTS
0000135A  4E4F                     520          TRAP    #15
0000135C                           521          
0000135C  6000 002A                522          BRA     DONE          * we already found instruction, next iteration
00001360                           523  NOTRTS  *LEA
00001360                           524         
00001360                           525          * prep values for BITMASK subroutine
00001360  7C06                     526          MOVE.L  #6,D6
00001362  7E08                     527          MOVE.L  #8,D7
00001364                           528          
00001364  6100 0054                529          BSR     BITMASK
00001368                           530          
00001368  CC42                     531          AND     D2,D6   * apply bitmask
0000136A                           532          
0000136A  0C46 01C0                533          CMPI    #%0000000111000000,D6
0000136E  6600 0014                534          BNE     UNKNOWN          * it's not LEA, we dont know what it is
00001372                           535          
00001372                           536          * check to make sure it is a supported mode and size
00001372                           537          
00001372  43F9 00001417            538          LEA     LEAOP,A1
00001378  103C 000E                539          MOVE.B  #14,D0          * Print LEA
0000137C  4E4F                     540          TRAP    #15
0000137E                           541          
0000137E                           542          * call EA helper
0000137E  341A                     543          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001380                           544                  
00001380  6000 0006                545          BRA     DONE          * we already found instruction, next iteration
00001384                           546          
00001384                           547  UNKNOWN *dont know what it is
00001384  6100 000A                548          BSR     UNKNOWNOP
00001388                           549          
00001388                           550  DONE
00001388  4C9F 0303                551          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
0000138C  6000 FCC2                552          BRA     ITERATION
00001390                           553          
00001390                           554          
00001390                           555          
00001390                           556  
00001390                           557  * --- OP 0101 ------------------------------------------
00001390                           558  * FUNCTIONS     SUBQ
00001390                           559  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001390                           560  * ADDR REG        
00001390                           561  * POST COND     All registers return to their previous state.
00001390                           562  * ------------------------------------------------------
00001390                           563  OP0101
00001390                           564  
00001390                           565  
00001390                           566  
00001390                           567  * --- OP 0110 ------------------------------------------
00001390                           568  * FUNCTIONS     BCC, BCS, BGE, BLT, BVC, BRA
00001390                           569  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001390                           570  * ADDR REG        
00001390                           571  * POST COND     All registers return to their previous state.
00001390                           572  * ------------------------------------------------------
00001390                           573  OP0110
00001390                           574  
00001390                           575  
00001390                           576  
00001390                           577  
00001390                           578  * --- OP 0111 ------------------------------------------
00001390                           579  * FUNCTIONS     
00001390                           580  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001390                           581  * ADDR REG        
00001390                           582  * POST COND     All registers return to their previous state.
00001390                           583  * ------------------------------------------------------
00001390                           584  OP0111
00001390                           585  
00001390                           586  
00001390                           587  
00001390                           588  * --- OP 1000 ------------------------------------------
00001390                           589  * FUNCTIONS     DIVS, OR
00001390                           590  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001390                           591  * ADDR REG        
00001390                           592  * POST COND     All registers return to their previous state.
00001390                           593  * ------------------------------------------------------
00001390                           594  OP1000
00001390                           595  
00001390                           596  
00001390                           597  
00001390                           598  * --- OP 1001 ------------------------------------------
00001390                           599  * FUNCTIONS     SUB
00001390                           600  * DATA REG      D0, D1 for output. D2 for entire instruction. D6 for bitmask.
00001390                           601  * ADDR REG        
00001390                           602  * POST COND     All registers return to their previous state.
00001390                           603  * ------------------------------------------------------
00001390                           604  OP1001
00001390                           605  
00001390                           606  
00001390                           607  
00001390                           608  * --- OP 1010 ------------------------------------------
00001390                           609  * FUNCTIONS     
00001390                           610  * DATA REG      D0, D1 for output. D2 for entire instruction. D6 for bitmask.
00001390                           611  * ADDR REG        
00001390                           612  * POST COND     All registers return to their previous state.
00001390                           613  * ------------------------------------------------------
00001390                           614  OP1010
00001390                           615  
00001390                           616  
00001390                           617  * --- OP 1011 ------------------------------------------
00001390                           618  * FUNCTIONS     EOR, CMP 
00001390                           619  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
00001390                           620  * ADDR REG        
00001390                           621  * POST COND     All registers return to their previous state.
00001390                           622  * ------------------------------------------------------
00001390                           623  OP1011
00001390                           624  
00001390                           625  
00001390                           626  * --- OP 1100 ------------------------------------------
00001390                           627  * FUNCTIONS     MULS
00001390                           628  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
00001390                           629  * ADDR REG        
00001390                           630  * POST COND     All registers return to their previous state.
00001390                           631  * ------------------------------------------------------
00001390                           632  OP1100
00001390                           633  
00001390                           634  
00001390                           635  
00001390                           636  * --- OP 1101 ------------------------------------------
00001390                           637  * FUNCTIONS     ADD, ADDA,
00001390                           638  * DATA REG      D0, D1 for output. D2 for entire opcode. D6 for bitmask.
00001390                           639  * ADDR REG        
00001390                           640  * POST COND     All registers return to their previous state.
00001390                           641  * ------------------------------------------------------
00001390                           642  OP1101
00001390                           643  
00001390                           644  
00001390                           645  
00001390                           646  * --- OP 1110 ------------------------------------------
00001390                           647  * FUNCTIONS     LSL, LSR, ASL, ASR, ROL, ROR, 
00001390                           648  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001390                           649  * ADDR REG        
00001390                           650  * POST COND     All registers return to their previous state.
00001390                           651  * ------------------------------------------------------
00001390                           652  OP1110
00001390                           653  
00001390                           654  
00001390                           655  
00001390                           656  
00001390                           657  * --- OP 1111 ------------------------------------------
00001390                           658  * FUNCTIONS     
00001390                           659  * DATA REG      D0, D1 for output. D2 for opcode. D6 for bitmask.
00001390                           660  * ADDR REG        
00001390                           661  * POST COND     All registers return to their previous state.
00001390                           662  * ------------------------------------------------------
00001390                           663  OP1111
00001390                           664  
00001390                           665  
00001390                           666  * --- UNKNOWNOP ----------------------------------------
00001390                           667  * PRE  COND     D2 contains the instruction we wish to print 
00001390                           668  * POST COND     D2 is no longer the opcode
00001390                           669  * ------------------------------------------------------
00001390                           670     
00001390                           671  UNKNOWNOP
00001390  220A                     672          MOVE.L  A2,D1   * prep the add to print
00001392                           673          
00001392  5581                     674          SUB.L   #2,D1   * off by two error due to post increment correct
00001394                           675          
00001394  2602                     676          MOVE.L  D2,D3   * save the opcode to print
00001396                           677          
00001396  7410                     678          MOVE.L  #16,D2  * set the base to 16
00001398                           679          
00001398  700F                     680          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
0000139A  4E4F                     681          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000139C                           682          
0000139C  43F9 00001429            683          LEA     DATA,A1 * load " DATA $" into register A1
000013A2  700E                     684          MOVE.L  #14,D0  * print the string stored in A1
000013A4  4E4F                     685          TRAP    #15
000013A6                           686          
000013A6  2203                     687          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
000013A8                           688          
000013A8  103C 000F                689          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
000013AC  4E4F                     690          TRAP    #15      * Perform Trap #3
000013AE                           691          
000013AE  43F9 000013FE            692          LEA     NEWLINE,A1 * load newline into register A1
000013B4  700E                     693          MOVE.L  #14,D0  * print the string stored in A1
000013B6  4E4F                     694          TRAP    #15
000013B8                           695          
000013B8  4E75                     696          RTS
000013BA                           697          *BRA     ITERATION * done with this op, move on to the next iteration
000013BA                           698  
000013BA                           699   * --- BITMASK ----------------------------------------------------------------
000013BA                           700   *@pre      D6 contains the starting bit you want masked, D7 the ending bit
000013BA                           701   *
000013BA                           702   *@post     D6 contains the bitmask, ready for use
000013BA                           703   
000013BA                           704  BITMASK
000013BA  3F05                     705          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
000013BC  4245                     706          CLR     D5          * clear D5 so we can use it
000013BE                           707  LOOPBIT 
000013BE  0DC5                     708          BSET    D6,D5       * set the D6th bit in D5 to 1
000013C0  5246                     709          ADD     #1,D6       * increment D6
000013C2                           710          
000013C2  BC47                     711          CMP     D7,D6       * have we finished?
000013C4  6E00 0004                712          BGT     BITMASKDONE * yes
000013C8  60F4                     713          BRA     LOOPBIT     * no, iterate again
000013CA                           714          
000013CA                           715  BITMASKDONE
000013CA                           716  
000013CA  2C05                     717          MOVE.L  D5,D6
000013CC  3A1F                     718          MOVE    (A7)+,D5    * restore D5
000013CE  4E75                     719          RTS
000013D0                           720          
000013D0                           721   * --- OP0100 -----------------------------------------------------------------
000013D0                           722   * @pre      D2 contains the opcode
000013D0                           723   *
000013D0                           724   * @post     all registers are returned to their previous state
000013D0                           725  
000013D0                           726  
000013D0                           727  
000013D0                           728   * ----------------------------------------------------------------------------
000013D0                           729   * ----------------------------------------------------------------------------
000013D0                           730   * Constants for printing information to the console
000013D0                           731  
000013D0  =0000000D                732  CR      EQU     $0D
000013D0  =0000000A                733  LF      EQU     $0A
000013D0= 45 4E 54 45 52 20 ...    734  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
000013E8= 45 4E 54 45 52 20 ...    735  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
000013FE= 0D 0A 00                 736  NEWLINE     DC.B    CR,LF,0
00001401= 4E 4F 50 00              737  NOOPERATION DC.B    'NOP',0
00001405= 4E 45 47 00              738  NEGOP       DC.B    'NEG',0
00001409= 4D 4F 56 45 4D 00        739  MOVEMOP     DC.B    'MOVEM',0
0000140F= 4A 53 52 00              740  JSROP       DC.B    'JSR',0
00001413= 52 54 53 00              741  RTSOP       DC.B    'RTS',0
00001417= 4C 45 41 00              742  LEAOP       DC.B    'LEA',0
0000141B= 42 43 4C 52 00           743  BCLROP      DC.B    'BCLR',0
00001420= 4F 52 49 00              744  ORIOP       DC.B    'ORI',0
00001424= 43 4D 50 49 00           745  CMPIOP      DC.B    'CMPI',0
00001429= 20 44 41 54 41 20 ...    746  DATA        DC.B    ' DATA $',0
00001431                           747  
00001431                           748   * ----------------------------------------------------------------------------
00001431                           749   * ----------------------------------------------------------------------------
00001431                           750   * Data defined constants
00001431                           751   *   - B/W/L (representing Byte, Word, Long)
00001431                           752   *   - A0-A7 (representing the 8 address registers)
00001431                           753   *   - D0-D7 (representing the 8 data registers)
00001431                           754   * ----------------------------------------------------------------------------
00001431                           755  
00001431= 23                       756  IMD        DC.B    '#'
00001432= 2C                       757  COMMA      DC.B    ','
00001433= 42 20                    758  __B        DC.B    'B '
00001435= 57 20                    759  __W        DC.B    'W '
00001437= 4C 20                    760  __L        DC.B    'L '
00001439                           761  
00001439= 41 30                    762  __A0        DC.B   'A0'
0000143B= 41 31                    763  __A1        DC.B   'A1'    
0000143D= 41 32                    764  __A2        DC.B   'A2'
0000143F= 41 33                    765  __A3        DC.B   'A3'
00001441= 41 34                    766  __A4        DC.B   'A4'
00001443= 41 35                    767  __A5        DC.B   'A5'
00001445= 41 36                    768  __A6        DC.B   'A6'
00001447= 41 37                    769  __A7        DC.B   'A7'
00001449                           770  
00001449= 44 30                    771  __D0        DC.B   'D0'
0000144B= 44 31                    772  __D1        DC.B   'D1'
0000144D= 44 32                    773  __D2        DC.B   'D2'
0000144F= 44 33                    774  __D3        DC.B   'D3'
00001451= 44 34                    775  __D4        DC.B   'D4'
00001453= 44 35                    776  __D5        DC.B   'D5'
00001455= 44 36                    777  __D6        DC.B   'D6'
00001457= 44 37                    778  __D7        DC.B   'D7'
00001459                           779   * ---------------------------------------------------------------------------
00001459                           780   * End of definition segment
00001459                           781   * ---------------------------------------------------------------------------
00001459                           782   * ---------------------------------------------------------------------------
00001459                           783  
00001459                           784  * Put variables and constants here
00001459                           785  
00004000                           786      ORG $4000
00004000                           787  
00004000  4E71                     788      NOP
00004002  103C 009A                789      MOVE.B   #%10011010, D0
00004006  123C 00A9                790      MOVE.B   #%10101001, D1
0000400A  D200                     791      ADD.B    D0,D1
0000400C  48A7 4000                792      MOVEM    D1,-(A7)
00004010  43F8 140F                793      LEA      JSROP,A1
00004014  4443                     794      NEG.W    D3
00004016  4EB9 0000401C            795      JSR      END
0000401C                           796  
0000401C                           797  END
0000401C  4E75                     798      RTS
0000401E                           799  RLLYEND
0000401E                           800      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BCLROP              141B
BITMASK             13BA
BITMASKDONE         13CA
CMPIBYTE            10E0
CMPIEA              1154
CMPILONG            112E
CMPIOP              1424
CMPIREG             11C0
CMPIREG000          11DE
CMPIREG001          11DE
CMPIWORD            1108
COMMA               1432
CR                  D
DATA                1429
DONE                1388
END                 401C
IMD                 1431
ISCMPI              10A6
ISORI               10A6
ITERATION           1050
JSROP               140F
LEAOP               1417
LF                  A
LOOP                103A
LOOPBIT             13BE
MODE_AN             129E
MODE_DN             11DE
MODE_IAN            129E
MODE_IAN_POS        129E
MODE_IAN_PRE        129E
MOVEMOP             1409
MSGEND              13E8
MSGSTART            13D0
NEGOP               1405
NEWLINE             13FE
NEXT                104C
NOOPERATION         1401
NOTBCLR             1084
NOTJSR              133E
NOTMOVEM            1318
NOTNEG              12F4
NOTNOP              12D2
NOTRTS              1360
OP0000              105A
OP0001              129E
OP0010              129E
OP0011              129E
OP0100              12B6
OP0101              1390
OP0110              1390
OP0111              1390
OP1000              1390
OP1001              1390
OP1010              1390
OP1011              1390
OP1100              1390
OP1101              1390
OP1110              1390
OP1111              1390
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
ORIOP               1420
PRINTD0             122E
PRINTD1             123C
PRINTD2             124A
PRINTD3             1258
PRINTD4             1266
PRINTD5             1274
PRINTD6             1282
PRINTD7             1290
RLLYEND             401E
RTSOP               1413
START               1000
UNKNOWN             1384
UNKNOWNOP           1390
__A0                1439
__A1                143B
__A2                143D
__A3                143F
__A4                1441
__A5                1443
__A6                1445
__A7                1447
__B                 1433
__D0                1449
__D1                144B
__D2                144D
__D3                144F
__D4                1451
__D5                1453
__D6                1455
__D7                1457
__L                 1437
__W                 1435
