00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/6/2014 6:11:45 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001C0A             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001C22             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001C38             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0BBC                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 0260                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 02B6                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 02AC                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 02AA                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 03C6                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 03BC                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 0460                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 0456                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 04DA                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 04D0                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 04C6                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 04BC                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 04B2                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 04A8                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 049E                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 08FA                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2EDE                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 C0C0                212          MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0A96                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162  0C46 0180                218          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0012                219          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           220          
0000116A  43F9 00001C5F            221          LEA     BCLROP,A1           * We found BCLR
00001170  103C 000E                222          MOVE.B  #14,D0              * Trap #14 prints out the data
00001174  4E4F                     223          TRAP    #15                 * Perform Trap #14
00001176  6000 013C                224          BRA     END0000              * Found the op, move to next iteration
0000117A                           225  
0000117A                           226  NOTBCLR * Possible options left are ORI or CMPI
0000117A  3C3C 0009                227          MOVE.W  #9, D6              * Prep lower value for bitmask
0000117E  3E3C 000B                228          MOVE.W  #11, D7             * Prep upper value for bitmask
00001182  6100 0A70                229          BSR     BITMASK             * Finalize bitmask setup
00001186  CC42                     230          AND     D2,D6               * Apply bitmask
00001188                           231          
00001188  0C46 0000                232          CMPI    #%0000000000000000, D6  * Are we ORI?
0000118C  6700 000E                233          BEQ     ISORI                   * If ORI, branch to ISORI
00001190                           234          
00001190  0C46 0C00                235          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
00001194  6700 0006                236          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
00001198                           237          
00001198  6600 08A2                238          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
0000119C                           239                                          * We don't deal too kindly with imposters.
0000119C                           240          
0000119C                           241  ISORI   * TODO
0000119C                           242          
0000119C                           243  
0000119C                           244  ISCMPI
0000119C  43F9 00001C6C            245          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000011A2  103C 000E                246          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000011A6  4E4F                     247          TRAP    #15                 * Perform Trap #14
000011A8                           248          
000011A8                           249          * Determine the Size
000011A8  3C3C 0006                250          MOVE.W  #6, D6              * Prep lower value for bitmask
000011AC  3E3C 0007                251          MOVE.W  #7, D7              * Prep upper value for bitmask
000011B0  6100 0A42                252          BSR     BITMASK             * Finalize bitmask setup
000011B4  CC42                     253          AND     D2,D6               * Apply bitmask
000011B6                           254          
000011B6  0C46 00C0                255          CMPI    #%0000000011000000, D6  * Imposter Op
000011BA  6700 0880                256          BEQ     UNKNOWNOP               * Deal with the imposter
000011BE                           257          
000011BE  0C46 0000                258          CMPI    #%0000000000000000, D6  * The size is a BYTE
000011C2  6700 0012                259          BEQ     CMPIBYTE                * Branch to CMPI.B
000011C6                           260          
000011C6  0C46 0040                261          CMPI    #%0000000001000000, D6  * The size is a WORD
000011CA  6700 0032                262          BEQ     CMPIWORD                * Branch to CMPI.W
000011CE                           263          
000011CE  0C46 0080                264          CMPI    #%0000000010000000, D6  * The size is a LONG
000011D2  6700 0050                265          BEQ     CMPILONG                * Branch to CMPI.L
000011D6                           266          
000011D6                           267  CMPIBYTE
000011D6  43F9 00001CC7            268          LEA     __B, A1     * Load .B
000011DC  103C 000E                269          MOVE.B  #14, D0     * Print out data
000011E0  4E4F                     270          TRAP    #15         * Perform Trap #14
000011E2                           271          
000011E2  43F9 00001CBB            272          LEA     IMD, A1     * Load #
000011E8  103C 000E                273          MOVE.B  #14, D0     * Print out data
000011EC  4E4F                     274          TRAP    #15         * Perform Trap #14
000011EE                           275          
000011EE  361A                     276          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
000011F0  1203                     277          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
000011F2  3622                     278          MOVE.W  -(A2),D3    * Now go back
000011F4  103C 000E                279          MOVE.B  #14, D0     * Print out the data
000011F8  4E4F                     280          TRAP    #15         * Perform Trap #14 
000011FA                           281          
000011FA  6000 004E                282          BRA     CMPIEA      * Branch to determine Effective Address
000011FE                           283          
000011FE                           284  CMPIWORD
000011FE  43F9 00001CCB            285          LEA     __W, A1     * Load .W
00001204  103C 000E                286          MOVE.B  #14, D0     * Print out data
00001208  4E4F                     287          TRAP    #15         * Perform Trap #14
0000120A                           288          
0000120A  43F9 00001CBB            289          LEA     IMD, A1     * Load #
00001210  103C 000E                290          MOVE.B  #14, D0     * Print out data
00001214  4E4F                     291          TRAP    #15         * Perform Trap #14
00001216                           292          
00001216  361A                     293          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001218  3222                     294          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
0000121A  103C 000E                295          MOVE.B  #14, D0     * Print out the data
0000121E  4E4F                     296          TRAP    #15         * Perform Trap #14
00001220                           297          
00001220                           298          
00001220  6000 0028                299          BRA     CMPIEA      * Branch to determine Effective Address
00001224                           300          
00001224                           301  CMPILONG
00001224  43F9 00001CCF            302          LEA     __L, A1     * Load .L
0000122A  103C 000E                303          MOVE.B  #14, D0     * Print out data
0000122E  4E4F                     304          TRAP    #15         * Perform Trap #14
00001230                           305          
00001230  43F9 00001CBB            306          LEA     IMD, A1     * Load #
00001236  103C 000E                307          MOVE.B  #14, D0     * Print out data
0000123A  4E4F                     308          TRAP    #15         * Perform Trap #14
0000123C                           309          
0000123C  361A                     310          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000123E  2222                     311          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
00001240  103C 000E                312          MOVE.B  #14, D0     * Print out the data
00001244  4E4F                     313          TRAP    #15         * Perform Trap #14
00001246                           314          
00001246  6000 0002                315          BRA     CMPIEA      * Branch to determine Effective Address
0000124A                           316          
0000124A                           317  CMPIEA
0000124A                           318          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
0000124A  43F9 00001CBD            319          LEA     COMMA, A1   * Load ,
00001250  103C 000E                320          MOVE.B  #14, D0     * Print out data
00001254  4E4F                     321          TRAP    #15         * Perform Trap #14
00001256                           322          
00001256  43F9 00001CCF            323          LEA     __L, A1     * Load .L
0000125C  103C 000E                324          MOVE.B  #14, D0     * Print out data
00001260  4E4F                     325          TRAP    #15         * Perform Trap #14
00001262                           326          
00001262                           327          * Determine the mode
00001262  3C3C 0003                328          MOVE.W  #3, D6              * Prep lower value for bitmask
00001266  3E3C 0005                329          MOVE.W  #5, D7              * Prep upper value for bitmask
0000126A  6100 0988                330          BSR     BITMASK             * Finalize bitmask setup
0000126E  CC42                     331          AND     D2,D6               * Apply bitmask
00001270                           332          
00001270  0C46 0008                333          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
00001274  6700 07C6                334          BEQ     UNKNOWNOP               * Imposter op
00001278                           335          
00001278  0C46 0028                336          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
0000127C  6700 07BE                337          BEQ     UNKNOWNOP               * Imposter op
00001280                           338          
00001280  0C46 0030                339          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
00001284  6700 07B6                340          BEQ     UNKNOWNOP               * Imposter op
00001288                           341  
00001288  0C46 0038                342          CMPI    #%0000000000111000, D6  * Is the Mode 111?
0000128C  6700 0008                343          BEQ     CMPIREG                 * Further investigation is needed
00001290                           344          
00001290                           345          * will need to call the EA helpers when they are complete
00001290                           346          
00001290                           347          * Mode is verified to be valid at this point
00001290                           348          *CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
00001290                           349          *BSR     MODE_DN
00001290                           350          
00001290                           351          *CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
00001290                           352          *BSR     MODE_AN
00001290                           353          
00001290                           354          *CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
00001290                           355          *BSR     MODE_IAN_POS
00001290                           356          
00001290                           357          *CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
00001290                           358          *BSR     MODE_IAN_PRE
00001290                           359          
00001290                           360          * Reached End of CMPI. Everything has been printed out
00001290  4C9F 0303                361          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001294  4E75                     362          RTS
00001296                           363          
00001296                           364  CMPIREG
00001296  3C3C 0000                365          MOVE.W  #0, D6              * Prep lower value for bitmask
0000129A  3E3C 0002                366          MOVE.W  #2, D7              * Prep upper value for bitmask
0000129E  6100 0954                367          BSR     BITMASK             * Finalize bitmask setup
000012A2  CC42                     368          AND     D2,D6               * Apply bitmask
000012A4                           369          
000012A4  0C46 0000                370          CMPI    #%0000000000000000, D6  * Is the Register 000?
000012A8  6700 0010                371          BEQ     CMPIREG000
000012AC                           372          
000012AC  0C46 0001                373          CMPI    #%0000000000000001, D6  * Is the Register 001?
000012B0  6700 0008                374          BEQ     CMPIREG001
000012B4                           375          
000012B4                           376  END0000          
000012B4  4C9F 0303                377         MOVEM   (A7)+,D0-D1/A0-A1   * Push values to the stack to save
000012B8  4E75                     378         RTS
000012BA                           379         
000012BA                           380  CMPIREG000  * TODO (xxx).W for CMPI
000012BA                           381  
000012BA                           382  CMPIREG001  * TODO (xxx).L for CMPI
000012BA                           383  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012BA                           384  *-----------------------------------------------------------------------------
000012BA                           385  
000012BA                           386  
000012BA                           387  
000012BA                           388  *-----------------------------------------------------------------------------
000012BA                           389  *-----------------------------------------------------------------------------
000012BA                           390  * NAME: OP_0001   (MOVE.B)
000012BA                           391  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012BA                           392  * PRE-CONDITION:  xyz
000012BA                           393  * POST-CONDITION: All registers return to their previous state, and the output
000012BA                           394  *                 goes to the output console for reading the raw data or the
000012BA                           395  *                 actual instruction.
000012BA                           396  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012BA                           397  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012BA                           398  OP0001  
000012BA  48A7 FFC0                399          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
000012BE  3C3C 0006                400          MOVE.W  #6, D6              * Prep lower value for bitmask
000012C2  3E3C 0008                401          MOVE.W  #8, D7              * Prep upper value for bitmask
000012C6  6100 092C                402          BSR     BITMASK             * Finalize bitmask setup
000012CA  CC42                     403          AND     D2,D6               * Apply bitmask
000012CC                           404          
000012CC                           405          * I may have fucked off this part, sorry - Caleb
000012CC                           406          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
000012CC                           407          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
000012CC                           408          
000012CC  43F9 00001C48            409          LEA     MOVEOP,A1   * Put 'MOVE' into the window
000012D2  103C 000E                410          MOVE.B  #14,D0      * Trap #14 to print out
000012D6  4E4F                     411          TRAP    #15         * Perform Trap #14
000012D8                           412          
000012D8                           413          *-----------------------------------------------------------
000012D8                           414          * the following code is to move the size bits into the
000012D8                           415          * 0-1 positions of D3 so that eahelper05 case use that as a "parameter"
000012D8                           416          * for eahelper05
000012D8                           417          
000012D8  3C3C 000C                418          MOVE.W  #12, D6              * Prep lower value for bitmask
000012DC  3E3C 000D                419          MOVE.W  #13, D7              * Prep upper value for bitmask
000012E0  6100 0912                420          BSR     BITMASK             * Finalize bitmask setup
000012E4                           421          
000012E4  CC42                     422          AND     D2,D6
000012E6                           423          
000012E6  E04E                     424          LSR     #8,D6
000012E8  E84E                     425          LSR     #4,D6
000012EA                           426          
000012EA  4243                     427          CLR     D3
000012EC                           428          
000012EC  1606                     429          MOVE.B  D6,D3
000012EE                           430          
000012EE                           431          *---------------------------------------------------------------
000012EE                           432          
000012EE                           433          
000012EE  6100 0686                434          BSR     SIZE67
000012F2  6100 032C                435          BSR     EAHELPER05
000012F6                           436          
000012F6  43F9 00001CBD            437          LEA     COMMA,A1
000012FC  103C 000E                438          MOVE.B  #14,D0
00001300  4E4F                     439          TRAP    #15
00001302                           440          
00001302  6100 02DA                441          BSR     EAHELPER611
00001306                           442          
00001306  43F9 00001C38            443          LEA     NEWLINE,A1
0000130C  103C 000E                444          MOVE.B  #14,D0
00001310  4E4F                     445          TRAP    #15
00001312                           446          
00001312  6000 0006                447          BRA     ENDOP0001
00001316                           448          *LEA     __B,A1      * Put '.B' into the window
00001316                           449          *MOVE.B  #14,D0      * Trap #14 to print out
00001316                           450          *TRAP    #15         * Perform Trap #14
00001316                           451          
00001316                           452  UNKNOWNOP0001
00001316                           453  
00001316  6100 0724                454          BSR     UNKNOWNOP
0000131A                           455          
0000131A                           456  ENDOP0001
0000131A                           457  
0000131A  4C9F 03FF                458          MOVEM (A7)+,D0-D7/A0-A1
0000131E  4E75                     459          RTS        
00001320                           460          
00001320                           461          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
00001320                           462  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001320                           463  *-----------------------------------------------------------------------------
00001320                           464  
00001320                           465  
00001320                           466  
00001320                           467  *-----------------------------------------------------------------------------
00001320                           468  *-----------------------------------------------------------------------------
00001320                           469  * NAME: OP_0010   (MOVE.L, MOVEA.L)
00001320                           470  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001320                           471  * PRE-CONDITION:  xyz
00001320                           472  * POST-CONDITION: All registers return to their previous state, and the output
00001320                           473  *                 goes to the output console for reading the raw data or the
00001320                           474  *                 actual instruction.
00001320                           475  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001320                           476  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001320                           477  OP0010
00001320                           478  
00001320  6100 071A                479      BSR     UNKNOWNOP
00001324  4E75                     480      RTS
00001326                           481  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001326                           482  *-----------------------------------------------------------------------------
00001326                           483  
00001326                           484  
00001326                           485  
00001326                           486  *-----------------------------------------------------------------------------
00001326                           487  *-----------------------------------------------------------------------------
00001326                           488  * NAME: OP_0011   (MOVE.W, MOVEA.W)
00001326                           489  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001326                           490  * PRE-CONDITION:  xyz
00001326                           491  * POST-CONDITION: All registers return to their previous state, and the output
00001326                           492  *                 goes to the output console for reading the raw data or the
00001326                           493  *                 actual instruction.
00001326                           494  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001326                           495  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001326                           496  OP0011
00001326  48A7 FFFE                497      MOVEM   D0-D7/A0-A6, -(A7)
0000132A                           498      
0000132A                           499      *MOVE.W  #6,D6
0000132A                           500      *MOVE.W  #8,D7
0000132A                           501      
0000132A                           502      *BSR     BITMASK
0000132A                           503      
0000132A                           504      *AND.W   D2,D6
0000132A                           505      
0000132A                           506      *CMP     #%0000000001000000,D6
0000132A                           507      *BNE     NEXT15
0000132A                           508      *BSR     * for MOVEA.W
0000132A                           509      
0000132A  4C9F 7FFF                510      MOVEM   (A7)+,D0-D7/A0-A6
0000132E                           511      
0000132E  6100 070C                512      BSR     UNKNOWNOP
00001332  4E75                     513      RTS
00001334                           514  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001334                           515  *-----------------------------------------------------------------------------
00001334                           516  
00001334                           517  
00001334                           518  
00001334                           519  *-----------------------------------------------------------------------------
00001334                           520  *-----------------------------------------------------------------------------
00001334                           521  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
00001334                           522  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001334                           523  * PRE-CONDITION:  xyz
00001334                           524  * POST-CONDITION: All registers return to their previous state, and the output
00001334                           525  *                 goes to the output console for reading the raw data or the
00001334                           526  *                 actual instruction.
00001334                           527  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001334                           528  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001334                           529  OP0100  
00001334                           530          * TODO: lea, movem
00001334                           531  
00001334  48A7 C0C0                532          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001338                           533          
00001338                           534          *NOP
00001338  0C42 4E71                535          CMPI    #%0100111001110001,D2
0000133C  6600 0012                536          BNE     NOTNOP
00001340                           537          
00001340  43F9 00001C40            538          LEA     NOOPERATION,A1
00001346  103C 000D                539          MOVE.B  #13,D0          * Print a newline
0000134A  4E4F                     540          TRAP    #15
0000134C                           541          
0000134C  6000 0108                542          BRA     DONE *we found it, move on to the next iteration
00001350                           543  NOTNOP *NEG
00001350                           544          
00001350                           545          * prep values for BITMASK subroutine
00001350  7C08                     546          MOVE.L  #8,D6
00001352  7E0B                     547          MOVE.L  #11,D7
00001354                           548          
00001354  6100 089E                549          BSR     BITMASK
00001358                           550          
00001358  CC42                     551          AND     D2,D6                   * apply bitmask
0000135A                           552          
0000135A  0C46 0400                553          CMPI    #%0000010000000000,D6   * are we NEG?
0000135E  6600 0046                554          BNE     NOTNEG                  * not neg
00001362                           555          
00001362  7C03                     556          MOVE.L  #3,D6
00001364  7E05                     557          MOVE.L  #5,D7
00001366                           558          
00001366  6100 088C                559          BSR     BITMASK * generate a bitmask to be used to check mode
0000136A                           560          
0000136A  0C46 0008                561          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
0000136E  6700 00E2                562          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001372                           563          
00001372  0C46 0028                564          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001376  6700 00DA                565          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000137A                           566          
0000137A  0C46 0030                567          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000137E  6700 00D2                568          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001382                           569        
00001382                           570          * it is NEG, print
00001382  43F9 00001C44            571          LEA     NEGOP,A1
00001388  103C 000E                572          MOVE.B  #14,D0
0000138C  4E4F                     573          TRAP    #15
0000138E                           574          
0000138E  6100 05E6                575          BSR     SIZE67
00001392                           576          
00001392  6100 028C                577          BSR     EAHELPER05
00001396                           578          
00001396  43F9 00001C38            579          LEA     NEWLINE,A1
0000139C  103C 000E                580          MOVE.B  #14,D0
000013A0  4E4F                     581          TRAP    #15
000013A2                           582          
000013A2  6000 00B2                583          BRA     DONE * we found the op, move to next iteration
000013A6                           584          
000013A6                           585  NOTNEG *MOVEM
000013A6                           586  
000013A6                           587          * prep values for BITMASK subroutine
000013A6  7C07                     588          MOVE.L  #7,D6
000013A8  7E09                     589          MOVE.L  #9,D7
000013AA                           590          
000013AA  6100 0848                591          BSR     BITMASK
000013AE                           592          
000013AE  CC42                     593          AND     D2,D6   * apply bitmask
000013B0                           594          
000013B0  0C46 0080                595          CMPI    #%0000000010000000,D6 * is it MOVEM?
000013B4  6600 0014                596          BNE     NOTMOVEM          * it is not MOVEM
000013B8                           597          
000013B8                           598          * make sure it is a valid size and mode for MOVEM
000013B8                           599          
000013B8                           600          * it is MOVEM
000013B8  43F9 00001C4D            601          LEA     MOVEMOP,A1
000013BE  103C 000D                602          MOVE.B  #13,D0          * Print a newline
000013C2  4E4F                     603          TRAP    #15
000013C4                           604          
000013C4                           605          * probably needs its own special code for printing the rest due to uniqueness of movem
000013C4                           606          
000013C4  341A                     607          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013C6                           608          
000013C6  6000 008E                609          BRA     DONE          * we found and printed, move on to the next iteration
000013CA                           610          
000013CA                           611  NOTMOVEM *JSR
000013CA                           612          * prep values for BITMASK subroutine
000013CA  7C06                     613          MOVE.L  #6,D6
000013CC  7E08                     614          MOVE.L  #8,D7
000013CE                           615          
000013CE  6100 0824                616          BSR     BITMASK
000013D2                           617          
000013D2  CC42                     618          AND     D2,D6   * apply bitmask
000013D4                           619          
000013D4  0C46 0080                620          CMPI    #%0000000010000000,D6
000013D8  6600 0032                621          BNE     NOTJSR          * it's not JSR
000013DC                           622          
000013DC  43F9 00001C53            623          LEA     JSROP,A1
000013E2  103C 000E                624          MOVE.B  #14,D0          * Print a newline and JSR
000013E6  4E4F                     625          TRAP    #15
000013E8                           626          
000013E8                           627          * print out where we are jumping to
000013E8                           628          
000013E8  341A                     629          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013EA                           630          
000013EA  2202                     631          MOVE.L  D2,D1   * save the opcode to print
000013EC                           632          
000013EC  7410                     633          MOVE.L  #16,D2  * set the base to 16
000013EE                           634          
000013EE  700F                     635          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000013F0  4E4F                     636          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000013F2                           637          
000013F2  341A                     638          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013F4                           639          
000013F4  2202                     640          MOVE.L  D2,D1   * save the opcode to print
000013F6                           641          
000013F6  7410                     642          MOVE.L  #16,D2  * set the base to 16
000013F8                           643          
000013F8  700F                     644          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000013FA  4E4F                     645          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000013FC                           646          
000013FC  43F9 00001C38            647          LEA     NEWLINE,A1
00001402  103C 000E                648          MOVE.B  #14,D0          * Print a newline
00001406  4E4F                     649          TRAP    #15
00001408                           650          
00001408  6000 004C                651          BRA     DONE          * we already found instruction, next iteration
0000140C                           652  NOTJSR *RTS
0000140C                           653  
0000140C                           654          * prep values for BITMASK subroutine
0000140C  7C06                     655          MOVE.L  #6,D6
0000140E  7E08                     656          MOVE.L  #8,D7
00001410                           657          
00001410  6100 07E2                658          BSR     BITMASK
00001414                           659          
00001414  CC42                     660          AND     D2,D6   * apply bitmask
00001416                           661          
00001416  0C46 0040                662          CMPI    #%0000000001000000,D6
0000141A  6600 0012                663          BNE     NOTRTS          * it's not RTS
0000141E                           664          
0000141E  43F9 00001C57            665          LEA     RTSOP,A1
00001424  103C 000D                666          MOVE.B  #13,D0          * Print a newline and RTS
00001428  4E4F                     667          TRAP    #15
0000142A                           668          
0000142A  6000 002A                669          BRA     DONE          * we already found instruction, next iteration
0000142E                           670  NOTRTS  *LEA
0000142E                           671         
0000142E                           672          * prep values for BITMASK subroutine
0000142E  7C06                     673          MOVE.L  #6,D6
00001430  7E08                     674          MOVE.L  #8,D7
00001432                           675          
00001432  6100 07C0                676          BSR     BITMASK
00001436                           677          
00001436  CC42                     678          AND     D2,D6   * apply bitmask
00001438                           679          
00001438  0C46 01C0                680          CMPI    #%0000000111000000,D6
0000143C  6600 0014                681          BNE     UNKNOWN          * it's not LEA, we dont know what it is
00001440                           682          
00001440                           683          * check to make sure it is a supported mode and size
00001440                           684          
00001440  43F9 00001C5B            685          LEA     LEAOP,A1
00001446  103C 000D                686          MOVE.B  #13,D0          * Print LEA
0000144A  4E4F                     687          TRAP    #15
0000144C                           688          
0000144C                           689          * call EA helper
0000144C  341A                     690          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000144E                           691                  
0000144E  6000 0006                692          BRA     DONE          * we already found instruction, next iteration
00001452                           693          
00001452                           694  UNKNOWN *dont know what it is
00001452  6100 05E8                695          BSR     UNKNOWNOP
00001456                           696          
00001456                           697  DONE
00001456  4C9F 0303                698          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
0000145A  4E75                     699          RTS
0000145C                           700          
0000145C  6000 FCE6                701          BRA     ITERATION
00001460                           702  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001460                           703  *-----------------------------------------------------------------------------        
00001460                           704          
00001460                           705          
00001460                           706  
00001460                           707  *-----------------------------------------------------------------------------
00001460                           708  *-----------------------------------------------------------------------------
00001460                           709  * NAME: OP_0101   (SUBQ)
00001460                           710  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001460                           711  * PRE-CONDITION:  xyz
00001460                           712  * POST-CONDITION: All registers return to their previous state, and the output
00001460                           713  *                 goes to the output console for reading the raw data or the
00001460                           714  *                 actual instruction.
00001460                           715  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001460                           716  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001460                           717  OP0101
00001460                           718  
00001460  6100 05DA                719      BSR     UNKNOWNOP
00001464  4E75                     720      RTS
00001466                           721  
00001466                           722  * testing branching
00001466                           723  * op op op
00001466                           724  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001466                           725  *-----------------------------------------------------------------------------
00001466                           726  
00001466                           727  
00001466                           728  
00001466                           729  *-----------------------------------------------------------------------------
00001466                           730  *-----------------------------------------------------------------------------
00001466                           731  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
00001466                           732  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001466                           733  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
00001466                           734  *                 in the instruction and determines what the bits match to a
00001466                           735  *                 given condition code. If the 8 bit offset is $00, or $FF,
00001466                           736  *                 this signifies a word or long offset (for $00 and $FF
00001466                           737  *                 respectively). The 8 bit offset is in 2's comp. form, and
00001466                           738  *                 should be un-done, then plus or minus to the current
00001466                           739  *                 program counter (PC) to get the actual memory label to
00001466                           740  *                 output to console. The word offset signal eats an
00001466                           741  *                 additional 16 bits and the long offset eats an additional
00001466                           742  *                 32 bits. The word/long offset are for memory alignment.
00001466                           743  * POST-CONDITION: All registers return to their previous state, and the output
00001466                           744  *                 goes to the output console for reading the raw data or the
00001466                           745  *                 actual instruction.
00001466                           746  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001466                           747  *                 A1 (output)
00001466                           748  * CONDITIONS TABLE:
00001466                           749  *                Condition Names  - Mnemonic - Condition Code
00001466                           750  *                --------------------------------------------
00001466                           751  *                True             -    T     - 0000
00001466                           752  *                False            -    F     - 0001
00001466                           753  *                Higher           -    HI    - 0010
00001466                           754  *                Lower or Same    -    LS    - 0011
00001466                           755  *                Carry Clear      -    CC    - 0100
00001466                           756  *                Carry Set        -    CS    - 0101
00001466                           757  *                Not Equal        -    NE    - 0110
00001466                           758  *                Equal            -    EQ    - 0111
00001466                           759  *                Overflow Clear   -    VC    - 1000
00001466                           760  *                Overflow Set     -    VS    - 1001
00001466                           761  *                Plus             -    PL    - 1010
00001466                           762  *                Minus            -    MI    - 1011
00001466                           763  *                Greater or Equal -    GE    - 1100
00001466                           764  *                Less Than        -    LT    - 1101
00001466                           765  *                Greater Than     -    GT    - 1110
00001466                           766  *                Less or Equal    -    LE    - 1111
00001466                           767  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001466                           768  OP0110
00001466  48A7 C0C0                769          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
0000146A                           770          
0000146A                           771          * Ready four bits to help distinguish op's with the 0110 prefix
0000146A  3C3C 0000                772          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
0000146E                           773                                        * BITMASK sub-routine call)
0000146E  3E3C 0007                774          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001472                           775                                        * BITMASK sub-routine call)
00001472                           776                                        
00001472                           777          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001472  6100 0780                778          BSR     BITMASK               * Call BITMASK sub-routine
00001476                           779                                        * Returns a bitmask in D6
00001476                           780          
00001476  CC42                     781          AND     D2,D6                 * And the index op, which was pre-loaded
00001478                           782                                        * in the main memory loop with the bitmask
00001478                           783                                        * to use to determine what case we need.
00001478                           784          
00001478                           785          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
00001478                           786          * $00 == word offset, $FF == long offset
00001478                           787       ***CMPI    #%0000000000000000,D6
00001478                           788       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
00001478                           789       ***
00001478                           790       ***CMPI    #%0000000011111111,D6
00001478                           791       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
00001478                           792          
00001478                           793          * IF PASSED BOTH CMPI CHECKS (ABOVE),
00001478                           794          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
00001478                           795          
00001478  3C3C 0009                796          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
0000147C  3E3C 000B                797          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
00001480                           798                                        
00001480                           799          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001480  6100 0772                800          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
00001484  CC42                     801          AND     D2,D6   * apply the BITMASK
00001486                           802          
00001486                           803          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001486  0C46 0400                804          CMPI    #%0000010000000000,D6
0000148A  6700 002A                805          BEQ     OP_BCC
0000148E                           806          
0000148E                           807          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
0000148E  0C46 0500                808          CMPI    #%0000010100000000,D6
00001492  6700 002C                809          BEQ     OP_BCS
00001496                           810          
00001496                           811          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001496  0C46 0C00                812          CMPI    #%0000110000000000,D6
0000149A  6700 002E                813          BEQ     OP_BGE
0000149E                           814          
0000149E                           815          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
0000149E  0C46 0D00                816          CMPI    #%0000110100000000,D6
000014A2  6700 0030                817          BEQ     OP_BLT
000014A6                           818          
000014A6                           819          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
000014A6  0C46 0800                820          CMPI    #%0000100000000000,D6
000014AA  6700 0032                821          BEQ     OP_BVC
000014AE                           822          
000014AE                           823          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
000014AE                           824          * NOTE: A branch to the immediately following instruction automatically
000014AE                           825          *       uses the 16-bit displacement format because the 8-bit displacement
000014AE                           826          *       field contains $00 zero offset
000014AE                           827          * http://68k.hax.com/BRA
000014AE                           828          * NOTE2 ---> Does this mean, there should be no checks when debugging
000014AE                           829          *            for word/long offsets?
000014AE  0C46 0000                830          CMPI    #%0000000000000000,D6
000014B2  6700 0034                831          BEQ     OP_BRA
000014B6                           832          
000014B6                           833          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
000014B6                           834          ; call raw data print out sub routine
000014B6                           835  
000014B6                           836  OP_BCC
000014B6  43F9 00001C79            837          LEA     OP_BCC_MSG,A1
000014BC  6000 0034                838          BRA     OP_BRANCHES_PRINT
000014C0                           839  OP_BCS
000014C0  43F9 00001C7E            840          LEA     OP_BCS_MSG,A1
000014C6  6000 002A                841          BRA     OP_BRANCHES_PRINT
000014CA                           842  OP_BGE
000014CA  43F9 00001C83            843          LEA     OP_BGE_MSG,A1
000014D0  6000 0020                844          BRA     OP_BRANCHES_PRINT
000014D4                           845  OP_BLT
000014D4  43F9 00001C88            846          LEA     OP_BLT_MSG,A1
000014DA  6000 0016                847          BRA     OP_BRANCHES_PRINT
000014DE                           848  OP_BVC
000014DE  43F9 00001C8D            849          LEA     OP_BVC_MSG,A1
000014E4  6000 000C                850          BRA     OP_BRANCHES_PRINT
000014E8                           851  OP_BRA
000014E8  43F9 00001C92            852          LEA     OP_BRA_MSG,A1
000014EE  6000 0002                853          BRA     OP_BRANCHES_PRINT
000014F2                           854  
000014F2                           855  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000014F2                           856          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000014F2                           857          * assemble output to console
000014F2                           858  OP_BRANCHES_PRINT
000014F2  103C 000E                859          MOVE.B  #14,D0 * print instruction op
000014F6  4E4F                     860          TRAP    #15
000014F8                           861          
000014F8  43F9 00001C71            862          LEA     DATA,A1
000014FE  103C 000E                863          MOVE.B  #14,D0 * print raw data hex of the LABEL
00001502  4E4F                     864          TRAP    #15
00001504                           865          
00001504  1A1A                     866          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
00001506  2845                     867          MOVE.L  D5,A4 * ready the 8bits into a4
00001508  43D4                     868          LEA     (A4),A1 * ready the a4 into a1 for print
0000150A  103C 000E                869          MOVE.B  #14,D0 * print the 8bit addr
0000150E  4E4F                     870          TRAP    #15
00001510                           871  
00001510  6000 0002                872          BRA     BCC_END
00001514                           873  
00001514                           874  BCC_END * reload the memory, call RTS
00001514  4C9F 0303                875          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001518  4E75                     876          RTS
0000151A                           877  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000151A                           878  *-----------------------------------------------------------------------------
0000151A                           879  
0000151A                           880  
0000151A                           881  
0000151A                           882  *-----------------------------------------------------------------------------
0000151A                           883  *-----------------------------------------------------------------------------
0000151A                           884  * NAME: OP_0111   ()
0000151A                           885  * DESCRIPTION:    OP code 0111 is not supported. 
0000151A                           886  * PRE-CONDITION:  
0000151A                           887  * POST-CONDITION: 
0000151A                           888  * REGISTERS:
0000151A                           889  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000151A                           890  OP0111
0000151A  6100 0520                891      BSR     UNKNOWNOP
0000151E  4E75                     892      RTS
00001520                           893  
00001520                           894  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001520                           895  *-----------------------------------------------------------------------------
00001520                           896  
00001520                           897  
00001520                           898  
00001520                           899  *-----------------------------------------------------------------------------
00001520                           900  *-----------------------------------------------------------------------------
00001520                           901  * NAME: OP_1000   (DIVS, OR)
00001520                           902  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001520                           903  * PRE-CONDITION:  xyz
00001520                           904  * POST-CONDITION: All registers return to their previous state, and the output
00001520                           905  *                 goes to the output console for reading the raw data or the
00001520                           906  *                 actual instruction.
00001520                           907  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001520                           908  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001520                           909  OP1000
00001520                           910          * Saving values to the stack
00001520  48A7 FFC0                911          MOVEM   D0-D7/A0-A1,-(A7)
00001524                           912  
00001524                           913          * Check if the EA Mode is 001 since both DIVS and OR do not support it
00001524  3C3C 0003                914          MOVE.W  #3, D6              * Prep lower value for bitmask
00001528  3E3C 0005                915          MOVE.W  #5, D7              * Prep upper value for bitmask
0000152C  6100 06C6                916          BSR     BITMASK             * Finalize bitmask setup
00001530  CC42                     917          AND     D2,D6               * Apply bitmask
00001532                           918          
00001532  0C46 0008                919          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
00001536  6700 FF1A                920          BEQ     UNKNOWN                 * If so, the op is not supported
0000153A                           921          
0000153A                           922          * Checking for DIVS
0000153A  3C3C 0006                923          MOVE.W  #6, D6              * Prep lower value for bitmask
0000153E  3E3C 0008                924          MOVE.W  #8, D7              * Prep upper value for bitmask
00001542  6100 06B0                925          BSR     BITMASK             * Finalize bitmask setup
00001546  CC42                     926          AND     D2,D6               * Apply bitmask
00001548                           927          
00001548  0C46 01C0                928          CMPI    #%0000000111000000, D6  * Are we DIVS?
0000154C  6600 0050                929          BNE     NOTDIVS                 * If not, branch to see if it's OR
00001550                           930          
00001550  43F9 00001C3B            931          LEA     DIVSOP,A1           * We found DIVS
00001556  103C 000E                932          MOVE.B  #14,D0              * Trap #14 prints out the data
0000155A  4E4F                     933          TRAP    #15                 * Perform Trap #14
0000155C                           934          
0000155C  43F9 00001CB7            935          LEA     SPACE,A1            * formatting
00001562  103C 000E                936          MOVE.B  #14,D0              * Trap #14 prints out space
00001566  4E4F                     937          TRAP    #15                 * Perform Trap #14
00001568                           938          
00001568  4243                     939          CLR     D3                  * clear D5, it is a parameter of ea05 to indicate size
0000156A  08C3 0000                940          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
0000156E                           941                                      * to indicate a potential immediate of size word
0000156E                           942          
0000156E  6100 00B0                943          BSR     EAHELPER05          * Print out data. TODO: DOESN'T WORK.
00001572                           944  
00001572  43F9 00001CBD            945          LEA     COMMA,A1            * formatting
00001578  103C 000E                946          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000157C  4E4F                     947          TRAP    #15                 * Perform Trap #14
0000157E                           948          
0000157E                           949          *--------------------------------------------------------------------
0000157E                           950          * bit manipulation is needed to make the outlier DIVS work
0000157E                           951          * with the generic EAHELPER611
0000157E                           952          
0000157E  0882 0006                953          BCLR    #6,D2
00001582  0882 0007                954          BCLR    #7,D2
00001586  0882 0008                955          BCLR    #8,D2
0000158A                           956          
0000158A                           957          * the above bits were cleared so that eahelper05 knows the destination
0000158A                           958          * is a data register.
0000158A                           959          
0000158A  6100 0052                960          BSR     EAHELPER611         * Print out data. TODO: DOESN'T WORK
0000158E                           961                                      * it doesnt work because DIVS is an unusual op
0000158E                           962                                      * you need to do some bit manipulation to
0000158E                           963                                      * use the helpers, since they are generic
0000158E                           964                                      * and DIVS is a special case
0000158E                           965  
0000158E  43F9 00001C38            966          LEA     NEWLINE,A1          * We found DIVS
00001594  103C 000E                967          MOVE.B  #14,D0              * Trap #14 prints out the data
00001598  4E4F                     968          TRAP    #15                 * Perform Trap #14
0000159A                           969          
0000159A  6000 0012                970          BRA     OP1000END
0000159E                           971          
0000159E                           972  NOTDIVS * It is confirmed OR at this point
0000159E  43F9 00001C65            973          LEA     OROP,A1         * We found OR
000015A4  103C 000E                974          MOVE.B  #14,D0          * Trap #14 prints out the data
000015A8  4E4F                     975          TRAP    #15             * Perform Trap #14
000015AA                           976          *================================================================
000015AA                           977          * todo, move the size of the operation into the leading bits of D5
000015AA                           978          * before subroutine call
000015AA  6100 0032                979          BSR     EAHELPER611
000015AE                           980  
000015AE                           981  OP1000END
000015AE  4C9F 03FF                982          MOVEM   (A7)+,D0-D7/A0-A1
000015B2  4E75                     983          RTS
000015B4                           984  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015B4                           985  *-----------------------------------------------------------------------------
000015B4                           986  
000015B4                           987  
000015B4                           988  
000015B4                           989  *-----------------------------------------------------------------------------
000015B4                           990  *-----------------------------------------------------------------------------
000015B4                           991  * NAME: OP_1001   (SUB)
000015B4                           992  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015B4                           993  * PRE-CONDITION:  xyz
000015B4                           994  * POST-CONDITION: All registers return to their previous state, and the output
000015B4                           995  *                 goes to the output console for reading the raw data or the
000015B4                           996  *                 actual instruction.
000015B4                           997  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015B4                           998  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015B4                           999  OP1001
000015B4                          1000  
000015B4  6100 0486               1001      BSR     UNKNOWNOP
000015B8  4E75                    1002      RTS
000015BA                          1003  
000015BA                          1004  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015BA                          1005  *-----------------------------------------------------------------------------
000015BA                          1006  
000015BA                          1007  
000015BA                          1008  
000015BA                          1009  *-----------------------------------------------------------------------------
000015BA                          1010  *-----------------------------------------------------------------------------
000015BA                          1011  * NAME: OP_1010   ()
000015BA                          1012  * DESCRIPTION:    a
000015BA                          1013  * PRE-CONDITION:  b
000015BA                          1014  * POST-CONDITION: c
000015BA                          1015  * REGISTERS:      d
000015BA                          1016  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015BA                          1017  OP1010
000015BA                          1018  
000015BA  6100 0480               1019      BSR     UNKNOWNOP
000015BE  4E75                    1020      RTS
000015C0                          1021  
000015C0                          1022  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015C0                          1023  *-----------------------------------------------------------------------------
000015C0                          1024  
000015C0                          1025  
000015C0                          1026  
000015C0                          1027  *-----------------------------------------------------------------------------
000015C0                          1028  *-----------------------------------------------------------------------------
000015C0                          1029  * NAME: OP_1011   (EOR, CMP)
000015C0                          1030  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015C0                          1031  * PRE-CONDITION:  xyz
000015C0                          1032  * POST-CONDITION: All registers return to their previous state, and the output
000015C0                          1033  *                 goes to the output console for reading the raw data or the
000015C0                          1034  *                 actual instruction.
000015C0                          1035  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015C0                          1036  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015C0                          1037  OP1011
000015C0                          1038  
000015C0  6100 047A               1039      BSR     UNKNOWNOP
000015C4  4E75                    1040      RTS
000015C6                          1041  
000015C6                          1042  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015C6                          1043  *-----------------------------------------------------------------------------
000015C6                          1044  
000015C6                          1045  
000015C6                          1046  
000015C6                          1047  *-----------------------------------------------------------------------------
000015C6                          1048  *-----------------------------------------------------------------------------
000015C6                          1049  * NAME: OP_1100   (MULS)
000015C6                          1050  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015C6                          1051  * PRE-CONDITION:  xyz
000015C6                          1052  * POST-CONDITION: All registers return to their previous state, and the output
000015C6                          1053  *                 goes to the output console for reading the raw data or the
000015C6                          1054  *                 actual instruction.
000015C6                          1055  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015C6                          1056  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015C6                          1057  OP1100
000015C6                          1058  
000015C6  6100 0474               1059      BSR     UNKNOWNOP
000015CA  4E75                    1060      RTS
000015CC                          1061  
000015CC                          1062  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015CC                          1063  *-----------------------------------------------------------------------------
000015CC                          1064  
000015CC                          1065  
000015CC                          1066  
000015CC                          1067  *-----------------------------------------------------------------------------
000015CC                          1068  *-----------------------------------------------------------------------------
000015CC                          1069  * NAME: OP_1101   (ADD, ADDA)
000015CC                          1070  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015CC                          1071  * PRE-CONDITION:  xyz
000015CC                          1072  * POST-CONDITION: All registers return to their previous state, and the output
000015CC                          1073  *                 goes to the output console for reading the raw data or the
000015CC                          1074  *                 actual instruction.
000015CC                          1075  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015CC                          1076  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015CC                          1077  OP1101
000015CC                          1078  
000015CC  6100 046E               1079      BSR     UNKNOWNOP
000015D0  4E75                    1080      RTS
000015D2                          1081  
000015D2                          1082  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015D2                          1083  *-----------------------------------------------------------------------------
000015D2                          1084  
000015D2                          1085  
000015D2                          1086  
000015D2                          1087  *-----------------------------------------------------------------------------
000015D2                          1088  *-----------------------------------------------------------------------------
000015D2                          1089  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
000015D2                          1090  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015D2                          1091  * PRE-CONDITION:  xyz
000015D2                          1092  * POST-CONDITION: All registers return to their previous state, and the output
000015D2                          1093  *                 goes to the output console for reading the raw data or the
000015D2                          1094  *                 actual instruction.
000015D2                          1095  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015D2                          1096  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015D2                          1097  OP1110
000015D2                          1098  
000015D2  6100 0468               1099      BSR     UNKNOWNOP
000015D6  4E75                    1100      RTS
000015D8                          1101  
000015D8                          1102  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015D8                          1103  *-----------------------------------------------------------------------------
000015D8                          1104  
000015D8                          1105  
000015D8                          1106  
000015D8                          1107  *-----------------------------------------------------------------------------
000015D8                          1108  *-----------------------------------------------------------------------------
000015D8                          1109  * NAME: OP_1111   ()
000015D8                          1110  * DESCRIPTION:    a
000015D8                          1111  * PRE-CONDITION:  b
000015D8                          1112  * POST-CONDITION: c
000015D8                          1113  * REGISTERS:      d
000015D8                          1114  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015D8                          1115  OP1111
000015D8                          1116  
000015D8  6100 0462               1117      BSR     UNKNOWNOP
000015DC  4E75                    1118      RTS
000015DE                          1119  
000015DE                          1120  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015DE                          1121  *-----------------------------------------------------------------------------
000015DE                          1122  
000015DE                          1123  
000015DE                          1124  
000015DE                          1125  *-----------------------------------------------------------------------------
000015DE                          1126  *-----------------------------------------------------------------------------
000015DE                          1127  * NAME:           EAHELPER611
000015DE                          1128  * DESCRIPTION:    a
000015DE                          1129  * PRE-CONDITION:  D2 contains the instruction to print modes for.
000015DE                          1130  *                 D5 contains the size of the data to be printed
000015DE                          1131  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
000015DE                          1132  *                 EAHELPER05 to print.
000015DE                          1133  * REGISTERS:      a
000015DE                          1134  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015DE                          1135  EAHELPER611
000015DE  48A7 FFC0               1136      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
000015E2                          1137      
000015E2  3C3C 0006               1138      MOVE.W  #6, D6              * Prep lower value for bitmask
000015E6  3E3C 0008               1139      MOVE.W  #8, D7              * Prep upper value for bitmask
000015EA  6100 0608               1140      BSR     BITMASK             * Finalize bitmask setup
000015EE  CC42                    1141      AND     D2,D6               * Apply bitmask
000015F0                          1142      
000015F0                          1143      * to move the mode where EAHELPER50 can process it
000015F0  7C06                    1144      MOVE.L  #6,D6
000015F2  7E08                    1145      MOVE.L  #8,D7
000015F4                          1146      
000015F4  6100 05FE               1147      BSR     BITMASK * create bitmask
000015F8                          1148      
000015F8  CC42                    1149      AND     D2,D6   * apply bitmask
000015FA                          1150      
000015FA  4243                    1151      CLR     D3      * prep D3 to store values
000015FC                          1152      
000015FC  3606                    1153      MOVE.W  D6,D3   * store bitmasked value in D3
000015FE                          1154      
000015FE  E64B                    1155      LSR     #3,D3   * move bits 6-8 to 3-5
00001600                          1156      
00001600                          1157      * to move the register where EAHELPER50 can process it
00001600  7C09                    1158      MOVE.L  #9,D6   *prep registers to create bitmask
00001602  7E0B                    1159      MOVE.L  #11,D7
00001604                          1160      
00001604  6100 05EE               1161      BSR     BITMASK * create bitmask
00001608                          1162      
00001608  CC42                    1163      AND     D2,D6   * apply bitmask
0000160A                          1164      
0000160A  4244                    1165      CLR     D4      * prep D3 to store values
0000160C                          1166      
0000160C  3806                    1167      MOVE.W  D6,D4   * store bitmasked value in D3
0000160E                          1168      
0000160E  E04C                    1169      LSR     #8,D4   * move bits 9-11 to 0-2
00001610  E24C                    1170      LSR     #1,D4   * move bits 9-11 to 0-2
00001612                          1171      
00001612  8684                    1172      OR.L    D4,D3   * combind the register and mode
00001614                          1173      
00001614  2403                    1174      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
00001616                          1175      
00001616  6100 0008               1176      BSR     EAHELPER05
0000161A                          1177      
0000161A                          1178  ENDEAHELPER611
0000161A                          1179      
0000161A  4C9F 03FF               1180      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
0000161E                          1181      
0000161E  4E75                    1182      RTS
00001620                          1183  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001620                          1184  *-----------------------------------------------------------------------------
00001620                          1185  
00001620                          1186  
00001620                          1187  
00001620                          1188  *-----------------------------------------------------------------------------
00001620                          1189  *-----------------------------------------------------------------------------
00001620                          1190  * NAME:           EAHELPER05
00001620                          1191  * DESCRIPTION:    a
00001620                          1192  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
00001620                          1193  *                 this sub-routine helper for operations that only have one
00001620                          1194  *                 mode register.
00001620                          1195  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
00001620                          1196  * REGISTERS:      a
00001620                          1197  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001620                          1198  EAHELPER05
00001620                          1199      * todo: add code for printing immediate values
00001620                          1200      
00001620  48A7 FFC0               1201      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001624                          1202      
00001624  7C03                    1203      MOVE.L  #3,D6
00001626  7E05                    1204      MOVE.L  #5,D7
00001628                          1205      
00001628  6100 05CA               1206      BSR     BITMASK * generate a bitmask to identify the mode
0000162C                          1207      
0000162C  CC42                    1208      AND     D2,D6   * mask off the parts of D2 we don't need
0000162E                          1209      
0000162E  2A06                    1210      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
00001630                          1211      
00001630  0C46 0000               1212      CMPI    #%0000000000000000,D6 * is it data register direct?
00001634  6600 000A               1213      BNE     NOTDATAREG
00001638                          1214      
00001638  6100 013C               1215      BSR     MODE_DN
0000163C                          1216       
0000163C  6000 0132               1217      BRA     ENDEAHELPER05
00001640                          1218      
00001640                          1219  NOTDATAREG * address register direct
00001640                          1220      
00001640  0C46 0008               1221      CMPI    #%0000000000001000,D6 * is it address register direct?
00001644  6600 000A               1222      BNE     NOTADRDIRECT
00001648                          1223      
00001648  6100 022C               1224      BSR     MODE_AN * simply prints out the address register
0000164C                          1225       
0000164C  6000 0122               1226      BRA     ENDEAHELPER05
00001650                          1227      
00001650                          1228  NOTADRDIRECT * address register indirect
00001650                          1229          
00001650  0C46 0010               1230      CMPI    #%0000000000010000,D6 * is it address register indirect?
00001654  6600 0022               1231      BNE     NOTADRINDIRECT
00001658                          1232      
00001658  43F9 00001CBF           1233      LEA     OBRACK,A1       * Load '('
0000165E  303C 000E               1234      MOVE.W  #14,D0          * Trap #14 to display message
00001662  4E4F                    1235      TRAP    #15             * Perform #14
00001664                          1236          
00001664                          1237  
00001664  6100 0210               1238      BSR     MODE_AN * print out an address register
00001668                          1239      
00001668  43F9 00001CC1           1240      LEA     CBRACK,A1       * Load ')'
0000166E  303C 000E               1241      MOVE.W  #14,D0          * Trap #14 to display message
00001672  4E4F                    1242      TRAP    #15             * Perform #14
00001674                          1243       
00001674  6000 00FA               1244      BRA     ENDEAHELPER05
00001678                          1245      
00001678                          1246  NOTADRINDIRECT * address register indirect, post increment
00001678                          1247      
00001678  0C46 0018               1248      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
0000167C  6600 002E               1249      BNE     NOTADRINDIRECTPOST
00001680                          1250      
00001680  43F9 00001CBF           1251      LEA     OBRACK,A1       * Load '('
00001686  303C 000E               1252      MOVE.W  #14,D0          * Trap #14 to display message
0000168A  4E4F                    1253      TRAP    #15             * Perform #14
0000168C                          1254          
0000168C                          1255  
0000168C  6100 01E8               1256      BSR     MODE_AN * print out an address register
00001690                          1257      
00001690  43F9 00001CC1           1258      LEA     CBRACK,A1       * Load ')'
00001696  303C 000E               1259      MOVE.W  #14,D0          * Trap #14 to display message
0000169A  4E4F                    1260      TRAP    #15             * Perform #14
0000169C                          1261      
0000169C  43F9 00001CC3           1262      LEA     PLUS,A1       * Load '+'
000016A2  303C 000E               1263      MOVE.W  #14,D0          * Trap #14 to display message
000016A6  4E4F                    1264      TRAP    #15             * Perform #14
000016A8                          1265       
000016A8  6000 00C6               1266      BRA     ENDEAHELPER05
000016AC                          1267      
000016AC                          1268  NOTADRINDIRECTPOST * address register indirect, pre decrement
000016AC                          1269      
000016AC  0C46 0020               1270      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
000016B0  6600 002E               1271      BNE     NOTADRINDIRECTPRE
000016B4                          1272      
000016B4  43F9 00001CC5           1273      LEA     MINUS,A1       * Load '-'
000016BA  303C 000E               1274      MOVE.W  #14,D0          * Trap #14 to display message
000016BE  4E4F                    1275      TRAP    #15             * Perform #14
000016C0                          1276      
000016C0  43F9 00001CBF           1277      LEA     OBRACK,A1       * Load '('
000016C6  303C 000E               1278      MOVE.W  #14,D0          * Trap #14 to display message
000016CA  4E4F                    1279      TRAP    #15             * Perform #14
000016CC                          1280          
000016CC                          1281  
000016CC  6100 01A8               1282      BSR     MODE_AN * print out an address register
000016D0                          1283      
000016D0  43F9 00001CC1           1284      LEA     CBRACK,A1       * Load ')'
000016D6  303C 000E               1285      MOVE.W  #14,D0          * Trap #14 to display message
000016DA  4E4F                    1286      TRAP    #15             * Perform #14
000016DC                          1287       
000016DC  6000 0092               1288      BRA     ENDEAHELPER05
000016E0                          1289  
000016E0                          1290  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
000016E0                          1291  
000016E0  0C46 0038               1292      CMPI    #%0000000000111000,D6 * is it immediate?
000016E4  6600 0086               1293      BNE     NOTIMMEDIATE
000016E8                          1294  
000016E8  0C43 0001               1295      CMPI    #1,D3 * is it a byte?
000016EC  6600 0028               1296      BNE     NOTIMMBYTE
000016F0                          1297      
000016F0  43F9 00001CBB           1298      LEA     IMD,A1 *print out the '#' indicating an immediate value
000016F6  103C 000E               1299      MOVE.B  #14,D0
000016FA  4E4F                    1300      TRAP    #15
000016FC                          1301      
000016FC  3C3C 0000               1302      MOVE.W  #0, D6              * Prep lower value for bitmask
00001700  3E3C 0007               1303      MOVE.W  #7, D7              * Prep upper value for bitmask
00001704  6100 04EE               1304      BSR     BITMASK             * Finalize bitmask setup
00001708                          1305          
00001708  321A                    1306      MOVE.W  (A2)+,D1
0000170A                          1307      
0000170A  C286                    1308      AND.L     D6,D1
0000170C                          1309          
0000170C  103C 0003               1310      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001710  4E4F                    1311      TRAP    #15      * Perform Trap #3
00001712                          1312      
00001712  6000 005C               1313      BRA     ENDEAHELPER05
00001716                          1314  
00001716                          1315  NOTIMMBYTE
00001716                          1316      
00001716  0C43 0002               1317      CMPI    #2,D3 * is it a word?
0000171A  6600 0028               1318      BNE     NOTIMMWORD
0000171E                          1319      
0000171E  43F9 00001CBB           1320      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001724  103C 000E               1321      MOVE.B  #14,D0
00001728  4E4F                    1322      TRAP    #15
0000172A                          1323      
0000172A  3C3C 0000               1324      MOVE.W  #0, D6              * Prep lower value for bitmask
0000172E  3E3C 000F               1325      MOVE.W  #15, D7             * Prep upper value for bitmask
00001732  6100 04C0               1326      BSR     BITMASK             * Finalize bitmask setup
00001736                          1327          
00001736  321A                    1328      MOVE.W  (A2)+,D1
00001738                          1329      
00001738  C286                    1330      AND.L     D6,D1               * Apply bitmask
0000173A                          1331          
0000173A  103C 0003               1332      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000173E  4E4F                    1333      TRAP    #15      * Perform Trap #3
00001740                          1334      
00001740  6000 002E               1335      BRA     ENDEAHELPER05
00001744                          1336      
00001744                          1337  NOTIMMWORD
00001744  0C43 0003               1338      CMPI    #3,D3 * is it a long?
00001748  6600 0022               1339      BNE     NOTIMMEDIATE
0000174C                          1340      
0000174C  43F9 00001CBB           1341      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001752  103C 000E               1342      MOVE.B  #14,D0
00001756  4E4F                    1343      TRAP    #15
00001758                          1344          
00001758  221A                    1345      MOVE.L  (A2)+,D1
0000175A                          1346          
0000175A  103C 0003               1347      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000175E  4E4F                    1348      TRAP    #15      * Perform Trap #3
00001760                          1349      
00001760  321A                    1350      MOVE.W  (A2)+,D1
00001762                          1351          
00001762  103C 0003               1352      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001766  4E4F                    1353      TRAP    #15      * Perform Trap #3
00001768                          1354      
00001768  6000 0006               1355      BRA     ENDEAHELPER05
0000176C                          1356  
0000176C                          1357  NOTIMMEDIATE    
0000176C                          1358  
0000176C                          1359  
0000176C  6100 02CE               1360      BSR     UNKNOWNOP
00001770                          1361      
00001770                          1362  ENDEAHELPER05
00001770  4C9F 03FF               1363      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001774  4E75                    1364      RTS
00001776                          1365  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001776                          1366  *-----------------------------------------------------------------------------
00001776                          1367  
00001776                          1368  
00001776                          1369  
00001776                          1370  *-----------------------------------------------------------------------------
00001776                          1371  *-----------------------------------------------------------------------------
00001776                          1372  * NAME:           MODE_DN
00001776                          1373  * DESCRIPTION:    Generalize the EA part of the project.
00001776                          1374  * PRE-CONDITION:  The mode must have been correctly identified. All modes
00001776                          1375  *                 must be called by RTS.
00001776                          1376  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
00001776                          1377  *                 called it.
00001776                          1378  * REGISTERS:      a
00001776                          1379  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001776                          1380  * ---> Dn
00001776                          1381  MODE_DN
00001776  48A7 FFC0               1382          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
0000177A                          1383  
0000177A  3C3C 0000               1384          MOVE.W  #0, D6              * Prep lower value for bitmask
0000177E  3E3C 0002               1385          MOVE.W  #2, D7              * Prep upper value for bitmask
00001782  6100 0470               1386          BSR     BITMASK             * Finalize bitmask setup
00001786  CC42                    1387          AND     D2,D6               * Apply bitmask
00001788                          1388          
00001788  0C46 0000               1389          CMPI    #%000000000000000, D6   * Data Register D0?
0000178C  6600 000A               1390          BNE     NOTD0
00001790                          1391          
00001790  6100 0074               1392          BSR     PRINTD0
00001794  6000 006A               1393          BRA     ENDMODE_DN
00001798                          1394  NOTD0      
00001798  0C46 0001               1395          CMPI    #%000000000000001, D6   * Data Register D1?
0000179C  6600 000A               1396          BNE     NOTD1
000017A0                          1397          
000017A0  6100 0072               1398          BSR     PRINTD1
000017A4  6000 005A               1399          BRA     ENDMODE_DN
000017A8                          1400  NOTD1
000017A8  0C46 0002               1401          CMPI    #%000000000000010, D6   * Data Register D2?
000017AC  6600 000A               1402          BNE     NOTD2
000017B0                          1403          
000017B0  6100 0070               1404          BSR     PRINTD2
000017B4  6000 004A               1405          BRA     ENDMODE_DN
000017B8                          1406  NOTD2
000017B8  0C46 0003               1407          CMPI    #%000000000000011, D6   * Data Register D3?
000017BC  6600 000A               1408          BNE     NOTD3
000017C0                          1409          
000017C0  6100 006E               1410          BSR     PRINTD3
000017C4  6000 003A               1411          BRA     ENDMODE_DN
000017C8                          1412  NOTD3
000017C8  0C46 0004               1413          CMPI    #%000000000000100, D6   * Data Register D4?
000017CC  6600 000A               1414          BNE     NOTD4
000017D0                          1415          
000017D0  6100 006C               1416          BSR     PRINTD4
000017D4  6000 002A               1417          BRA     ENDMODE_DN
000017D8                          1418  NOTD4
000017D8  0C46 0005               1419          CMPI    #%000000000000101, D6   * Data Register D5?
000017DC  6600 000A               1420          BNE     NOTD5
000017E0                          1421          
000017E0  6100 006A               1422          BSR     PRINTD5
000017E4  6000 001A               1423          BRA     ENDMODE_DN
000017E8                          1424  NOTD5
000017E8  0C46 0006               1425          CMPI    #%000000000000110, D6   * Data Register D6?
000017EC  6600 000A               1426          BNE     NOTD6
000017F0                          1427          
000017F0  6100 0068               1428          BSR     PRINTD6
000017F4  6000 000A               1429          BRA     ENDMODE_DN
000017F8                          1430  NOTD6
000017F8  6100 006E               1431          BSR     PRINTD7
000017FC  6000 0002               1432          BRA     ENDMODE_DN
00001800                          1433          
00001800                          1434  ENDMODE_DN
00001800  4C9F 03FF               1435          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001804  4E75                    1436          RTS
00001806                          1437  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001806                          1438  *-----------------------------------------------------------------------------
00001806                          1439  
00001806                          1440  
00001806                          1441  
00001806                          1442  *-----------------------------------------------------------------------------
00001806                          1443  *-----------------------------------------------------------------------------
00001806                          1444  * NAME:           PRINTD0
00001806                          1445  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
00001806                          1446  * PRE-CONDITION:  a
00001806                          1447  * POST-CONDITION: a
00001806                          1448  * REGISTERS:      a
00001806                          1449  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001806                          1450  PRINTD0
00001806  43F9 00001CEB           1451          LEA     __D0, A1        * Load 'D0'
0000180C  103C 000E               1452          MOVE.B  #14, D0         * Load Trap #14 to print out
00001810  4E4F                    1453          TRAP    #15             * Perform Trap #14
00001812  4E75                    1454          RTS
00001814                          1455  PRINTD1
00001814  43F9 00001CEE           1456          LEA     __D1, A1        * Load 'D1'
0000181A  103C 000E               1457          MOVE.B  #14, D0         * Load Trap #14 to print out
0000181E  4E4F                    1458          TRAP    #15             * Perform Trap #14
00001820  4E75                    1459          RTS      
00001822                          1460  PRINTD2
00001822  43F9 00001CF1           1461          LEA     __D2, A1        * Load 'D2'
00001828  103C 000E               1462          MOVE.B  #14, D0         * Load Trap #14 to print out
0000182C  4E4F                    1463          TRAP    #15             * Perform Trap #14
0000182E  4E75                    1464          RTS      
00001830                          1465  PRINTD3
00001830  43F9 00001CF4           1466          LEA     __D3, A1        * Load 'D3'
00001836  103C 000E               1467          MOVE.B  #14, D0         * Load Trap #14 to print out
0000183A  4E4F                    1468          TRAP    #15             * Perform Trap #14
0000183C  4E75                    1469          RTS      
0000183E                          1470  PRINTD4
0000183E  43F9 00001CF7           1471          LEA     __D4, A1        * Load 'D4'
00001844  103C 000E               1472          MOVE.B  #14, D0         * Load Trap #14 to print out
00001848  4E4F                    1473          TRAP    #15             * Perform Trap #14
0000184A  4E75                    1474          RTS       
0000184C                          1475  PRINTD5
0000184C  43F9 00001CFA           1476          LEA     __D5, A1        * Load 'D5'
00001852  103C 000E               1477          MOVE.B  #14, D0         * Load Trap #14 to print out
00001856  4E4F                    1478          TRAP    #15             * Perform Trap #14
00001858  4E75                    1479          RTS      
0000185A                          1480  PRINTD6
0000185A  43F9 00001CFD           1481          LEA     __D6, A1        * Load 'D6'
00001860  103C 000E               1482          MOVE.B  #14, D0         * Load Trap #14 to print out
00001864  4E4F                    1483          TRAP    #15             * Perform Trap #14
00001866  4E75                    1484          RTS
00001868                          1485  PRINTD7
00001868  43F9 00001D00           1486          LEA     __D7, A1        * Load 'D7'
0000186E  103C 000E               1487          MOVE.B  #14, D0         * Load Trap #14 to print out
00001872  4E4F                    1488          TRAP    #15             * Perform Trap #14
00001874  4E75                    1489          RTS
00001876                          1490  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001876                          1491  *-----------------------------------------------------------------------------
00001876                          1492  
00001876                          1493  
00001876                          1494  
00001876                          1495  *-----------------------------------------------------------------------------
00001876                          1496  *-----------------------------------------------------------------------------
00001876                          1497  * NAME:           MODE_AN
00001876                          1498  * DESCRIPTION:    Simply chooses to print A0-A7.
00001876                          1499  * PRE-CONDITION:  a
00001876                          1500  * POST-CONDITION: a
00001876                          1501  * REGISTERS:      a
00001876                          1502  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001876                          1503  MODE_AN
00001876  48A7 FFC0               1504          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
0000187A                          1505  
0000187A  3C3C 0000               1506          MOVE.W  #0, D6              * Prep lower value for bitmask
0000187E  3E3C 0002               1507          MOVE.W  #2, D7              * Prep upper value for bitmask
00001882  6100 0370               1508          BSR     BITMASK             * Finalize bitmask setup
00001886  CC42                    1509          AND     D2,D6               * Apply bitmask
00001888                          1510          
00001888  0C46 0000               1511          CMPI    #%000000000000000, D6   * Address Register A0?
0000188C  6600 000A               1512          BNE     NOTA0
00001890                          1513          
00001890  6100 0074               1514          BSR     PRINTA0
00001894                          1515          
00001894  6000 006A               1516          BRA     ENDMODE_AN
00001898                          1517  NOTA0      
00001898  0C46 0001               1518          CMPI    #%000000000000001, D6   * Address Register A1?
0000189C  6600 000A               1519          BNE     NOTA1
000018A0                          1520          
000018A0  6100 0072               1521          BSR     PRINTA1
000018A4                          1522          
000018A4  6000 005A               1523          BRA     ENDMODE_AN
000018A8                          1524  NOTA1
000018A8  0C46 0002               1525          CMPI    #%000000000000010, D6   * Address Register A2?
000018AC  6600 000A               1526          BNE     NOTA2
000018B0                          1527          
000018B0  6100 0070               1528          BSR     PRINTA2
000018B4                          1529          
000018B4  6000 004A               1530          BRA     ENDMODE_AN
000018B8                          1531  NOTA2
000018B8  0C46 0003               1532          CMPI    #%000000000000011, D6   * Address Register A3?
000018BC  6600 000A               1533          BNE     NOTA3
000018C0                          1534          
000018C0  6100 006E               1535          BSR     PRINTA3
000018C4                          1536          
000018C4  6000 003A               1537          BRA     ENDMODE_AN
000018C8                          1538  NOTA3
000018C8  0C46 0004               1539          CMPI    #%000000000000100, D6   * Address Register A4?
000018CC  6600 000A               1540          BNE     NOTA4
000018D0                          1541          
000018D0  6100 006C               1542          BSR     PRINTA4
000018D4                          1543          
000018D4  6000 002A               1544          BRA     ENDMODE_AN
000018D8                          1545  NOTA4
000018D8  0C46 0005               1546          CMPI    #%000000000000101, D6   * Address Register A5?
000018DC  6600 000A               1547          BNE     NOTA5
000018E0                          1548          
000018E0  6100 006A               1549          BSR     PRINTA5
000018E4                          1550          
000018E4  6000 001A               1551          BRA     ENDMODE_AN
000018E8                          1552  NOTA5
000018E8  0C46 0006               1553          CMPI    #%000000000000110, D6   * Address Register A6?
000018EC  6600 000A               1554          BNE     NOTA6
000018F0                          1555          
000018F0  6100 0068               1556          BSR     PRINTA6
000018F4                          1557          
000018F4  6000 000A               1558          BRA     ENDMODE_AN
000018F8                          1559  NOTA6
000018F8  6100 006E               1560          BSR     PRINTA7
000018FC                          1561          
000018FC  6000 0002               1562          BRA     ENDMODE_AN
00001900                          1563  ENDMODE_AN
00001900  4C9F 03FF               1564          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
00001904  4E75                    1565          RTS
00001906                          1566  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001906                          1567  *-----------------------------------------------------------------------------
00001906                          1568  
00001906                          1569  
00001906                          1570  
00001906                          1571  *-----------------------------------------------------------------------------
00001906                          1572  *-----------------------------------------------------------------------------
00001906                          1573  * NAME:           PRINTA0
00001906                          1574  * DESCRIPTION:    Simply print out the address register.
00001906                          1575  * PRE-CONDITION:  a
00001906                          1576  * POST-CONDITION: a
00001906                          1577  * REGISTERS:      a
00001906                          1578  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001906                          1579  PRINTA0
00001906  43F9 00001CD3           1580          LEA     __A0, A1        * Load 'A0'
0000190C  103C 000E               1581          MOVE.B  #14, D0         * Load Trap #14 to print out
00001910  4E4F                    1582          TRAP    #15             * Perform Trap #14
00001912  4E75                    1583          RTS
00001914                          1584  
00001914                          1585  PRINTA1
00001914  43F9 00001CD6           1586          LEA     __A1, A1        * Load 'A1'
0000191A  103C 000E               1587          MOVE.B  #14, D0         * Load Trap #14 to print out
0000191E  4E4F                    1588          TRAP    #15             * Perform Trap #14
00001920  4E75                    1589          RTS
00001922                          1590          
00001922                          1591  PRINTA2
00001922  43F9 00001CD9           1592          LEA     __A2, A1        * Load 'A2'
00001928  103C 000E               1593          MOVE.B  #14, D0         * Load Trap #14 to print out
0000192C  4E4F                    1594          TRAP    #15             * Perform Trap #14
0000192E  4E75                    1595          RTS
00001930                          1596  
00001930                          1597  PRINTA3
00001930  43F9 00001CDC           1598          LEA     __A3, A1        * Load 'A3'
00001936  103C 000E               1599          MOVE.B  #14, D0         * Load Trap #14 to print out
0000193A  4E4F                    1600          TRAP    #15             * Perform Trap #14
0000193C  4E75                    1601          RTS
0000193E                          1602  
0000193E                          1603  PRINTA4
0000193E  43F9 00001CDF           1604          LEA     __A4, A1        * Load 'A4'
00001944  103C 000E               1605          MOVE.B  #14, D0         * Load Trap #14 to print out
00001948  4E4F                    1606          TRAP    #15             * Perform Trap #14
0000194A  4E75                    1607          RTS
0000194C                          1608  
0000194C                          1609  PRINTA5
0000194C  43F9 00001CE2           1610          LEA     __A5, A1        * Load 'A5'
00001952  103C 000E               1611          MOVE.B  #14, D0         * Load Trap #14 to print out
00001956  4E4F                    1612          TRAP    #15             * Perform Trap #14
00001958  4E75                    1613          RTS
0000195A                          1614  
0000195A                          1615  PRINTA6
0000195A  43F9 00001CE5           1616          LEA     __A6, A1        * Load 'A6'
00001960  103C 000E               1617          MOVE.B  #14, D0         * Load Trap #14 to print out
00001964  4E4F                    1618          TRAP    #15             * Perform Trap #14
00001966  4E75                    1619          RTS
00001968                          1620  
00001968                          1621  PRINTA7
00001968  43F9 00001CE8           1622          LEA     __A7, A1        * Load 'A7'
0000196E  103C 000E               1623          MOVE.B  #14, D0         * Load Trap #14 to print out
00001972  4E4F                    1624          TRAP    #15             * Perform Trap #14
00001974  4E75                    1625          RTS
00001976                          1626  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001976                          1627  *-----------------------------------------------------------------------------
00001976                          1628  
00001976                          1629  
00001976                          1630  
00001976                          1631  *-----------------------------------------------------------------------------
00001976                          1632  *-----------------------------------------------------------------------------
00001976                          1633  * NAME:           SIZE67
00001976                          1634  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001976                          1635  * PRE-CONDITION:  a
00001976                          1636  * POST-CONDITION: a
00001976                          1637  * REGISTERS:      a
00001976                          1638  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001976                          1639  SIZE67
00001976  48A7 FFFE               1640          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
0000197A  3C3C 0006               1641          MOVE.W  #6, D6              * Prep lower value for bitmask
0000197E  3E3C 0007               1642          MOVE.W  #7, D7              * Prep upper value for bitmask
00001982  6100 0270               1643          BSR     BITMASK             * Finalize bitmask setup
00001986  CC42                    1644          AND     D2,D6               * Apply bitmask     
00001988                          1645  
00001988  0C46 0000               1646          CMPI    #%0000000000000000, D6   * is it a BYTE?
0000198C  6600 000A               1647          BNE     NOT67BYTE
00001990                          1648          
00001990  6100 0080               1649          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001994  6000 001E               1650          BRA     END67
00001998                          1651  NOT67BYTE        
00001998  0C46 0040               1652          CMPI    #%0000000001000000, D6   * is it a WORD?
0000199C  6600 000A               1653          BNE     NOT67WORD
000019A0                          1654          
000019A0  6100 007E               1655          BSR     PRINTWORD               * Branch to handle WORD sizes
000019A4  6000 000E               1656          BRA     END67
000019A8                          1657  NOT67WORD
000019A8  0C46 0080               1658          CMPI    #%0000000010000000, D6   * is it a LONG?
000019AC  6600 0006               1659          BNE     END67
000019B0                          1660          
000019B0  6100 007C               1661          BSR     PRINTLONG               * Branch to handle LONG sizes
000019B4                          1662  END67
000019B4  4C9F 7FFF               1663          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
000019B8  4E75                    1664          RTS                             * Return. Size handling is finished.
000019BA                          1665  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019BA                          1666  *-----------------------------------------------------------------------------
000019BA                          1667  
000019BA                          1668  
000019BA                          1669  
000019BA                          1670  *-----------------------------------------------------------------------------
000019BA                          1671  *-----------------------------------------------------------------------------
000019BA                          1672  * NAME:           SIZE68
000019BA                          1673  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
000019BA                          1674  * PRE-CONDITION:  a
000019BA                          1675  * POST-CONDITION: a
000019BA                          1676  * REGISTERS:      a
000019BA                          1677  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019BA                          1678  SIZE68
000019BA                          1679          * finish later, need to follow the same format as SIZE67
000019BA                          1680          
000019BA                          1681          
000019BA  48A7 FFFE               1682          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
000019BE  3C3C 0006               1683          MOVE.W  #6, D6              * Prep lower value for bitmask
000019C2  3E3C 0008               1684          MOVE.W  #8, D7              * Prep upper value for bitmask
000019C6  6100 022C               1685          BSR     BITMASK             * Finalize bitmask setup
000019CA  CC42                    1686          AND     D2,D6               * Apply bitmask          
000019CC                          1687          
000019CC  0C46 0000               1688          CMPI    #%0000000000000000, D6   * is it a BYTE?
000019D0  6100 0040               1689          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000019D4  0C46 0100               1690          CMPI    #%0000000100000000, D6   * is it a BYTE?
000019D8  6100 0038               1691          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
000019DC                          1692        
000019DC  0C46 0040               1693          CMPI    #%0000000001000000, D6   * is it a WORD?
000019E0  6100 003E               1694          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019E4  0C46 0140               1695          CMPI    #%0000000101000000, D6   * is it a WORD?
000019E8  6100 0036               1696          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019EC  0C46 00C0               1697          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
000019F0  6100 002E               1698          BSR     PRINTWORD               * Branch to handle BYTE sizes
000019F4                          1699  
000019F4  0C46 0080               1700          CMPI    #%0000000010000000, D6   * is it a LONG?
000019F8  6100 0034               1701          BSR     PRINTLONG               * Branch to handle BYTE sizes
000019FC  0C46 0180               1702          CMPI    #%0000000110000000, D6   * is it a LONG?
00001A00  6100 002C               1703          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001A04  0C46 01C0               1704          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001A08  6100 0024               1705          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001A0C                          1706  
00001A0C  4C9F 7FFF               1707          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001A10  4E75                    1708          RTS                             * Return. Size handling is finished.
00001A12                          1709  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A12                          1710  *-----------------------------------------------------------------------------
00001A12                          1711  
00001A12                          1712  
00001A12                          1713  
00001A12                          1714  *-----------------------------------------------------------------------------
00001A12                          1715  *-----------------------------------------------------------------------------
00001A12                          1716  * NAME:           PRINTBYTE
00001A12                          1717  * DESCRIPTION:    a
00001A12                          1718  * PRE-CONDITION:  a
00001A12                          1719  * POST-CONDITION: a
00001A12                          1720  * REGISTERS:      a
00001A12                          1721  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A12                          1722  PRINTBYTE
00001A12  43F9 00001CC7           1723          LEA     __B,A1      * Load '.B ' into A1
00001A18  103C 000E               1724          MOVE.B  #14,D0      * Trap #14 setup to print
00001A1C  4E4F                    1725          TRAP    #15         * Perform Trap #14
00001A1E  4E75                    1726          RTS                 * Return to SIZE67/SIZE68
00001A20                          1727          
00001A20                          1728  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A20                          1729  *-----------------------------------------------------------------------------
00001A20                          1730  
00001A20                          1731  
00001A20                          1732  
00001A20                          1733  *-----------------------------------------------------------------------------
00001A20                          1734  *-----------------------------------------------------------------------------
00001A20                          1735  * NAME:           PRINTWORD
00001A20                          1736  * DESCRIPTION:    a
00001A20                          1737  * PRE-CONDITION:  a
00001A20                          1738  * POST-CONDITION: a
00001A20                          1739  * REGISTERS:      a
00001A20                          1740  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A20                          1741  PRINTWORD
00001A20  43F9 00001CCB           1742          LEA     __W,A1      * Load '.W ' into A1
00001A26  103C 000E               1743          MOVE.B  #14,D0      * Trap #14 setup to print
00001A2A  4E4F                    1744          TRAP    #15         * Perform Trap #14
00001A2C  4E75                    1745          RTS                 * Return to SIZE67/SIZE68
00001A2E                          1746          
00001A2E                          1747  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A2E                          1748  *-----------------------------------------------------------------------------
00001A2E                          1749  
00001A2E                          1750  
00001A2E                          1751  
00001A2E                          1752  *-----------------------------------------------------------------------------
00001A2E                          1753  *-----------------------------------------------------------------------------
00001A2E                          1754  * NAME:           PRINTLONG
00001A2E                          1755  * DESCRIPTION:    a
00001A2E                          1756  * PRE-CONDITION:  a
00001A2E                          1757  * POST-CONDITION: a
00001A2E                          1758  * REGISTERS:      a
00001A2E                          1759  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A2E                          1760  PRINTLONG
00001A2E  43F9 00001CCF           1761          LEA     __L,A1      * Load '.L ' into A1
00001A34  103C 000E               1762          MOVE.B  #14,D0      * Trap #14 setup to print
00001A38  4E4F                    1763          TRAP    #15         * Perform Trap #14
00001A3A  4E75                    1764          RTS                 * Return to SIZE67/SIZE68
00001A3C                          1765          
00001A3C                          1766  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A3C                          1767  *-----------------------------------------------------------------------------
00001A3C                          1768  
00001A3C                          1769  
00001A3C                          1770  
00001A3C                          1771  *-----------------------------------------------------------------------------
00001A3C                          1772  *-----------------------------------------------------------------------------
00001A3C                          1773  * NAME:           UNKNOWNOP
00001A3C                          1774  * DESCRIPTION:    a
00001A3C                          1775  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001A3C                          1776  *                 identified as an unknown operation.
00001A3C                          1777  * POST-CONDITION: D2 is no longer the opcode.
00001A3C                          1778  * REGISTERS:      a
00001A3C                          1779  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A3C                          1780  UNKNOWNOP
00001A3C  220A                    1781          MOVE.L  A2,D1   * prep the add to print
00001A3E                          1782          
00001A3E  5581                    1783          SUB.L   #2,D1   * off by two error due to post increment correct
00001A40                          1784          
00001A40  2602                    1785          MOVE.L  D2,D3   * save the opcode to print
00001A42                          1786          
00001A42  7410                    1787          MOVE.L  #16,D2  * set the base to 16
00001A44                          1788          
00001A44  700F                    1789          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001A46  4E4F                    1790          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001A48                          1791          
00001A48  43F9 00001C71           1792          LEA     DATA,A1 * load " DATA $" into register A1
00001A4E  700E                    1793          MOVE.L  #14,D0  * print the string stored in A1
00001A50  4E4F                    1794          TRAP    #15
00001A52                          1795          
00001A52  2203                    1796          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001A54                          1797          
00001A54  103C 000F               1798          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A58  4E4F                    1799          TRAP    #15      * Perform Trap #3
00001A5A                          1800  
00001A5A  43F9 00001C38           1801          LEA     NEWLINE,A1 * load newline into register A1
00001A60  700E                    1802          MOVE.L  #14,D0  * print the string stored in A1
00001A62  4E4F                    1803          TRAP    #15
00001A64                          1804  
00001A64  4E75                    1805          RTS
00001A66                          1806  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A66                          1807  *-----------------------------------------------------------------------------
00001A66                          1808  
00001A66                          1809  
00001A66                          1810  
00001A66                          1811  *-----------------------------------------------------------------------------
00001A66                          1812  *-----------------------------------------------------------------------------
00001A66                          1813  * NAME: Print ASCII hex char
00001A66                          1814  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
00001A66                          1815  * PRE-CONDITION:  A6 contains the register for memory to print.
00001A66                          1816  *                 This parameter would be pre-loaded by, for example:
00001A66                          1817  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001A66                          1818  *                 D6 contains the loops to do (number of bytes).
00001A66                          1819  * POST-CONDITION: 
00001A66                          1820  * REGISTERS:      
00001A66                          1821  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A66                          1822  PRINT_ASCII_HEX_CHAR
00001A66  48E7 FFFC               1823      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001A6A  4285                    1824      CLR.L       D5
00001A6C                          1825      
00001A6C                          1826      * fence post check (if-statement, check if 0 > chars)
00001A6C  0C06 0000               1827      CMPI.B      #0,D6
00001A70  6700 017C               1828      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001A74                          1829      
00001A74                          1830  *    MOVE.L      A6,D4
00001A74  2E0E                    1831      MOVE.L      A6,D7
00001A76                          1832  PRINT_ASCII_LOOP
00001A76                          1833  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001A76                          1834  *    MOVE.L      D4,D7 * make a mutable copy
00001A76  E99F                    1835      ROL.L       #4,D7 * roll to next spot
00001A78  48E7 0100               1836      MOVEM.L     D7,-(A7) * save D7
00001A7C                          1837  
00001A7C  0287 0000000F           1838      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001A82                          1839      
00001A82  0C87 00000000           1840      CMPI.L      #0,D7
00001A88  6D00 0164               1841      BLT         INVALID_ASCII_INPUT
00001A8C                          1842  
00001A8C  0C87 0000000F           1843      CMPI.L      #15,D7
00001A92  6E00 015A               1844      BGT         INVALID_ASCII_INPUT
00001A96                          1845  
00001A96                          1846      * this might be faster... to do later, after entire assignment done
00001A96                          1847       * CMPI.L      #9,D7
00001A96                          1848       * BLE         PRINT_ASCII_0_TO_9
00001A96                          1849  
00001A96  0C87 00000000           1850      CMPI.L      #0,D7
00001A9C  6700 0098               1851      BEQ         PRINT_ASCII_0
00001AA0  0C87 00000001           1852      CMPI.L      #1,D7
00001AA6  6700 0098               1853      BEQ         PRINT_ASCII_1
00001AAA  0C87 00000002           1854      CMPI.L      #2,D7
00001AB0  6700 0098               1855      BEQ         PRINT_ASCII_2
00001AB4  0C87 00000003           1856      CMPI.L      #3,D7
00001ABA  6700 0098               1857      BEQ         PRINT_ASCII_3
00001ABE  0C87 00000004           1858      CMPI.L      #4,D7
00001AC4  6700 0098               1859      BEQ         PRINT_ASCII_4
00001AC8  0C87 00000005           1860      CMPI.L      #5,D7
00001ACE  6700 0098               1861      BEQ         PRINT_ASCII_5
00001AD2  0C87 00000006           1862      CMPI.L      #6,D7
00001AD8  6700 0098               1863      BEQ         PRINT_ASCII_6
00001ADC  0C87 00000007           1864      CMPI.L      #7,D7
00001AE2  6700 0098               1865      BEQ         PRINT_ASCII_7
00001AE6  0C87 00000008           1866      CMPI.L      #8,D7
00001AEC  6700 0098               1867      BEQ         PRINT_ASCII_8
00001AF0  0C87 00000009           1868      CMPI.L      #9,D7
00001AF6  6700 0098               1869      BEQ         PRINT_ASCII_9
00001AFA  0C87 0000000A           1870      CMPI.L      #10,D7
00001B00  6700 0098               1871      BEQ         PRINT_ASCII_A
00001B04  0C87 0000000B           1872      CMPI.L      #11,D7
00001B0A  6700 0098               1873      BEQ         PRINT_ASCII_B
00001B0E  0C87 0000000C           1874      CMPI.L      #12,D7
00001B14  6700 0098               1875      BEQ         PRINT_ASCII_C
00001B18  0C87 0000000D           1876      CMPI.L      #13,D7
00001B1E  6700 0098               1877      BEQ         PRINT_ASCII_D
00001B22  0C87 0000000E           1878      CMPI.L      #14,D7
00001B28  6700 0098               1879      BEQ         PRINT_ASCII_E
00001B2C  0C87 0000000F           1880      CMPI.L      #15,D7
00001B32  6700 0098               1881      BEQ         PRINT_ASCII_F
00001B36                          1882  PRINT_ASCII_0
00001B36  43F9 00001C97           1883      LEA         ASCII_0,A1
00001B3C  6000 0098               1884      BRA         PRINT_ASCII_CHAR
00001B40                          1885  PRINT_ASCII_1
00001B40  43F9 00001C99           1886      LEA         ASCII_1,A1
00001B46  6000 008E               1887      BRA         PRINT_ASCII_CHAR
00001B4A                          1888  PRINT_ASCII_2
00001B4A  43F9 00001C9B           1889      LEA         ASCII_2,A1
00001B50  6000 0084               1890      BRA         PRINT_ASCII_CHAR
00001B54                          1891  PRINT_ASCII_3
00001B54  43F9 00001C9D           1892      LEA         ASCII_3,A1
00001B5A  6000 007A               1893      BRA         PRINT_ASCII_CHAR
00001B5E                          1894  PRINT_ASCII_4
00001B5E  43F9 00001C9F           1895      LEA         ASCII_4,A1
00001B64  6000 0070               1896      BRA         PRINT_ASCII_CHAR
00001B68                          1897  PRINT_ASCII_5
00001B68  43F9 00001CA1           1898      LEA         ASCII_5,A1
00001B6E  6000 0066               1899      BRA         PRINT_ASCII_CHAR
00001B72                          1900  PRINT_ASCII_6
00001B72  43F9 00001CA3           1901      LEA         ASCII_6,A1
00001B78  6000 005C               1902      BRA         PRINT_ASCII_CHAR
00001B7C                          1903  PRINT_ASCII_7
00001B7C  43F9 00001CA5           1904      LEA         ASCII_7,A1
00001B82  6000 0052               1905      BRA         PRINT_ASCII_CHAR
00001B86                          1906  PRINT_ASCII_8
00001B86  43F9 00001CA7           1907      LEA         ASCII_8,A1
00001B8C  6000 0048               1908      BRA         PRINT_ASCII_CHAR
00001B90                          1909  PRINT_ASCII_9
00001B90  43F9 00001CA9           1910      LEA         ASCII_9,A1
00001B96  6000 003E               1911      BRA         PRINT_ASCII_CHAR
00001B9A                          1912  PRINT_ASCII_A
00001B9A  43F9 00001CAB           1913      LEA         ASCII_A,A1
00001BA0  6000 0034               1914      BRA         PRINT_ASCII_CHAR
00001BA4                          1915  PRINT_ASCII_B
00001BA4  43F9 00001CAD           1916      LEA         ASCII_B,A1
00001BAA  6000 002A               1917      BRA         PRINT_ASCII_CHAR
00001BAE                          1918  PRINT_ASCII_C
00001BAE  43F9 00001CAF           1919      LEA         ASCII_C,A1
00001BB4  6000 0020               1920      BRA         PRINT_ASCII_CHAR
00001BB8                          1921  PRINT_ASCII_D
00001BB8  43F9 00001CB1           1922      LEA         ASCII_D,A1
00001BBE  6000 0016               1923      BRA         PRINT_ASCII_CHAR
00001BC2                          1924  PRINT_ASCII_E
00001BC2  43F9 00001CB3           1925      LEA         ASCII_E,A1
00001BC8  6000 000C               1926      BRA         PRINT_ASCII_CHAR
00001BCC                          1927  PRINT_ASCII_F
00001BCC  43F9 00001CB5           1928      LEA         ASCII_F,A1
00001BD2  6000 0002               1929      BRA         PRINT_ASCII_CHAR
00001BD6                          1930  PRINT_ASCII_CHAR
00001BD6  103C 000E               1931      MOVE.B      #14,D0
00001BDA  4E4F                    1932      TRAP        #15
00001BDC                          1933      
00001BDC  5205                    1934      ADD.B       #1,D5 * loop until counter stops
00001BDE  BA06                    1935      CMP.B       D6,D5
00001BE0  6C00 000C               1936      BGE         PRINT_ASCII_FINISH
00001BE4                          1937      
00001BE4  4287                    1938      CLR.L       D7
00001BE6  4CDF 0080               1939      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001BEA                          1940      
00001BEA  6000 FE8A               1941      BRA         PRINT_ASCII_LOOP
00001BEE                          1942  INVALID_ASCII_INPUT
00001BEE                          1943  PRINT_ASCII_FINISH
00001BEE  4CDF 3FFF               1944      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001BF2  4E75                    1945      RTS
00001BF4                          1946  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001BF4                          1947  *-----------------------------------------------------------------------------
00001BF4                          1948  
00001BF4                          1949  
00001BF4                          1950  
00001BF4                          1951  *-----------------------------------------------------------------------------
00001BF4                          1952  *-----------------------------------------------------------------------------
00001BF4                          1953  * NAME: Bitmask
00001BF4                          1954  * DESCRIPTION:    Masks bits in a data register.
00001BF4                          1955  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001BF4                          1956  *                 the ending bit.  For example, a starting bit of decimal
00001BF4                          1957  *                 value 0 and an ending bit of decimal value 3 will mask the
00001BF4                          1958  *                 bits 0, 1, 2, and 3.
00001BF4                          1959  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001BF4                          1960  * REGISTERS:      D5,D6,D7
00001BF4                          1961  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001BF4                          1962  BITMASK
00001BF4  3F05                    1963          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001BF6  4245                    1964          CLR     D5          * clear D5 so we can use it
00001BF8                          1965  LOOPBIT 
00001BF8  0DC5                    1966          BSET    D6,D5       * set the D6th bit in D5 to 1
00001BFA  5246                    1967          ADD     #1,D6       * increment D6
00001BFC                          1968  
00001BFC  BC47                    1969          CMP     D7,D6       * have we finished?
00001BFE  6E00 0004               1970          BGT     BITMASKDONE * yes
00001C02  60F4                    1971          BRA     LOOPBIT     * no, iterate again
00001C04                          1972  
00001C04                          1973  BITMASKDONE
00001C04  2C05                    1974          MOVE.L  D5,D6
00001C06  3A1F                    1975          MOVE    (A7)+,D5    * restore D5
00001C08  4E75                    1976          RTS
00001C0A                          1977  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C0A                          1978  *-----------------------------------------------------------------------------
00001C0A                          1979  
00001C0A                          1980  
00001C0A                          1981  
00001C0A                          1982  *-----------------------------------------------------------------------------
00001C0A                          1983  *-----------------------------------------------------------------------------
00001C0A                          1984  * SECTION: Constants/variables used throughout the program.
00001C0A                          1985  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C0A                          1986  * ---> GENERAL
00001C0A  =0000000D               1987  CR          EQU     $0D
00001C0A  =0000000A               1988  LF          EQU     $0A
00001C0A= 45 4E 54 45 52 20 ...   1989  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001C22= 45 4E 54 45 52 20 ...   1990  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001C38= 0D 0A 00                1991  NEWLINE     DC.B    CR,LF,0
00001C3B                          1992  * ---> OPS
00001C3B= 44 49 56 53 00          1993  DIVSOP      DC.B    'DIVS',0
00001C40= 4E 4F 50 00             1994  NOOPERATION DC.B    'NOP',0
00001C44= 4E 45 47 00             1995  NEGOP       DC.B    'NEG',0
00001C48= 4D 4F 56 45 00          1996  MOVEOP      DC.B    'MOVE',0
00001C4D= 4D 4F 56 45 4D 00       1997  MOVEMOP     DC.B    'MOVEM',0
00001C53= 4A 53 52 00             1998  JSROP       DC.B    'JSR',0
00001C57= 52 54 53 00             1999  RTSOP       DC.B    'RTS',0
00001C5B= 4C 45 41 00             2000  LEAOP       DC.B    'LEA',0
00001C5F= 42 43 4C 52 20 00       2001  BCLROP      DC.B    'BCLR ',0
00001C65= 4F 52 00                2002  OROP        DC.B    'OR',0
00001C68= 4F 52 49 00             2003  ORIOP       DC.B    'ORI',0
00001C6C= 43 4D 50 49 00          2004  CMPIOP      DC.B    'CMPI',0
00001C71= 20 44 41 54 41 20 ...   2005  DATA        DC.B    ' DATA $',0
00001C79= 42 43 43 20 00          2006  OP_BCC_MSG  DC.B    'BCC ',0
00001C7E= 42 43 53 20 00          2007  OP_BCS_MSG  DC.B    'BCS ',0
00001C83= 42 47 45 20 00          2008  OP_BGE_MSG  DC.B    'BGE ',0
00001C88= 42 4C 54 20 00          2009  OP_BLT_MSG  DC.B    'BLT ',0
00001C8D= 42 56 43 20 00          2010  OP_BVC_MSG  DC.B    'BVC ',0
00001C92= 42 52 41 20 00          2011  OP_BRA_MSG  DC.B    'BRA ',0
00001C97                          2012  * ---> HEX CHARS
00001C97= 30 00                   2013  ASCII_0     DC.B    '0',0
00001C99= 31 00                   2014  ASCII_1     DC.B    '1',0
00001C9B= 32 00                   2015  ASCII_2     DC.B    '2',0
00001C9D= 33 00                   2016  ASCII_3     DC.B    '3',0
00001C9F= 34 00                   2017  ASCII_4     DC.B    '4',0
00001CA1= 35 00                   2018  ASCII_5     DC.B    '5',0
00001CA3= 36 00                   2019  ASCII_6     DC.B    '6',0
00001CA5= 37 00                   2020  ASCII_7     DC.B    '7',0
00001CA7= 38 00                   2021  ASCII_8     DC.B    '8',0
00001CA9= 39 00                   2022  ASCII_9     DC.B    '9',0
00001CAB= 41 00                   2023  ASCII_A     DC.B    'A',0
00001CAD= 42 00                   2024  ASCII_B     DC.B    'B',0
00001CAF= 43 00                   2025  ASCII_C     DC.B    'C',0
00001CB1= 44 00                   2026  ASCII_D     DC.B    'D',0
00001CB3= 45 00                   2027  ASCII_E     DC.B    'E',0
00001CB5= 46 00                   2028  ASCII_F     DC.B    'F',0
00001CB7                          2029  * ---> SPECIAL CHARACTERS
00001CB7= 20 00                   2030  SPACE       DC.B    ' ',0
00001CB9= 24 00                   2031  DOLLAR      DC.B    '$',0
00001CBB= 23 00                   2032  IMD         DC.B    '#',0
00001CBD= 2C 00                   2033  COMMA       DC.B    ',',0
00001CBF= 28 00                   2034  OBRACK      DC.B    '(',0
00001CC1= 29 00                   2035  CBRACK      DC.B    ')',0
00001CC3= 2B 00                   2036  PLUS        DC.B    '+',0
00001CC5= 2D 00                   2037  MINUS       DC.B    '-',0
00001CC7                          2038  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001CC7= 2E 42 20 00             2039  __B         DC.B    '.B ',0
00001CCB= 2E 57 20 00             2040  __W         DC.B    '.W ',0
00001CCF= 2E 4C 20 00             2041  __L         DC.B    '.L ',0
00001CD3                          2042  * ---> ADDRESS REGISTERS A0-A7
00001CD3= 41 30 00                2043  __A0        DC.B   'A0',0
00001CD6= 41 31 00                2044  __A1        DC.B   'A1',0    
00001CD9= 41 32 00                2045  __A2        DC.B   'A2',0
00001CDC= 41 33 00                2046  __A3        DC.B   'A3',0
00001CDF= 41 34 00                2047  __A4        DC.B   'A4',0
00001CE2= 41 35 00                2048  __A5        DC.B   'A5',0
00001CE5= 41 36 00                2049  __A6        DC.B   'A6',0
00001CE8= 41 37 00                2050  __A7        DC.B   'A7',0
00001CEB                          2051  * ---> DATA REGISTERS D0-D7
00001CEB= 44 30 00                2052  __D0        DC.B   'D0',0
00001CEE= 44 31 00                2053  __D1        DC.B   'D1',0
00001CF1= 44 32 00                2054  __D2        DC.B   'D2',0
00001CF4= 44 33 00                2055  __D3        DC.B   'D3',0
00001CF7= 44 34 00                2056  __D4        DC.B   'D4',0
00001CFA= 44 35 00                2057  __D5        DC.B   'D5',0
00001CFD= 44 36 00                2058  __D6        DC.B   'D6',0
00001D00= 44 37 00                2059  __D7        DC.B   'D7',0
00001D03                          2060  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D03                          2061  *-----------------------------------------------------------------------------
00001D03                          2062  
00001D03                          2063  
00001D03                          2064  
00001D03                          2065  *-----------------------------------------------------------------------------
00001D03                          2066  *-----------------------------------------------------------------------------
00001D03                          2067  * SECTION: Sample program to run, then attempt testing disassembly on.
00001D03                          2068  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2069      ORG $4000
00004000                          2070  
00004000  4E71                    2071      NOP
00004002  103C 009A               2072      MOVE.B   #%10011010, D0
00004006  123C 00A9               2073      MOVE.B   #%10101001, D1
0000400A  D200                    2074      ADD.B    D0,D1
0000400C  48A7 4000               2075      MOVEM    D1,-(A7)
00004010  43F8 1C53               2076      LEA      JSROP,A1
00004014  6700 0012               2077      BEQ      END
00004018  6600 000E               2078      BNE      END
0000401C  4467                    2079      NEG.W    -(A7)
0000401E  4EB9 00004028           2080      JSR      END
00004024  81FC 0001               2081      DIVS    #1, D0
00004028                          2082  
00004028                          2083  END
00004028  4E75                    2084      RTS
0000402A                          2085  RLLYEND
0000402A                          2086      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1C97
ASCII_1             1C99
ASCII_2             1C9B
ASCII_3             1C9D
ASCII_4             1C9F
ASCII_5             1CA1
ASCII_6             1CA3
ASCII_7             1CA5
ASCII_8             1CA7
ASCII_9             1CA9
ASCII_A             1CAB
ASCII_B             1CAD
ASCII_C             1CAF
ASCII_D             1CB1
ASCII_E             1CB3
ASCII_F             1CB5
BCC_END             1514
BCLROP              1C5F
BITMASK             1BF4
BITMASKDONE         1C04
CBRACK              1CC1
CMPIBYTE            11D6
CMPIEA              124A
CMPILONG            1224
CMPIOP              1C6C
CMPIREG             1296
CMPIREG000          12BA
CMPIREG001          12BA
CMPIWORD            11FE
COMMA               1CBD
CR                  D
DATA                1C71
DIVSOP              1C3B
DOLLAR              1CB9
DONE                1456
EAHELPER05          1620
EAHELPER611         15DE
END                 4028
END0000             12B4
END67               19B4
ENDEAHELPER05       1770
ENDEAHELPER611      161A
ENDMODE_AN          1900
ENDMODE_DN          1800
ENDOP0001           131A
HEX_VALUE_MASK_LONG  F
IMD                 1CBB
INVALID_ASCII_INPUT  1BEE
ISCMPI              119C
ISORI               119C
ITERATION           1144
JSROP               1C53
LEAOP               1C5B
LF                  A
LOOP                103A
LOOPBIT             1BF8
LOOPUNKNOWNOP       1140
MINUS               1CC5
MODE_AN             1876
MODE_DN             1776
MOVEMOP             1C4D
MOVEOP              1C48
MSGEND              1C22
MSGSTART            1C0A
NEGOP               1C44
NEWLINE             1C38
NOOPERATION         1C40
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           1998
NOT67WORD           19A8
NOTA0               1898
NOTA1               18A8
NOTA2               18B8
NOTA3               18C8
NOTA4               18D8
NOTA5               18E8
NOTA6               18F8
NOTADRDIRECT        1650
NOTADRINDIRECT      1678
NOTADRINDIRECTPOST  16AC
NOTADRINDIRECTPRE   16E0
NOTBCLR             117A
NOTD0               1798
NOTD1               17A8
NOTD2               17B8
NOTD3               17C8
NOTD4               17D8
NOTD5               17E8
NOTD6               17F8
NOTDATAREG          1640
NOTDIVS             159E
NOTIMMBYTE          1716
NOTIMMEDIATE        176C
NOTIMMWORD          1744
NOTJSR              140C
NOTMOVEM            13CA
NOTNEG              13A6
NOTNOP              1350
NOTRTS              142E
OBRACK              1CBF
OP0000              1150
OP0001              12BA
OP0010              1320
OP0011              1326
OP0100              1334
OP0101              1460
OP0110              1466
OP0111              151A
OP1000              1520
OP1000END           15AE
OP1001              15B4
OP1010              15BA
OP1011              15C0
OP1100              15C6
OP1101              15CC
OP1110              15D2
OP1111              15D8
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              14B6
OP_BCC_MSG          1C79
OP_BCS              14C0
OP_BCS_MSG          1C7E
OP_BGE              14CA
OP_BGE_MSG          1C83
OP_BLT              14D4
OP_BLT_MSG          1C88
OP_BRA              14E8
OP_BRANCHES_PRINT   14F2
OP_BRA_MSG          1C92
OP_BVC              14DE
OP_BVC_MSG          1C8D
ORIOP               1C68
OROP                1C65
PLUS                1CC3
PRINTA0             1906
PRINTA1             1914
PRINTA2             1922
PRINTA3             1930
PRINTA4             193E
PRINTA5             194C
PRINTA6             195A
PRINTA7             1968
PRINTBYTE           1A12
PRINTD0             1806
PRINTD1             1814
PRINTD2             1822
PRINTD3             1830
PRINTD4             183E
PRINTD5             184C
PRINTD6             185A
PRINTD7             1868
PRINTLONG           1A2E
PRINTWORD           1A20
PRINT_ASCII_0       1B36
PRINT_ASCII_1       1B40
PRINT_ASCII_2       1B4A
PRINT_ASCII_3       1B54
PRINT_ASCII_4       1B5E
PRINT_ASCII_5       1B68
PRINT_ASCII_6       1B72
PRINT_ASCII_7       1B7C
PRINT_ASCII_8       1B86
PRINT_ASCII_9       1B90
PRINT_ASCII_A       1B9A
PRINT_ASCII_B       1BA4
PRINT_ASCII_C       1BAE
PRINT_ASCII_CHAR    1BD6
PRINT_ASCII_D       1BB8
PRINT_ASCII_E       1BC2
PRINT_ASCII_F       1BCC
PRINT_ASCII_FINISH  1BEE
PRINT_ASCII_HEX_CHAR  1A66
PRINT_ASCII_LOOP    1A76
RLLYEND             402A
RTSOP               1C57
SIZE67              1976
SIZE68              19BA
SPACE               1CB7
START               1000
UNKNOWN             1452
UNKNOWNOP           1A3C
UNKNOWNOP0001       1316
__A0                1CD3
__A1                1CD6
__A2                1CD9
__A3                1CDC
__A4                1CDF
__A5                1CE2
__A6                1CE5
__A7                1CE8
__B                 1CC7
__D0                1CEB
__D1                1CEE
__D2                1CF1
__D3                1CF4
__D4                1CF7
__D5                1CFA
__D6                1CFD
__D7                1D00
__L                 1CCF
__W                 1CCB
