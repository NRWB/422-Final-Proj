00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/6/2014 7:56:47 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001B96             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001BAE             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001BC4             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0B48                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A  3F06                     100          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     101          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     102          AND.W   D2,D6           * Apply this bitmask
00001040                           103          
00001040  BC7C 0000                104          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001044  6600 000A                105          BNE     NOT0000         * No, check next case
00001048  6100 0106                106          BSR     OP0000          * Branch to subroutine 0000
0000104C  6000 00F6                107          BRA     ITERATION       * Move to next iteration of the loop
00001050                           108  NOT0000        
00001050  BC7C 1000                109          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001054  6600 000A                110          BNE     NOT0001         * No, check next case
00001058  6100 01EC                111          BSR     OP0001          * Branch to subroutine 0001
0000105C  6000 00E6                112          BRA     ITERATION       * Move to next iteration of the loop
00001060                           113  NOT0001
00001060  BC7C 2000                114          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001064  6600 000A                115          BNE     NOT0010         * No, check next case
00001068  6100 0242                116          BSR     OP0010          * Branch to subroutine 0010
0000106C  6000 00D6                117          BRA     ITERATION       * Move to next iteration of the loop
00001070                           118  NOT0010
00001070  BC7C 3000                119          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001074  6600 000A                120          BNE     NOT0011         * No, check next case
00001078  6100 0238                121          BSR     OP0011          * Branch to subroutine 0011
0000107C  6000 00C6                122          BRA     ITERATION       * Move to next iteration of the loop
00001080                           123  NOT0011
00001080  BC7C 4000                124          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001084  6600 000A                125          BNE     NOT0100         * No, check next case
00001088  6100 0236                126          BSR     OP0100          * Branch to subroutine 0100
0000108C  6000 00B6                127          BRA     ITERATION       * Move to next iteration of the loop
00001090                           128  NOT0100
00001090  BC7C 5000                129          CMP     #OP_0101,D6     * Does the operation start with 0101?
00001094  6600 000A                130          BNE     NOT0101         * No, check next case
00001098  6100 0352                131          BSR     OP0101          * Branch to subroutine 0101
0000109C  6000 00A6                132          BRA     ITERATION       * Move to next iteration of the loop
000010A0                           133  NOT0101
000010A0  BC7C 6000                134          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010A4  6600 000A                135          BNE     NOT0110         * No, check next case
000010A8  6100 0348                136          BSR     OP0110          * Branch to subroutine 0110
000010AC  6000 0096                137          BRA     ITERATION       * Move to next iteration of the loop
000010B0                           138  NOT0110
000010B0  BC7C 7000                139          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010B4  6600 000A                140          BNE     NOT0111         * No, check next case
000010B8  6100 03EC                141          BSR     OP0111          * Branch to subroutine 0111
000010BC  6000 0086                142          BRA     ITERATION       * Move to next iteration of the loop
000010C0                           143  NOT0111
000010C0  BC7C 8000                144          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010C4  6600 000A                145          BNE     NOT1000         * No, check next case
000010C8  6100 03E2                146          BSR     OP1000          * Branch to subroutine 1000
000010CC  6000 0076                147          BRA     ITERATION       * Move to next iteration of the loop
000010D0                           148  NOT1000
000010D0  BC7C 9000                149          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010D4  6600 000A                150          BNE     NOT1001         * No, check next case
000010D8  6100 0466                151          BSR     OP1001          * Branch to subroutine 1001
000010DC  6000 0066                152          BRA     ITERATION       * Move to next iteration of the loop
000010E0                           153  NOT1001
000010E0  BC7C A000                154          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010E4  6600 000A                155          BNE     NOT1010         * No, check next case
000010E8  6100 045C                156          BSR     OP1010          * Branch to subroutine 1010
000010EC  6000 0056                157          BRA     ITERATION       * Move to next iteration of the loop
000010F0                           158  NOT1010
000010F0  BC7C B000                159          CMP     #OP_1011,D6     * Does the operation start with 1011?
000010F4  6600 000A                160          BNE     NOT1011         * No, check next case
000010F8  6100 0452                161          BSR     OP1011          * Branch to subroutine 1011
000010FC  6000 0046                162          BRA     ITERATION       * Move to next iteration of the loop
00001100                           163  NOT1011
00001100  BC7C C000                164          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001104  6600 000A                165          BNE     NOT1100         * No, check next case
00001108  6100 0448                166          BSR     OP1100          * Branch to subroutine 1100
0000110C  6000 0036                167          BRA     ITERATION       * Move to next iteration of the loop
00001110                           168  NOT1100
00001110  BC7C D000                169          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001114  6600 000A                170          BNE     NOT1101         * No, check next case
00001118  6100 043E                171          BSR     OP1101          * Branch to subroutine 1101
0000111C  6000 0026                172          BRA     ITERATION       * Move to next iteration of the loop
00001120                           173  NOT1101
00001120  BC7C E000                174          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001124  6600 000A                175          BNE     NOT1110         * No, check next case
00001128  6100 0434                176          BSR     OP1110          * Branch to subroutine 1110
0000112C  6000 0016                177          BRA     ITERATION       * Move to next iteration of the loop
00001130                           178  NOT1110
00001130  BC7C F000                179          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001134  6600 000A                180          BNE     LOOPUNKNOWNOP   * No, check next case
00001138  6100 042A                181          BSR     OP1111          * Branch to subroutine 1111
0000113C  6000 0006                182          BRA     ITERATION       * Move to next iteration of the loop
00001140                           183          
00001140                           184  LOOPUNKNOWNOP
00001140  6100 0886                185          BSR     UNKNOWNOP
00001144                           186          
00001144                           187  ITERATION
00001144  3C1F                     188          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001146                           189  
00001146                           190          *MOVE.B  #14,D0          * Print a newline
00001146                           191          *TRAP    #15             * Perform Trap #14
00001146                           192  
00001146  BA4A                     193          CMP     A2,D5           * Compare the starting address to ending address
00001148  6700 2EDC                194          BEQ     END             * If they are equal, branch 
0000114C  6000 FEEC                195          BRA     LOOP            * Otherwise, branch back to LOOP
00001150                           196  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001150                           197  *-----------------------------------------------------------------------------
00001150                           198  
00001150                           199  
00001150                           200  
00001150                           201  *-----------------------------------------------------------------------------
00001150                           202  *-----------------------------------------------------------------------------
00001150                           203  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001150                           204  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001150                           205  * PRE-CONDITION:  xyz
00001150                           206  * POST-CONDITION: All registers return to their previous state, and the output
00001150                           207  *                 goes to the output console for reading the raw data or the
00001150                           208  *                 actual instruction.
00001150                           209  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001150                           210  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001150                           211  OP0000
00001150  48A7 FFC0                212          MOVEM   D0-D7/A0-A1,-(A7)   * Push values to the stack to save
00001154  3C3C 0006                213          MOVE.W  #6, D6              * Prep lower value for bitmask
00001158  3E3C 0008                214          MOVE.W  #8, D7              * Prep upper value for bitmask
0000115C  6100 0A22                215          BSR     BITMASK             * Finalize bitmask setup
00001160  CC42                     216          AND     D2,D6               * Apply bitmask
00001162                           217          
00001162                           218          * TODO: Consider static  AND dynamic BCLR.
00001162                           219          * Only works for Dynamic right now
00001162  0C46 0180                220          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001166  6600 0066                221          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000116A                           222          
0000116A  3C3C 0003                223          MOVE.W  #3, D6              * Prep lower value for bitmask
0000116E  3E3C 0005                224          MOVE.W  #5, D7              * Prep upper value for bitmask
00001172  6100 0A0C                225          BSR     BITMASK             * Finalize bitmask setup
00001176  CC42                     226          AND     D2,D6               * Apply bitmask
00001178                           227          
00001178                           228          * Checking for unsupported mode
00001178  0C46 0008                229          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000117C  6700 00BE                230          BEQ     UNKNOWN0000             * If so, branch to other OP0000 functions
00001180                           231          
00001180                           232          * Confirmed BCLR at this point
00001180  43F9 00001BEB            233          LEA     BCLROP,A1           * We found BCLR
00001186  103C 000E                234          MOVE.B  #14,D0              * Trap #14 prints out the data
0000118A  4E4F                     235          TRAP    #15                 * Perform Trap #14
0000118C                           236  
0000118C  43F9 00001C43            237          LEA     SPACE,A1            * Formatting
00001192  103C 000E                238          MOVE.B  #14,D0              * Trap #14 prints out space
00001196  4E4F                     239          TRAP    #15                 * Perform Trap #14
00001198                           240          
00001198  4243                     241          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
0000119A  08C3 0000                242          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
0000119E                           243      
0000119E  6100 040C                244          BSR     EAHELPER05          * Print out data.
000011A2                           245  
000011A2  43F9 00001C49            246          LEA     COMMA,A1            * formatting
000011A8  103C 000E                247          MOVE.B  #14,D0              * Trap #14 prints out a comma
000011AC  4E4F                     248          TRAP    #15                 * Perform Trap #14
000011AE                           249          
000011AE                           250          * Set up for printing out the Register
000011AE  0882 0006                251          BCLR    #6,D2               * Clear bit 6
000011B2  0882 0007                252          BCLR    #7,D2               * Clear bit 7
000011B6  0882 0008                253          BCLR    #8,D2               * Clear bit 8
000011BA                           254          
000011BA  6100 03AE                255          BSR     EAHELPER611         * Print out Register
000011BE                           256          
000011BE  43F9 00001BC4            257          LEA     NEWLINE,A1          * Formatting
000011C4  103C 000E                258          MOVE.B  #14,D0              * Trap #14 prints out the data
000011C8  4E4F                     259          TRAP    #15                 * Perform Trap #14
000011CA                           260          
000011CA  6000 0074                261          BRA     END0000             * Found the op, move to next iteration
000011CE                           262          
000011CE                           263  NOTBCLR * Possible options left are ORI or CMPI
000011CE  3C3C 0009                264          MOVE.W  #9, D6              * Prep lower value for bitmask
000011D2  3E3C 000B                265          MOVE.W  #11, D7             * Prep upper value for bitmask
000011D6  6100 09A8                266          BSR     BITMASK             * Finalize bitmask setup
000011DA  CC42                     267          AND     D2,D6               * Apply bitmask
000011DC                           268          
000011DC  0C46 0000                269          CMPI    #%0000000000000000, D6   * Are we possibly ORI?
000011E0  6600 0052                270          BNE     NOTORI                   * If not, branch to NOTORI
000011E4                           271          
000011E4                           272          * Size check to see if unsupported ORI mode
000011E4  3C3C 0006                273          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E8  3E3C 0007                274          MOVE.W  #7, D7              * Prep upper value for bitmask
000011EC  6100 0992                275          BSR     BITMASK             * Finalize bitmask setup
000011F0  CC42                     276          AND     D2,D6               * Apply bitmask
000011F2                           277          
000011F2  0C46 00C0                278          CMPI    #%0000000011000000, D6  * Are bits 6,7 == 1,1?
000011F6  6700 0044                279          BEQ     UNKNOWN0000             * If so, unknown op. 
000011FA                           280          
000011FA                           281          * Mode check to see if unsupported ORI mode
000011FA  3C3C 0003                282          MOVE.W  #3, D6              * Prep lower value for bitmask
000011FE  3E3C 0005                283          MOVE.W  #5, D7              * Prep upper value for bitmask
00001202  6100 097C                284          BSR     BITMASK             * Finalize bitmask setup
00001206  CC42                     285          AND     D2,D6               * Apply bitmask
00001208                           286          
00001208  0C46 0008                287          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
0000120C  6700 002E                288          BEQ     UNKNOWN0000             * If so, unknown op. 
00001210                           289          
00001210                           290          * Confirmed ORI at this point
00001210                           291          * TODO: Get the immediate data following the instruction and print it out
00001210  43F9 00001BF4            292          LEA     ORIOP, A1           * Load 'ORI' into the output window
00001216  103C 000E                293          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
0000121A  4E4F                     294          TRAP    #15                 * Perform Trap #14
0000121C                           295          
0000121C  6100 06E4                296          BSR     SIZE67              * Print the size
00001220  6100 038A                297          BSR     EAHELPER05          * Print out the EA
00001224                           298          
00001224  43F9 00001BC4            299          LEA     NEWLINE,A1          * Formatting
0000122A  103C 000E                300          MOVE.B  #14,D0              * Trap #14 prints out the data
0000122E  4E4F                     301          TRAP    #15                 * Perform Trap #14
00001230                           302          
00001230  6000 000E                303          BRA     END0000             * Done with op. Move to next iteration
00001234                           304          
00001234                           305  NOTORI  * Possible option left is CMPI
00001234  0C46 0C00                306          CMPI    #%0000110000000000, D6  * Are we CMPI?
00001238  6600 0002                307          BNE     UNKNOWN0000             * If not, unknown op
0000123C                           308          
0000123C                           309          * TODO: Continue checking for CMPI validity
0000123C                           310          
0000123C                           311  UNKNOWN0000
0000123C  6100 078A                312          BSR     UNKNOWNOP       * Unknown op
00001240                           313          
00001240                           314  END0000          
00001240  4C9F 03FF                315         MOVEM   (A7)+,D0-D7/A0-A1   * Push values to the stack to save
00001244  4E75                     316         RTS
00001246                           317  
00001246                           318  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001246                           319  *-----------------------------------------------------------------------------
00001246                           320  
00001246                           321  
00001246                           322  
00001246                           323  *-----------------------------------------------------------------------------
00001246                           324  *-----------------------------------------------------------------------------
00001246                           325  * NAME: OP_0001   (MOVE.B)
00001246                           326  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001246                           327  * PRE-CONDITION:  xyz
00001246                           328  * POST-CONDITION: All registers return to their previous state, and the output
00001246                           329  *                 goes to the output console for reading the raw data or the
00001246                           330  *                 actual instruction.
00001246                           331  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001246                           332  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001246                           333  OP0001  
00001246  48A7 FFC0                334          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
0000124A  3C3C 0006                335          MOVE.W  #6, D6              * Prep lower value for bitmask
0000124E  3E3C 0008                336          MOVE.W  #8, D7              * Prep upper value for bitmask
00001252  6100 092C                337          BSR     BITMASK             * Finalize bitmask setup
00001256  CC42                     338          AND     D2,D6               * Apply bitmask
00001258                           339          
00001258                           340          * I may have fucked off this part, sorry - Caleb
00001258                           341          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
00001258                           342          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
00001258                           343          
00001258  43F9 00001BD4            344          LEA     MOVEOP,A1   * Put 'MOVE' into the window
0000125E  103C 000E                345          MOVE.B  #14,D0      * Trap #14 to print out
00001262  4E4F                     346          TRAP    #15         * Perform Trap #14
00001264                           347          
00001264                           348          *-----------------------------------------------------------
00001264                           349          * the following code is to move the size bits into the
00001264                           350          * 0-1 positions of D3 so that eahelper05 case use that as a "parameter"
00001264                           351          * for eahelper05
00001264                           352          
00001264  3C3C 000C                353          MOVE.W  #12, D6              * Prep lower value for bitmask
00001268  3E3C 000D                354          MOVE.W  #13, D7              * Prep upper value for bitmask
0000126C  6100 0912                355          BSR     BITMASK             * Finalize bitmask setup
00001270                           356          
00001270  CC42                     357          AND     D2,D6
00001272                           358          
00001272  E04E                     359          LSR     #8,D6
00001274  E84E                     360          LSR     #4,D6
00001276                           361          
00001276  4243                     362          CLR     D3
00001278                           363          
00001278  1606                     364          MOVE.B  D6,D3
0000127A                           365          
0000127A                           366          *---------------------------------------------------------------
0000127A                           367          
0000127A                           368          
0000127A  6100 0686                369          BSR     SIZE67
0000127E  6100 032C                370          BSR     EAHELPER05
00001282                           371          
00001282  43F9 00001C49            372          LEA     COMMA,A1
00001288  103C 000E                373          MOVE.B  #14,D0
0000128C  4E4F                     374          TRAP    #15
0000128E                           375          
0000128E  6100 02DA                376          BSR     EAHELPER611
00001292                           377          
00001292  43F9 00001BC4            378          LEA     NEWLINE,A1
00001298  103C 000E                379          MOVE.B  #14,D0
0000129C  4E4F                     380          TRAP    #15
0000129E                           381          
0000129E  6000 0006                382          BRA     ENDOP0001
000012A2                           383          *LEA     __B,A1      * Put '.B' into the window
000012A2                           384          *MOVE.B  #14,D0      * Trap #14 to print out
000012A2                           385          *TRAP    #15         * Perform Trap #14
000012A2                           386          
000012A2                           387  UNKNOWNOP0001
000012A2                           388  
000012A2  6100 0724                389          BSR     UNKNOWNOP
000012A6                           390          
000012A6                           391  ENDOP0001
000012A6                           392  
000012A6  4C9F 03FF                393          MOVEM (A7)+,D0-D7/A0-A1
000012AA  4E75                     394          RTS        
000012AC                           395          
000012AC                           396          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
000012AC                           397  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012AC                           398  *-----------------------------------------------------------------------------
000012AC                           399  
000012AC                           400  
000012AC                           401  
000012AC                           402  *-----------------------------------------------------------------------------
000012AC                           403  *-----------------------------------------------------------------------------
000012AC                           404  * NAME: OP_0010   (MOVE.L, MOVEA.L)
000012AC                           405  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012AC                           406  * PRE-CONDITION:  xyz
000012AC                           407  * POST-CONDITION: All registers return to their previous state, and the output
000012AC                           408  *                 goes to the output console for reading the raw data or the
000012AC                           409  *                 actual instruction.
000012AC                           410  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012AC                           411  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012AC                           412  OP0010
000012AC                           413  
000012AC  6100 071A                414      BSR     UNKNOWNOP
000012B0  4E75                     415      RTS
000012B2                           416  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012B2                           417  *-----------------------------------------------------------------------------
000012B2                           418  
000012B2                           419  
000012B2                           420  
000012B2                           421  *-----------------------------------------------------------------------------
000012B2                           422  *-----------------------------------------------------------------------------
000012B2                           423  * NAME: OP_0011   (MOVE.W, MOVEA.W)
000012B2                           424  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012B2                           425  * PRE-CONDITION:  xyz
000012B2                           426  * POST-CONDITION: All registers return to their previous state, and the output
000012B2                           427  *                 goes to the output console for reading the raw data or the
000012B2                           428  *                 actual instruction.
000012B2                           429  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012B2                           430  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012B2                           431  OP0011
000012B2  48A7 FFFE                432      MOVEM   D0-D7/A0-A6, -(A7)
000012B6                           433      
000012B6                           434      *MOVE.W  #6,D6
000012B6                           435      *MOVE.W  #8,D7
000012B6                           436      
000012B6                           437      *BSR     BITMASK
000012B6                           438      
000012B6                           439      *AND.W   D2,D6
000012B6                           440      
000012B6                           441      *CMP     #%0000000001000000,D6
000012B6                           442      *BNE     NEXT15
000012B6                           443      *BSR     * for MOVEA.W
000012B6                           444      
000012B6  4C9F 7FFF                445      MOVEM   (A7)+,D0-D7/A0-A6
000012BA                           446      
000012BA  6100 070C                447      BSR     UNKNOWNOP
000012BE  4E75                     448      RTS
000012C0                           449  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012C0                           450  *-----------------------------------------------------------------------------
000012C0                           451  
000012C0                           452  
000012C0                           453  
000012C0                           454  *-----------------------------------------------------------------------------
000012C0                           455  *-----------------------------------------------------------------------------
000012C0                           456  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
000012C0                           457  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012C0                           458  * PRE-CONDITION:  xyz
000012C0                           459  * POST-CONDITION: All registers return to their previous state, and the output
000012C0                           460  *                 goes to the output console for reading the raw data or the
000012C0                           461  *                 actual instruction.
000012C0                           462  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012C0                           463  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012C0                           464  OP0100  
000012C0                           465          * TODO: lea, movem
000012C0                           466  
000012C0  48A7 C0C0                467          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000012C4                           468          
000012C4                           469          *NOP
000012C4  0C42 4E71                470          CMPI    #%0100111001110001,D2
000012C8  6600 0012                471          BNE     NOTNOP
000012CC                           472          
000012CC  43F9 00001BCC            473          LEA     NOOPERATION,A1
000012D2  103C 000D                474          MOVE.B  #13,D0          * Print a newline
000012D6  4E4F                     475          TRAP    #15
000012D8                           476          
000012D8  6000 0108                477          BRA     DONE *we found it, move on to the next iteration
000012DC                           478  NOTNOP *NEG
000012DC                           479          
000012DC                           480          * prep values for BITMASK subroutine
000012DC  7C08                     481          MOVE.L  #8,D6
000012DE  7E0B                     482          MOVE.L  #11,D7
000012E0                           483          
000012E0  6100 089E                484          BSR     BITMASK
000012E4                           485          
000012E4  CC42                     486          AND     D2,D6                   * apply bitmask
000012E6                           487          
000012E6  0C46 0400                488          CMPI    #%0000010000000000,D6   * are we NEG?
000012EA  6600 0046                489          BNE     NOTNEG                  * not neg
000012EE                           490          
000012EE  7C03                     491          MOVE.L  #3,D6
000012F0  7E05                     492          MOVE.L  #5,D7
000012F2                           493          
000012F2  6100 088C                494          BSR     BITMASK * generate a bitmask to be used to check mode
000012F6                           495          
000012F6  0C46 0008                496          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
000012FA  6700 00E2                497          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
000012FE                           498          
000012FE  0C46 0028                499          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001302  6700 00DA                500          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001306                           501          
00001306  0C46 0030                502          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000130A  6700 00D2                503          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000130E                           504        
0000130E                           505          * it is NEG, print
0000130E  43F9 00001BD0            506          LEA     NEGOP,A1
00001314  103C 000E                507          MOVE.B  #14,D0
00001318  4E4F                     508          TRAP    #15
0000131A                           509          
0000131A  6100 05E6                510          BSR     SIZE67
0000131E                           511          
0000131E  6100 028C                512          BSR     EAHELPER05
00001322                           513          
00001322  43F9 00001BC4            514          LEA     NEWLINE,A1
00001328  103C 000E                515          MOVE.B  #14,D0
0000132C  4E4F                     516          TRAP    #15
0000132E                           517          
0000132E  6000 00B2                518          BRA     DONE * we found the op, move to next iteration
00001332                           519          
00001332                           520  NOTNEG *MOVEM
00001332                           521  
00001332                           522          * prep values for BITMASK subroutine
00001332  7C07                     523          MOVE.L  #7,D6
00001334  7E09                     524          MOVE.L  #9,D7
00001336                           525          
00001336  6100 0848                526          BSR     BITMASK
0000133A                           527          
0000133A  CC42                     528          AND     D2,D6   * apply bitmask
0000133C                           529          
0000133C  0C46 0080                530          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001340  6600 0014                531          BNE     NOTMOVEM          * it is not MOVEM
00001344                           532          
00001344                           533          * make sure it is a valid size and mode for MOVEM
00001344                           534          
00001344                           535          * it is MOVEM
00001344  43F9 00001BD9            536          LEA     MOVEMOP,A1
0000134A  103C 000D                537          MOVE.B  #13,D0          * Print a newline
0000134E  4E4F                     538          TRAP    #15
00001350                           539          
00001350                           540          * probably needs its own special code for printing the rest due to uniqueness of movem
00001350                           541          
00001350  341A                     542          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001352                           543          
00001352  6000 008E                544          BRA     DONE          * we found and printed, move on to the next iteration
00001356                           545          
00001356                           546  NOTMOVEM *JSR
00001356                           547          * prep values for BITMASK subroutine
00001356  7C06                     548          MOVE.L  #6,D6
00001358  7E08                     549          MOVE.L  #8,D7
0000135A                           550          
0000135A  6100 0824                551          BSR     BITMASK
0000135E                           552          
0000135E  CC42                     553          AND     D2,D6   * apply bitmask
00001360                           554          
00001360  0C46 0080                555          CMPI    #%0000000010000000,D6
00001364  6600 0032                556          BNE     NOTJSR          * it's not JSR
00001368                           557          
00001368  43F9 00001BDF            558          LEA     JSROP,A1
0000136E  103C 000E                559          MOVE.B  #14,D0          * Print a newline and JSR
00001372  4E4F                     560          TRAP    #15
00001374                           561          
00001374                           562          * print out where we are jumping to
00001374                           563          
00001374  341A                     564          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001376                           565          
00001376  2202                     566          MOVE.L  D2,D1   * save the opcode to print
00001378                           567          
00001378  7410                     568          MOVE.L  #16,D2  * set the base to 16
0000137A                           569          
0000137A  700F                     570          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
0000137C  4E4F                     571          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000137E                           572          
0000137E  341A                     573          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001380                           574          
00001380  2202                     575          MOVE.L  D2,D1   * save the opcode to print
00001382                           576          
00001382  7410                     577          MOVE.L  #16,D2  * set the base to 16
00001384                           578          
00001384  700F                     579          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001386  4E4F                     580          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001388                           581          
00001388  43F9 00001BC4            582          LEA     NEWLINE,A1
0000138E  103C 000E                583          MOVE.B  #14,D0          * Print a newline
00001392  4E4F                     584          TRAP    #15
00001394                           585          
00001394  6000 004C                586          BRA     DONE          * we already found instruction, next iteration
00001398                           587  NOTJSR *RTS
00001398                           588  
00001398                           589          * prep values for BITMASK subroutine
00001398  7C06                     590          MOVE.L  #6,D6
0000139A  7E08                     591          MOVE.L  #8,D7
0000139C                           592          
0000139C  6100 07E2                593          BSR     BITMASK
000013A0                           594          
000013A0  CC42                     595          AND     D2,D6   * apply bitmask
000013A2                           596          
000013A2  0C46 0040                597          CMPI    #%0000000001000000,D6
000013A6  6600 0012                598          BNE     NOTRTS          * it's not RTS
000013AA                           599          
000013AA  43F9 00001BE3            600          LEA     RTSOP,A1
000013B0  103C 000D                601          MOVE.B  #13,D0          * Print a newline and RTS
000013B4  4E4F                     602          TRAP    #15
000013B6                           603          
000013B6  6000 002A                604          BRA     DONE          * we already found instruction, next iteration
000013BA                           605  NOTRTS  *LEA
000013BA                           606         
000013BA                           607          * prep values for BITMASK subroutine
000013BA  7C06                     608          MOVE.L  #6,D6
000013BC  7E08                     609          MOVE.L  #8,D7
000013BE                           610          
000013BE  6100 07C0                611          BSR     BITMASK
000013C2                           612          
000013C2  CC42                     613          AND     D2,D6   * apply bitmask
000013C4                           614          
000013C4  0C46 01C0                615          CMPI    #%0000000111000000,D6
000013C8  6600 0014                616          BNE     UNKNOWN          * it's not LEA, we dont know what it is
000013CC                           617          
000013CC                           618          * check to make sure it is a supported mode and size
000013CC                           619          
000013CC  43F9 00001BE7            620          LEA     LEAOP,A1
000013D2  103C 000D                621          MOVE.B  #13,D0          * Print LEA
000013D6  4E4F                     622          TRAP    #15
000013D8                           623          
000013D8                           624          * call EA helper
000013D8  341A                     625          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013DA                           626                  
000013DA  6000 0006                627          BRA     DONE          * we already found instruction, next iteration
000013DE                           628          
000013DE                           629  UNKNOWN *dont know what it is
000013DE  6100 05E8                630          BSR     UNKNOWNOP
000013E2                           631          
000013E2                           632  DONE
000013E2  4C9F 0303                633          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000013E6  4E75                     634          RTS
000013E8                           635          
000013E8  6000 FD5A                636          BRA     ITERATION
000013EC                           637  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000013EC                           638  *-----------------------------------------------------------------------------        
000013EC                           639          
000013EC                           640          
000013EC                           641  
000013EC                           642  *-----------------------------------------------------------------------------
000013EC                           643  *-----------------------------------------------------------------------------
000013EC                           644  * NAME: OP_0101   (SUBQ)
000013EC                           645  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000013EC                           646  * PRE-CONDITION:  xyz
000013EC                           647  * POST-CONDITION: All registers return to their previous state, and the output
000013EC                           648  *                 goes to the output console for reading the raw data or the
000013EC                           649  *                 actual instruction.
000013EC                           650  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000013EC                           651  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000013EC                           652  OP0101
000013EC                           653  
000013EC  6100 05DA                654      BSR     UNKNOWNOP
000013F0  4E75                     655      RTS
000013F2                           656  
000013F2                           657  * testing branching
000013F2                           658  * op op op
000013F2                           659  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000013F2                           660  *-----------------------------------------------------------------------------
000013F2                           661  
000013F2                           662  
000013F2                           663  
000013F2                           664  *-----------------------------------------------------------------------------
000013F2                           665  *-----------------------------------------------------------------------------
000013F2                           666  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
000013F2                           667  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000013F2                           668  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
000013F2                           669  *                 in the instruction and determines what the bits match to a
000013F2                           670  *                 given condition code. If the 8 bit offset is $00, or $FF,
000013F2                           671  *                 this signifies a word or long offset (for $00 and $FF
000013F2                           672  *                 respectively). The 8 bit offset is in 2's comp. form, and
000013F2                           673  *                 should be un-done, then plus or minus to the current
000013F2                           674  *                 program counter (PC) to get the actual memory label to
000013F2                           675  *                 output to console. The word offset signal eats an
000013F2                           676  *                 additional 16 bits and the long offset eats an additional
000013F2                           677  *                 32 bits. The word/long offset are for memory alignment.
000013F2                           678  * POST-CONDITION: All registers return to their previous state, and the output
000013F2                           679  *                 goes to the output console for reading the raw data or the
000013F2                           680  *                 actual instruction.
000013F2                           681  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000013F2                           682  *                 A1 (output)
000013F2                           683  * CONDITIONS TABLE:
000013F2                           684  *                Condition Names  - Mnemonic - Condition Code
000013F2                           685  *                --------------------------------------------
000013F2                           686  *                True             -    T     - 0000
000013F2                           687  *                False            -    F     - 0001
000013F2                           688  *                Higher           -    HI    - 0010
000013F2                           689  *                Lower or Same    -    LS    - 0011
000013F2                           690  *                Carry Clear      -    CC    - 0100
000013F2                           691  *                Carry Set        -    CS    - 0101
000013F2                           692  *                Not Equal        -    NE    - 0110
000013F2                           693  *                Equal            -    EQ    - 0111
000013F2                           694  *                Overflow Clear   -    VC    - 1000
000013F2                           695  *                Overflow Set     -    VS    - 1001
000013F2                           696  *                Plus             -    PL    - 1010
000013F2                           697  *                Minus            -    MI    - 1011
000013F2                           698  *                Greater or Equal -    GE    - 1100
000013F2                           699  *                Less Than        -    LT    - 1101
000013F2                           700  *                Greater Than     -    GT    - 1110
000013F2                           701  *                Less or Equal    -    LE    - 1111
000013F2                           702  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000013F2                           703  OP0110
000013F2  48A7 C0C0                704          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
000013F6                           705          
000013F6                           706          * Ready four bits to help distinguish op's with the 0110 prefix
000013F6  3C3C 0000                707          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
000013FA                           708                                        * BITMASK sub-routine call)
000013FA  3E3C 0007                709          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
000013FE                           710                                        * BITMASK sub-routine call)
000013FE                           711                                        
000013FE                           712          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
000013FE  6100 0780                713          BSR     BITMASK               * Call BITMASK sub-routine
00001402                           714                                        * Returns a bitmask in D6
00001402                           715          
00001402  CC42                     716          AND     D2,D6                 * And the index op, which was pre-loaded
00001404                           717                                        * in the main memory loop with the bitmask
00001404                           718                                        * to use to determine what case we need.
00001404                           719          
00001404                           720          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
00001404                           721          * $00 == word offset, $FF == long offset
00001404                           722       ***CMPI    #%0000000000000000,D6
00001404                           723       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
00001404                           724       ***
00001404                           725       ***CMPI    #%0000000011111111,D6
00001404                           726       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
00001404                           727          
00001404                           728          * IF PASSED BOTH CMPI CHECKS (ABOVE),
00001404                           729          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
00001404                           730          
00001404  3C3C 0009                731          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
00001408  3E3C 000B                732          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
0000140C                           733                                        
0000140C                           734          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
0000140C  6100 0772                735          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
00001410  CC42                     736          AND     D2,D6   * apply the BITMASK
00001412                           737          
00001412                           738          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001412  0C46 0400                739          CMPI    #%0000010000000000,D6
00001416  6700 002A                740          BEQ     OP_BCC
0000141A                           741          
0000141A                           742          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
0000141A  0C46 0500                743          CMPI    #%0000010100000000,D6
0000141E  6700 002C                744          BEQ     OP_BCS
00001422                           745          
00001422                           746          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001422  0C46 0C00                747          CMPI    #%0000110000000000,D6
00001426  6700 002E                748          BEQ     OP_BGE
0000142A                           749          
0000142A                           750          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
0000142A  0C46 0D00                751          CMPI    #%0000110100000000,D6
0000142E  6700 0030                752          BEQ     OP_BLT
00001432                           753          
00001432                           754          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
00001432  0C46 0800                755          CMPI    #%0000100000000000,D6
00001436  6700 0032                756          BEQ     OP_BVC
0000143A                           757          
0000143A                           758          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
0000143A                           759          * NOTE: A branch to the immediately following instruction automatically
0000143A                           760          *       uses the 16-bit displacement format because the 8-bit displacement
0000143A                           761          *       field contains $00 zero offset
0000143A                           762          * http://68k.hax.com/BRA
0000143A                           763          * NOTE2 ---> Does this mean, there should be no checks when debugging
0000143A                           764          *            for word/long offsets?
0000143A  0C46 0000                765          CMPI    #%0000000000000000,D6
0000143E  6700 0034                766          BEQ     OP_BRA
00001442                           767          
00001442                           768          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
00001442                           769          ; call raw data print out sub routine
00001442                           770  
00001442                           771  OP_BCC
00001442  43F9 00001C05            772          LEA     OP_BCC_MSG,A1
00001448  6000 0034                773          BRA     OP_BRANCHES_PRINT
0000144C                           774  OP_BCS
0000144C  43F9 00001C0A            775          LEA     OP_BCS_MSG,A1
00001452  6000 002A                776          BRA     OP_BRANCHES_PRINT
00001456                           777  OP_BGE
00001456  43F9 00001C0F            778          LEA     OP_BGE_MSG,A1
0000145C  6000 0020                779          BRA     OP_BRANCHES_PRINT
00001460                           780  OP_BLT
00001460  43F9 00001C14            781          LEA     OP_BLT_MSG,A1
00001466  6000 0016                782          BRA     OP_BRANCHES_PRINT
0000146A                           783  OP_BVC
0000146A  43F9 00001C19            784          LEA     OP_BVC_MSG,A1
00001470  6000 000C                785          BRA     OP_BRANCHES_PRINT
00001474                           786  OP_BRA
00001474  43F9 00001C1E            787          LEA     OP_BRA_MSG,A1
0000147A  6000 0002                788          BRA     OP_BRANCHES_PRINT
0000147E                           789  
0000147E                           790  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
0000147E                           791          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
0000147E                           792          * assemble output to console
0000147E                           793  OP_BRANCHES_PRINT
0000147E  103C 000E                794          MOVE.B  #14,D0 * print instruction op
00001482  4E4F                     795          TRAP    #15
00001484                           796          
00001484  43F9 00001BFD            797          LEA     DATA,A1
0000148A  103C 000E                798          MOVE.B  #14,D0 * print raw data hex of the LABEL
0000148E  4E4F                     799          TRAP    #15
00001490                           800          
00001490  1A1A                     801          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
00001492  2845                     802          MOVE.L  D5,A4 * ready the 8bits into a4
00001494  43D4                     803          LEA     (A4),A1 * ready the a4 into a1 for print
00001496  103C 000E                804          MOVE.B  #14,D0 * print the 8bit addr
0000149A  4E4F                     805          TRAP    #15
0000149C                           806  
0000149C  6000 0002                807          BRA     BCC_END
000014A0                           808  
000014A0                           809  BCC_END * reload the memory, call RTS
000014A0  4C9F 0303                810          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000014A4  4E75                     811          RTS
000014A6                           812  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014A6                           813  *-----------------------------------------------------------------------------
000014A6                           814  
000014A6                           815  
000014A6                           816  
000014A6                           817  *-----------------------------------------------------------------------------
000014A6                           818  *-----------------------------------------------------------------------------
000014A6                           819  * NAME: OP_0111   ()
000014A6                           820  * DESCRIPTION:    OP code 0111 is not supported. 
000014A6                           821  * PRE-CONDITION:  
000014A6                           822  * POST-CONDITION: 
000014A6                           823  * REGISTERS:
000014A6                           824  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014A6                           825  OP0111
000014A6  6100 0520                826      BSR     UNKNOWNOP
000014AA  4E75                     827      RTS
000014AC                           828  
000014AC                           829  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014AC                           830  *-----------------------------------------------------------------------------
000014AC                           831  
000014AC                           832  
000014AC                           833  
000014AC                           834  *-----------------------------------------------------------------------------
000014AC                           835  *-----------------------------------------------------------------------------
000014AC                           836  * NAME: OP_1000   (DIVS, OR)
000014AC                           837  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000014AC                           838  * PRE-CONDITION:  xyz
000014AC                           839  * POST-CONDITION: All registers return to their previous state, and the output
000014AC                           840  *                 goes to the output console for reading the raw data or the
000014AC                           841  *                 actual instruction.
000014AC                           842  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000014AC                           843  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014AC                           844  OP1000
000014AC                           845          * Saving values to the stack
000014AC  48A7 FFC0                846          MOVEM   D0-D7/A0-A1,-(A7)
000014B0                           847  
000014B0                           848          * Check if the EA Mode is 001 since both DIVS and OR do not support it
000014B0  3C3C 0003                849          MOVE.W  #3, D6              * Prep lower value for bitmask
000014B4  3E3C 0005                850          MOVE.W  #5, D7              * Prep upper value for bitmask
000014B8  6100 06C6                851          BSR     BITMASK             * Finalize bitmask setup
000014BC  CC42                     852          AND     D2,D6               * Apply bitmask
000014BE                           853          
000014BE  0C46 0008                854          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
000014C2  6700 FF1A                855          BEQ     UNKNOWN                 * If so, the op is not supported
000014C6                           856          
000014C6                           857          * Checking for DIVS
000014C6  3C3C 0006                858          MOVE.W  #6, D6              * Prep lower value for bitmask
000014CA  3E3C 0008                859          MOVE.W  #8, D7              * Prep upper value for bitmask
000014CE  6100 06B0                860          BSR     BITMASK             * Finalize bitmask setup
000014D2  CC42                     861          AND     D2,D6               * Apply bitmask
000014D4                           862          
000014D4  0C46 01C0                863          CMPI    #%0000000111000000, D6  * Are we DIVS?
000014D8  6600 0050                864          BNE     NOTDIVS                 * If not, branch to see if it's OR
000014DC                           865          
000014DC  43F9 00001BC7            866          LEA     DIVSOP,A1           * We found DIVS
000014E2  103C 000E                867          MOVE.B  #14,D0              * Trap #14 prints out the data
000014E6  4E4F                     868          TRAP    #15                 * Perform Trap #14
000014E8                           869          
000014E8  43F9 00001C43            870          LEA     SPACE,A1            * formatting
000014EE  103C 000E                871          MOVE.B  #14,D0              * Trap #14 prints out space
000014F2  4E4F                     872          TRAP    #15                 * Perform Trap #14
000014F4                           873          
000014F4  4243                     874          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000014F6  08C3 0000                875          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000014FA                           876                                      * to indicate a potential immediate of size word
000014FA                           877          
000014FA  6100 00B0                878          BSR     EAHELPER05          * Print out data. TODO: DOESN'T WORK.
000014FE                           879  
000014FE  43F9 00001C49            880          LEA     COMMA,A1            * formatting
00001504  103C 000E                881          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001508  4E4F                     882          TRAP    #15                 * Perform Trap #14
0000150A                           883          
0000150A                           884          * bit manipulation is needed to make the outlier DIVS work
0000150A                           885          * with the generic EAHELPER611
0000150A  0882 0006                886          BCLR    #6,D2
0000150E  0882 0007                887          BCLR    #7,D2
00001512  0882 0008                888          BCLR    #8,D2
00001516                           889          
00001516                           890          * the above bits were cleared so that eahelper05 knows the destination
00001516                           891          * is a data register.
00001516                           892          
00001516  6100 0052                893          BSR     EAHELPER611 
0000151A                           894  
0000151A  43F9 00001BC4            895          LEA     NEWLINE,A1          * We found DIVS
00001520  103C 000E                896          MOVE.B  #14,D0              * Trap #14 prints out the data
00001524  4E4F                     897          TRAP    #15                 * Perform Trap #14
00001526                           898          
00001526  6000 0012                899          BRA     OP1000END
0000152A                           900          
0000152A                           901  NOTDIVS * It is confirmed OR at this point
0000152A  43F9 00001BF1            902          LEA     OROP,A1         * We found OR
00001530  103C 000E                903          MOVE.B  #14,D0          * Trap #14 prints out the data
00001534  4E4F                     904          TRAP    #15             * Perform Trap #14
00001536                           905          *================================================================
00001536                           906          * todo, move the size of the operation into the leading bits of D5
00001536                           907          * before subroutine call
00001536  6100 0032                908          BSR     EAHELPER611
0000153A                           909  
0000153A                           910  OP1000END
0000153A  4C9F 03FF                911          MOVEM   (A7)+,D0-D7/A0-A1
0000153E  4E75                     912          RTS
00001540                           913  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001540                           914  *-----------------------------------------------------------------------------
00001540                           915  
00001540                           916  
00001540                           917  
00001540                           918  *-----------------------------------------------------------------------------
00001540                           919  *-----------------------------------------------------------------------------
00001540                           920  * NAME: OP_1001   (SUB)
00001540                           921  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001540                           922  * PRE-CONDITION:  xyz
00001540                           923  * POST-CONDITION: All registers return to their previous state, and the output
00001540                           924  *                 goes to the output console for reading the raw data or the
00001540                           925  *                 actual instruction.
00001540                           926  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001540                           927  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001540                           928  OP1001
00001540                           929  
00001540  6100 0486                930      BSR     UNKNOWNOP
00001544  4E75                     931      RTS
00001546                           932  
00001546                           933  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001546                           934  *-----------------------------------------------------------------------------
00001546                           935  
00001546                           936  
00001546                           937  
00001546                           938  *-----------------------------------------------------------------------------
00001546                           939  *-----------------------------------------------------------------------------
00001546                           940  * NAME: OP_1010   ()
00001546                           941  * DESCRIPTION:    a
00001546                           942  * PRE-CONDITION:  b
00001546                           943  * POST-CONDITION: c
00001546                           944  * REGISTERS:      d
00001546                           945  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001546                           946  OP1010
00001546                           947  
00001546  6100 0480                948      BSR     UNKNOWNOP
0000154A  4E75                     949      RTS
0000154C                           950  
0000154C                           951  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000154C                           952  *-----------------------------------------------------------------------------
0000154C                           953  
0000154C                           954  
0000154C                           955  
0000154C                           956  *-----------------------------------------------------------------------------
0000154C                           957  *-----------------------------------------------------------------------------
0000154C                           958  * NAME: OP_1011   (EOR, CMP)
0000154C                           959  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000154C                           960  * PRE-CONDITION:  xyz
0000154C                           961  * POST-CONDITION: All registers return to their previous state, and the output
0000154C                           962  *                 goes to the output console for reading the raw data or the
0000154C                           963  *                 actual instruction.
0000154C                           964  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000154C                           965  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000154C                           966  OP1011
0000154C                           967  
0000154C  6100 047A                968      BSR     UNKNOWNOP
00001550  4E75                     969      RTS
00001552                           970  
00001552                           971  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001552                           972  *-----------------------------------------------------------------------------
00001552                           973  
00001552                           974  
00001552                           975  
00001552                           976  *-----------------------------------------------------------------------------
00001552                           977  *-----------------------------------------------------------------------------
00001552                           978  * NAME: OP_1100   (MULS)
00001552                           979  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001552                           980  * PRE-CONDITION:  xyz
00001552                           981  * POST-CONDITION: All registers return to their previous state, and the output
00001552                           982  *                 goes to the output console for reading the raw data or the
00001552                           983  *                 actual instruction.
00001552                           984  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001552                           985  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001552                           986  OP1100
00001552                           987  
00001552  6100 0474                988      BSR     UNKNOWNOP
00001556  4E75                     989      RTS
00001558                           990  
00001558                           991  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001558                           992  *-----------------------------------------------------------------------------
00001558                           993  
00001558                           994  
00001558                           995  
00001558                           996  *-----------------------------------------------------------------------------
00001558                           997  *-----------------------------------------------------------------------------
00001558                           998  * NAME: OP_1101   (ADD, ADDA)
00001558                           999  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001558                          1000  * PRE-CONDITION:  xyz
00001558                          1001  * POST-CONDITION: All registers return to their previous state, and the output
00001558                          1002  *                 goes to the output console for reading the raw data or the
00001558                          1003  *                 actual instruction.
00001558                          1004  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001558                          1005  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001558                          1006  OP1101
00001558                          1007  
00001558  6100 046E               1008      BSR     UNKNOWNOP
0000155C  4E75                    1009      RTS
0000155E                          1010  
0000155E                          1011  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000155E                          1012  *-----------------------------------------------------------------------------
0000155E                          1013  
0000155E                          1014  
0000155E                          1015  
0000155E                          1016  *-----------------------------------------------------------------------------
0000155E                          1017  *-----------------------------------------------------------------------------
0000155E                          1018  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
0000155E                          1019  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000155E                          1020  * PRE-CONDITION:  xyz
0000155E                          1021  * POST-CONDITION: All registers return to their previous state, and the output
0000155E                          1022  *                 goes to the output console for reading the raw data or the
0000155E                          1023  *                 actual instruction.
0000155E                          1024  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000155E                          1025  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000155E                          1026  OP1110
0000155E                          1027  
0000155E  6100 0468               1028      BSR     UNKNOWNOP
00001562  4E75                    1029      RTS
00001564                          1030  
00001564                          1031  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001564                          1032  *-----------------------------------------------------------------------------
00001564                          1033  
00001564                          1034  
00001564                          1035  
00001564                          1036  *-----------------------------------------------------------------------------
00001564                          1037  *-----------------------------------------------------------------------------
00001564                          1038  * NAME: OP_1111   ()
00001564                          1039  * DESCRIPTION:    a
00001564                          1040  * PRE-CONDITION:  b
00001564                          1041  * POST-CONDITION: c
00001564                          1042  * REGISTERS:      d
00001564                          1043  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001564                          1044  OP1111
00001564                          1045  
00001564  6100 0462               1046      BSR     UNKNOWNOP
00001568  4E75                    1047      RTS
0000156A                          1048  
0000156A                          1049  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000156A                          1050  *-----------------------------------------------------------------------------
0000156A                          1051  
0000156A                          1052  
0000156A                          1053  
0000156A                          1054  *-----------------------------------------------------------------------------
0000156A                          1055  *-----------------------------------------------------------------------------
0000156A                          1056  * NAME:           EAHELPER611
0000156A                          1057  * DESCRIPTION:    a
0000156A                          1058  * PRE-CONDITION:  D2 contains the instruction to print modes for.
0000156A                          1059  *                 D5 contains the size of the data to be printed
0000156A                          1060  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
0000156A                          1061  *                 EAHELPER05 to print.
0000156A                          1062  * REGISTERS:      a
0000156A                          1063  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000156A                          1064  EAHELPER611
0000156A  48A7 FFC0               1065      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
0000156E                          1066      
0000156E  3C3C 0006               1067      MOVE.W  #6, D6              * Prep lower value for bitmask
00001572  3E3C 0008               1068      MOVE.W  #8, D7              * Prep upper value for bitmask
00001576  6100 0608               1069      BSR     BITMASK             * Finalize bitmask setup
0000157A  CC42                    1070      AND     D2,D6               * Apply bitmask
0000157C                          1071      
0000157C                          1072      * to move the mode where EAHELPER50 can process it
0000157C  7C06                    1073      MOVE.L  #6,D6
0000157E  7E08                    1074      MOVE.L  #8,D7
00001580                          1075      
00001580  6100 05FE               1076      BSR     BITMASK * create bitmask
00001584                          1077      
00001584  CC42                    1078      AND     D2,D6   * apply bitmask
00001586                          1079      
00001586  4243                    1080      CLR     D3      * prep D3 to store values
00001588                          1081      
00001588  3606                    1082      MOVE.W  D6,D3   * store bitmasked value in D3
0000158A                          1083      
0000158A  E64B                    1084      LSR     #3,D3   * move bits 6-8 to 3-5
0000158C                          1085      
0000158C                          1086      * to move the register where EAHELPER50 can process it
0000158C  7C09                    1087      MOVE.L  #9,D6   *prep registers to create bitmask
0000158E  7E0B                    1088      MOVE.L  #11,D7
00001590                          1089      
00001590  6100 05EE               1090      BSR     BITMASK * create bitmask
00001594                          1091      
00001594  CC42                    1092      AND     D2,D6   * apply bitmask
00001596                          1093      
00001596  4244                    1094      CLR     D4      * prep D3 to store values
00001598                          1095      
00001598  3806                    1096      MOVE.W  D6,D4   * store bitmasked value in D3
0000159A                          1097      
0000159A  E04C                    1098      LSR     #8,D4   * move bits 9-11 to 0-2
0000159C  E24C                    1099      LSR     #1,D4   * move bits 9-11 to 0-2
0000159E                          1100      
0000159E  8684                    1101      OR.L    D4,D3   * combind the register and mode
000015A0                          1102      
000015A0  2403                    1103      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
000015A2                          1104      
000015A2  6100 0008               1105      BSR     EAHELPER05
000015A6                          1106      
000015A6                          1107  ENDEAHELPER611
000015A6                          1108      
000015A6  4C9F 03FF               1109      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
000015AA                          1110      
000015AA  4E75                    1111      RTS
000015AC                          1112  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015AC                          1113  *-----------------------------------------------------------------------------
000015AC                          1114  
000015AC                          1115  
000015AC                          1116  
000015AC                          1117  *-----------------------------------------------------------------------------
000015AC                          1118  *-----------------------------------------------------------------------------
000015AC                          1119  * NAME:           EAHELPER05
000015AC                          1120  * DESCRIPTION:    a
000015AC                          1121  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
000015AC                          1122  *                 this sub-routine helper for operations that only have one
000015AC                          1123  *                 mode register.
000015AC                          1124  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
000015AC                          1125  * REGISTERS:      a
000015AC                          1126  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015AC                          1127  EAHELPER05
000015AC                          1128      * todo: add code for printing immediate values
000015AC                          1129      
000015AC  48A7 FFC0               1130      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000015B0                          1131      
000015B0  7C03                    1132      MOVE.L  #3,D6
000015B2  7E05                    1133      MOVE.L  #5,D7
000015B4                          1134      
000015B4  6100 05CA               1135      BSR     BITMASK * generate a bitmask to identify the mode
000015B8                          1136      
000015B8  CC42                    1137      AND     D2,D6   * mask off the parts of D2 we don't need
000015BA                          1138      
000015BA  2A06                    1139      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
000015BC                          1140      
000015BC  0C46 0000               1141      CMPI    #%0000000000000000,D6 * is it data register direct?
000015C0  6600 000A               1142      BNE     NOTDATAREG
000015C4                          1143      
000015C4  6100 013C               1144      BSR     MODE_DN
000015C8                          1145       
000015C8  6000 0132               1146      BRA     ENDEAHELPER05
000015CC                          1147      
000015CC                          1148  NOTDATAREG * address register direct
000015CC                          1149      
000015CC  0C46 0008               1150      CMPI    #%0000000000001000,D6 * is it address register direct?
000015D0  6600 000A               1151      BNE     NOTADRDIRECT
000015D4                          1152      
000015D4  6100 022C               1153      BSR     MODE_AN * simply prints out the address register
000015D8                          1154       
000015D8  6000 0122               1155      BRA     ENDEAHELPER05
000015DC                          1156      
000015DC                          1157  NOTADRDIRECT * address register indirect
000015DC                          1158          
000015DC  0C46 0010               1159      CMPI    #%0000000000010000,D6 * is it address register indirect?
000015E0  6600 0022               1160      BNE     NOTADRINDIRECT
000015E4                          1161      
000015E4  43F9 00001C4B           1162      LEA     OBRACK,A1       * Load '('
000015EA  303C 000E               1163      MOVE.W  #14,D0          * Trap #14 to display message
000015EE  4E4F                    1164      TRAP    #15             * Perform #14
000015F0                          1165          
000015F0                          1166  
000015F0  6100 0210               1167      BSR     MODE_AN * print out an address register
000015F4                          1168      
000015F4  43F9 00001C4D           1169      LEA     CBRACK,A1       * Load ')'
000015FA  303C 000E               1170      MOVE.W  #14,D0          * Trap #14 to display message
000015FE  4E4F                    1171      TRAP    #15             * Perform #14
00001600                          1172       
00001600  6000 00FA               1173      BRA     ENDEAHELPER05
00001604                          1174      
00001604                          1175  NOTADRINDIRECT * address register indirect, post increment
00001604                          1176      
00001604  0C46 0018               1177      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
00001608  6600 002E               1178      BNE     NOTADRINDIRECTPOST
0000160C                          1179      
0000160C  43F9 00001C4B           1180      LEA     OBRACK,A1       * Load '('
00001612  303C 000E               1181      MOVE.W  #14,D0          * Trap #14 to display message
00001616  4E4F                    1182      TRAP    #15             * Perform #14
00001618                          1183          
00001618                          1184  
00001618  6100 01E8               1185      BSR     MODE_AN * print out an address register
0000161C                          1186      
0000161C  43F9 00001C4D           1187      LEA     CBRACK,A1       * Load ')'
00001622  303C 000E               1188      MOVE.W  #14,D0          * Trap #14 to display message
00001626  4E4F                    1189      TRAP    #15             * Perform #14
00001628                          1190      
00001628  43F9 00001C4F           1191      LEA     PLUS,A1       * Load '+'
0000162E  303C 000E               1192      MOVE.W  #14,D0          * Trap #14 to display message
00001632  4E4F                    1193      TRAP    #15             * Perform #14
00001634                          1194       
00001634  6000 00C6               1195      BRA     ENDEAHELPER05
00001638                          1196      
00001638                          1197  NOTADRINDIRECTPOST * address register indirect, pre decrement
00001638                          1198      
00001638  0C46 0020               1199      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
0000163C  6600 002E               1200      BNE     NOTADRINDIRECTPRE
00001640                          1201      
00001640  43F9 00001C51           1202      LEA     MINUS,A1       * Load '-'
00001646  303C 000E               1203      MOVE.W  #14,D0          * Trap #14 to display message
0000164A  4E4F                    1204      TRAP    #15             * Perform #14
0000164C                          1205      
0000164C  43F9 00001C4B           1206      LEA     OBRACK,A1       * Load '('
00001652  303C 000E               1207      MOVE.W  #14,D0          * Trap #14 to display message
00001656  4E4F                    1208      TRAP    #15             * Perform #14
00001658                          1209          
00001658                          1210  
00001658  6100 01A8               1211      BSR     MODE_AN * print out an address register
0000165C                          1212      
0000165C  43F9 00001C4D           1213      LEA     CBRACK,A1       * Load ')'
00001662  303C 000E               1214      MOVE.W  #14,D0          * Trap #14 to display message
00001666  4E4F                    1215      TRAP    #15             * Perform #14
00001668                          1216       
00001668  6000 0092               1217      BRA     ENDEAHELPER05
0000166C                          1218  
0000166C                          1219  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
0000166C                          1220  
0000166C  0C46 0038               1221      CMPI    #%0000000000111000,D6 * is it immediate?
00001670  6600 0086               1222      BNE     NOTIMMEDIATE
00001674                          1223  
00001674  0C43 0001               1224      CMPI    #1,D3 * is it a byte?
00001678  6600 0028               1225      BNE     NOTIMMBYTE
0000167C                          1226      
0000167C  43F9 00001C47           1227      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001682  103C 000E               1228      MOVE.B  #14,D0
00001686  4E4F                    1229      TRAP    #15
00001688                          1230      
00001688  3C3C 0000               1231      MOVE.W  #0, D6              * Prep lower value for bitmask
0000168C  3E3C 0007               1232      MOVE.W  #7, D7              * Prep upper value for bitmask
00001690  6100 04EE               1233      BSR     BITMASK             * Finalize bitmask setup
00001694                          1234          
00001694  321A                    1235      MOVE.W  (A2)+,D1
00001696                          1236      
00001696  C286                    1237      AND.L     D6,D1
00001698                          1238          
00001698  103C 0003               1239      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000169C  4E4F                    1240      TRAP    #15      * Perform Trap #3
0000169E                          1241      
0000169E  6000 005C               1242      BRA     ENDEAHELPER05
000016A2                          1243  
000016A2                          1244  NOTIMMBYTE
000016A2                          1245      
000016A2  0C43 0002               1246      CMPI    #2,D3 * is it a word?
000016A6  6600 0028               1247      BNE     NOTIMMWORD
000016AA                          1248      
000016AA  43F9 00001C47           1249      LEA     IMD,A1 *print out the '#' indicating an immediate value
000016B0  103C 000E               1250      MOVE.B  #14,D0
000016B4  4E4F                    1251      TRAP    #15
000016B6                          1252      
000016B6  3C3C 0000               1253      MOVE.W  #0, D6              * Prep lower value for bitmask
000016BA  3E3C 000F               1254      MOVE.W  #15, D7             * Prep upper value for bitmask
000016BE  6100 04C0               1255      BSR     BITMASK             * Finalize bitmask setup
000016C2                          1256          
000016C2  321A                    1257      MOVE.W  (A2)+,D1
000016C4                          1258      
000016C4  C286                    1259      AND.L     D6,D1               * Apply bitmask
000016C6                          1260          
000016C6  103C 0003               1261      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000016CA  4E4F                    1262      TRAP    #15      * Perform Trap #3
000016CC                          1263      
000016CC  6000 002E               1264      BRA     ENDEAHELPER05
000016D0                          1265      
000016D0                          1266  NOTIMMWORD
000016D0  0C43 0003               1267      CMPI    #3,D3 * is it a long?
000016D4  6600 0022               1268      BNE     NOTIMMEDIATE
000016D8                          1269      
000016D8  43F9 00001C47           1270      LEA     IMD,A1 *print out the '#' indicating an immediate value
000016DE  103C 000E               1271      MOVE.B  #14,D0
000016E2  4E4F                    1272      TRAP    #15
000016E4                          1273          
000016E4  221A                    1274      MOVE.L  (A2)+,D1
000016E6                          1275          
000016E6  103C 0003               1276      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000016EA  4E4F                    1277      TRAP    #15      * Perform Trap #3
000016EC                          1278      
000016EC  321A                    1279      MOVE.W  (A2)+,D1
000016EE                          1280          
000016EE  103C 0003               1281      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000016F2  4E4F                    1282      TRAP    #15      * Perform Trap #3
000016F4                          1283      
000016F4  6000 0006               1284      BRA     ENDEAHELPER05
000016F8                          1285  
000016F8                          1286  NOTIMMEDIATE    
000016F8                          1287  
000016F8                          1288  
000016F8  6100 02CE               1289      BSR     UNKNOWNOP
000016FC                          1290      
000016FC                          1291  ENDEAHELPER05
000016FC  4C9F 03FF               1292      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001700  4E75                    1293      RTS
00001702                          1294  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001702                          1295  *-----------------------------------------------------------------------------
00001702                          1296  
00001702                          1297  
00001702                          1298  
00001702                          1299  *-----------------------------------------------------------------------------
00001702                          1300  *-----------------------------------------------------------------------------
00001702                          1301  * NAME:           MODE_DN
00001702                          1302  * DESCRIPTION:    Generalize the EA part of the project.
00001702                          1303  * PRE-CONDITION:  The mode must have been correctly identified. All modes
00001702                          1304  *                 must be called by RTS.
00001702                          1305  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
00001702                          1306  *                 called it.
00001702                          1307  * REGISTERS:      a
00001702                          1308  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001702                          1309  * ---> Dn
00001702                          1310  MODE_DN
00001702  48A7 FFC0               1311          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001706                          1312  
00001706  3C3C 0000               1313          MOVE.W  #0, D6              * Prep lower value for bitmask
0000170A  3E3C 0002               1314          MOVE.W  #2, D7              * Prep upper value for bitmask
0000170E  6100 0470               1315          BSR     BITMASK             * Finalize bitmask setup
00001712  CC42                    1316          AND     D2,D6               * Apply bitmask
00001714                          1317          
00001714  0C46 0000               1318          CMPI    #%000000000000000, D6   * Data Register D0?
00001718  6600 000A               1319          BNE     NOTD0
0000171C                          1320          
0000171C  6100 0074               1321          BSR     PRINTD0
00001720  6000 006A               1322          BRA     ENDMODE_DN
00001724                          1323  NOTD0      
00001724  0C46 0001               1324          CMPI    #%000000000000001, D6   * Data Register D1?
00001728  6600 000A               1325          BNE     NOTD1
0000172C                          1326          
0000172C  6100 0072               1327          BSR     PRINTD1
00001730  6000 005A               1328          BRA     ENDMODE_DN
00001734                          1329  NOTD1
00001734  0C46 0002               1330          CMPI    #%000000000000010, D6   * Data Register D2?
00001738  6600 000A               1331          BNE     NOTD2
0000173C                          1332          
0000173C  6100 0070               1333          BSR     PRINTD2
00001740  6000 004A               1334          BRA     ENDMODE_DN
00001744                          1335  NOTD2
00001744  0C46 0003               1336          CMPI    #%000000000000011, D6   * Data Register D3?
00001748  6600 000A               1337          BNE     NOTD3
0000174C                          1338          
0000174C  6100 006E               1339          BSR     PRINTD3
00001750  6000 003A               1340          BRA     ENDMODE_DN
00001754                          1341  NOTD3
00001754  0C46 0004               1342          CMPI    #%000000000000100, D6   * Data Register D4?
00001758  6600 000A               1343          BNE     NOTD4
0000175C                          1344          
0000175C  6100 006C               1345          BSR     PRINTD4
00001760  6000 002A               1346          BRA     ENDMODE_DN
00001764                          1347  NOTD4
00001764  0C46 0005               1348          CMPI    #%000000000000101, D6   * Data Register D5?
00001768  6600 000A               1349          BNE     NOTD5
0000176C                          1350          
0000176C  6100 006A               1351          BSR     PRINTD5
00001770  6000 001A               1352          BRA     ENDMODE_DN
00001774                          1353  NOTD5
00001774  0C46 0006               1354          CMPI    #%000000000000110, D6   * Data Register D6?
00001778  6600 000A               1355          BNE     NOTD6
0000177C                          1356          
0000177C  6100 0068               1357          BSR     PRINTD6
00001780  6000 000A               1358          BRA     ENDMODE_DN
00001784                          1359  NOTD6
00001784  6100 006E               1360          BSR     PRINTD7
00001788  6000 0002               1361          BRA     ENDMODE_DN
0000178C                          1362          
0000178C                          1363  ENDMODE_DN
0000178C  4C9F 03FF               1364          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001790  4E75                    1365          RTS
00001792                          1366  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001792                          1367  *-----------------------------------------------------------------------------
00001792                          1368  
00001792                          1369  
00001792                          1370  
00001792                          1371  *-----------------------------------------------------------------------------
00001792                          1372  *-----------------------------------------------------------------------------
00001792                          1373  * NAME:           PRINTD0
00001792                          1374  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
00001792                          1375  * PRE-CONDITION:  a
00001792                          1376  * POST-CONDITION: a
00001792                          1377  * REGISTERS:      a
00001792                          1378  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001792                          1379  PRINTD0
00001792  43F9 00001C77           1380          LEA     __D0, A1        * Load 'D0'
00001798  103C 000E               1381          MOVE.B  #14, D0         * Load Trap #14 to print out
0000179C  4E4F                    1382          TRAP    #15             * Perform Trap #14
0000179E  4E75                    1383          RTS
000017A0                          1384  PRINTD1
000017A0  43F9 00001C7A           1385          LEA     __D1, A1        * Load 'D1'
000017A6  103C 000E               1386          MOVE.B  #14, D0         * Load Trap #14 to print out
000017AA  4E4F                    1387          TRAP    #15             * Perform Trap #14
000017AC  4E75                    1388          RTS      
000017AE                          1389  PRINTD2
000017AE  43F9 00001C7D           1390          LEA     __D2, A1        * Load 'D2'
000017B4  103C 000E               1391          MOVE.B  #14, D0         * Load Trap #14 to print out
000017B8  4E4F                    1392          TRAP    #15             * Perform Trap #14
000017BA  4E75                    1393          RTS      
000017BC                          1394  PRINTD3
000017BC  43F9 00001C80           1395          LEA     __D3, A1        * Load 'D3'
000017C2  103C 000E               1396          MOVE.B  #14, D0         * Load Trap #14 to print out
000017C6  4E4F                    1397          TRAP    #15             * Perform Trap #14
000017C8  4E75                    1398          RTS      
000017CA                          1399  PRINTD4
000017CA  43F9 00001C83           1400          LEA     __D4, A1        * Load 'D4'
000017D0  103C 000E               1401          MOVE.B  #14, D0         * Load Trap #14 to print out
000017D4  4E4F                    1402          TRAP    #15             * Perform Trap #14
000017D6  4E75                    1403          RTS       
000017D8                          1404  PRINTD5
000017D8  43F9 00001C86           1405          LEA     __D5, A1        * Load 'D5'
000017DE  103C 000E               1406          MOVE.B  #14, D0         * Load Trap #14 to print out
000017E2  4E4F                    1407          TRAP    #15             * Perform Trap #14
000017E4  4E75                    1408          RTS      
000017E6                          1409  PRINTD6
000017E6  43F9 00001C89           1410          LEA     __D6, A1        * Load 'D6'
000017EC  103C 000E               1411          MOVE.B  #14, D0         * Load Trap #14 to print out
000017F0  4E4F                    1412          TRAP    #15             * Perform Trap #14
000017F2  4E75                    1413          RTS
000017F4                          1414  PRINTD7
000017F4  43F9 00001C8C           1415          LEA     __D7, A1        * Load 'D7'
000017FA  103C 000E               1416          MOVE.B  #14, D0         * Load Trap #14 to print out
000017FE  4E4F                    1417          TRAP    #15             * Perform Trap #14
00001800  4E75                    1418          RTS
00001802                          1419  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001802                          1420  *-----------------------------------------------------------------------------
00001802                          1421  
00001802                          1422  
00001802                          1423  
00001802                          1424  *-----------------------------------------------------------------------------
00001802                          1425  *-----------------------------------------------------------------------------
00001802                          1426  * NAME:           MODE_AN
00001802                          1427  * DESCRIPTION:    Simply chooses to print A0-A7.
00001802                          1428  * PRE-CONDITION:  a
00001802                          1429  * POST-CONDITION: a
00001802                          1430  * REGISTERS:      a
00001802                          1431  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001802                          1432  MODE_AN
00001802  48A7 FFC0               1433          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
00001806                          1434  
00001806  3C3C 0000               1435          MOVE.W  #0, D6              * Prep lower value for bitmask
0000180A  3E3C 0002               1436          MOVE.W  #2, D7              * Prep upper value for bitmask
0000180E  6100 0370               1437          BSR     BITMASK             * Finalize bitmask setup
00001812  CC42                    1438          AND     D2,D6               * Apply bitmask
00001814                          1439          
00001814  0C46 0000               1440          CMPI    #%000000000000000, D6   * Address Register A0?
00001818  6600 000A               1441          BNE     NOTA0
0000181C                          1442          
0000181C  6100 0074               1443          BSR     PRINTA0
00001820                          1444          
00001820  6000 006A               1445          BRA     ENDMODE_AN
00001824                          1446  NOTA0      
00001824  0C46 0001               1447          CMPI    #%000000000000001, D6   * Address Register A1?
00001828  6600 000A               1448          BNE     NOTA1
0000182C                          1449          
0000182C  6100 0072               1450          BSR     PRINTA1
00001830                          1451          
00001830  6000 005A               1452          BRA     ENDMODE_AN
00001834                          1453  NOTA1
00001834  0C46 0002               1454          CMPI    #%000000000000010, D6   * Address Register A2?
00001838  6600 000A               1455          BNE     NOTA2
0000183C                          1456          
0000183C  6100 0070               1457          BSR     PRINTA2
00001840                          1458          
00001840  6000 004A               1459          BRA     ENDMODE_AN
00001844                          1460  NOTA2
00001844  0C46 0003               1461          CMPI    #%000000000000011, D6   * Address Register A3?
00001848  6600 000A               1462          BNE     NOTA3
0000184C                          1463          
0000184C  6100 006E               1464          BSR     PRINTA3
00001850                          1465          
00001850  6000 003A               1466          BRA     ENDMODE_AN
00001854                          1467  NOTA3
00001854  0C46 0004               1468          CMPI    #%000000000000100, D6   * Address Register A4?
00001858  6600 000A               1469          BNE     NOTA4
0000185C                          1470          
0000185C  6100 006C               1471          BSR     PRINTA4
00001860                          1472          
00001860  6000 002A               1473          BRA     ENDMODE_AN
00001864                          1474  NOTA4
00001864  0C46 0005               1475          CMPI    #%000000000000101, D6   * Address Register A5?
00001868  6600 000A               1476          BNE     NOTA5
0000186C                          1477          
0000186C  6100 006A               1478          BSR     PRINTA5
00001870                          1479          
00001870  6000 001A               1480          BRA     ENDMODE_AN
00001874                          1481  NOTA5
00001874  0C46 0006               1482          CMPI    #%000000000000110, D6   * Address Register A6?
00001878  6600 000A               1483          BNE     NOTA6
0000187C                          1484          
0000187C  6100 0068               1485          BSR     PRINTA6
00001880                          1486          
00001880  6000 000A               1487          BRA     ENDMODE_AN
00001884                          1488  NOTA6
00001884  6100 006E               1489          BSR     PRINTA7
00001888                          1490          
00001888  6000 0002               1491          BRA     ENDMODE_AN
0000188C                          1492  ENDMODE_AN
0000188C  4C9F 03FF               1493          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
00001890  4E75                    1494          RTS
00001892                          1495  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001892                          1496  *-----------------------------------------------------------------------------
00001892                          1497  
00001892                          1498  
00001892                          1499  
00001892                          1500  *-----------------------------------------------------------------------------
00001892                          1501  *-----------------------------------------------------------------------------
00001892                          1502  * NAME:           PRINTA0
00001892                          1503  * DESCRIPTION:    Simply print out the address register.
00001892                          1504  * PRE-CONDITION:  a
00001892                          1505  * POST-CONDITION: a
00001892                          1506  * REGISTERS:      a
00001892                          1507  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001892                          1508  PRINTA0
00001892  43F9 00001C5F           1509          LEA     __A0, A1        * Load 'A0'
00001898  103C 000E               1510          MOVE.B  #14, D0         * Load Trap #14 to print out
0000189C  4E4F                    1511          TRAP    #15             * Perform Trap #14
0000189E  4E75                    1512          RTS
000018A0                          1513  
000018A0                          1514  PRINTA1
000018A0  43F9 00001C62           1515          LEA     __A1, A1        * Load 'A1'
000018A6  103C 000E               1516          MOVE.B  #14, D0         * Load Trap #14 to print out
000018AA  4E4F                    1517          TRAP    #15             * Perform Trap #14
000018AC  4E75                    1518          RTS
000018AE                          1519          
000018AE                          1520  PRINTA2
000018AE  43F9 00001C65           1521          LEA     __A2, A1        * Load 'A2'
000018B4  103C 000E               1522          MOVE.B  #14, D0         * Load Trap #14 to print out
000018B8  4E4F                    1523          TRAP    #15             * Perform Trap #14
000018BA  4E75                    1524          RTS
000018BC                          1525  
000018BC                          1526  PRINTA3
000018BC  43F9 00001C68           1527          LEA     __A3, A1        * Load 'A3'
000018C2  103C 000E               1528          MOVE.B  #14, D0         * Load Trap #14 to print out
000018C6  4E4F                    1529          TRAP    #15             * Perform Trap #14
000018C8  4E75                    1530          RTS
000018CA                          1531  
000018CA                          1532  PRINTA4
000018CA  43F9 00001C6B           1533          LEA     __A4, A1        * Load 'A4'
000018D0  103C 000E               1534          MOVE.B  #14, D0         * Load Trap #14 to print out
000018D4  4E4F                    1535          TRAP    #15             * Perform Trap #14
000018D6  4E75                    1536          RTS
000018D8                          1537  
000018D8                          1538  PRINTA5
000018D8  43F9 00001C6E           1539          LEA     __A5, A1        * Load 'A5'
000018DE  103C 000E               1540          MOVE.B  #14, D0         * Load Trap #14 to print out
000018E2  4E4F                    1541          TRAP    #15             * Perform Trap #14
000018E4  4E75                    1542          RTS
000018E6                          1543  
000018E6                          1544  PRINTA6
000018E6  43F9 00001C71           1545          LEA     __A6, A1        * Load 'A6'
000018EC  103C 000E               1546          MOVE.B  #14, D0         * Load Trap #14 to print out
000018F0  4E4F                    1547          TRAP    #15             * Perform Trap #14
000018F2  4E75                    1548          RTS
000018F4                          1549  
000018F4                          1550  PRINTA7
000018F4  43F9 00001C74           1551          LEA     __A7, A1        * Load 'A7'
000018FA  103C 000E               1552          MOVE.B  #14, D0         * Load Trap #14 to print out
000018FE  4E4F                    1553          TRAP    #15             * Perform Trap #14
00001900  4E75                    1554          RTS
00001902                          1555  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001902                          1556  *-----------------------------------------------------------------------------
00001902                          1557  
00001902                          1558  
00001902                          1559  
00001902                          1560  *-----------------------------------------------------------------------------
00001902                          1561  *-----------------------------------------------------------------------------
00001902                          1562  * NAME:           SIZE67
00001902                          1563  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001902                          1564  * PRE-CONDITION:  a
00001902                          1565  * POST-CONDITION: a
00001902                          1566  * REGISTERS:      a
00001902                          1567  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001902                          1568  SIZE67
00001902  48A7 FFFE               1569          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001906  3C3C 0006               1570          MOVE.W  #6, D6              * Prep lower value for bitmask
0000190A  3E3C 0007               1571          MOVE.W  #7, D7              * Prep upper value for bitmask
0000190E  6100 0270               1572          BSR     BITMASK             * Finalize bitmask setup
00001912  CC42                    1573          AND     D2,D6               * Apply bitmask     
00001914                          1574  
00001914  0C46 0000               1575          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001918  6600 000A               1576          BNE     NOT67BYTE
0000191C                          1577          
0000191C  6100 0080               1578          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001920  6000 001E               1579          BRA     END67
00001924                          1580  NOT67BYTE        
00001924  0C46 0040               1581          CMPI    #%0000000001000000, D6   * is it a WORD?
00001928  6600 000A               1582          BNE     NOT67WORD
0000192C                          1583          
0000192C  6100 007E               1584          BSR     PRINTWORD               * Branch to handle WORD sizes
00001930  6000 000E               1585          BRA     END67
00001934                          1586  NOT67WORD
00001934  0C46 0080               1587          CMPI    #%0000000010000000, D6   * is it a LONG?
00001938  6600 0006               1588          BNE     END67
0000193C                          1589          
0000193C  6100 007C               1590          BSR     PRINTLONG               * Branch to handle LONG sizes
00001940                          1591  END67
00001940  4C9F 7FFF               1592          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001944  4E75                    1593          RTS                             * Return. Size handling is finished.
00001946                          1594  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001946                          1595  *-----------------------------------------------------------------------------
00001946                          1596  
00001946                          1597  
00001946                          1598  
00001946                          1599  *-----------------------------------------------------------------------------
00001946                          1600  *-----------------------------------------------------------------------------
00001946                          1601  * NAME:           SIZE68
00001946                          1602  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
00001946                          1603  * PRE-CONDITION:  a
00001946                          1604  * POST-CONDITION: a
00001946                          1605  * REGISTERS:      a
00001946                          1606  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001946                          1607  SIZE68
00001946                          1608          * finish later, need to follow the same format as SIZE67
00001946                          1609          
00001946                          1610          
00001946  48A7 FFFE               1611          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
0000194A  3C3C 0006               1612          MOVE.W  #6, D6              * Prep lower value for bitmask
0000194E  3E3C 0008               1613          MOVE.W  #8, D7              * Prep upper value for bitmask
00001952  6100 022C               1614          BSR     BITMASK             * Finalize bitmask setup
00001956  CC42                    1615          AND     D2,D6               * Apply bitmask          
00001958                          1616          
00001958  0C46 0000               1617          CMPI    #%0000000000000000, D6   * is it a BYTE?
0000195C  6100 0040               1618          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001960  0C46 0100               1619          CMPI    #%0000000100000000, D6   * is it a BYTE?
00001964  6100 0038               1620          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001968                          1621        
00001968  0C46 0040               1622          CMPI    #%0000000001000000, D6   * is it a WORD?
0000196C  6100 003E               1623          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001970  0C46 0140               1624          CMPI    #%0000000101000000, D6   * is it a WORD?
00001974  6100 0036               1625          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001978  0C46 00C0               1626          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
0000197C  6100 002E               1627          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001980                          1628  
00001980  0C46 0080               1629          CMPI    #%0000000010000000, D6   * is it a LONG?
00001984  6100 0034               1630          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001988  0C46 0180               1631          CMPI    #%0000000110000000, D6   * is it a LONG?
0000198C  6100 002C               1632          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001990  0C46 01C0               1633          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001994  6100 0024               1634          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001998                          1635  
00001998  4C9F 7FFF               1636          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
0000199C  4E75                    1637          RTS                             * Return. Size handling is finished.
0000199E                          1638  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000199E                          1639  *-----------------------------------------------------------------------------
0000199E                          1640  
0000199E                          1641  
0000199E                          1642  
0000199E                          1643  *-----------------------------------------------------------------------------
0000199E                          1644  *-----------------------------------------------------------------------------
0000199E                          1645  * NAME:           PRINTBYTE
0000199E                          1646  * DESCRIPTION:    a
0000199E                          1647  * PRE-CONDITION:  a
0000199E                          1648  * POST-CONDITION: a
0000199E                          1649  * REGISTERS:      a
0000199E                          1650  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000199E                          1651  PRINTBYTE
0000199E  43F9 00001C53           1652          LEA     __B,A1      * Load '.B ' into A1
000019A4  103C 000E               1653          MOVE.B  #14,D0      * Trap #14 setup to print
000019A8  4E4F                    1654          TRAP    #15         * Perform Trap #14
000019AA  4E75                    1655          RTS                 * Return to SIZE67/SIZE68
000019AC                          1656          
000019AC                          1657  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019AC                          1658  *-----------------------------------------------------------------------------
000019AC                          1659  
000019AC                          1660  
000019AC                          1661  
000019AC                          1662  *-----------------------------------------------------------------------------
000019AC                          1663  *-----------------------------------------------------------------------------
000019AC                          1664  * NAME:           PRINTWORD
000019AC                          1665  * DESCRIPTION:    a
000019AC                          1666  * PRE-CONDITION:  a
000019AC                          1667  * POST-CONDITION: a
000019AC                          1668  * REGISTERS:      a
000019AC                          1669  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019AC                          1670  PRINTWORD
000019AC  43F9 00001C57           1671          LEA     __W,A1      * Load '.W ' into A1
000019B2  103C 000E               1672          MOVE.B  #14,D0      * Trap #14 setup to print
000019B6  4E4F                    1673          TRAP    #15         * Perform Trap #14
000019B8  4E75                    1674          RTS                 * Return to SIZE67/SIZE68
000019BA                          1675          
000019BA                          1676  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019BA                          1677  *-----------------------------------------------------------------------------
000019BA                          1678  
000019BA                          1679  
000019BA                          1680  
000019BA                          1681  *-----------------------------------------------------------------------------
000019BA                          1682  *-----------------------------------------------------------------------------
000019BA                          1683  * NAME:           PRINTLONG
000019BA                          1684  * DESCRIPTION:    a
000019BA                          1685  * PRE-CONDITION:  a
000019BA                          1686  * POST-CONDITION: a
000019BA                          1687  * REGISTERS:      a
000019BA                          1688  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019BA                          1689  PRINTLONG
000019BA  43F9 00001C5B           1690          LEA     __L,A1      * Load '.L ' into A1
000019C0  103C 000E               1691          MOVE.B  #14,D0      * Trap #14 setup to print
000019C4  4E4F                    1692          TRAP    #15         * Perform Trap #14
000019C6  4E75                    1693          RTS                 * Return to SIZE67/SIZE68
000019C8                          1694          
000019C8                          1695  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019C8                          1696  *-----------------------------------------------------------------------------
000019C8                          1697  
000019C8                          1698  
000019C8                          1699  
000019C8                          1700  *-----------------------------------------------------------------------------
000019C8                          1701  *-----------------------------------------------------------------------------
000019C8                          1702  * NAME:           UNKNOWNOP
000019C8                          1703  * DESCRIPTION:    a
000019C8                          1704  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
000019C8                          1705  *                 identified as an unknown operation.
000019C8                          1706  * POST-CONDITION: D2 is no longer the opcode.
000019C8                          1707  * REGISTERS:      a
000019C8                          1708  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019C8                          1709  UNKNOWNOP
000019C8  220A                    1710          MOVE.L  A2,D1   * prep the add to print
000019CA                          1711          
000019CA  5581                    1712          SUB.L   #2,D1   * off by two error due to post increment correct
000019CC                          1713          
000019CC  2602                    1714          MOVE.L  D2,D3   * save the opcode to print
000019CE                          1715          
000019CE  7410                    1716          MOVE.L  #16,D2  * set the base to 16
000019D0                          1717          
000019D0  700F                    1718          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000019D2  4E4F                    1719          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000019D4                          1720          
000019D4  43F9 00001BFD           1721          LEA     DATA,A1 * load " DATA $" into register A1
000019DA  700E                    1722          MOVE.L  #14,D0  * print the string stored in A1
000019DC  4E4F                    1723          TRAP    #15
000019DE                          1724          
000019DE  2203                    1725          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
000019E0                          1726          
000019E0  103C 000F               1727          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
000019E4  4E4F                    1728          TRAP    #15      * Perform Trap #3
000019E6                          1729  
000019E6  43F9 00001BC4           1730          LEA     NEWLINE,A1 * load newline into register A1
000019EC  700E                    1731          MOVE.L  #14,D0  * print the string stored in A1
000019EE  4E4F                    1732          TRAP    #15
000019F0                          1733  
000019F0  4E75                    1734          RTS
000019F2                          1735  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000019F2                          1736  *-----------------------------------------------------------------------------
000019F2                          1737  
000019F2                          1738  
000019F2                          1739  
000019F2                          1740  *-----------------------------------------------------------------------------
000019F2                          1741  *-----------------------------------------------------------------------------
000019F2                          1742  * NAME: Print ASCII hex char
000019F2                          1743  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
000019F2                          1744  * PRE-CONDITION:  A6 contains the register for memory to print.
000019F2                          1745  *                 This parameter would be pre-loaded by, for example:
000019F2                          1746  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
000019F2                          1747  *                 D6 contains the loops to do (number of bytes).
000019F2                          1748  * POST-CONDITION: 
000019F2                          1749  * REGISTERS:      
000019F2                          1750  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000019F2                          1751  PRINT_ASCII_HEX_CHAR
000019F2  48E7 FFFC               1752      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
000019F6  4285                    1753      CLR.L       D5
000019F8                          1754      
000019F8                          1755      * fence post check (if-statement, check if 0 > chars)
000019F8  0C06 0000               1756      CMPI.B      #0,D6
000019FC  6700 017C               1757      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001A00                          1758      
00001A00                          1759  *    MOVE.L      A6,D4
00001A00  2E0E                    1760      MOVE.L      A6,D7
00001A02                          1761  PRINT_ASCII_LOOP
00001A02                          1762  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001A02                          1763  *    MOVE.L      D4,D7 * make a mutable copy
00001A02  E99F                    1764      ROL.L       #4,D7 * roll to next spot
00001A04  48E7 0100               1765      MOVEM.L     D7,-(A7) * save D7
00001A08                          1766  
00001A08  0287 0000000F           1767      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001A0E                          1768      
00001A0E  0C87 00000000           1769      CMPI.L      #0,D7
00001A14  6D00 0164               1770      BLT         INVALID_ASCII_INPUT
00001A18                          1771  
00001A18  0C87 0000000F           1772      CMPI.L      #15,D7
00001A1E  6E00 015A               1773      BGT         INVALID_ASCII_INPUT
00001A22                          1774  
00001A22                          1775      * this might be faster... to do later, after entire assignment done
00001A22                          1776       * CMPI.L      #9,D7
00001A22                          1777       * BLE         PRINT_ASCII_0_TO_9
00001A22                          1778  
00001A22  0C87 00000000           1779      CMPI.L      #0,D7
00001A28  6700 0098               1780      BEQ         PRINT_ASCII_0
00001A2C  0C87 00000001           1781      CMPI.L      #1,D7
00001A32  6700 0098               1782      BEQ         PRINT_ASCII_1
00001A36  0C87 00000002           1783      CMPI.L      #2,D7
00001A3C  6700 0098               1784      BEQ         PRINT_ASCII_2
00001A40  0C87 00000003           1785      CMPI.L      #3,D7
00001A46  6700 0098               1786      BEQ         PRINT_ASCII_3
00001A4A  0C87 00000004           1787      CMPI.L      #4,D7
00001A50  6700 0098               1788      BEQ         PRINT_ASCII_4
00001A54  0C87 00000005           1789      CMPI.L      #5,D7
00001A5A  6700 0098               1790      BEQ         PRINT_ASCII_5
00001A5E  0C87 00000006           1791      CMPI.L      #6,D7
00001A64  6700 0098               1792      BEQ         PRINT_ASCII_6
00001A68  0C87 00000007           1793      CMPI.L      #7,D7
00001A6E  6700 0098               1794      BEQ         PRINT_ASCII_7
00001A72  0C87 00000008           1795      CMPI.L      #8,D7
00001A78  6700 0098               1796      BEQ         PRINT_ASCII_8
00001A7C  0C87 00000009           1797      CMPI.L      #9,D7
00001A82  6700 0098               1798      BEQ         PRINT_ASCII_9
00001A86  0C87 0000000A           1799      CMPI.L      #10,D7
00001A8C  6700 0098               1800      BEQ         PRINT_ASCII_A
00001A90  0C87 0000000B           1801      CMPI.L      #11,D7
00001A96  6700 0098               1802      BEQ         PRINT_ASCII_B
00001A9A  0C87 0000000C           1803      CMPI.L      #12,D7
00001AA0  6700 0098               1804      BEQ         PRINT_ASCII_C
00001AA4  0C87 0000000D           1805      CMPI.L      #13,D7
00001AAA  6700 0098               1806      BEQ         PRINT_ASCII_D
00001AAE  0C87 0000000E           1807      CMPI.L      #14,D7
00001AB4  6700 0098               1808      BEQ         PRINT_ASCII_E
00001AB8  0C87 0000000F           1809      CMPI.L      #15,D7
00001ABE  6700 0098               1810      BEQ         PRINT_ASCII_F
00001AC2                          1811  PRINT_ASCII_0
00001AC2  43F9 00001C23           1812      LEA         ASCII_0,A1
00001AC8  6000 0098               1813      BRA         PRINT_ASCII_CHAR
00001ACC                          1814  PRINT_ASCII_1
00001ACC  43F9 00001C25           1815      LEA         ASCII_1,A1
00001AD2  6000 008E               1816      BRA         PRINT_ASCII_CHAR
00001AD6                          1817  PRINT_ASCII_2
00001AD6  43F9 00001C27           1818      LEA         ASCII_2,A1
00001ADC  6000 0084               1819      BRA         PRINT_ASCII_CHAR
00001AE0                          1820  PRINT_ASCII_3
00001AE0  43F9 00001C29           1821      LEA         ASCII_3,A1
00001AE6  6000 007A               1822      BRA         PRINT_ASCII_CHAR
00001AEA                          1823  PRINT_ASCII_4
00001AEA  43F9 00001C2B           1824      LEA         ASCII_4,A1
00001AF0  6000 0070               1825      BRA         PRINT_ASCII_CHAR
00001AF4                          1826  PRINT_ASCII_5
00001AF4  43F9 00001C2D           1827      LEA         ASCII_5,A1
00001AFA  6000 0066               1828      BRA         PRINT_ASCII_CHAR
00001AFE                          1829  PRINT_ASCII_6
00001AFE  43F9 00001C2F           1830      LEA         ASCII_6,A1
00001B04  6000 005C               1831      BRA         PRINT_ASCII_CHAR
00001B08                          1832  PRINT_ASCII_7
00001B08  43F9 00001C31           1833      LEA         ASCII_7,A1
00001B0E  6000 0052               1834      BRA         PRINT_ASCII_CHAR
00001B12                          1835  PRINT_ASCII_8
00001B12  43F9 00001C33           1836      LEA         ASCII_8,A1
00001B18  6000 0048               1837      BRA         PRINT_ASCII_CHAR
00001B1C                          1838  PRINT_ASCII_9
00001B1C  43F9 00001C35           1839      LEA         ASCII_9,A1
00001B22  6000 003E               1840      BRA         PRINT_ASCII_CHAR
00001B26                          1841  PRINT_ASCII_A
00001B26  43F9 00001C37           1842      LEA         ASCII_A,A1
00001B2C  6000 0034               1843      BRA         PRINT_ASCII_CHAR
00001B30                          1844  PRINT_ASCII_B
00001B30  43F9 00001C39           1845      LEA         ASCII_B,A1
00001B36  6000 002A               1846      BRA         PRINT_ASCII_CHAR
00001B3A                          1847  PRINT_ASCII_C
00001B3A  43F9 00001C3B           1848      LEA         ASCII_C,A1
00001B40  6000 0020               1849      BRA         PRINT_ASCII_CHAR
00001B44                          1850  PRINT_ASCII_D
00001B44  43F9 00001C3D           1851      LEA         ASCII_D,A1
00001B4A  6000 0016               1852      BRA         PRINT_ASCII_CHAR
00001B4E                          1853  PRINT_ASCII_E
00001B4E  43F9 00001C3F           1854      LEA         ASCII_E,A1
00001B54  6000 000C               1855      BRA         PRINT_ASCII_CHAR
00001B58                          1856  PRINT_ASCII_F
00001B58  43F9 00001C41           1857      LEA         ASCII_F,A1
00001B5E  6000 0002               1858      BRA         PRINT_ASCII_CHAR
00001B62                          1859  PRINT_ASCII_CHAR
00001B62  103C 000E               1860      MOVE.B      #14,D0
00001B66  4E4F                    1861      TRAP        #15
00001B68                          1862      
00001B68  5205                    1863      ADD.B       #1,D5 * loop until counter stops
00001B6A  BA06                    1864      CMP.B       D6,D5
00001B6C  6C00 000C               1865      BGE         PRINT_ASCII_FINISH
00001B70                          1866      
00001B70  4287                    1867      CLR.L       D7
00001B72  4CDF 0080               1868      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001B76                          1869      
00001B76  6000 FE8A               1870      BRA         PRINT_ASCII_LOOP
00001B7A                          1871  INVALID_ASCII_INPUT
00001B7A                          1872  PRINT_ASCII_FINISH
00001B7A  4CDF 3FFF               1873      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001B7E  4E75                    1874      RTS
00001B80                          1875  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B80                          1876  *-----------------------------------------------------------------------------
00001B80                          1877  
00001B80                          1878  
00001B80                          1879  
00001B80                          1880  *-----------------------------------------------------------------------------
00001B80                          1881  *-----------------------------------------------------------------------------
00001B80                          1882  * NAME: Bitmask
00001B80                          1883  * DESCRIPTION:    Masks bits in a data register.
00001B80                          1884  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001B80                          1885  *                 the ending bit.  For example, a starting bit of decimal
00001B80                          1886  *                 value 0 and an ending bit of decimal value 3 will mask the
00001B80                          1887  *                 bits 0, 1, 2, and 3.
00001B80                          1888  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001B80                          1889  * REGISTERS:      D5,D6,D7
00001B80                          1890  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B80                          1891  BITMASK
00001B80  3F05                    1892          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001B82  4245                    1893          CLR     D5          * clear D5 so we can use it
00001B84                          1894  LOOPBIT 
00001B84  0DC5                    1895          BSET    D6,D5       * set the D6th bit in D5 to 1
00001B86  5246                    1896          ADD     #1,D6       * increment D6
00001B88                          1897  
00001B88  BC47                    1898          CMP     D7,D6       * have we finished?
00001B8A  6E00 0004               1899          BGT     BITMASKDONE * yes
00001B8E  60F4                    1900          BRA     LOOPBIT     * no, iterate again
00001B90                          1901  
00001B90                          1902  BITMASKDONE
00001B90  2C05                    1903          MOVE.L  D5,D6
00001B92  3A1F                    1904          MOVE    (A7)+,D5    * restore D5
00001B94  4E75                    1905          RTS
00001B96                          1906  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B96                          1907  *-----------------------------------------------------------------------------
00001B96                          1908  
00001B96                          1909  
00001B96                          1910  
00001B96                          1911  *-----------------------------------------------------------------------------
00001B96                          1912  *-----------------------------------------------------------------------------
00001B96                          1913  * SECTION: Constants/variables used throughout the program.
00001B96                          1914  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B96                          1915  * ---> GENERAL
00001B96  =0000000D               1916  CR          EQU     $0D
00001B96  =0000000A               1917  LF          EQU     $0A
00001B96= 45 4E 54 45 52 20 ...   1918  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001BAE= 45 4E 54 45 52 20 ...   1919  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001BC4= 0D 0A 00                1920  NEWLINE     DC.B    CR,LF,0
00001BC7                          1921  * ---> OPS
00001BC7= 44 49 56 53 00          1922  DIVSOP      DC.B    'DIVS',0
00001BCC= 4E 4F 50 00             1923  NOOPERATION DC.B    'NOP',0
00001BD0= 4E 45 47 00             1924  NEGOP       DC.B    'NEG',0
00001BD4= 4D 4F 56 45 00          1925  MOVEOP      DC.B    'MOVE',0
00001BD9= 4D 4F 56 45 4D 00       1926  MOVEMOP     DC.B    'MOVEM',0
00001BDF= 4A 53 52 00             1927  JSROP       DC.B    'JSR',0
00001BE3= 52 54 53 00             1928  RTSOP       DC.B    'RTS',0
00001BE7= 4C 45 41 00             1929  LEAOP       DC.B    'LEA',0
00001BEB= 42 43 4C 52 20 00       1930  BCLROP      DC.B    'BCLR ',0
00001BF1= 4F 52 00                1931  OROP        DC.B    'OR',0
00001BF4= 4F 52 49 00             1932  ORIOP       DC.B    'ORI',0
00001BF8= 43 4D 50 49 00          1933  CMPIOP      DC.B    'CMPI',0
00001BFD= 20 44 41 54 41 20 ...   1934  DATA        DC.B    ' DATA $',0
00001C05= 42 43 43 20 00          1935  OP_BCC_MSG  DC.B    'BCC ',0
00001C0A= 42 43 53 20 00          1936  OP_BCS_MSG  DC.B    'BCS ',0
00001C0F= 42 47 45 20 00          1937  OP_BGE_MSG  DC.B    'BGE ',0
00001C14= 42 4C 54 20 00          1938  OP_BLT_MSG  DC.B    'BLT ',0
00001C19= 42 56 43 20 00          1939  OP_BVC_MSG  DC.B    'BVC ',0
00001C1E= 42 52 41 20 00          1940  OP_BRA_MSG  DC.B    'BRA ',0
00001C23                          1941  * ---> HEX CHARS
00001C23= 30 00                   1942  ASCII_0     DC.B    '0',0
00001C25= 31 00                   1943  ASCII_1     DC.B    '1',0
00001C27= 32 00                   1944  ASCII_2     DC.B    '2',0
00001C29= 33 00                   1945  ASCII_3     DC.B    '3',0
00001C2B= 34 00                   1946  ASCII_4     DC.B    '4',0
00001C2D= 35 00                   1947  ASCII_5     DC.B    '5',0
00001C2F= 36 00                   1948  ASCII_6     DC.B    '6',0
00001C31= 37 00                   1949  ASCII_7     DC.B    '7',0
00001C33= 38 00                   1950  ASCII_8     DC.B    '8',0
00001C35= 39 00                   1951  ASCII_9     DC.B    '9',0
00001C37= 41 00                   1952  ASCII_A     DC.B    'A',0
00001C39= 42 00                   1953  ASCII_B     DC.B    'B',0
00001C3B= 43 00                   1954  ASCII_C     DC.B    'C',0
00001C3D= 44 00                   1955  ASCII_D     DC.B    'D',0
00001C3F= 45 00                   1956  ASCII_E     DC.B    'E',0
00001C41= 46 00                   1957  ASCII_F     DC.B    'F',0
00001C43                          1958  * ---> SPECIAL CHARACTERS
00001C43= 20 00                   1959  SPACE       DC.B    ' ',0
00001C45= 24 00                   1960  DOLLAR      DC.B    '$',0
00001C47= 23 00                   1961  IMD         DC.B    '#',0
00001C49= 2C 00                   1962  COMMA       DC.B    ',',0
00001C4B= 28 00                   1963  OBRACK      DC.B    '(',0
00001C4D= 29 00                   1964  CBRACK      DC.B    ')',0
00001C4F= 2B 00                   1965  PLUS        DC.B    '+',0
00001C51= 2D 00                   1966  MINUS       DC.B    '-',0
00001C53                          1967  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001C53= 2E 42 20 00             1968  __B         DC.B    '.B ',0
00001C57= 2E 57 20 00             1969  __W         DC.B    '.W ',0
00001C5B= 2E 4C 20 00             1970  __L         DC.B    '.L ',0
00001C5F                          1971  * ---> ADDRESS REGISTERS A0-A7
00001C5F= 41 30 00                1972  __A0        DC.B   'A0',0
00001C62= 41 31 00                1973  __A1        DC.B   'A1',0    
00001C65= 41 32 00                1974  __A2        DC.B   'A2',0
00001C68= 41 33 00                1975  __A3        DC.B   'A3',0
00001C6B= 41 34 00                1976  __A4        DC.B   'A4',0
00001C6E= 41 35 00                1977  __A5        DC.B   'A5',0
00001C71= 41 36 00                1978  __A6        DC.B   'A6',0
00001C74= 41 37 00                1979  __A7        DC.B   'A7',0
00001C77                          1980  * ---> DATA REGISTERS D0-D7
00001C77= 44 30 00                1981  __D0        DC.B   'D0',0
00001C7A= 44 31 00                1982  __D1        DC.B   'D1',0
00001C7D= 44 32 00                1983  __D2        DC.B   'D2',0
00001C80= 44 33 00                1984  __D3        DC.B   'D3',0
00001C83= 44 34 00                1985  __D4        DC.B   'D4',0
00001C86= 44 35 00                1986  __D5        DC.B   'D5',0
00001C89= 44 36 00                1987  __D6        DC.B   'D6',0
00001C8C= 44 37 00                1988  __D7        DC.B   'D7',0
00001C8F                          1989  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C8F                          1990  *-----------------------------------------------------------------------------
00001C8F                          1991  
00001C8F                          1992  
00001C8F                          1993  
00001C8F                          1994  *-----------------------------------------------------------------------------
00001C8F                          1995  *-----------------------------------------------------------------------------
00001C8F                          1996  * SECTION: Sample program to run, then attempt testing disassembly on.
00001C8F                          1997  * STARTING: 16384
00001C8F                          1998  * ENDING:   16420
00001C8F                          1999  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2000      ORG $4000
00004000                          2001      
00004000  4E71                    2002      NOP
00004002  103C 009A               2003      MOVE.B   #%10011010, D0
00004006  123C 00A9               2004      MOVE.B   #%10101001, D1
0000400A  D200                    2005      ADD.B    D0,D1
0000400C  48A7 4000               2006      MOVEM    D1,-(A7)
00004010  43F8 1BDF               2007      LEA      JSROP,A1
00004014  4467                    2008      NEG.W    -(A7)
00004016  4EB9 00004026           2009      JSR      END
0000401C  81FC 0001               2010      DIVS    #1, D0
00004020  0181                    2011      BCLR    D0, D1
00004022  0041 0004               2012      ORI     #4, D1
00004026                          2013  
00004026                          2014  END
00004026  4E75                    2015      RTS
00004028                          2016      
00004028                          2017  RLLYEND
00004028                          2018      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1C23
ASCII_1             1C25
ASCII_2             1C27
ASCII_3             1C29
ASCII_4             1C2B
ASCII_5             1C2D
ASCII_6             1C2F
ASCII_7             1C31
ASCII_8             1C33
ASCII_9             1C35
ASCII_A             1C37
ASCII_B             1C39
ASCII_C             1C3B
ASCII_D             1C3D
ASCII_E             1C3F
ASCII_F             1C41
BCC_END             14A0
BCLROP              1BEB
BITMASK             1B80
BITMASKDONE         1B90
CBRACK              1C4D
CMPIOP              1BF8
COMMA               1C49
CR                  D
DATA                1BFD
DIVSOP              1BC7
DOLLAR              1C45
DONE                13E2
EAHELPER05          15AC
EAHELPER611         156A
END                 4026
END0000             1240
END67               1940
ENDEAHELPER05       16FC
ENDEAHELPER611      15A6
ENDMODE_AN          188C
ENDMODE_DN          178C
ENDOP0001           12A6
HEX_VALUE_MASK_LONG  F
IMD                 1C47
INVALID_ASCII_INPUT  1B7A
ITERATION           1144
JSROP               1BDF
LEAOP               1BE7
LF                  A
LOOP                103A
LOOPBIT             1B84
LOOPUNKNOWNOP       1140
MINUS               1C51
MODE_AN             1802
MODE_DN             1702
MOVEMOP             1BD9
MOVEOP              1BD4
MSGEND              1BAE
MSGSTART            1B96
NEGOP               1BD0
NEWLINE             1BC4
NOOPERATION         1BCC
NOT0000             1050
NOT0001             1060
NOT0010             1070
NOT0011             1080
NOT0100             1090
NOT0101             10A0
NOT0110             10B0
NOT0111             10C0
NOT1000             10D0
NOT1001             10E0
NOT1010             10F0
NOT1011             1100
NOT1100             1110
NOT1101             1120
NOT1110             1130
NOT67BYTE           1924
NOT67WORD           1934
NOTA0               1824
NOTA1               1834
NOTA2               1844
NOTA3               1854
NOTA4               1864
NOTA5               1874
NOTA6               1884
NOTADRDIRECT        15DC
NOTADRINDIRECT      1604
NOTADRINDIRECTPOST  1638
NOTADRINDIRECTPRE   166C
NOTBCLR             11CE
NOTD0               1724
NOTD1               1734
NOTD2               1744
NOTD3               1754
NOTD4               1764
NOTD5               1774
NOTD6               1784
NOTDATAREG          15CC
NOTDIVS             152A
NOTIMMBYTE          16A2
NOTIMMEDIATE        16F8
NOTIMMWORD          16D0
NOTJSR              1398
NOTMOVEM            1356
NOTNEG              1332
NOTNOP              12DC
NOTORI              1234
NOTRTS              13BA
OBRACK              1C4B
OP0000              1150
OP0001              1246
OP0010              12AC
OP0011              12B2
OP0100              12C0
OP0101              13EC
OP0110              13F2
OP0111              14A6
OP1000              14AC
OP1000END           153A
OP1001              1540
OP1010              1546
OP1011              154C
OP1100              1552
OP1101              1558
OP1110              155E
OP1111              1564
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              1442
OP_BCC_MSG          1C05
OP_BCS              144C
OP_BCS_MSG          1C0A
OP_BGE              1456
OP_BGE_MSG          1C0F
OP_BLT              1460
OP_BLT_MSG          1C14
OP_BRA              1474
OP_BRANCHES_PRINT   147E
OP_BRA_MSG          1C1E
OP_BVC              146A
OP_BVC_MSG          1C19
ORIOP               1BF4
OROP                1BF1
PLUS                1C4F
PRINTA0             1892
PRINTA1             18A0
PRINTA2             18AE
PRINTA3             18BC
PRINTA4             18CA
PRINTA5             18D8
PRINTA6             18E6
PRINTA7             18F4
PRINTBYTE           199E
PRINTD0             1792
PRINTD1             17A0
PRINTD2             17AE
PRINTD3             17BC
PRINTD4             17CA
PRINTD5             17D8
PRINTD6             17E6
PRINTD7             17F4
PRINTLONG           19BA
PRINTWORD           19AC
PRINT_ASCII_0       1AC2
PRINT_ASCII_1       1ACC
PRINT_ASCII_2       1AD6
PRINT_ASCII_3       1AE0
PRINT_ASCII_4       1AEA
PRINT_ASCII_5       1AF4
PRINT_ASCII_6       1AFE
PRINT_ASCII_7       1B08
PRINT_ASCII_8       1B12
PRINT_ASCII_9       1B1C
PRINT_ASCII_A       1B26
PRINT_ASCII_B       1B30
PRINT_ASCII_C       1B3A
PRINT_ASCII_CHAR    1B62
PRINT_ASCII_D       1B44
PRINT_ASCII_E       1B4E
PRINT_ASCII_F       1B58
PRINT_ASCII_FINISH  1B7A
PRINT_ASCII_HEX_CHAR  19F2
PRINT_ASCII_LOOP    1A02
RLLYEND             4028
RTSOP               1BE3
SIZE67              1902
SIZE68              1946
SPACE               1C43
START               1000
UNKNOWN             13DE
UNKNOWN0000         123C
UNKNOWNOP           19C8
UNKNOWNOP0001       12A2
__A0                1C5F
__A1                1C62
__A2                1C65
__A3                1C68
__A4                1C6B
__A5                1C6E
__A6                1C71
__A7                1C74
__B                 1C53
__D0                1C77
__D1                1C7A
__D2                1C7D
__D3                1C80
__D4                1C83
__D5                1C86
__D6                1C89
__D7                1C8C
__L                 1C5B
__W                 1C57
