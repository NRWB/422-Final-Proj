00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/5/2014 8:06:14 AM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001A40             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001A58             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001A6E             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 09F2                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A                           100          
0000103A                           101          * MOVE.W  #BITMASK,D2     * Load the bitmask into data register D2
0000103A  3F06                     102          MOVE    D6,-(A7)        * save the bitmask on the stack
0000103C  341A                     103          MOVE.W  (A2)+,D2        * Read an operation into D1
0000103E  CC42                     104          AND.W   D2,D6           * Apply this bitmask
00001040                           105          
00001040  BC7C 1000                106          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001044  6600 000A                107          BNE     NOT0001            * No, check next case
00001048  6100 018E                108          BSR     OP0001          * Branch to subroutine 0001
0000104C  6000 0016                109          BRA     ITERATION       * Move to next iteration of the loop
00001050                           110  NOT0001       
00001050  BC7C 4000                111          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001054  6600 000A                112          BNE     NEXT            * No, check next case
00001058  6100 01E6                113          BSR     OP0100          * Branch to subroutine 0100
0000105C  6000 0006                114          BRA     ITERATION       * Move to next iteration of the loop
00001060                           115          
00001060                           116  NEXT
00001060  6100 0810                117          BSR     UNKNOWNOP
00001064                           118          
00001064                           119  ITERATION
00001064  3C1F                     120          MOVE    (A7)+,D6        * restore the bitmask to its previous state
00001066                           121  
00001066                           122          *MOVE.B  #14,D0          * Print a newline
00001066                           123          *TRAP    #15             * Perform Trap #14
00001066                           124  
00001066  BA4A                     125          CMP     A2,D5           * Compare the starting address to ending address
00001068  6700 2FB6                126          BEQ     END             * If they are equal, branch 
0000106C  60CC                     127          BRA     LOOP            * Otherwise, branch back to LOOP
0000106E                           128  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000106E                           129  *-----------------------------------------------------------------------------
0000106E                           130  
0000106E                           131  
0000106E                           132  
0000106E                           133  *-----------------------------------------------------------------------------
0000106E                           134  *-----------------------------------------------------------------------------
0000106E                           135  * NAME: OP_0000   (BCLR, ORI, CMPI)
0000106E                           136  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000106E                           137  * PRE-CONDITION:  xyz
0000106E                           138  * POST-CONDITION: All registers return to their previous state, and the output
0000106E                           139  *                 goes to the output console for reading the raw data or the
0000106E                           140  *                 actual instruction.
0000106E                           141  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000106E                           142  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000106E                           143  OP0000
0000106E  48A7 C0C0                144          MOVEM   D0-D1/A0-A1,-(A7)   * Push values to the stack to save
00001072  3C3C 0006                145          MOVE.W  #6, D6              * Prep lower value for bitmask
00001076  3E3C 0008                146          MOVE.W  #8, D7              * Prep upper value for bitmask
0000107A  6100 09AE                147          BSR     BITMASK             * Finalize bitmask setup
0000107E  CC42                     148          AND     D2,D6               * Apply bitmask
00001080                           149          
00001080  0C46 0180                150          CMPI    #%0000000110000000, D6  * Are we BCLR?
00001084  6600 0012                151          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
00001088                           152          
00001088  43F9 00001A96            153          LEA     BCLROP,A1           * We found BCLR
0000108E  103C 000E                154          MOVE.B  #14,D0              * Trap #14 prints out the data
00001092  4E4F                     155          TRAP    #15                 * Perform Trap #14
00001094  6000 013C                156          BRA     END0000              * Found the op, move to next iteration
00001098                           157  
00001098                           158  NOTBCLR * Possible options left are ORI or CMPI
00001098  3C3C 0009                159          MOVE.W  #9, D6              * Prep lower value for bitmask
0000109C  3E3C 000B                160          MOVE.W  #11, D7             * Prep upper value for bitmask
000010A0  6100 0988                161          BSR     BITMASK             * Finalize bitmask setup
000010A4  CC42                     162          AND     D2,D6               * Apply bitmask
000010A6                           163          
000010A6  0C46 0000                164          CMPI    #%0000000000000000, D6  * Are we ORI?
000010AA  6700 000E                165          BEQ     ISORI                   * If ORI, branch to ISORI
000010AE                           166          
000010AE  0C46 0C00                167          CMPI    #%0000110000000000, D6  * Hmm... Maybe we're CMPI?
000010B2  6700 0006                168          BEQ     ISCMPI                  * If CMPI, branch to ISCMPI
000010B6                           169          
000010B6  6600 07BA                170          BNE     UNKNOWNOP               * Otherwise, this op is an imposter. 
000010BA                           171                                          * We don't deal too kindly with imposters.
000010BA                           172          
000010BA                           173  ISORI   * TODO
000010BA                           174          
000010BA                           175  
000010BA                           176  ISCMPI
000010BA  43F9 00001AA2            177          LEA     CMPIOP, A1          * Load 'CMPI' into the output window
000010C0  103C 000E                178          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000010C4  4E4F                     179          TRAP    #15                 * Perform Trap #14
000010C6                           180          
000010C6                           181          * Determine the Size
000010C6  3C3C 0006                182          MOVE.W  #6, D6              * Prep lower value for bitmask
000010CA  3E3C 0007                183          MOVE.W  #7, D7              * Prep upper value for bitmask
000010CE  6100 095A                184          BSR     BITMASK             * Finalize bitmask setup
000010D2  CC42                     185          AND     D2,D6               * Apply bitmask
000010D4                           186          
000010D4  0C46 00C0                187          CMPI    #%0000000011000000, D6  * Imposter Op
000010D8  6700 0798                188          BEQ     UNKNOWNOP               * Deal with the imposter
000010DC                           189          
000010DC  0C46 0000                190          CMPI    #%0000000000000000, D6  * The size is a BYTE
000010E0  6700 0012                191          BEQ     CMPIBYTE                * Branch to CMPI.B
000010E4                           192          
000010E4  0C46 0040                193          CMPI    #%0000000001000000, D6  * The size is a WORD
000010E8  6700 0032                194          BEQ     CMPIWORD                * Branch to CMPI.W
000010EC                           195          
000010EC  0C46 0080                196          CMPI    #%0000000010000000, D6  * The size is a LONG
000010F0  6700 0050                197          BEQ     CMPILONG                * Branch to CMPI.L
000010F4                           198          
000010F4                           199  CMPIBYTE
000010F4  43F9 00001AF7            200          LEA     __B, A1     * Load .B
000010FA  103C 000E                201          MOVE.B  #14, D0     * Print out data
000010FE  4E4F                     202          TRAP    #15         * Perform Trap #14
00001100                           203          
00001100  43F9 00001AEB            204          LEA     IMD, A1     * Load #
00001106  103C 000E                205          MOVE.B  #14, D0     * Print out data
0000110A  4E4F                     206          TRAP    #15         * Perform Trap #14
0000110C                           207          
0000110C  361A                     208          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000110E  1203                     209          MOVE.B  D3,D1       * Move the lower byte from D3 into D1
00001110  3622                     210          MOVE.W  -(A2),D3    * Now go back
00001112  103C 000E                211          MOVE.B  #14, D0     * Print out the data
00001116  4E4F                     212          TRAP    #15         * Perform Trap #14 
00001118                           213          
00001118  6000 004E                214          BRA     CMPIEA      * Branch to determine Effective Address
0000111C                           215          
0000111C                           216  CMPIWORD
0000111C  43F9 00001AFB            217          LEA     __W, A1     * Load .W
00001122  103C 000E                218          MOVE.B  #14, D0     * Print out data
00001126  4E4F                     219          TRAP    #15         * Perform Trap #14
00001128                           220          
00001128  43F9 00001AEB            221          LEA     IMD, A1     * Load #
0000112E  103C 000E                222          MOVE.B  #14, D0     * Print out data
00001132  4E4F                     223          TRAP    #15         * Perform Trap #14
00001134                           224          
00001134  361A                     225          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
00001136  3222                     226          MOVE.W  -(A2),D1    * Copy the immediate Value into D1, then go back
00001138  103C 000E                227          MOVE.B  #14, D0     * Print out the data
0000113C  4E4F                     228          TRAP    #15         * Perform Trap #14
0000113E                           229          
0000113E                           230          
0000113E  6000 0028                231          BRA     CMPIEA      * Branch to determine Effective Address
00001142                           232          
00001142                           233  CMPILONG
00001142  43F9 00001AFF            234          LEA     __L, A1     * Load .L
00001148  103C 000E                235          MOVE.B  #14, D0     * Print out data
0000114C  4E4F                     236          TRAP    #15         * Perform Trap #14
0000114E                           237          
0000114E  43F9 00001AEB            238          LEA     IMD, A1     * Load #
00001154  103C 000E                239          MOVE.B  #14, D0     * Print out data
00001158  4E4F                     240          TRAP    #15         * Perform Trap #14
0000115A                           241          
0000115A  361A                     242          MOVE.W  (A2)+,D3    * Advance a word forward to get the value.
0000115C  2222                     243          MOVE.L  -(A2),D1    * Copy the immediate value (long) into D1, then go back
0000115E  103C 000E                244          MOVE.B  #14, D0     * Print out the data
00001162  4E4F                     245          TRAP    #15         * Perform Trap #14
00001164                           246          
00001164  6000 0002                247          BRA     CMPIEA      * Branch to determine Effective Address
00001168                           248          
00001168                           249  CMPIEA
00001168                           250          * So far the buffer is CMPI.X #Y ... Now we need to add a comma
00001168  43F9 00001AED            251          LEA     COMMA, A1   * Load ,
0000116E  103C 000E                252          MOVE.B  #14, D0     * Print out data
00001172  4E4F                     253          TRAP    #15         * Perform Trap #14
00001174                           254          
00001174  43F9 00001AFF            255          LEA     __L, A1     * Load .L
0000117A  103C 000E                256          MOVE.B  #14, D0     * Print out data
0000117E  4E4F                     257          TRAP    #15         * Perform Trap #14
00001180                           258          
00001180                           259          * Determine the mode
00001180  3C3C 0003                260          MOVE.W  #3, D6              * Prep lower value for bitmask
00001184  3E3C 0005                261          MOVE.W  #5, D7              * Prep upper value for bitmask
00001188  6100 08A0                262          BSR     BITMASK             * Finalize bitmask setup
0000118C  CC42                     263          AND     D2,D6               * Apply bitmask
0000118E                           264          
0000118E  0C46 0008                265          CMPI    #%0000000000001000, D6  * Is the Mode 001, an unsupported mode for CMPI?
00001192  6700 06DE                266          BEQ     UNKNOWNOP               * Imposter op
00001196                           267          
00001196  0C46 0028                268          CMPI    #%0000000000101000, D6  * Is the Mode 101, an unsupported mode?
0000119A  6700 06D6                269          BEQ     UNKNOWNOP               * Imposter op
0000119E                           270          
0000119E  0C46 0030                271          CMPI    #%0000000000110000, D6  * Is the Mode 110, an unsupported mode?
000011A2  6700 06CE                272          BEQ     UNKNOWNOP               * Imposter op
000011A6                           273  
000011A6  0C46 0038                274          CMPI    #%0000000000111000, D6  * Is the Mode 111?
000011AA  6700 0008                275          BEQ     CMPIREG                 * Further investigation is needed
000011AE                           276          
000011AE                           277          * will need to call the EA helpers when they are complete
000011AE                           278          
000011AE                           279          * Mode is verified to be valid at this point
000011AE                           280          *CMPI    #%0000000000000000, D6  * AMode = Dn, Reg = Dn
000011AE                           281          *BSR     MODE_DN
000011AE                           282          
000011AE                           283          *CMPI    #%0000000000010000, D6  * AMode = (An), Reg = An
000011AE                           284          *BSR     MODE_AN
000011AE                           285          
000011AE                           286          *CMPI    #%0000000000011000, D6  * AMode = (An)+, Reg = An
000011AE                           287          *BSR     MODE_IAN_POS
000011AE                           288          
000011AE                           289          *CMPI    #%0000000000000000, D6  * AMode = -(An), Reg = An
000011AE                           290          *BSR     MODE_IAN_PRE
000011AE                           291          
000011AE                           292          * Reached End of CMPI. Everything has been printed out
000011AE  4C9F 0303                293          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000011B2  4E75                     294          RTS
000011B4                           295          
000011B4                           296  CMPIREG
000011B4  3C3C 0000                297          MOVE.W  #0, D6              * Prep lower value for bitmask
000011B8  3E3C 0002                298          MOVE.W  #2, D7              * Prep upper value for bitmask
000011BC  6100 086C                299          BSR     BITMASK             * Finalize bitmask setup
000011C0  CC42                     300          AND     D2,D6               * Apply bitmask
000011C2                           301          
000011C2  0C46 0000                302          CMPI    #%0000000000000000, D6  * Is the Register 000?
000011C6  6700 0010                303          BEQ     CMPIREG000
000011CA                           304          
000011CA  0C46 0001                305          CMPI    #%0000000000000001, D6  * Is the Register 001?
000011CE  6700 0008                306          BEQ     CMPIREG001
000011D2                           307          
000011D2                           308  END0000          
000011D2  4C9F 0303                309         MOVEM   (A7)+,D0-D1/A0-A1   * Push values to the stack to save
000011D6  4E75                     310         RTS
000011D8                           311         
000011D8                           312  CMPIREG000  * TODO (xxx).W for CMPI
000011D8                           313  
000011D8                           314  CMPIREG001  * TODO (xxx).L for CMPI
000011D8                           315  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000011D8                           316  *-----------------------------------------------------------------------------
000011D8                           317  
000011D8                           318  
000011D8                           319  
000011D8                           320  *-----------------------------------------------------------------------------
000011D8                           321  *-----------------------------------------------------------------------------
000011D8                           322  * NAME: OP_0001   (MOVE.B)
000011D8                           323  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000011D8                           324  * PRE-CONDITION:  xyz
000011D8                           325  * POST-CONDITION: All registers return to their previous state, and the output
000011D8                           326  *                 goes to the output console for reading the raw data or the
000011D8                           327  *                 actual instruction.
000011D8                           328  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000011D8                           329  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000011D8                           330  OP0001  
000011D8  48A7 FFC0                331          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
000011DC  3C3C 0006                332          MOVE.W  #6, D6              * Prep lower value for bitmask
000011E0  3E3C 0008                333          MOVE.W  #8, D7              * Prep upper value for bitmask
000011E4  6100 0844                334          BSR     BITMASK             * Finalize bitmask setup
000011E8  CC42                     335          AND     D2,D6               * Apply bitmask
000011EA                           336          
000011EA                           337          * I may have fucked off this part, sorry - Caleb
000011EA                           338          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
000011EA                           339          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
000011EA                           340          
000011EA  43F9 00001A7E            341          LEA     MOVEOP,A1   * Put 'MOVE' into the window
000011F0  103C 000E                342          MOVE.B  #14,D0      * Trap #14 to print out
000011F4  4E4F                     343          TRAP    #15         * Perform Trap #14
000011F6                           344          
000011F6  6100 05B4                345          BSR     SIZE67
000011FA  6100 02B2                346          BSR     EAHELPER05
000011FE                           347          
000011FE  43F9 00001AED            348          LEA     COMMA,A1
00001204  103C 000E                349          MOVE.B  #14,D0
00001208  4E4F                     350          TRAP    #15
0000120A                           351          
0000120A  6100 026E                352          BSR     EAHELPER611
0000120E                           353          
0000120E  43F9 00001A6E            354          LEA     NEWLINE,A1
00001214  103C 000E                355          MOVE.B  #14,D0
00001218  4E4F                     356          TRAP    #15
0000121A                           357          
0000121A  6000 0006                358          BRA     ENDOP0001
0000121E                           359          *LEA     __B,A1      * Put '.B' into the window
0000121E                           360          *MOVE.B  #14,D0      * Trap #14 to print out
0000121E                           361          *TRAP    #15         * Perform Trap #14
0000121E                           362          
0000121E                           363  UNKNOWNOP0001
0000121E                           364  
0000121E  6100 0652                365          BSR     UNKNOWNOP
00001222                           366          
00001222                           367  ENDOP0001
00001222                           368  
00001222  4C9F 03FF                369          MOVEM (A7)+,D0-D7/A0-A1
00001226  4E75                     370          RTS        
00001228                           371          
00001228                           372          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
00001228                           373  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001228                           374  *-----------------------------------------------------------------------------
00001228                           375  
00001228                           376  
00001228                           377  
00001228                           378  *-----------------------------------------------------------------------------
00001228                           379  *-----------------------------------------------------------------------------
00001228                           380  * NAME: OP_0010   (MOVE.L, MOVEA.L)
00001228                           381  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001228                           382  * PRE-CONDITION:  xyz
00001228                           383  * POST-CONDITION: All registers return to their previous state, and the output
00001228                           384  *                 goes to the output console for reading the raw data or the
00001228                           385  *                 actual instruction.
00001228                           386  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001228                           387  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001228                           388  OP0010
00001228                           389  
00001228                           390  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001228                           391  *-----------------------------------------------------------------------------
00001228                           392  
00001228                           393  
00001228                           394  
00001228                           395  *-----------------------------------------------------------------------------
00001228                           396  *-----------------------------------------------------------------------------
00001228                           397  * NAME: OP_0011   (MOVE.W, MOVEA.W)
00001228                           398  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001228                           399  * PRE-CONDITION:  xyz
00001228                           400  * POST-CONDITION: All registers return to their previous state, and the output
00001228                           401  *                 goes to the output console for reading the raw data or the
00001228                           402  *                 actual instruction.
00001228                           403  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001228                           404  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001228                           405  OP0011
00001228  48A7 FFFE                406      MOVEM   D0-D7/A0-A6, -(A7)
0000122C                           407      
0000122C  3C3C 0006                408      MOVE.W  #6,D6
00001230  3E3C 0008                409      MOVE.W  #8,D7
00001234                           410      
00001234  6100 07F4                411      BSR     BITMASK
00001238                           412      
00001238  CC42                     413      AND.W   D2,D6
0000123A                           414      
0000123A  BC7C 0040                415      CMP     #%0000000001000000,D6
0000123E                           416      *BNE     NEXT15
0000123E  61FE                     417      BSR     * for MOVEA.W
00001240                           418  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001240                           419  *-----------------------------------------------------------------------------
00001240                           420  
00001240                           421  
00001240                           422  
00001240                           423  *-----------------------------------------------------------------------------
00001240                           424  *-----------------------------------------------------------------------------
00001240                           425  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
00001240                           426  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001240                           427  * PRE-CONDITION:  xyz
00001240                           428  * POST-CONDITION: All registers return to their previous state, and the output
00001240                           429  *                 goes to the output console for reading the raw data or the
00001240                           430  *                 actual instruction.
00001240                           431  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001240                           432  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001240                           433  OP0100  
00001240                           434          * TODO: lea, movem
00001240                           435  
00001240  48A7 C0C0                436          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001244                           437          
00001244                           438          *NOP
00001244  0C42 4E71                439          CMPI    #%0100111001110001,D2
00001248  6600 0012                440          BNE     NOTNOP
0000124C                           441          
0000124C  43F9 00001A76            442          LEA     NOOPERATION,A1
00001252  103C 000D                443          MOVE.B  #13,D0          * Print a newline
00001256  4E4F                     444          TRAP    #15
00001258                           445          
00001258  6000 0108                446          BRA     DONE *we found it, move on to the next iteration
0000125C                           447  NOTNOP *NEG
0000125C                           448          
0000125C                           449          * prep values for BITMASK subroutine
0000125C  7C08                     450          MOVE.L  #8,D6
0000125E  7E0B                     451          MOVE.L  #11,D7
00001260                           452          
00001260  6100 07C8                453          BSR     BITMASK
00001264                           454          
00001264  CC42                     455          AND     D2,D6                   * apply bitmask
00001266                           456          
00001266  0C46 0400                457          CMPI    #%0000010000000000,D6   * are we NEG?
0000126A  6600 0046                458          BNE     NOTNEG                  * not neg
0000126E                           459          
0000126E  7C03                     460          MOVE.L  #3,D6
00001270  7E05                     461          MOVE.L  #5,D7
00001272                           462          
00001272  6100 07B6                463          BSR     BITMASK * generate a bitmask to be used to check mode
00001276                           464          
00001276  0C46 0008                465          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
0000127A  6700 00E2                466          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000127E                           467          
0000127E  0C46 0028                468          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001282  6700 00DA                469          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
00001286                           470          
00001286  0C46 0030                471          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000128A  6700 00D2                472          BEQ     UNKNOWN * if it is, print print out as hex indicating bad op
0000128E                           473        
0000128E                           474          * it is NEG, print
0000128E  43F9 00001A7A            475          LEA     NEGOP,A1
00001294  103C 000E                476          MOVE.B  #14,D0
00001298  4E4F                     477          TRAP    #15
0000129A                           478          
0000129A  6100 0510                479          BSR     SIZE67
0000129E                           480          
0000129E  6100 020E                481          BSR     EAHELPER05
000012A2                           482          
000012A2  43F9 00001A6E            483          LEA     NEWLINE,A1
000012A8  103C 000E                484          MOVE.B  #14,D0
000012AC  4E4F                     485          TRAP    #15
000012AE                           486          
000012AE  6000 00B2                487          BRA     DONE * we found the op, move to next iteration
000012B2                           488          
000012B2                           489  NOTNEG *MOVEM
000012B2                           490  
000012B2                           491          * prep values for BITMASK subroutine
000012B2  7C07                     492          MOVE.L  #7,D6
000012B4  7E09                     493          MOVE.L  #9,D7
000012B6                           494          
000012B6  6100 0772                495          BSR     BITMASK
000012BA                           496          
000012BA  CC42                     497          AND     D2,D6   * apply bitmask
000012BC                           498          
000012BC  0C46 0080                499          CMPI    #%0000000010000000,D6 * is it MOVEM?
000012C0  6600 0014                500          BNE     NOTMOVEM          * it is not MOVEM
000012C4                           501          
000012C4                           502          * make sure it is a valid size and mode for MOVEM
000012C4                           503          
000012C4                           504          * it is MOVEM
000012C4  43F9 00001A83            505          LEA     MOVEMOP,A1
000012CA  103C 000D                506          MOVE.B  #13,D0          * Print a newline
000012CE  4E4F                     507          TRAP    #15
000012D0                           508          
000012D0                           509          * probably needs its own special code for printing the rest due to uniqueness of movem
000012D0                           510          
000012D0  341A                     511          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000012D2                           512          
000012D2  6000 008E                513          BRA     DONE          * we found and printed, move on to the next iteration
000012D6                           514          
000012D6                           515  NOTMOVEM *JSR
000012D6                           516          * prep values for BITMASK subroutine
000012D6  7C06                     517          MOVE.L  #6,D6
000012D8  7E08                     518          MOVE.L  #8,D7
000012DA                           519          
000012DA  6100 074E                520          BSR     BITMASK
000012DE                           521          
000012DE  CC42                     522          AND     D2,D6   * apply bitmask
000012E0                           523          
000012E0  0C46 0080                524          CMPI    #%0000000010000000,D6
000012E4  6600 0032                525          BNE     NOTJSR          * it's not JSR
000012E8                           526          
000012E8  43F9 00001A89            527          LEA     JSROP,A1
000012EE  103C 000E                528          MOVE.B  #14,D0          * Print a newline and JSR
000012F2  4E4F                     529          TRAP    #15
000012F4                           530          
000012F4                           531          * print out where we are jumping to
000012F4                           532          
000012F4  341A                     533          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000012F6                           534          
000012F6  2202                     535          MOVE.L  D2,D1   * save the opcode to print
000012F8                           536          
000012F8  7410                     537          MOVE.L  #16,D2  * set the base to 16
000012FA                           538          
000012FA  700F                     539          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000012FC  4E4F                     540          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000012FE                           541          
000012FE  341A                     542          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001300                           543          
00001300  2202                     544          MOVE.L  D2,D1   * save the opcode to print
00001302                           545          
00001302  7410                     546          MOVE.L  #16,D2  * set the base to 16
00001304                           547          
00001304  700F                     548          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001306  4E4F                     549          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001308                           550          
00001308  43F9 00001A6E            551          LEA     NEWLINE,A1
0000130E  103C 000E                552          MOVE.B  #14,D0          * Print a newline
00001312  4E4F                     553          TRAP    #15
00001314                           554          
00001314  6000 004C                555          BRA     DONE          * we already found instruction, next iteration
00001318                           556  NOTJSR *RTS
00001318                           557  
00001318                           558          * prep values for BITMASK subroutine
00001318  7C06                     559          MOVE.L  #6,D6
0000131A  7E08                     560          MOVE.L  #8,D7
0000131C                           561          
0000131C  6100 070C                562          BSR     BITMASK
00001320                           563          
00001320  CC42                     564          AND     D2,D6   * apply bitmask
00001322                           565          
00001322  0C46 0040                566          CMPI    #%0000000001000000,D6
00001326  6600 0012                567          BNE     NOTRTS          * it's not RTS
0000132A                           568          
0000132A  43F9 00001A8E            569          LEA     RTSOP,A1
00001330  103C 000D                570          MOVE.B  #13,D0          * Print a newline and RTS
00001334  4E4F                     571          TRAP    #15
00001336                           572          
00001336  6000 002A                573          BRA     DONE          * we already found instruction, next iteration
0000133A                           574  NOTRTS  *LEA
0000133A                           575         
0000133A                           576          * prep values for BITMASK subroutine
0000133A  7C06                     577          MOVE.L  #6,D6
0000133C  7E08                     578          MOVE.L  #8,D7
0000133E                           579          
0000133E  6100 06EA                580          BSR     BITMASK
00001342                           581          
00001342  CC42                     582          AND     D2,D6   * apply bitmask
00001344                           583          
00001344  0C46 01C0                584          CMPI    #%0000000111000000,D6
00001348  6600 0014                585          BNE     UNKNOWN          * it's not LEA, we dont know what it is
0000134C                           586          
0000134C                           587          * check to make sure it is a supported mode and size
0000134C                           588          
0000134C  43F9 00001A92            589          LEA     LEAOP,A1
00001352  103C 000D                590          MOVE.B  #13,D0          * Print LEA
00001356  4E4F                     591          TRAP    #15
00001358                           592          
00001358                           593          * call EA helper
00001358  341A                     594          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
0000135A                           595                  
0000135A  6000 0006                596          BRA     DONE          * we already found instruction, next iteration
0000135E                           597          
0000135E                           598  UNKNOWN *dont know what it is
0000135E  6100 0512                599          BSR     UNKNOWNOP
00001362                           600          
00001362                           601  DONE
00001362  4C9F 0303                602          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
00001366  4E75                     603          RTS
00001368                           604          
00001368  6000 FCFA                605          BRA     ITERATION
0000136C                           606  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000136C                           607  *-----------------------------------------------------------------------------        
0000136C                           608          
0000136C                           609          
0000136C                           610  
0000136C                           611  *-----------------------------------------------------------------------------
0000136C                           612  *-----------------------------------------------------------------------------
0000136C                           613  * NAME: OP_0101   (SUBQ)
0000136C                           614  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000136C                           615  * PRE-CONDITION:  xyz
0000136C                           616  * POST-CONDITION: All registers return to their previous state, and the output
0000136C                           617  *                 goes to the output console for reading the raw data or the
0000136C                           618  *                 actual instruction.
0000136C                           619  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000136C                           620  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000136C                           621  OP0101
0000136C                           622  
0000136C                           623  * testing branching
0000136C                           624  * op op op
0000136C                           625  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000136C                           626  *-----------------------------------------------------------------------------
0000136C                           627  
0000136C                           628  
0000136C                           629  
0000136C                           630  *-----------------------------------------------------------------------------
0000136C                           631  *-----------------------------------------------------------------------------
0000136C                           632  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
0000136C                           633  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000136C                           634  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
0000136C                           635  *                 in the instruction and determines what the bits match to a
0000136C                           636  *                 given condition code. If the 8 bit offset is $00, or $FF,
0000136C                           637  *                 this signifies a word or long offset (for $00 and $FF
0000136C                           638  *                 respectively). The 8 bit offset is in 2's comp. form, and
0000136C                           639  *                 should be un-done, then plus or minus to the current
0000136C                           640  *                 program counter (PC) to get the actual memory label to
0000136C                           641  *                 output to console. The word offset signal eats an
0000136C                           642  *                 additional 16 bits and the long offset eats an additional
0000136C                           643  *                 32 bits. The word/long offset are for memory alignment.
0000136C                           644  * POST-CONDITION: All registers return to their previous state, and the output
0000136C                           645  *                 goes to the output console for reading the raw data or the
0000136C                           646  *                 actual instruction.
0000136C                           647  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000136C                           648  *                 A1 (output)
0000136C                           649  * CONDITIONS TABLE:
0000136C                           650  *                Condition Names  - Mnemonic - Condition Code
0000136C                           651  *                --------------------------------------------
0000136C                           652  *                True             -    T     - 0000
0000136C                           653  *                False            -    F     - 0001
0000136C                           654  *                Higher           -    HI    - 0010
0000136C                           655  *                Lower or Same    -    LS    - 0011
0000136C                           656  *                Carry Clear      -    CC    - 0100
0000136C                           657  *                Carry Set        -    CS    - 0101
0000136C                           658  *                Not Equal        -    NE    - 0110
0000136C                           659  *                Equal            -    EQ    - 0111
0000136C                           660  *                Overflow Clear   -    VC    - 1000
0000136C                           661  *                Overflow Set     -    VS    - 1001
0000136C                           662  *                Plus             -    PL    - 1010
0000136C                           663  *                Minus            -    MI    - 1011
0000136C                           664  *                Greater or Equal -    GE    - 1100
0000136C                           665  *                Less Than        -    LT    - 1101
0000136C                           666  *                Greater Than     -    GT    - 1110
0000136C                           667  *                Less or Equal    -    LE    - 1111
0000136C                           668  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000136C                           669  OP0110
0000136C  48A7 C0C0                670          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
00001370                           671          
00001370                           672          * Ready four bits to help distinguish op's with the 0110 prefix
00001370  3C3C 0000                673          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
00001374                           674                                        * BITMASK sub-routine call)
00001374  3E3C 0007                675          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001378                           676                                        * BITMASK sub-routine call)
00001378                           677                                        
00001378                           678          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001378  6100 06B0                679          BSR     BITMASK               * Call BITMASK sub-routine
0000137C                           680                                        * Returns a bitmask in D6
0000137C                           681          
0000137C  CC42                     682          AND     D2,D6                 * And the index op, which was pre-loaded
0000137E                           683                                        * in the main memory loop with the bitmask
0000137E                           684                                        * to use to determine what case we need.
0000137E                           685          
0000137E                           686          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
0000137E                           687          * $00 == word offset, $FF == long offset
0000137E                           688       ***CMPI    #%0000000000000000,D6
0000137E                           689       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
0000137E                           690       ***
0000137E                           691       ***CMPI    #%0000000011111111,D6
0000137E                           692       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
0000137E                           693          
0000137E                           694          * IF PASSED BOTH CMPI CHECKS (ABOVE),
0000137E                           695          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
0000137E                           696          
0000137E  3C3C 0009                697          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
00001382  3E3C 000B                698          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
00001386                           699                                        
00001386                           700          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001386  6100 06A2                701          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
0000138A  CC42                     702          AND     D2,D6   * apply the BITMASK
0000138C                           703          
0000138C                           704          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
0000138C  0C46 0400                705          CMPI    #%0000010000000000,D6
00001390  6700 002A                706          BEQ     OP_BCC
00001394                           707          
00001394                           708          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
00001394  0C46 0500                709          CMPI    #%0000010100000000,D6
00001398  6700 002C                710          BEQ     OP_BCS
0000139C                           711          
0000139C                           712          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
0000139C  0C46 0C00                713          CMPI    #%0000110000000000,D6
000013A0  6700 002E                714          BEQ     OP_BGE
000013A4                           715          
000013A4                           716          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
000013A4  0C46 0D00                717          CMPI    #%0000110100000000,D6
000013A8  6700 0030                718          BEQ     OP_BLT
000013AC                           719          
000013AC                           720          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
000013AC  0C46 0800                721          CMPI    #%0000100000000000,D6
000013B0  6700 0032                722          BEQ     OP_BVC
000013B4                           723          
000013B4                           724          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
000013B4                           725          * NOTE: A branch to the immediately following instruction automatically
000013B4                           726          *       uses the 16-bit displacement format because the 8-bit displacement
000013B4                           727          *       field contains $00 zero offset
000013B4                           728          * http://68k.hax.com/BRA
000013B4                           729          * NOTE2 ---> Does this mean, there should be no checks when debugging
000013B4                           730          *            for word/long offsets?
000013B4  0C46 0000                731          CMPI    #%0000000000000000,D6
000013B8  6700 0034                732          BEQ     OP_BRA
000013BC                           733          
000013BC                           734          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
000013BC                           735          ; call raw data print out sub routine
000013BC                           736  
000013BC                           737  OP_BCC
000013BC  43F9 00001AAF            738          LEA     OP_BCC_MSG,A1
000013C2  6000 0034                739          BRA     OP_BRANCHES_PRINT
000013C6                           740  OP_BCS
000013C6  43F9 00001AB3            741          LEA     OP_BCS_MSG,A1
000013CC  6000 002A                742          BRA     OP_BRANCHES_PRINT
000013D0                           743  OP_BGE
000013D0  43F9 00001AB7            744          LEA     OP_BGE_MSG,A1
000013D6  6000 0020                745          BRA     OP_BRANCHES_PRINT
000013DA                           746  OP_BLT
000013DA  43F9 00001ABB            747          LEA     OP_BLT_MSG,A1
000013E0  6000 0016                748          BRA     OP_BRANCHES_PRINT
000013E4                           749  OP_BVC
000013E4  43F9 00001ABF            750          LEA     OP_BVC_MSG,A1
000013EA  6000 000C                751          BRA     OP_BRANCHES_PRINT
000013EE                           752  OP_BRA
000013EE  43F9 00001AC3            753          LEA     OP_BRA_MSG,A1
000013F4  6000 0002                754          BRA     OP_BRANCHES_PRINT
000013F8                           755  
000013F8                           756  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000013F8                           757          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000013F8                           758          * assemble output to console
000013F8                           759  OP_BRANCHES_PRINT
000013F8  103C 000E                760          MOVE.B  #14,D0 * print instruction op
000013FC  4E4F                     761          TRAP    #15
000013FE                           762          
000013FE  43F9 00001AA7            763          LEA     DATA,A1
00001404  103C 000E                764          MOVE.B  #14,D0 * print raw data hex of the LABEL
00001408  4E4F                     765          TRAP    #15
0000140A                           766          
0000140A  1A1A                     767          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
0000140C  2845                     768          MOVE.L  D5,A4 * ready the 8bits into a4
0000140E  43D4                     769          LEA     (A4),A1 * ready the a4 into a1 for print
00001410  103C 000E                770          MOVE.B  #14,D0 * print the 8bit addr
00001414  4E4F                     771          TRAP    #15
00001416                           772  
00001416  6000 0002                773          BRA     BCC_END
0000141A                           774  
0000141A                           775  BCC_END * reload the memory, call RTS
0000141A  4C9F 0303                776          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
0000141E  4E75                     777          RTS
00001420                           778  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001420                           779  *-----------------------------------------------------------------------------
00001420                           780  
00001420                           781  
00001420                           782  
00001420                           783  *-----------------------------------------------------------------------------
00001420                           784  *-----------------------------------------------------------------------------
00001420                           785  * NAME: OP_0111   ()
00001420                           786  * DESCRIPTION:    OP code 0111 is not supported. 
00001420                           787  * PRE-CONDITION:  
00001420                           788  * POST-CONDITION: 
00001420                           789  * REGISTERS:
00001420                           790  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001420                           791  OP0111
00001420  6700 FF3C                792          BEQ     UNKNOWN     * OP 0111 is not supported
00001424                           793  
00001424                           794  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001424                           795  *-----------------------------------------------------------------------------
00001424                           796  
00001424                           797  
00001424                           798  
00001424                           799  *-----------------------------------------------------------------------------
00001424                           800  *-----------------------------------------------------------------------------
00001424                           801  * NAME: OP_1000   (DIVS, OR)
00001424                           802  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001424                           803  * PRE-CONDITION:  xyz
00001424                           804  * POST-CONDITION: All registers return to their previous state, and the output
00001424                           805  *                 goes to the output console for reading the raw data or the
00001424                           806  *                 actual instruction.
00001424                           807  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001424                           808  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001424                           809  OP1000
00001424                           810          * Saving values to the stack
00001424  48A7 FFC0                811          MOVEM   D0-D7/A0-A1,-(A7)
00001428                           812  
00001428                           813          * Check if the EA Mode is 001 since both DIVS and OR do not support it
00001428  3C3C 0003                814          MOVE.W  #3, D6              * Prep lower value for bitmask
0000142C  3E3C 0005                815          MOVE.W  #5, D7              * Prep upper value for bitmask
00001430  6100 05F8                816          BSR     BITMASK             * Finalize bitmask setup
00001434  CC42                     817          AND     D2,D6               * Apply bitmask
00001436                           818          
00001436  0C46 0008                819          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
0000143A  6700 FF22                820          BEQ     UNKNOWN                 * If so, the op is not supported
0000143E                           821          
0000143E                           822          * Checking for DIVS
0000143E  3C3C 0006                823          MOVE.W  #6, D6              * Prep lower value for bitmask
00001442  3E3C 0008                824          MOVE.W  #8, D7              * Prep upper value for bitmask
00001446  6100 05E2                825          BSR     BITMASK             * Finalize bitmask setup
0000144A  CC42                     826          AND     D2,D6               * Apply bitmask
0000144C                           827          
0000144C  0C46 01C0                828          CMPI    #%0000000111000000, D6  * Are we DIVS?
00001450  6600 0012                829          BNE     NOTDIVS                 * If not, branch to see if it's OR
00001454                           830          
00001454  43F9 00001A71            831          LEA     DIVSOP,A1           * We found DIVS
0000145A  103C 000E                832          MOVE.B  #14,D0              * Trap #14 prints out the data
0000145E  4E4F                     833          TRAP    #15                 * Perform Trap #14
00001460                           834          
00001460  6100 0018                835          BSR     EAHELPER611         * Print out data. TODO: DOESN'T WORK
00001464                           836          
00001464                           837  NOTDIVS * It is confirmed OR at this point
00001464  43F9 00001A9B            838          LEA     OROP,A1         * We found OR
0000146A  103C 000E                839          MOVE.B  #14,D0          * Trap #14 prints out the data
0000146E  4E4F                     840          TRAP    #15             * Perform Trap #14
00001470                           841          
00001470  6100 0008                842          BSR     EAHELPER611
00001474                           843  
00001474                           844  OP1000END
00001474  48A7 FFC0                845          MOVEM   D0-D7/A0-A1,-(A7)
00001478  4E75                     846          RTS
0000147A                           847  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           848  *-----------------------------------------------------------------------------
0000147A                           849  
0000147A                           850  
0000147A                           851  
0000147A                           852  *-----------------------------------------------------------------------------
0000147A                           853  *-----------------------------------------------------------------------------
0000147A                           854  * NAME: OP_1001   (SUB)
0000147A                           855  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000147A                           856  * PRE-CONDITION:  xyz
0000147A                           857  * POST-CONDITION: All registers return to their previous state, and the output
0000147A                           858  *                 goes to the output console for reading the raw data or the
0000147A                           859  *                 actual instruction.
0000147A                           860  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000147A                           861  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           862  OP1001
0000147A                           863  
0000147A                           864  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           865  *-----------------------------------------------------------------------------
0000147A                           866  
0000147A                           867  
0000147A                           868  
0000147A                           869  *-----------------------------------------------------------------------------
0000147A                           870  *-----------------------------------------------------------------------------
0000147A                           871  * NAME: OP_1010   ()
0000147A                           872  * DESCRIPTION:    a
0000147A                           873  * PRE-CONDITION:  b
0000147A                           874  * POST-CONDITION: c
0000147A                           875  * REGISTERS:      d
0000147A                           876  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           877  OP1010
0000147A                           878  
0000147A                           879  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           880  *-----------------------------------------------------------------------------
0000147A                           881  
0000147A                           882  
0000147A                           883  
0000147A                           884  *-----------------------------------------------------------------------------
0000147A                           885  *-----------------------------------------------------------------------------
0000147A                           886  * NAME: OP_1011   (EOR, CMP)
0000147A                           887  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000147A                           888  * PRE-CONDITION:  xyz
0000147A                           889  * POST-CONDITION: All registers return to their previous state, and the output
0000147A                           890  *                 goes to the output console for reading the raw data or the
0000147A                           891  *                 actual instruction.
0000147A                           892  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000147A                           893  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           894  OP1011
0000147A                           895  
0000147A                           896  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           897  *-----------------------------------------------------------------------------
0000147A                           898  
0000147A                           899  
0000147A                           900  
0000147A                           901  *-----------------------------------------------------------------------------
0000147A                           902  *-----------------------------------------------------------------------------
0000147A                           903  * NAME: OP_1100   (MULS)
0000147A                           904  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000147A                           905  * PRE-CONDITION:  xyz
0000147A                           906  * POST-CONDITION: All registers return to their previous state, and the output
0000147A                           907  *                 goes to the output console for reading the raw data or the
0000147A                           908  *                 actual instruction.
0000147A                           909  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000147A                           910  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           911  OP1100
0000147A                           912  
0000147A                           913  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           914  *-----------------------------------------------------------------------------
0000147A                           915  
0000147A                           916  
0000147A                           917  
0000147A                           918  *-----------------------------------------------------------------------------
0000147A                           919  *-----------------------------------------------------------------------------
0000147A                           920  * NAME: OP_1101   (ADD, ADDA)
0000147A                           921  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000147A                           922  * PRE-CONDITION:  xyz
0000147A                           923  * POST-CONDITION: All registers return to their previous state, and the output
0000147A                           924  *                 goes to the output console for reading the raw data or the
0000147A                           925  *                 actual instruction.
0000147A                           926  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000147A                           927  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           928  OP1101
0000147A                           929  
0000147A                           930  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           931  *-----------------------------------------------------------------------------
0000147A                           932  
0000147A                           933  
0000147A                           934  
0000147A                           935  *-----------------------------------------------------------------------------
0000147A                           936  *-----------------------------------------------------------------------------
0000147A                           937  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
0000147A                           938  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000147A                           939  * PRE-CONDITION:  xyz
0000147A                           940  * POST-CONDITION: All registers return to their previous state, and the output
0000147A                           941  *                 goes to the output console for reading the raw data or the
0000147A                           942  *                 actual instruction.
0000147A                           943  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000147A                           944  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           945  OP1110
0000147A                           946  
0000147A                           947  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           948  *-----------------------------------------------------------------------------
0000147A                           949  
0000147A                           950  
0000147A                           951  
0000147A                           952  *-----------------------------------------------------------------------------
0000147A                           953  *-----------------------------------------------------------------------------
0000147A                           954  * NAME: OP_1111   ()
0000147A                           955  * DESCRIPTION:    a
0000147A                           956  * PRE-CONDITION:  b
0000147A                           957  * POST-CONDITION: c
0000147A                           958  * REGISTERS:      d
0000147A                           959  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           960  OP1111
0000147A                           961  
0000147A                           962  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000147A                           963  *-----------------------------------------------------------------------------
0000147A                           964  
0000147A                           965  
0000147A                           966  
0000147A                           967  *-----------------------------------------------------------------------------
0000147A                           968  *-----------------------------------------------------------------------------
0000147A                           969  * NAME:           EAHELPER611
0000147A                           970  * DESCRIPTION:    a
0000147A                           971  * PRE-CONDITION:  D2 contains the instruction to print modes for.
0000147A                           972  * POST-CONDITION: Determines mode, passes D2 to EAHELPER05 to print.
0000147A                           973  * REGISTERS:      a
0000147A                           974  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000147A                           975  EAHELPER611
0000147A  48A7 FFC0                976      MOVEM  D0-D7/A0-A1,-(A7) * save stuff
0000147E                           977      
0000147E                           978      * to move the mode where EAHELPER50 can process it
0000147E  7C06                     979      MOVE.L  #6,D6   *prep registers to create bitmask
00001480  7E08                     980      MOVE.L  #8,D7
00001482                           981      
00001482  6100 05A6                982      BSR     BITMASK * create bitmask
00001486                           983      
00001486  CC42                     984      AND     D2,D6   * apply bitmask
00001488                           985      
00001488  4243                     986      CLR     D3      * prep D3 to store values
0000148A                           987      
0000148A  3606                     988      MOVE.W  D6,D3   * store bitmasked value in D3
0000148C                           989      
0000148C  E64B                     990      LSR     #3,D3   * move bits 6-8 to 3-5
0000148E                           991      
0000148E                           992      * to move the register where EAHELPER50 can process it
0000148E  7C09                     993      MOVE.L  #9,D6   *prep registers to create bitmask
00001490  7E0B                     994      MOVE.L  #11,D7
00001492                           995      
00001492  6100 0596                996      BSR     BITMASK * create bitmask
00001496                           997      
00001496  CC42                     998      AND     D2,D6   * apply bitmask
00001498                           999      
00001498  4244                    1000      CLR     D4      * prep D3 to store values
0000149A                          1001      
0000149A  3806                    1002      MOVE.W  D6,D4   * store bitmasked value in D3
0000149C                          1003      
0000149C  E04C                    1004      LSR     #8,D4   * move bits 9-11 to 0-2
0000149E  E24C                    1005      LSR     #1,D4   * move bits 9-11 to 0-2
000014A0                          1006      
000014A0  8684                    1007      OR.L    D4,D3   * combind the register and mode
000014A2                          1008      
000014A2  2403                    1009      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
000014A4                          1010      
000014A4  6100 0008               1011      BSR     EAHELPER05
000014A8                          1012      
000014A8  4C9F 03FF               1013      MOVEM  (A7)+,D0-D7/A0-A1 * save stuff
000014AC                          1014      
000014AC  4E75                    1015      RTS
000014AE                          1016  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014AE                          1017  *-----------------------------------------------------------------------------
000014AE                          1018  
000014AE                          1019  
000014AE                          1020  
000014AE                          1021  *-----------------------------------------------------------------------------
000014AE                          1022  *-----------------------------------------------------------------------------
000014AE                          1023  * NAME:           EAHELPER05
000014AE                          1024  * DESCRIPTION:    a
000014AE                          1025  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
000014AE                          1026  *                 this sub-routine helper for operations that only have one
000014AE                          1027  *                 mode register.
000014AE                          1028  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
000014AE                          1029  * REGISTERS:      a
000014AE                          1030  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014AE                          1031  EAHELPER05
000014AE                          1032      * todo: add code for printing immediate values
000014AE                          1033      
000014AE  48A7 FFC0               1034      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000014B2                          1035      
000014B2  7C03                    1036      MOVE.L  #3,D6
000014B4  7E05                    1037      MOVE.L  #5,D7
000014B6                          1038      
000014B6  6100 0572               1039      BSR     BITMASK * generate a bitmask to identify the mode
000014BA                          1040      
000014BA  CC42                    1041      AND     D2,D6   * mask off the parts of D2 we don't need
000014BC                          1042      
000014BC  2A06                    1043      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
000014BE                          1044      
000014BE  0C46 0000               1045      CMPI    #%0000000000000000,D6 * is it data register direct?
000014C2  6600 000A               1046      BNE     NOTDATAREG
000014C6                          1047      
000014C6  6100 00E4               1048      BSR     MODE_DN
000014CA                          1049       
000014CA  6000 00DA               1050      BRA     ENDEAHELPER05
000014CE                          1051      
000014CE                          1052  NOTDATAREG * address register direct
000014CE                          1053      
000014CE  0C46 0008               1054      CMPI    #%0000000000001000,D6 * is it address register direct?
000014D2  6600 000A               1055      BNE     NOTADRDIRECT
000014D6                          1056      
000014D6  6100 01D4               1057      BSR     MODE_AN * simply prints out the address register
000014DA                          1058       
000014DA  6000 00CA               1059      BRA     ENDEAHELPER05
000014DE                          1060      
000014DE                          1061  NOTADRDIRECT * address register indirect
000014DE                          1062          
000014DE  0C46 0010               1063      CMPI    #%0000000000010000,D6 * is it address register indirect?
000014E2  6600 0022               1064      BNE     NOTADRINDIRECT
000014E6                          1065      
000014E6  43F9 00001AEF           1066      LEA     OBRACK,A1       * Load '('
000014EC  303C 000E               1067      MOVE.W  #14,D0          * Trap #14 to display message
000014F0  4E4F                    1068      TRAP    #15             * Perform #14
000014F2                          1069          
000014F2                          1070  
000014F2  6100 01B8               1071      BSR     MODE_AN * print out an address register
000014F6                          1072      
000014F6  43F9 00001AF1           1073      LEA     CBRACK,A1       * Load ')'
000014FC  303C 000E               1074      MOVE.W  #14,D0          * Trap #14 to display message
00001500  4E4F                    1075      TRAP    #15             * Perform #14
00001502                          1076       
00001502  6000 00A2               1077      BRA     ENDEAHELPER05
00001506                          1078      
00001506                          1079  NOTADRINDIRECT * address register indirect, post increment
00001506                          1080      
00001506  0C46 0018               1081      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
0000150A  6600 002E               1082      BNE     NOTADRINDIRECTPOST
0000150E                          1083      
0000150E  43F9 00001AEF           1084      LEA     OBRACK,A1       * Load '('
00001514  303C 000E               1085      MOVE.W  #14,D0          * Trap #14 to display message
00001518  4E4F                    1086      TRAP    #15             * Perform #14
0000151A                          1087          
0000151A                          1088  
0000151A  6100 0190               1089      BSR     MODE_AN * print out an address register
0000151E                          1090      
0000151E  43F9 00001AF1           1091      LEA     CBRACK,A1       * Load ')'
00001524  303C 000E               1092      MOVE.W  #14,D0          * Trap #14 to display message
00001528  4E4F                    1093      TRAP    #15             * Perform #14
0000152A                          1094      
0000152A  43F9 00001AF3           1095      LEA     PLUS,A1       * Load '+'
00001530  303C 000E               1096      MOVE.W  #14,D0          * Trap #14 to display message
00001534  4E4F                    1097      TRAP    #15             * Perform #14
00001536                          1098       
00001536  6000 006E               1099      BRA     ENDEAHELPER05
0000153A                          1100      
0000153A                          1101  NOTADRINDIRECTPOST * address register indirect, pre decrement
0000153A                          1102      
0000153A  0C46 0020               1103      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
0000153E  6600 002E               1104      BNE     NOTADRINDIRECTPRE
00001542                          1105      
00001542  43F9 00001AF5           1106      LEA     MINUS,A1       * Load '-'
00001548  303C 000E               1107      MOVE.W  #14,D0          * Trap #14 to display message
0000154C  4E4F                    1108      TRAP    #15             * Perform #14
0000154E                          1109      
0000154E  43F9 00001AEF           1110      LEA     OBRACK,A1       * Load '('
00001554  303C 000E               1111      MOVE.W  #14,D0          * Trap #14 to display message
00001558  4E4F                    1112      TRAP    #15             * Perform #14
0000155A                          1113          
0000155A                          1114  
0000155A  6100 0150               1115      BSR     MODE_AN * print out an address register
0000155E                          1116      
0000155E  43F9 00001AF1           1117      LEA     CBRACK,A1       * Load ')'
00001564  303C 000E               1118      MOVE.W  #14,D0          * Trap #14 to display message
00001568  4E4F                    1119      TRAP    #15             * Perform #14
0000156A                          1120       
0000156A  6000 003A               1121      BRA     ENDEAHELPER05
0000156E                          1122      
0000156E                          1123  NOTADRINDIRECTPRE * immediate
0000156E                          1124      
0000156E  0C46 0038               1125      CMPI    #%0000000000111000,D6 * is it immediate?
00001572  6600 002E               1126      BNE     NOTIMMEDIATE
00001576                          1127  
00001576  3C3C 0006               1128      MOVE.W  #6, D6              * Prep lower value for bitmask
0000157A  3E3C 0007               1129      MOVE.W  #7, D7              * Prep upper value for bitmask
0000157E  6100 04AA               1130      BSR     BITMASK             * Finalize bitmask setup
00001582  CC42                    1131      AND     D2,D6               * Apply bitmask  
00001584                          1132  
00001584  43F9 00001AEB           1133      LEA     IMD,A1 *print out the '#' indicating an immediate value
0000158A  103C 000E               1134      MOVE.B  #14,D0
0000158E  4E4F                    1135      TRAP    #15
00001590                          1136          
00001590  341A                    1137      MOVE.W  (A2)+,D2
00001592                          1138      
00001592  3202                    1139      MOVE.W  D2,D1
00001594                          1140      
00001594  343C 0010               1141      MOVE.W  #16,D2
00001598                          1142          
00001598  103C 000F               1143      MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000159C  4E4F                    1144      TRAP    #15      * Perform Trap #3
0000159E                          1145      
0000159E  6000 0006               1146      BRA     ENDEAHELPER05
000015A2                          1147      
000015A2                          1148  NOTIMMEDIATE * if none of the previous cases are true, it is a mode not supported by our decompiler
000015A2                          1149  
000015A2  6100 02CE               1150      BSR     UNKNOWNOP
000015A6                          1151      
000015A6                          1152  ENDEAHELPER05
000015A6  4C9F 03FF               1153      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
000015AA  4E75                    1154      RTS
000015AC                          1155  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015AC                          1156  *-----------------------------------------------------------------------------
000015AC                          1157  
000015AC                          1158  
000015AC                          1159  
000015AC                          1160  *-----------------------------------------------------------------------------
000015AC                          1161  *-----------------------------------------------------------------------------
000015AC                          1162  * NAME:           MODE_DN
000015AC                          1163  * DESCRIPTION:    Generalize the EA part of the project.
000015AC                          1164  * PRE-CONDITION:  The mode must have been correctly identified. All modes
000015AC                          1165  *                 must be called by RTS.
000015AC                          1166  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
000015AC                          1167  *                 called it.
000015AC                          1168  * REGISTERS:      a
000015AC                          1169  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015AC                          1170  * ---> Dn
000015AC                          1171  MODE_DN
000015AC  48A7 FFC0               1172          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
000015B0                          1173  
000015B0  3C3C 0000               1174          MOVE.W  #0, D6              * Prep lower value for bitmask
000015B4  3E3C 0002               1175          MOVE.W  #2, D7              * Prep upper value for bitmask
000015B8  6100 0470               1176          BSR     BITMASK             * Finalize bitmask setup
000015BC  CC42                    1177          AND     D2,D6               * Apply bitmask
000015BE                          1178          
000015BE  0C46 0000               1179          CMPI    #%000000000000000, D6   * Data Register D0?
000015C2  6600 000A               1180          BNE     NOTD0
000015C6                          1181          
000015C6  6100 0074               1182          BSR     PRINTD0
000015CA  6000 006A               1183          BRA     ENDMODE_DN
000015CE                          1184  NOTD0      
000015CE  0C46 0001               1185          CMPI    #%000000000000001, D6   * Data Register D1?
000015D2  6600 000A               1186          BNE     NOTD1
000015D6                          1187          
000015D6  6100 0072               1188          BSR     PRINTD1
000015DA  6000 005A               1189          BRA     ENDMODE_DN
000015DE                          1190  NOTD1
000015DE  0C46 0002               1191          CMPI    #%000000000000010, D6   * Data Register D2?
000015E2  6600 000A               1192          BNE     NOTD2
000015E6                          1193          
000015E6  6100 0070               1194          BSR     PRINTD2
000015EA  6000 004A               1195          BRA     ENDMODE_DN
000015EE                          1196  NOTD2
000015EE  0C46 0003               1197          CMPI    #%000000000000011, D6   * Data Register D3?
000015F2  6600 000A               1198          BNE     NOTD3
000015F6                          1199          
000015F6  6100 006E               1200          BSR     PRINTD3
000015FA  6000 003A               1201          BRA     ENDMODE_DN
000015FE                          1202  NOTD3
000015FE  0C46 0004               1203          CMPI    #%000000000000100, D6   * Data Register D4?
00001602  6600 000A               1204          BNE     NOTD4
00001606                          1205          
00001606  6100 006C               1206          BSR     PRINTD4
0000160A  6000 002A               1207          BRA     ENDMODE_DN
0000160E                          1208  NOTD4
0000160E  0C46 0005               1209          CMPI    #%000000000000101, D6   * Data Register D5?
00001612  6600 000A               1210          BNE     NOTD5
00001616                          1211          
00001616  6100 006A               1212          BSR     PRINTD5
0000161A  6000 001A               1213          BRA     ENDMODE_DN
0000161E                          1214  NOTD5
0000161E  0C46 0006               1215          CMPI    #%000000000000110, D6   * Data Register D6?
00001622  6600 000A               1216          BNE     NOTD6
00001626                          1217          
00001626  6100 0068               1218          BSR     PRINTD6
0000162A  6000 000A               1219          BRA     ENDMODE_DN
0000162E                          1220  NOTD6
0000162E  6100 006E               1221          BSR     PRINTD7
00001632  6000 0002               1222          BRA     ENDMODE_DN
00001636                          1223          
00001636                          1224  ENDMODE_DN
00001636  4C9F 03FF               1225          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
0000163A  4E75                    1226          RTS
0000163C                          1227  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000163C                          1228  *-----------------------------------------------------------------------------
0000163C                          1229  
0000163C                          1230  
0000163C                          1231  
0000163C                          1232  *-----------------------------------------------------------------------------
0000163C                          1233  *-----------------------------------------------------------------------------
0000163C                          1234  * NAME:           PRINTD0
0000163C                          1235  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
0000163C                          1236  * PRE-CONDITION:  a
0000163C                          1237  * POST-CONDITION: a
0000163C                          1238  * REGISTERS:      a
0000163C                          1239  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000163C                          1240  PRINTD0
0000163C  43F9 00001B1B           1241          LEA     __D0, A1        * Load 'D0'
00001642  103C 000E               1242          MOVE.B  #14, D0         * Load Trap #14 to print out
00001646  4E4F                    1243          TRAP    #15             * Perform Trap #14
00001648  4E75                    1244          RTS
0000164A                          1245  PRINTD1
0000164A  43F9 00001B1E           1246          LEA     __D1, A1        * Load 'D1'
00001650  103C 000E               1247          MOVE.B  #14, D0         * Load Trap #14 to print out
00001654  4E4F                    1248          TRAP    #15             * Perform Trap #14
00001656  4E75                    1249          RTS      
00001658                          1250  PRINTD2
00001658  43F9 00001B21           1251          LEA     __D2, A1        * Load 'D2'
0000165E  103C 000E               1252          MOVE.B  #14, D0         * Load Trap #14 to print out
00001662  4E4F                    1253          TRAP    #15             * Perform Trap #14
00001664  4E75                    1254          RTS      
00001666                          1255  PRINTD3
00001666  43F9 00001B24           1256          LEA     __D3, A1        * Load 'D3'
0000166C  103C 000E               1257          MOVE.B  #14, D0         * Load Trap #14 to print out
00001670  4E4F                    1258          TRAP    #15             * Perform Trap #14
00001672  4E75                    1259          RTS      
00001674                          1260  PRINTD4
00001674  43F9 00001B27           1261          LEA     __D4, A1        * Load 'D4'
0000167A  103C 000E               1262          MOVE.B  #14, D0         * Load Trap #14 to print out
0000167E  4E4F                    1263          TRAP    #15             * Perform Trap #14
00001680  4E75                    1264          RTS       
00001682                          1265  PRINTD5
00001682  43F9 00001B2A           1266          LEA     __D5, A1        * Load 'D5'
00001688  103C 000E               1267          MOVE.B  #14, D0         * Load Trap #14 to print out
0000168C  4E4F                    1268          TRAP    #15             * Perform Trap #14
0000168E  4E75                    1269          RTS      
00001690                          1270  PRINTD6
00001690  43F9 00001B2D           1271          LEA     __D6, A1        * Load 'D6'
00001696  103C 000E               1272          MOVE.B  #14, D0         * Load Trap #14 to print out
0000169A  4E4F                    1273          TRAP    #15             * Perform Trap #14
0000169C  4E75                    1274          RTS
0000169E                          1275  PRINTD7
0000169E  43F9 00001B30           1276          LEA     __D7, A1        * Load 'D7'
000016A4  103C 000E               1277          MOVE.B  #14, D0         * Load Trap #14 to print out
000016A8  4E4F                    1278          TRAP    #15             * Perform Trap #14
000016AA  4E75                    1279          RTS
000016AC                          1280  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000016AC                          1281  *-----------------------------------------------------------------------------
000016AC                          1282  
000016AC                          1283  
000016AC                          1284  
000016AC                          1285  *-----------------------------------------------------------------------------
000016AC                          1286  *-----------------------------------------------------------------------------
000016AC                          1287  * NAME:           MODE_AN
000016AC                          1288  * DESCRIPTION:    Simply chooses to print A0-A7.
000016AC                          1289  * PRE-CONDITION:  a
000016AC                          1290  * POST-CONDITION: a
000016AC                          1291  * REGISTERS:      a
000016AC                          1292  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000016AC                          1293  MODE_AN
000016AC  48A7 FFC0               1294          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
000016B0                          1295  
000016B0  3C3C 0000               1296          MOVE.W  #0, D6              * Prep lower value for bitmask
000016B4  3E3C 0002               1297          MOVE.W  #2, D7              * Prep upper value for bitmask
000016B8  6100 0370               1298          BSR     BITMASK             * Finalize bitmask setup
000016BC  CC42                    1299          AND     D2,D6               * Apply bitmask
000016BE                          1300          
000016BE  0C46 0000               1301          CMPI    #%000000000000000, D6   * Address Register A0?
000016C2  6600 000A               1302          BNE     NOTA0
000016C6                          1303          
000016C6  6100 0074               1304          BSR     PRINTA0
000016CA                          1305          
000016CA  6000 006A               1306          BRA     ENDMODE_AN
000016CE                          1307  NOTA0      
000016CE  0C46 0001               1308          CMPI    #%000000000000001, D6   * Address Register A1?
000016D2  6600 000A               1309          BNE     NOTA1
000016D6                          1310          
000016D6  6100 0072               1311          BSR     PRINTA1
000016DA                          1312          
000016DA  6000 005A               1313          BRA     ENDMODE_AN
000016DE                          1314  NOTA1
000016DE  0C46 0002               1315          CMPI    #%000000000000010, D6   * Address Register A2?
000016E2  6600 000A               1316          BNE     NOTA2
000016E6                          1317          
000016E6  6100 0070               1318          BSR     PRINTA2
000016EA                          1319          
000016EA  6000 004A               1320          BRA     ENDMODE_AN
000016EE                          1321  NOTA2
000016EE  0C46 0003               1322          CMPI    #%000000000000011, D6   * Address Register A3?
000016F2  6600 000A               1323          BNE     NOTA3
000016F6                          1324          
000016F6  6100 006E               1325          BSR     PRINTA3
000016FA                          1326          
000016FA  6000 003A               1327          BRA     ENDMODE_AN
000016FE                          1328  NOTA3
000016FE  0C46 0004               1329          CMPI    #%000000000000100, D6   * Address Register A4?
00001702  6600 000A               1330          BNE     NOTA4
00001706                          1331          
00001706  6100 006C               1332          BSR     PRINTA4
0000170A                          1333          
0000170A  6000 002A               1334          BRA     ENDMODE_AN
0000170E                          1335  NOTA4
0000170E  0C46 0005               1336          CMPI    #%000000000000101, D6   * Address Register A5?
00001712  6600 000A               1337          BNE     NOTA5
00001716                          1338          
00001716  6100 006A               1339          BSR     PRINTA5
0000171A                          1340          
0000171A  6000 001A               1341          BRA     ENDMODE_AN
0000171E                          1342  NOTA5
0000171E  0C46 0006               1343          CMPI    #%000000000000110, D6   * Address Register A6?
00001722  6600 000A               1344          BNE     NOTA6
00001726                          1345          
00001726  6100 0068               1346          BSR     PRINTA6
0000172A                          1347          
0000172A  6000 000A               1348          BRA     ENDMODE_AN
0000172E                          1349  NOTA6
0000172E  6100 006E               1350          BSR     PRINTA7
00001732                          1351          
00001732  6000 0002               1352          BRA     ENDMODE_AN
00001736                          1353  ENDMODE_AN
00001736  4C9F 03FF               1354          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
0000173A  4E75                    1355          RTS
0000173C                          1356  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000173C                          1357  *-----------------------------------------------------------------------------
0000173C                          1358  
0000173C                          1359  
0000173C                          1360  
0000173C                          1361  *-----------------------------------------------------------------------------
0000173C                          1362  *-----------------------------------------------------------------------------
0000173C                          1363  * NAME:           PRINTA0
0000173C                          1364  * DESCRIPTION:    Simply print out the address register.
0000173C                          1365  * PRE-CONDITION:  a
0000173C                          1366  * POST-CONDITION: a
0000173C                          1367  * REGISTERS:      a
0000173C                          1368  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000173C                          1369  PRINTA0
0000173C  43F9 00001B03           1370          LEA     __A0, A1        * Load 'A0'
00001742  103C 000E               1371          MOVE.B  #14, D0         * Load Trap #14 to print out
00001746  4E4F                    1372          TRAP    #15             * Perform Trap #14
00001748  4E75                    1373          RTS
0000174A                          1374  
0000174A                          1375  PRINTA1
0000174A  43F9 00001B06           1376          LEA     __A1, A1        * Load 'A1'
00001750  103C 000E               1377          MOVE.B  #14, D0         * Load Trap #14 to print out
00001754  4E4F                    1378          TRAP    #15             * Perform Trap #14
00001756  4E75                    1379          RTS
00001758                          1380          
00001758                          1381  PRINTA2
00001758  43F9 00001B09           1382          LEA     __A2, A1        * Load 'A2'
0000175E  103C 000E               1383          MOVE.B  #14, D0         * Load Trap #14 to print out
00001762  4E4F                    1384          TRAP    #15             * Perform Trap #14
00001764  4E75                    1385          RTS
00001766                          1386  
00001766                          1387  PRINTA3
00001766  43F9 00001B0C           1388          LEA     __A3, A1        * Load 'A3'
0000176C  103C 000E               1389          MOVE.B  #14, D0         * Load Trap #14 to print out
00001770  4E4F                    1390          TRAP    #15             * Perform Trap #14
00001772  4E75                    1391          RTS
00001774                          1392  
00001774                          1393  PRINTA4
00001774  43F9 00001B0F           1394          LEA     __A4, A1        * Load 'A4'
0000177A  103C 000E               1395          MOVE.B  #14, D0         * Load Trap #14 to print out
0000177E  4E4F                    1396          TRAP    #15             * Perform Trap #14
00001780  4E75                    1397          RTS
00001782                          1398  
00001782                          1399  PRINTA5
00001782  43F9 00001B12           1400          LEA     __A5, A1        * Load 'A5'
00001788  103C 000E               1401          MOVE.B  #14, D0         * Load Trap #14 to print out
0000178C  4E4F                    1402          TRAP    #15             * Perform Trap #14
0000178E  4E75                    1403          RTS
00001790                          1404  
00001790                          1405  PRINTA6
00001790  43F9 00001B15           1406          LEA     __A6, A1        * Load 'A6'
00001796  103C 000E               1407          MOVE.B  #14, D0         * Load Trap #14 to print out
0000179A  4E4F                    1408          TRAP    #15             * Perform Trap #14
0000179C  4E75                    1409          RTS
0000179E                          1410  
0000179E                          1411  PRINTA7
0000179E  43F9 00001B18           1412          LEA     __A7, A1        * Load 'A7'
000017A4  103C 000E               1413          MOVE.B  #14, D0         * Load Trap #14 to print out
000017A8  4E4F                    1414          TRAP    #15             * Perform Trap #14
000017AA  4E75                    1415          RTS
000017AC                          1416  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000017AC                          1417  *-----------------------------------------------------------------------------
000017AC                          1418  
000017AC                          1419  
000017AC                          1420  
000017AC                          1421  *-----------------------------------------------------------------------------
000017AC                          1422  *-----------------------------------------------------------------------------
000017AC                          1423  * NAME:           SIZE67
000017AC                          1424  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
000017AC                          1425  * PRE-CONDITION:  a
000017AC                          1426  * POST-CONDITION: a
000017AC                          1427  * REGISTERS:      a
000017AC                          1428  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000017AC                          1429  SIZE67
000017AC  48A7 FFFE               1430          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
000017B0  3C3C 0006               1431          MOVE.W  #6, D6              * Prep lower value for bitmask
000017B4  3E3C 0007               1432          MOVE.W  #7, D7              * Prep upper value for bitmask
000017B8  6100 0270               1433          BSR     BITMASK             * Finalize bitmask setup
000017BC  CC42                    1434          AND     D2,D6               * Apply bitmask     
000017BE                          1435  
000017BE  0C46 0000               1436          CMPI    #%0000000000000000, D6   * is it a BYTE?
000017C2  6600 000A               1437          BNE     NOT67BYTE
000017C6                          1438          
000017C6  6100 0080               1439          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000017CA  6000 001E               1440          BRA     END67
000017CE                          1441  NOT67BYTE        
000017CE  0C46 0040               1442          CMPI    #%0000000001000000, D6   * is it a WORD?
000017D2  6600 000A               1443          BNE     NOT67WORD
000017D6                          1444          
000017D6  6100 007E               1445          BSR     PRINTWORD               * Branch to handle WORD sizes
000017DA  6000 000E               1446          BRA     END67
000017DE                          1447  NOT67WORD
000017DE  0C46 0080               1448          CMPI    #%0000000010000000, D6   * is it a LONG?
000017E2  6600 0006               1449          BNE     END67
000017E6                          1450          
000017E6  6100 007C               1451          BSR     PRINTLONG               * Branch to handle LONG sizes
000017EA                          1452  END67
000017EA  4C9F 7FFF               1453          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
000017EE  4E75                    1454          RTS                             * Return. Size handling is finished.
000017F0                          1455  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000017F0                          1456  *-----------------------------------------------------------------------------
000017F0                          1457  
000017F0                          1458  
000017F0                          1459  
000017F0                          1460  *-----------------------------------------------------------------------------
000017F0                          1461  *-----------------------------------------------------------------------------
000017F0                          1462  * NAME:           SIZE68
000017F0                          1463  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
000017F0                          1464  * PRE-CONDITION:  a
000017F0                          1465  * POST-CONDITION: a
000017F0                          1466  * REGISTERS:      a
000017F0                          1467  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000017F0                          1468  SIZE68
000017F0                          1469          * finish later, need to follow the same format as SIZE67
000017F0                          1470          
000017F0                          1471          
000017F0  48A7 FFFE               1472          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
000017F4  3C3C 0006               1473          MOVE.W  #6, D6              * Prep lower value for bitmask
000017F8  3E3C 0008               1474          MOVE.W  #8, D7              * Prep upper value for bitmask
000017FC  6100 022C               1475          BSR     BITMASK             * Finalize bitmask setup
00001800  CC42                    1476          AND     D2,D6               * Apply bitmask          
00001802                          1477          
00001802  0C46 0000               1478          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001806  6100 0040               1479          BSR     PRINTBYTE               * Branch to handle BYTE sizes
0000180A  0C46 0100               1480          CMPI    #%0000000100000000, D6   * is it a BYTE?
0000180E  6100 0038               1481          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001812                          1482        
00001812  0C46 0040               1483          CMPI    #%0000000001000000, D6   * is it a WORD?
00001816  6100 003E               1484          BSR     PRINTWORD               * Branch to handle BYTE sizes
0000181A  0C46 0140               1485          CMPI    #%0000000101000000, D6   * is it a WORD?
0000181E  6100 0036               1486          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001822  0C46 00C0               1487          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
00001826  6100 002E               1488          BSR     PRINTWORD               * Branch to handle BYTE sizes
0000182A                          1489  
0000182A  0C46 0080               1490          CMPI    #%0000000010000000, D6   * is it a LONG?
0000182E  6100 0034               1491          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001832  0C46 0180               1492          CMPI    #%0000000110000000, D6   * is it a LONG?
00001836  6100 002C               1493          BSR     PRINTLONG               * Branch to handle BYTE sizes
0000183A  0C46 01C0               1494          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
0000183E  6100 0024               1495          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001842                          1496  
00001842  4C9F 7FFF               1497          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001846  4E75                    1498          RTS                             * Return. Size handling is finished.
00001848                          1499  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001848                          1500  *-----------------------------------------------------------------------------
00001848                          1501  
00001848                          1502  
00001848                          1503  
00001848                          1504  *-----------------------------------------------------------------------------
00001848                          1505  *-----------------------------------------------------------------------------
00001848                          1506  * NAME:           PRINTBYTE
00001848                          1507  * DESCRIPTION:    a
00001848                          1508  * PRE-CONDITION:  a
00001848                          1509  * POST-CONDITION: a
00001848                          1510  * REGISTERS:      a
00001848                          1511  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001848                          1512  PRINTBYTE
00001848  43F9 00001AF7           1513          LEA     __B,A1      * Load '.B ' into A1
0000184E  103C 000E               1514          MOVE.B  #14,D0      * Trap #14 setup to print
00001852  4E4F                    1515          TRAP    #15         * Perform Trap #14
00001854  4E75                    1516          RTS                 * Return to SIZE67/SIZE68
00001856                          1517          
00001856                          1518  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001856                          1519  *-----------------------------------------------------------------------------
00001856                          1520  
00001856                          1521  
00001856                          1522  
00001856                          1523  *-----------------------------------------------------------------------------
00001856                          1524  *-----------------------------------------------------------------------------
00001856                          1525  * NAME:           PRINTWORD
00001856                          1526  * DESCRIPTION:    a
00001856                          1527  * PRE-CONDITION:  a
00001856                          1528  * POST-CONDITION: a
00001856                          1529  * REGISTERS:      a
00001856                          1530  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001856                          1531  PRINTWORD
00001856  43F9 00001AFB           1532          LEA     __W,A1      * Load '.W ' into A1
0000185C  103C 000E               1533          MOVE.B  #14,D0      * Trap #14 setup to print
00001860  4E4F                    1534          TRAP    #15         * Perform Trap #14
00001862  4E75                    1535          RTS                 * Return to SIZE67/SIZE68
00001864                          1536          
00001864                          1537  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001864                          1538  *-----------------------------------------------------------------------------
00001864                          1539  
00001864                          1540  
00001864                          1541  
00001864                          1542  *-----------------------------------------------------------------------------
00001864                          1543  *-----------------------------------------------------------------------------
00001864                          1544  * NAME:           PRINTLONG
00001864                          1545  * DESCRIPTION:    a
00001864                          1546  * PRE-CONDITION:  a
00001864                          1547  * POST-CONDITION: a
00001864                          1548  * REGISTERS:      a
00001864                          1549  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001864                          1550  PRINTLONG
00001864  43F9 00001AFF           1551          LEA     __L,A1      * Load '.L ' into A1
0000186A  103C 000E               1552          MOVE.B  #14,D0      * Trap #14 setup to print
0000186E  4E4F                    1553          TRAP    #15         * Perform Trap #14
00001870  4E75                    1554          RTS                 * Return to SIZE67/SIZE68
00001872                          1555          
00001872                          1556  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001872                          1557  *-----------------------------------------------------------------------------
00001872                          1558  
00001872                          1559  
00001872                          1560  
00001872                          1561  *-----------------------------------------------------------------------------
00001872                          1562  *-----------------------------------------------------------------------------
00001872                          1563  * NAME:           UNKNOWNOP
00001872                          1564  * DESCRIPTION:    a
00001872                          1565  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001872                          1566  *                 identified as an unknown operation.
00001872                          1567  * POST-CONDITION: D2 is no longer the opcode.
00001872                          1568  * REGISTERS:      a
00001872                          1569  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001872                          1570  UNKNOWNOP
00001872  220A                    1571          MOVE.L  A2,D1   * prep the add to print
00001874                          1572          
00001874  5581                    1573          SUB.L   #2,D1   * off by two error due to post increment correct
00001876                          1574          
00001876  2602                    1575          MOVE.L  D2,D3   * save the opcode to print
00001878                          1576          
00001878  7410                    1577          MOVE.L  #16,D2  * set the base to 16
0000187A                          1578          
0000187A  700F                    1579          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
0000187C  4E4F                    1580          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000187E                          1581          
0000187E  43F9 00001AA7           1582          LEA     DATA,A1 * load " DATA $" into register A1
00001884  700E                    1583          MOVE.L  #14,D0  * print the string stored in A1
00001886  4E4F                    1584          TRAP    #15
00001888                          1585          
00001888  2203                    1586          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
0000188A                          1587          
0000188A  103C 000F               1588          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
0000188E  4E4F                    1589          TRAP    #15      * Perform Trap #3
00001890                          1590  
00001890  43F9 00001A6E           1591          LEA     NEWLINE,A1 * load newline into register A1
00001896  700E                    1592          MOVE.L  #14,D0  * print the string stored in A1
00001898  4E4F                    1593          TRAP    #15
0000189A                          1594  
0000189A  4E75                    1595          RTS
0000189C                          1596  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000189C                          1597  *-----------------------------------------------------------------------------
0000189C                          1598  
0000189C                          1599  
0000189C                          1600  
0000189C                          1601  *-----------------------------------------------------------------------------
0000189C                          1602  *-----------------------------------------------------------------------------
0000189C                          1603  * NAME: Print ASCII hex char
0000189C                          1604  * DESCRIPTION:    Prints and addres register to console in hex (ASCII chars)
0000189C                          1605  * PRE-CONDITION:  A6 contains the register for memory to print.
0000189C                          1606  *                 This parameter would be pre-loaded by, for example:
0000189C                          1607  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
0000189C                          1608  *                 D6 contains the loops to do (number of bytes).
0000189C                          1609  * POST-CONDITION: 
0000189C                          1610  * REGISTERS:      
0000189C                          1611  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000189C                          1612  PRINT_ASCII_HEX_CHAR
0000189C  48E7 FFFC               1613      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
000018A0  4285                    1614      CLR.L       D5
000018A2                          1615      
000018A2                          1616      * fence post check (if-statement, check if 0 > chars)
000018A2  0C06 0000               1617      CMPI.B      #0,D6
000018A6  6700 017C               1618      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
000018AA                          1619      
000018AA                          1620  *    MOVE.L      A6,D4
000018AA  2E0E                    1621      MOVE.L      A6,D7
000018AC                          1622  PRINT_ASCII_LOOP
000018AC                          1623  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
000018AC                          1624  *    MOVE.L      D4,D7 * make a mutable copy
000018AC  E99F                    1625      ROL.L       #4,D7 * roll to next spot
000018AE  48E7 0100               1626      MOVEM.L     D7,-(A7) * save D7
000018B2                          1627  
000018B2  0287 0000000F           1628      ANDI.L      #HEX_VALUE_MASK_LONG,D7
000018B8                          1629      
000018B8  0C87 00000000           1630      CMPI.L      #0,D7
000018BE  6D00 0164               1631      BLT         INVALID_ASCII_INPUT
000018C2                          1632  
000018C2  0C87 0000000F           1633      CMPI.L      #15,D7
000018C8  6E00 015A               1634      BGT         INVALID_ASCII_INPUT
000018CC                          1635  
000018CC                          1636      * this might be faster... to do later, after entire assignment done
000018CC                          1637       * CMPI.L      #9,D7
000018CC                          1638       * BLE         PRINT_ASCII_0_TO_9
000018CC                          1639  
000018CC  0C87 00000000           1640      CMPI.L      #0,D7
000018D2  6700 0098               1641      BEQ         PRINT_ASCII_0
000018D6  0C87 00000001           1642      CMPI.L      #1,D7
000018DC  6700 0098               1643      BEQ         PRINT_ASCII_1
000018E0  0C87 00000002           1644      CMPI.L      #2,D7
000018E6  6700 0098               1645      BEQ         PRINT_ASCII_2
000018EA  0C87 00000003           1646      CMPI.L      #3,D7
000018F0  6700 0098               1647      BEQ         PRINT_ASCII_3
000018F4  0C87 00000004           1648      CMPI.L      #4,D7
000018FA  6700 0098               1649      BEQ         PRINT_ASCII_4
000018FE  0C87 00000005           1650      CMPI.L      #5,D7
00001904  6700 0098               1651      BEQ         PRINT_ASCII_5
00001908  0C87 00000006           1652      CMPI.L      #6,D7
0000190E  6700 0098               1653      BEQ         PRINT_ASCII_6
00001912  0C87 00000007           1654      CMPI.L      #7,D7
00001918  6700 0098               1655      BEQ         PRINT_ASCII_7
0000191C  0C87 00000008           1656      CMPI.L      #8,D7
00001922  6700 0098               1657      BEQ         PRINT_ASCII_8
00001926  0C87 00000009           1658      CMPI.L      #9,D7
0000192C  6700 0098               1659      BEQ         PRINT_ASCII_9
00001930  0C87 0000000A           1660      CMPI.L      #10,D7
00001936  6700 0098               1661      BEQ         PRINT_ASCII_A
0000193A  0C87 0000000B           1662      CMPI.L      #11,D7
00001940  6700 0098               1663      BEQ         PRINT_ASCII_B
00001944  0C87 0000000C           1664      CMPI.L      #12,D7
0000194A  6700 0098               1665      BEQ         PRINT_ASCII_C
0000194E  0C87 0000000D           1666      CMPI.L      #13,D7
00001954  6700 0098               1667      BEQ         PRINT_ASCII_D
00001958  0C87 0000000E           1668      CMPI.L      #14,D7
0000195E  6700 0098               1669      BEQ         PRINT_ASCII_E
00001962  0C87 0000000F           1670      CMPI.L      #15,D7
00001968  6700 0098               1671      BEQ         PRINT_ASCII_F
0000196C                          1672  PRINT_ASCII_0
0000196C  43F9 00001AC7           1673      LEA         ASCII_0,A1
00001972  6000 0098               1674      BRA         PRINT_ASCII_CHAR
00001976                          1675  PRINT_ASCII_1
00001976  43F9 00001AC9           1676      LEA         ASCII_1,A1
0000197C  6000 008E               1677      BRA         PRINT_ASCII_CHAR
00001980                          1678  PRINT_ASCII_2
00001980  43F9 00001ACB           1679      LEA         ASCII_2,A1
00001986  6000 0084               1680      BRA         PRINT_ASCII_CHAR
0000198A                          1681  PRINT_ASCII_3
0000198A  43F9 00001ACD           1682      LEA         ASCII_3,A1
00001990  6000 007A               1683      BRA         PRINT_ASCII_CHAR
00001994                          1684  PRINT_ASCII_4
00001994  43F9 00001ACF           1685      LEA         ASCII_4,A1
0000199A  6000 0070               1686      BRA         PRINT_ASCII_CHAR
0000199E                          1687  PRINT_ASCII_5
0000199E  43F9 00001AD1           1688      LEA         ASCII_5,A1
000019A4  6000 0066               1689      BRA         PRINT_ASCII_CHAR
000019A8                          1690  PRINT_ASCII_6
000019A8  43F9 00001AD3           1691      LEA         ASCII_6,A1
000019AE  6000 005C               1692      BRA         PRINT_ASCII_CHAR
000019B2                          1693  PRINT_ASCII_7
000019B2  43F9 00001AD5           1694      LEA         ASCII_7,A1
000019B8  6000 0052               1695      BRA         PRINT_ASCII_CHAR
000019BC                          1696  PRINT_ASCII_8
000019BC  43F9 00001AD7           1697      LEA         ASCII_8,A1
000019C2  6000 0048               1698      BRA         PRINT_ASCII_CHAR
000019C6                          1699  PRINT_ASCII_9
000019C6  43F9 00001AD9           1700      LEA         ASCII_9,A1
000019CC  6000 003E               1701      BRA         PRINT_ASCII_CHAR
000019D0                          1702  PRINT_ASCII_A
000019D0  43F9 00001ADB           1703      LEA         ASCII_A,A1
000019D6  6000 0034               1704      BRA         PRINT_ASCII_CHAR
000019DA                          1705  PRINT_ASCII_B
000019DA  43F9 00001ADD           1706      LEA         ASCII_B,A1
000019E0  6000 002A               1707      BRA         PRINT_ASCII_CHAR
000019E4                          1708  PRINT_ASCII_C
000019E4  43F9 00001ADF           1709      LEA         ASCII_C,A1
000019EA  6000 0020               1710      BRA         PRINT_ASCII_CHAR
000019EE                          1711  PRINT_ASCII_D
000019EE  43F9 00001AE1           1712      LEA         ASCII_D,A1
000019F4  6000 0016               1713      BRA         PRINT_ASCII_CHAR
000019F8                          1714  PRINT_ASCII_E
000019F8  43F9 00001AE3           1715      LEA         ASCII_E,A1
000019FE  6000 000C               1716      BRA         PRINT_ASCII_CHAR
00001A02                          1717  PRINT_ASCII_F
00001A02  43F9 00001AE5           1718      LEA         ASCII_F,A1
00001A08  6000 0002               1719      BRA         PRINT_ASCII_CHAR
00001A0C                          1720  PRINT_ASCII_CHAR
00001A0C  103C 000E               1721      MOVE.B      #14,D0
00001A10  4E4F                    1722      TRAP        #15
00001A12                          1723      
00001A12  5205                    1724      ADD.B       #1,D5 * loop until counter stops
00001A14  BA06                    1725      CMP.B       D6,D5
00001A16  6C00 000C               1726      BGE         PRINT_ASCII_FINISH
00001A1A                          1727      
00001A1A  4287                    1728      CLR.L       D7
00001A1C  4CDF 0080               1729      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001A20                          1730      
00001A20  6000 FE8A               1731      BRA         PRINT_ASCII_LOOP
00001A24                          1732  INVALID_ASCII_INPUT
00001A24                          1733  PRINT_ASCII_FINISH
00001A24  4CDF 3FFF               1734      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001A28  4E75                    1735      RTS
00001A2A                          1736  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A2A                          1737  *-----------------------------------------------------------------------------
00001A2A                          1738  
00001A2A                          1739  
00001A2A                          1740  
00001A2A                          1741  *-----------------------------------------------------------------------------
00001A2A                          1742  *-----------------------------------------------------------------------------
00001A2A                          1743  * NAME: Bitmask
00001A2A                          1744  * DESCRIPTION:    Masks bits in a data register.
00001A2A                          1745  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001A2A                          1746  *                 the ending bit.  For example, a starting bit of decimal
00001A2A                          1747  *                 value 0 and an ending bit of decimal value 3 will mask the
00001A2A                          1748  *                 bits 0, 1, 2, and 3.
00001A2A                          1749  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001A2A                          1750  * REGISTERS:      D5,D6,D7
00001A2A                          1751  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A2A                          1752  BITMASK
00001A2A  3F05                    1753          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001A2C  4245                    1754          CLR     D5          * clear D5 so we can use it
00001A2E                          1755  LOOPBIT 
00001A2E  0DC5                    1756          BSET    D6,D5       * set the D6th bit in D5 to 1
00001A30  5246                    1757          ADD     #1,D6       * increment D6
00001A32                          1758  
00001A32  BC47                    1759          CMP     D7,D6       * have we finished?
00001A34  6E00 0004               1760          BGT     BITMASKDONE * yes
00001A38  60F4                    1761          BRA     LOOPBIT     * no, iterate again
00001A3A                          1762  
00001A3A                          1763  BITMASKDONE
00001A3A  2C05                    1764          MOVE.L  D5,D6
00001A3C  3A1F                    1765          MOVE    (A7)+,D5    * restore D5
00001A3E  4E75                    1766          RTS
00001A40                          1767  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A40                          1768  *-----------------------------------------------------------------------------
00001A40                          1769  
00001A40                          1770  
00001A40                          1771  
00001A40                          1772  *-----------------------------------------------------------------------------
00001A40                          1773  *-----------------------------------------------------------------------------
00001A40                          1774  * SECTION: Constants/variables used throughout the program.
00001A40                          1775  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A40                          1776  * ---> GENERAL
00001A40  =0000000D               1777  CR          EQU     $0D
00001A40  =0000000A               1778  LF          EQU     $0A
00001A40= 45 4E 54 45 52 20 ...   1779  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001A58= 45 4E 54 45 52 20 ...   1780  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001A6E= 0D 0A 00                1781  NEWLINE     DC.B    CR,LF,0
00001A71                          1782  * ---> OPS
00001A71= 44 49 56 53 00          1783  DIVSOP      DC.B    'DIVS',0
00001A76= 4E 4F 50 00             1784  NOOPERATION DC.B    'NOP',0
00001A7A= 4E 45 47 00             1785  NEGOP       DC.B    'NEG',0
00001A7E= 4D 4F 56 45 00          1786  MOVEOP      DC.B    'MOVE',0
00001A83= 4D 4F 56 45 4D 00       1787  MOVEMOP     DC.B    'MOVEM',0
00001A89= 4A 53 52 20 00          1788  JSROP       DC.B    'JSR ',0
00001A8E= 52 54 53 00             1789  RTSOP       DC.B    'RTS',0
00001A92= 4C 45 41 00             1790  LEAOP       DC.B    'LEA',0
00001A96= 42 43 4C 52 00          1791  BCLROP      DC.B    'BCLR',0
00001A9B= 4F 52 00                1792  OROP        DC.B    'OR',0
00001A9E= 4F 52 49 00             1793  ORIOP       DC.B    'ORI',0
00001AA2= 43 4D 50 49 00          1794  CMPIOP      DC.B    'CMPI',0
00001AA7= 20 44 41 54 41 20 ...   1795  DATA        DC.B    ' DATA $',0
00001AAF= 42 43 43 00             1796  OP_BCC_MSG  DC.B    'BCC',0
00001AB3= 42 43 53 00             1797  OP_BCS_MSG  DC.B    'BCS',0
00001AB7= 42 47 45 00             1798  OP_BGE_MSG  DC.B    'BGE',0
00001ABB= 42 4C 54 00             1799  OP_BLT_MSG  DC.B    'BLT',0
00001ABF= 42 56 43 00             1800  OP_BVC_MSG  DC.B    'BVC',0
00001AC3= 42 52 41 00             1801  OP_BRA_MSG  DC.B    'BRA',0
00001AC7                          1802  * ---> HEX CHARS
00001AC7= 30 00                   1803  ASCII_0     DC.B    '0',0
00001AC9= 31 00                   1804  ASCII_1     DC.B    '1',0
00001ACB= 32 00                   1805  ASCII_2     DC.B    '2',0
00001ACD= 33 00                   1806  ASCII_3     DC.B    '3',0
00001ACF= 34 00                   1807  ASCII_4     DC.B    '4',0
00001AD1= 35 00                   1808  ASCII_5     DC.B    '5',0
00001AD3= 36 00                   1809  ASCII_6     DC.B    '6',0
00001AD5= 37 00                   1810  ASCII_7     DC.B    '7',0
00001AD7= 38 00                   1811  ASCII_8     DC.B    '8',0
00001AD9= 39 00                   1812  ASCII_9     DC.B    '9',0
00001ADB= 41 00                   1813  ASCII_A     DC.B    'A',0
00001ADD= 42 00                   1814  ASCII_B     DC.B    'B',0
00001ADF= 43 00                   1815  ASCII_C     DC.B    'C',0
00001AE1= 44 00                   1816  ASCII_D     DC.B    'D',0
00001AE3= 45 00                   1817  ASCII_E     DC.B    'E',0
00001AE5= 46 00                   1818  ASCII_F     DC.B    'F',0
00001AE7                          1819  * ---> SPECIAL CHARACTERS
00001AE7= 20 00                   1820  SPACE       DC.B    ' ',0
00001AE9= 24 00                   1821  DOLLAR      DC.B    '$',0
00001AEB= 23 00                   1822  IMD         DC.B    '#',0
00001AED= 2C 00                   1823  COMMA       DC.B    ',',0
00001AEF= 28 00                   1824  OBRACK      DC.B    '(',0
00001AF1= 29 00                   1825  CBRACK      DC.B    ')',0
00001AF3= 2B 00                   1826  PLUS        DC.B    '+',0
00001AF5= 2D 00                   1827  MINUS       DC.B    '-',0
00001AF7                          1828  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
00001AF7= 2E 42 20 00             1829  __B         DC.B    '.B ',0
00001AFB= 2E 57 20 00             1830  __W         DC.B    '.W ',0
00001AFF= 2E 4C 20 00             1831  __L         DC.B    '.L ',0
00001B03                          1832  * ---> ADDRESS REGISTERS A0-A7
00001B03= 41 30 00                1833  __A0        DC.B   'A0',0
00001B06= 41 31 00                1834  __A1        DC.B   'A1',0    
00001B09= 41 32 00                1835  __A2        DC.B   'A2',0
00001B0C= 41 33 00                1836  __A3        DC.B   'A3',0
00001B0F= 41 34 00                1837  __A4        DC.B   'A4',0
00001B12= 41 35 00                1838  __A5        DC.B   'A5',0
00001B15= 41 36 00                1839  __A6        DC.B   'A6',0
00001B18= 41 37 00                1840  __A7        DC.B   'A7',0
00001B1B                          1841  * ---> DATA REGISTERS D0-D7
00001B1B= 44 30 00                1842  __D0        DC.B   'D0',0
00001B1E= 44 31 00                1843  __D1        DC.B   'D1',0
00001B21= 44 32 00                1844  __D2        DC.B   'D2',0
00001B24= 44 33 00                1845  __D3        DC.B   'D3',0
00001B27= 44 34 00                1846  __D4        DC.B   'D4',0
00001B2A= 44 35 00                1847  __D5        DC.B   'D5',0
00001B2D= 44 36 00                1848  __D6        DC.B   'D6',0
00001B30= 44 37 00                1849  __D7        DC.B   'D7',0
00001B33                          1850  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B33                          1851  *-----------------------------------------------------------------------------
00001B33                          1852  
00001B33                          1853  
00001B33                          1854  
00001B33                          1855  *-----------------------------------------------------------------------------
00001B33                          1856  *-----------------------------------------------------------------------------
00001B33                          1857  * SECTION: Sample program to run, then attempt testing disassembly on.
00001B33                          1858  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          1859      ORG $4000
00004000                          1860  
00004000  4E71                    1861      NOP
00004002  103C 009A               1862      MOVE.B   #%10011010, D0
00004006  123C 00A9               1863      MOVE.B   #%10101001, D1
0000400A  D200                    1864      ADD.B    D0,D1
0000400C  48A7 4000               1865      MOVEM    D1,-(A7)
00004010  43F8 1A89               1866      LEA      JSROP,A1
00004014  4467                    1867      NEG.W    -(A7)
00004016  4EB9 00004020           1868      JSR      END
0000401C  81FC 0001               1869      DIVS    #1, D0
00004020                          1870  
00004020                          1871  END
00004020  4E75                    1872      RTS
00004022                          1873  RLLYEND
00004022                          1874      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASCII_0             1AC7
ASCII_1             1AC9
ASCII_2             1ACB
ASCII_3             1ACD
ASCII_4             1ACF
ASCII_5             1AD1
ASCII_6             1AD3
ASCII_7             1AD5
ASCII_8             1AD7
ASCII_9             1AD9
ASCII_A             1ADB
ASCII_B             1ADD
ASCII_C             1ADF
ASCII_D             1AE1
ASCII_E             1AE3
ASCII_F             1AE5
BCC_END             141A
BCLROP              1A96
BITMASK             1A2A
BITMASKDONE         1A3A
CBRACK              1AF1
CMPIBYTE            10F4
CMPIEA              1168
CMPILONG            1142
CMPIOP              1AA2
CMPIREG             11B4
CMPIREG000          11D8
CMPIREG001          11D8
CMPIWORD            111C
COMMA               1AED
CR                  D
DATA                1AA7
DIVSOP              1A71
DOLLAR              1AE9
DONE                1362
EAHELPER05          14AE
EAHELPER611         147A
END                 4020
END0000             11D2
END67               17EA
ENDEAHELPER05       15A6
ENDMODE_AN          1736
ENDMODE_DN          1636
ENDOP0001           1222
HEX_VALUE_MASK_LONG  F
IMD                 1AEB
INVALID_ASCII_INPUT  1A24
ISCMPI              10BA
ISORI               10BA
ITERATION           1064
JSROP               1A89
LEAOP               1A92
LF                  A
LOOP                103A
LOOPBIT             1A2E
MINUS               1AF5
MODE_AN             16AC
MODE_DN             15AC
MOVEMOP             1A83
MOVEOP              1A7E
MSGEND              1A58
MSGSTART            1A40
NEGOP               1A7A
NEWLINE             1A6E
NEXT                1060
NOOPERATION         1A76
NOT0001             1050
NOT67BYTE           17CE
NOT67WORD           17DE
NOTA0               16CE
NOTA1               16DE
NOTA2               16EE
NOTA3               16FE
NOTA4               170E
NOTA5               171E
NOTA6               172E
NOTADRDIRECT        14DE
NOTADRINDIRECT      1506
NOTADRINDIRECTPOST  153A
NOTADRINDIRECTPRE   156E
NOTBCLR             1098
NOTD0               15CE
NOTD1               15DE
NOTD2               15EE
NOTD3               15FE
NOTD4               160E
NOTD5               161E
NOTD6               162E
NOTDATAREG          14CE
NOTDIVS             1464
NOTIMMEDIATE        15A2
NOTJSR              1318
NOTMOVEM            12D6
NOTNEG              12B2
NOTNOP              125C
NOTRTS              133A
OBRACK              1AEF
OP0000              106E
OP0001              11D8
OP0010              1228
OP0011              1228
OP0100              1240
OP0101              136C
OP0110              136C
OP0111              1420
OP1000              1424
OP1000END           1474
OP1001              147A
OP1010              147A
OP1011              147A
OP1100              147A
OP1101              147A
OP1110              147A
OP1111              147A
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              13BC
OP_BCC_MSG          1AAF
OP_BCS              13C6
OP_BCS_MSG          1AB3
OP_BGE              13D0
OP_BGE_MSG          1AB7
OP_BLT              13DA
OP_BLT_MSG          1ABB
OP_BRA              13EE
OP_BRANCHES_PRINT   13F8
OP_BRA_MSG          1AC3
OP_BVC              13E4
OP_BVC_MSG          1ABF
ORIOP               1A9E
OROP                1A9B
PLUS                1AF3
PRINTA0             173C
PRINTA1             174A
PRINTA2             1758
PRINTA3             1766
PRINTA4             1774
PRINTA5             1782
PRINTA6             1790
PRINTA7             179E
PRINTBYTE           1848
PRINTD0             163C
PRINTD1             164A
PRINTD2             1658
PRINTD3             1666
PRINTD4             1674
PRINTD5             1682
PRINTD6             1690
PRINTD7             169E
PRINTLONG           1864
PRINTWORD           1856
PRINT_ASCII_0       196C
PRINT_ASCII_1       1976
PRINT_ASCII_2       1980
PRINT_ASCII_3       198A
PRINT_ASCII_4       1994
PRINT_ASCII_5       199E
PRINT_ASCII_6       19A8
PRINT_ASCII_7       19B2
PRINT_ASCII_8       19BC
PRINT_ASCII_9       19C6
PRINT_ASCII_A       19D0
PRINT_ASCII_B       19DA
PRINT_ASCII_C       19E4
PRINT_ASCII_CHAR    1A0C
PRINT_ASCII_D       19EE
PRINT_ASCII_E       19F8
PRINT_ASCII_F       1A02
PRINT_ASCII_FINISH  1A24
PRINT_ASCII_HEX_CHAR  189C
PRINT_ASCII_LOOP    18AC
RLLYEND             4022
RTSOP               1A8E
SIZE67              17AC
SIZE68              17F0
SPACE               1AE7
START               1000
UNKNOWN             135E
UNKNOWNOP           1872
UNKNOWNOP0001       121E
__A0                1B03
__A1                1B06
__A2                1B09
__A3                1B0C
__A4                1B0F
__A5                1B12
__A6                1B15
__A7                1B18
__B                 1AF7
__D0                1B1B
__D1                1B1E
__D2                1B21
__D3                1B24
__D4                1B27
__D5                1B2A
__D6                1B2D
__D7                1B30
__L                 1AFF
__W                 1AFB
