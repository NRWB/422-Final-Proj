00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 7:16:57 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00000000                            53  * BITMASK     EQU     $F000       * used to bitmask the first nibble
00000000                            54  
00001000                            55  START:  ORG    $1000            * first instruction of program
00001000                            56  
00001000                            57  * -----------------------------------
00001000                            58  * Starting and Ending Addresses
00001000                            59  * -----------------------------------
00001000                            60  *-----------------------------------------------------------------------------
00001000                            61  *-----------------------------------------------------------------------------
00001000                            62  * NAME: x
00001000                            63  * DESCRIPTION:    a
00001000                            64  * PRE-CONDITION:  b
00001000                            65  * POST-CONDITION: c
00001000                            66  * REGISTERS:      d
00001000                            67  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            68  
00001000                            69  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            70  
00001000                            71  * LOAD MSGSTART, ASK FOR INPUT
00001000  43F9 00001F9C             72          LEA     MSGSTART,A1     * Load MESSAGE START
00001006  103C 000E                 73          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      74          TRAP    #15             * Perform #14
0000100C                            75          
0000100C                            76  * GETS THE STARTING ADDRESS
0000100C  103C 0004                 77          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      78          TRAP    #15             * Perform #15
00001012                            79          
00001012                            80  * MOVE IT TO ANOTHER ADDRESS REGISTER
00001012  2441                      81          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            82  
00001014                            83  * LOAD MSGSTART, ASK FOR INPUT
00001014  43F9 00001FB4             84          LEA     MSGEND,A1       * Load MESSAGE END
0000101A  303C 000E                 85          MOVE.W  #14,D0          * Trap #14 to display message
0000101E  4E4F                      86          TRAP    #15             * Perform #14
00001020                            87          
00001020                            88  * GETS THE ENDING ADDRESS
00001020  103C 0004                 89          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      90          TRAP    #15             * Perform Trap #4
00001026  2A01                      91          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00001FCA             92          LEA     NEWLINE,A1      * Store newline variable for seper opcodes
0000102E                            93          
0000102E  3E3C 000F                 94          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 95          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 0F4E                 96          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            97          * MOVE.W  D6,D2           * move the bitmask to D2
0000103A                            98          
0000103A                            99  LOOP    
0000103A                           100  
0000103A  2C4A                     101          MOVE.L  A2,A6
0000103C  7608                     102          MOVE.L  #8,D3
0000103E  6100 0D06                103          BSR     PRINT_ASCII_HEX_CHAR
00001042                           104          
00001042                           105          *MOVE.W  A2,D1           * print what address we are processing
00001042                           106          *MOVE.B  #3,D0
00001042                           107          *TRAP    #15
00001042                           108          
00001042  43F9 0000206B            109          LEA     SPACE,A1        * print a space to seperate the address from the data
00001048  303C 000E                110          MOVE.W  #14,D0
0000104C  4E4F                     111          TRAP    #15
0000104E                           112  
0000104E  3F06                     113          MOVE    D6,-(A7)        * save the bitmask on the stack
00001050  341A                     114          MOVE.W  (A2)+,D2        * Read an operation into D2
00001052  CC42                     115          AND.W   D2,D6           * Apply this bitmask
00001054                           116          
00001054  BC7C 0000                117          CMP     #OP_0000,D6     * Does the operation start with 0000?
00001058  6600 000A                118          BNE     NOT0000         * No, check next case
0000105C  6100 0106                119          BSR     OP0000          * Branch to subroutine 0000
00001060  6000 00F6                120          BRA     ITERATION       * Move to next iteration of the loop
00001064                           121  NOT0000        
00001064  BC7C 1000                122          CMP     #OP_0001,D6     * Does the operation start with 0001?
00001068  6600 000A                123          BNE     NOT0001         * No, check next case
0000106C  6100 01EC                124          BSR     OP0001          * Branch to subroutine 0001
00001070  6000 00E6                125          BRA     ITERATION       * Move to next iteration of the loop
00001074                           126  NOT0001
00001074  BC7C 2000                127          CMP     #OP_0010,D6     * Does the operation start with 0010?
00001078  6600 000A                128          BNE     NOT0010         * No, check next case
0000107C  6100 0242                129          BSR     OP0010          * Branch to subroutine 0010
00001080  6000 00D6                130          BRA     ITERATION       * Move to next iteration of the loop
00001084                           131  NOT0010
00001084  BC7C 3000                132          CMP     #OP_0011,D6     * Does the operation start with 0011?
00001088  6600 000A                133          BNE     NOT0011         * No, check next case
0000108C  6100 0238                134          BSR     OP0011          * Branch to subroutine 0011
00001090  6000 00C6                135          BRA     ITERATION       * Move to next iteration of the loop
00001094                           136  NOT0011
00001094  BC7C 4000                137          CMP     #OP_0100,D6     * Does the operation start with 0100?
00001098  6600 000A                138          BNE     NOT0100         * No, check next case
0000109C  6100 0236                139          BSR     OP0100          * Branch to subroutine 0100
000010A0  6000 00B6                140          BRA     ITERATION       * Move to next iteration of the loop
000010A4                           141  NOT0100
000010A4  BC7C 5000                142          CMP     #OP_0101,D6     * Does the operation start with 0101?
000010A8  6600 000A                143          BNE     NOT0101         * No, check next case
000010AC  6100 041C                144          BSR     OP0101          * Branch to subroutine 0101
000010B0  6000 00A6                145          BRA     ITERATION       * Move to next iteration of the loop
000010B4                           146  NOT0101
000010B4  BC7C 6000                147          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010B8  6600 000A                148          BNE     NOT0110         * No, check next case
000010BC  6100 047A                149          BSR     OP0110          * Branch to subroutine 0110
000010C0  6000 0096                150          BRA     ITERATION       * Move to next iteration of the loop
000010C4                           151  NOT0110
000010C4  BC7C 7000                152          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010C8  6600 000A                153          BNE     NOT0111         * No, check next case
000010CC  6100 051E                154          BSR     OP0111          * Branch to subroutine 0111
000010D0  6000 0086                155          BRA     ITERATION       * Move to next iteration of the loop
000010D4                           156  NOT0111
000010D4  BC7C 8000                157          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010D8  6600 000A                158          BNE     NOT1000         * No, check next case
000010DC  6100 0514                159          BSR     OP1000          * Branch to subroutine 1000
000010E0  6000 0076                160          BRA     ITERATION       * Move to next iteration of the loop
000010E4                           161  NOT1000
000010E4  BC7C 9000                162          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010E8  6600 000A                163          BNE     NOT1001         * No, check next case
000010EC  6100 0598                164          BSR     OP1001          * Branch to subroutine 1001
000010F0  6000 0066                165          BRA     ITERATION       * Move to next iteration of the loop
000010F4                           166  NOT1001
000010F4  BC7C A000                167          CMP     #OP_1010,D6     * Does the operation start with 1010?
000010F8  6600 000A                168          BNE     NOT1010         * No, check next case
000010FC  6100 0588                169          BSR     OP1010          * Branch to subroutine 1010
00001100  6000 0056                170          BRA     ITERATION       * Move to next iteration of the loop
00001104                           171  NOT1010
00001104  BC7C B000                172          CMP     #OP_1011,D6     * Does the operation start with 1011?
00001108  6600 000A                173          BNE     NOT1011         * No, check next case
0000110C  6100 057E                174          BSR     OP1011          * Branch to subroutine 1011
00001110  6000 0046                175          BRA     ITERATION       * Move to next iteration of the loop
00001114                           176  NOT1011
00001114  BC7C C000                177          CMP     #OP_1100,D6     * Does the operation start with 1100?
00001118  6600 000A                178          BNE     NOT1100         * No, check next case
0000111C  6100 0574                179          BSR     OP1100          * Branch to subroutine 1100
00001120  6000 0036                180          BRA     ITERATION       * Move to next iteration of the loop
00001124                           181  NOT1100
00001124  BC7C D000                182          CMP     #OP_1101,D6     * Does the operation start with 1101?
00001128  6600 000A                183          BNE     NOT1101         * No, check next case
0000112C  6100 05EE                184          BSR     OP1101          * Branch to subroutine 1101
00001130  6000 0026                185          BRA     ITERATION       * Move to next iteration of the loop
00001134                           186  NOT1101
00001134  BC7C E000                187          CMP     #OP_1110,D6     * Does the operation start with 1110?
00001138  6600 000A                188          BNE     NOT1110         * No, check next case
0000113C  6100 05E4                189          BSR     OP1110          * Branch to subroutine 1110
00001140  6000 0016                190          BRA     ITERATION       * Move to next iteration of the loop
00001144                           191  NOT1110
00001144  BC7C F000                192          CMP     #OP_1111,D6     * Does the operation start with 1111?
00001148  6600 000A                193          BNE     LOOPUNKNOWNOP   * No, check next case
0000114C  6100 076A                194          BSR     OP1111          * Branch to subroutine 1111
00001150  6000 0006                195          BRA     ITERATION       * Move to next iteration of the loop
00001154                           196          
00001154                           197  LOOPUNKNOWNOP
00001154  6100 0BC6                198          BSR     UNKNOWNOP
00001158                           199          
00001158                           200  ITERATION
00001158  3C1F                     201          MOVE    (A7)+,D6        * restore the bitmask to its previous state
0000115A                           202  
0000115A                           203          *MOVE.B  #14,D0          * Print a newline
0000115A                           204          *TRAP    #15             * Perform Trap #14
0000115A                           205  
0000115A  BA4A                     206          CMP     A2,D5           * Compare the starting address to ending address
0000115C  6700 2EE8                207          BEQ     END             * If they are equal, branch 
00001160  6000 FED8                208          BRA     LOOP            * Otherwise, branch back to LOOP
00001164                           209  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001164                           210  *-----------------------------------------------------------------------------
00001164                           211  
00001164                           212  
00001164                           213  
00001164                           214  *-----------------------------------------------------------------------------
00001164                           215  *-----------------------------------------------------------------------------
00001164                           216  * NAME: OP_0000   (BCLR, ORI, CMPI)
00001164                           217  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001164                           218  * PRE-CONDITION:  xyz
00001164                           219  * POST-CONDITION: All registers return to their previous state, and the output
00001164                           220  *                 goes to the output console for reading the raw data or the
00001164                           221  *                 actual instruction.
00001164                           222  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001164                           223  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001164                           224  OP0000
00001164  48A7 FFC0                225          MOVEM   D0-D7/A0-A1,-(A7)   * Push values to the stack to save
00001168  3C3C 0006                226          MOVE.W  #6, D6              * Prep lower value for bitmask
0000116C  3E3C 0008                227          MOVE.W  #8, D7              * Prep upper value for bitmask
00001170  6100 0E14                228          BSR     BITMASK             * Finalize bitmask setup
00001174  CC42                     229          AND     D2,D6               * Apply bitmask
00001176                           230          
00001176                           231          * TODO: Consider static  AND dynamic BCLR.
00001176                           232          * Only works for Dynamic right now
00001176  0C46 0180                233          CMPI    #%0000000110000000, D6  * Are we BCLR?
0000117A  6600 0066                234          BNE     NOTBCLR                 * If not, branch to other OP0000 functions
0000117E                           235          
0000117E  3C3C 0003                236          MOVE.W  #3, D6              * Prep lower value for bitmask
00001182  3E3C 0005                237          MOVE.W  #5, D7              * Prep upper value for bitmask
00001186  6100 0DFE                238          BSR     BITMASK             * Finalize bitmask setup
0000118A  CC42                     239          AND     D2,D6               * Apply bitmask
0000118C                           240          
0000118C                           241          * Checking for unsupported mode
0000118C  0C46 0008                242          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
00001190  6700 00BE                243          BEQ     UNKNOWN0000             * If so, branch to other OP0000 functions
00001194                           244          
00001194                           245          * Confirmed BCLR at this point
00001194  43F9 00001FF6            246          LEA     BCLROP,A1           * We found BCLR
0000119A  103C 000E                247          MOVE.B  #14,D0              * Trap #14 prints out the data
0000119E  4E4F                     248          TRAP    #15                 * Perform Trap #14
000011A0                           249  
000011A0  43F9 0000206B            250          LEA     SPACE,A1            * Formatting
000011A6  103C 000E                251          MOVE.B  #14,D0              * Trap #14 prints out space
000011AA  4E4F                     252          TRAP    #15                 * Perform Trap #14
000011AC                           253          
000011AC                           254          * Set up for printing out the Register
000011AC  0882 0006                255          BCLR    #6,D2               * Clear bit 6
000011B0  0882 0007                256          BCLR    #7,D2               * Clear bit 7
000011B4  0882 0008                257          BCLR    #8,D2               * Clear bit 8
000011B8                           258          
000011B8  6100 0704                259          BSR     EAHELPER611         * Print out Register
000011BC                           260  
000011BC  43F9 00002071            261          LEA     COMMA,A1            * formatting
000011C2  103C 000E                262          MOVE.B  #14,D0              * Trap #14 prints out a comma
000011C6  4E4F                     263          TRAP    #15                 * Perform Trap #14
000011C8                           264          
000011C8  4243                     265          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
000011CA  08C3 0000                266          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
000011CE                           267      
000011CE  6100 0730                268          BSR     EAHELPER05          * Print out data.
000011D2                           269          
000011D2  43F9 00001FCA            270          LEA     NEWLINE,A1          * Formatting
000011D8  103C 000E                271          MOVE.B  #14,D0              * Trap #14 prints out the data
000011DC  4E4F                     272          TRAP    #15                 * Perform Trap #14
000011DE                           273          
000011DE  6000 0074                274          BRA     END0000             * Found the op, move to next iteration
000011E2                           275          
000011E2                           276  NOTBCLR * Possible options left are ORI or CMPI
000011E2  3C3C 0009                277          MOVE.W  #9, D6              * Prep lower value for bitmask
000011E6  3E3C 000B                278          MOVE.W  #11, D7             * Prep upper value for bitmask
000011EA  6100 0D9A                279          BSR     BITMASK             * Finalize bitmask setup
000011EE  CC42                     280          AND     D2,D6               * Apply bitmask
000011F0                           281          
000011F0  0C46 0000                282          CMPI    #%0000000000000000, D6   * Are we possibly ORI?
000011F4  6600 0052                283          BNE     NOTORI                   * If not, branch to NOTORI
000011F8                           284          
000011F8                           285          * Size check to see if unsupported ORI mode
000011F8  3C3C 0006                286          MOVE.W  #6, D6              * Prep lower value for bitmask
000011FC  3E3C 0007                287          MOVE.W  #7, D7              * Prep upper value for bitmask
00001200  6100 0D84                288          BSR     BITMASK             * Finalize bitmask setup
00001204  CC42                     289          AND     D2,D6               * Apply bitmask
00001206                           290          
00001206  0C46 00C0                291          CMPI    #%0000000011000000, D6  * Are bits 6,7 == 1,1?
0000120A  6700 0044                292          BEQ     UNKNOWN0000             * If so, unknown op. 
0000120E                           293          
0000120E                           294          * Mode check to see if unsupported ORI mode
0000120E  3C3C 0003                295          MOVE.W  #3, D6              * Prep lower value for bitmask
00001212  3E3C 0005                296          MOVE.W  #5, D7              * Prep upper value for bitmask
00001216  6100 0D6E                297          BSR     BITMASK             * Finalize bitmask setup
0000121A  CC42                     298          AND     D2,D6               * Apply bitmask
0000121C                           299          
0000121C  0C46 0008                300          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
00001220  6700 002E                301          BEQ     UNKNOWN0000             * If so, unknown op. 
00001224                           302          
00001224                           303          * Confirmed ORI at this point
00001224                           304          * TODO: Get the immediate data following the instruction and print it out
00001224  43F9 00002004            305          LEA     ORIOP, A1           * Load 'ORI' into the output window
0000122A  103C 000E                306          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
0000122E  4E4F                     307          TRAP    #15                 * Perform Trap #14
00001230                           308          
00001230  6100 0A24                309          BSR     SIZE67              * Print the size
00001234  6100 06CA                310          BSR     EAHELPER05          * Print out the EA
00001238                           311          
00001238  43F9 00001FCA            312          LEA     NEWLINE,A1          * Formatting
0000123E  103C 000E                313          MOVE.B  #14,D0              * Trap #14 prints out the data
00001242  4E4F                     314          TRAP    #15                 * Perform Trap #14
00001244                           315          
00001244  6000 000E                316          BRA     END0000             * Done with op. Move to next iteration
00001248                           317          
00001248                           318  NOTORI  * Possible option left is CMPI
00001248  0C46 0C00                319          CMPI    #%0000110000000000, D6  * Are we CMPI?
0000124C  6600 0002                320          BNE     UNKNOWN0000             * If not, unknown op
00001250                           321          
00001250                           322          * TODO: Continue checking for CMPI validity
00001250                           323          
00001250                           324  UNKNOWN0000
00001250  6100 0ACA                325          BSR     UNKNOWNOP       * Unknown op
00001254                           326          
00001254                           327  END0000          
00001254  4C9F 03FF                328         MOVEM   (A7)+,D0-D7/A0-A1   * Push values to the stack to save
00001258  4E75                     329         RTS
0000125A                           330  
0000125A                           331  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000125A                           332  *-----------------------------------------------------------------------------
0000125A                           333  
0000125A                           334  
0000125A                           335  
0000125A                           336  *-----------------------------------------------------------------------------
0000125A                           337  *-----------------------------------------------------------------------------
0000125A                           338  * NAME: OP_0001   (MOVE.B)
0000125A                           339  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000125A                           340  * PRE-CONDITION:  xyz
0000125A                           341  * POST-CONDITION: All registers return to their previous state, and the output
0000125A                           342  *                 goes to the output console for reading the raw data or the
0000125A                           343  *                 actual instruction.
0000125A                           344  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000125A                           345  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000125A                           346  OP0001  
0000125A  48A7 FFC0                347          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
0000125E  3C3C 0006                348          MOVE.W  #6, D6              * Prep lower value for bitmask
00001262  3E3C 0008                349          MOVE.W  #8, D7              * Prep upper value for bitmask
00001266  6100 0D1E                350          BSR     BITMASK             * Finalize bitmask setup
0000126A  CC42                     351          AND     D2,D6               * Apply bitmask
0000126C                           352          
0000126C                           353          * I may have fucked off this part, sorry - Caleb
0000126C                           354          * CMPI    #%0000000001000000, D6  * Is the destination mode 001?
0000126C                           355          * BNE     UNKNOWNOP0001                 * If so, it's unknown.
0000126C                           356          
0000126C  43F9 00001FDA            357          LEA     MOVEOP,A1   * Put 'MOVE' into the window
00001272  103C 000E                358          MOVE.B  #14,D0      * Trap #14 to print out
00001276  4E4F                     359          TRAP    #15         * Perform Trap #14
00001278                           360          
00001278                           361          *-----------------------------------------------------------
00001278                           362          * the following code is to move the size bits into the
00001278                           363          * 0-1 positions of D3 so that eahelper05 case use that as a "parameter"
00001278                           364          * for eahelper05
00001278                           365          
00001278  3C3C 000C                366          MOVE.W  #12, D6              * Prep lower value for bitmask
0000127C  3E3C 000D                367          MOVE.W  #13, D7              * Prep upper value for bitmask
00001280  6100 0D04                368          BSR     BITMASK             * Finalize bitmask setup
00001284                           369          
00001284  CC42                     370          AND     D2,D6
00001286                           371          
00001286  E04E                     372          LSR     #8,D6
00001288  E84E                     373          LSR     #4,D6
0000128A                           374          
0000128A  4243                     375          CLR     D3
0000128C                           376          
0000128C  1606                     377          MOVE.B  D6,D3
0000128E                           378          
0000128E                           379          *---------------------------------------------------------------
0000128E                           380          
0000128E                           381          
0000128E  6100 09C6                382          BSR     SIZE67
00001292  6100 066C                383          BSR     EAHELPER05
00001296                           384          
00001296  43F9 00002071            385          LEA     COMMA,A1
0000129C  103C 000E                386          MOVE.B  #14,D0
000012A0  4E4F                     387          TRAP    #15
000012A2                           388          
000012A2  6100 061A                389          BSR     EAHELPER611
000012A6                           390          
000012A6  43F9 00001FCA            391          LEA     NEWLINE,A1
000012AC  103C 000E                392          MOVE.B  #14,D0
000012B0  4E4F                     393          TRAP    #15
000012B2                           394          
000012B2  6000 0006                395          BRA     ENDOP0001
000012B6                           396          *LEA     __B,A1      * Put '.B' into the window
000012B6                           397          *MOVE.B  #14,D0      * Trap #14 to print out
000012B6                           398          *TRAP    #15         * Perform Trap #14
000012B6                           399          
000012B6                           400  UNKNOWNOP0001
000012B6                           401  
000012B6  6100 0A64                402          BSR     UNKNOWNOP
000012BA                           403          
000012BA                           404  ENDOP0001
000012BA                           405  
000012BA  4C9F 03FF                406          MOVEM (A7)+,D0-D7/A0-A1
000012BE  4E75                     407          RTS        
000012C0                           408          
000012C0                           409          * TODO: DETERMINE THE MODE AND REG FOR DESTINATION AND SOURCE
000012C0                           410  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012C0                           411  *-----------------------------------------------------------------------------
000012C0                           412  
000012C0                           413  
000012C0                           414  
000012C0                           415  *-----------------------------------------------------------------------------
000012C0                           416  *-----------------------------------------------------------------------------
000012C0                           417  * NAME: OP_0010   (MOVE.L, MOVEA.L)
000012C0                           418  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012C0                           419  * PRE-CONDITION:  xyz
000012C0                           420  * POST-CONDITION: All registers return to their previous state, and the output
000012C0                           421  *                 goes to the output console for reading the raw data or the
000012C0                           422  *                 actual instruction.
000012C0                           423  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012C0                           424  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012C0                           425  OP0010
000012C0                           426  
000012C0  6100 0A5A                427      BSR     UNKNOWNOP
000012C4  4E75                     428      RTS
000012C6                           429  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012C6                           430  *-----------------------------------------------------------------------------
000012C6                           431  
000012C6                           432  
000012C6                           433  
000012C6                           434  *-----------------------------------------------------------------------------
000012C6                           435  *-----------------------------------------------------------------------------
000012C6                           436  * NAME: OP_0011   (MOVE.W, MOVEA.W)
000012C6                           437  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012C6                           438  * PRE-CONDITION:  xyz
000012C6                           439  * POST-CONDITION: All registers return to their previous state, and the output
000012C6                           440  *                 goes to the output console for reading the raw data or the
000012C6                           441  *                 actual instruction.
000012C6                           442  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012C6                           443  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012C6                           444  OP0011
000012C6  48A7 FFFE                445      MOVEM   D0-D7/A0-A6, -(A7)
000012CA                           446      
000012CA                           447      *MOVE.W  #6,D6
000012CA                           448      *MOVE.W  #8,D7
000012CA                           449      
000012CA                           450      *BSR     BITMASK
000012CA                           451      
000012CA                           452      *AND.W   D2,D6
000012CA                           453      
000012CA                           454      *CMP     #%0000000001000000,D6
000012CA                           455      *BNE     NEXT15
000012CA                           456      *BSR     * for MOVEA.W
000012CA                           457      
000012CA  4C9F 7FFF                458      MOVEM   (A7)+,D0-D7/A0-A6
000012CE                           459      
000012CE  6100 0A4C                460      BSR     UNKNOWNOP
000012D2  4E75                     461      RTS
000012D4                           462  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000012D4                           463  *-----------------------------------------------------------------------------
000012D4                           464  
000012D4                           465  
000012D4                           466  
000012D4                           467  *-----------------------------------------------------------------------------
000012D4                           468  *-----------------------------------------------------------------------------
000012D4                           469  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
000012D4                           470  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000012D4                           471  * PRE-CONDITION:  xyz
000012D4                           472  * POST-CONDITION: All registers return to their previous state, and the output
000012D4                           473  *                 goes to the output console for reading the raw data or the
000012D4                           474  *                 actual instruction.
000012D4                           475  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000012D4                           476  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000012D4                           477  OP0100  
000012D4                           478          * TODO: movem
000012D4                           479  
000012D4  48A7 C0C0                480          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
000012D8                           481          
000012D8                           482          *NOP
000012D8  0C42 4E71                483          CMPI    #%0100111001110001,D2
000012DC  6600 0012                484          BNE     NOTNOP
000012E0                           485          
000012E0  43F9 00001FD2            486          LEA     NOOPERATION,A1
000012E6  103C 000D                487          MOVE.B  #13,D0          * Print a newline
000012EA  4E4F                     488          TRAP    #15
000012EC                           489          
000012EC  6000 01D2                490          BRA     DONE0100 *we found it, move on to the next iteration
000012F0                           491  NOTNOP *NEG
000012F0                           492          
000012F0                           493          * prep values for BITMASK subroutine
000012F0  7C08                     494          MOVE.L  #8,D6
000012F2  7E0B                     495          MOVE.L  #11,D7
000012F4                           496          
000012F4  6100 0C90                497          BSR     BITMASK
000012F8                           498          
000012F8  CC42                     499          AND     D2,D6                   * apply bitmask
000012FA                           500          
000012FA  0C46 0400                501          CMPI    #%0000010000000000,D6   * are we NEG?
000012FE  6600 0046                502          BNE     NOTNEG                  * not neg
00001302                           503          
00001302  7C03                     504          MOVE.L  #3,D6
00001304  7E05                     505          MOVE.L  #5,D7
00001306                           506          
00001306  6100 0C7E                507          BSR     BITMASK * generate a bitmask to be used to check mode
0000130A                           508          
0000130A  0C46 0008                509          CMPI    #%0000000000001000,D6 * check to see if it is the unsupported mode
0000130E  6700 01AC                510          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
00001312                           511          
00001312  0C46 0028                512          CMPI    #%0000000000101000,D6 * check to see if it is the unsupported mode
00001316  6700 01A4                513          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
0000131A                           514          
0000131A  0C46 0030                515          CMPI    #%0000000000110000,D6 * check to see if it is the unsupported mode
0000131E  6700 019C                516          BEQ     UNKNOWN0100 * if it is, print print out as hex indicating bad op
00001322                           517        
00001322                           518          * it is NEG, print
00001322  43F9 00001FD6            519          LEA     NEGOP,A1
00001328  103C 000E                520          MOVE.B  #14,D0
0000132C  4E4F                     521          TRAP    #15
0000132E                           522          
0000132E  6100 0926                523          BSR     SIZE67
00001332                           524          
00001332  6100 05CC                525          BSR     EAHELPER05
00001336                           526          
00001336  43F9 00001FCA            527          LEA     NEWLINE,A1
0000133C  103C 000E                528          MOVE.B  #14,D0
00001340  4E4F                     529          TRAP    #15
00001342                           530          
00001342  6000 017C                531          BRA     DONE0100 * we found the op, move to next iteration
00001346                           532          
00001346                           533  NOTNEG *MOVEM
00001346                           534  
00001346                           535          * prep values for BITMASK subroutine
00001346  7C07                     536          MOVE.L  #7,D6
00001348  7E09                     537          MOVE.L  #9,D7
0000134A                           538          
0000134A  6100 0C3A                539          BSR     BITMASK
0000134E                           540          
0000134E  CC42                     541          AND     D2,D6   * apply bitmask
00001350                           542          
00001350  0C46 0080                543          CMPI    #%0000000010000000,D6 * is it MOVEM?
00001354  6600 0014                544          BNE     NOTMOVEM          * it is not MOVEM
00001358                           545          
00001358                           546          * make sure it is a valid size and mode for MOVEM
00001358                           547          
00001358                           548          * it is MOVEM
00001358  43F9 00001FDF            549          LEA     MOVEMOP,A1
0000135E  103C 000D                550          MOVE.B  #13,D0          * Print a newline
00001362  4E4F                     551          TRAP    #15
00001364                           552          
00001364                           553          * probably needs its own special code for printing the rest due to uniqueness of movem
00001364                           554          
00001364  341A                     555          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001366                           556          
00001366  6000 0158                557          BRA     DONE0100          * we found and printed, move on to the next iteration
0000136A                           558          
0000136A                           559  NOTMOVEM *JSR
0000136A                           560          * prep values for BITMASK subroutine
0000136A  7C06                     561          MOVE.L  #6,D6
0000136C  7E08                     562          MOVE.L  #8,D7
0000136E                           563          
0000136E  6100 0C16                564          BSR     BITMASK
00001372                           565          
00001372  CC42                     566          AND     D2,D6   * apply bitmask
00001374                           567          
00001374  0C46 0080                568          CMPI    #%0000000010000000,D6
00001378  6600 003E                569          BNE     NOTJSR          * it's not JSR
0000137C                           570          
0000137C  43F9 00001FE5            571          LEA     JSROP,A1
00001382  103C 000E                572          MOVE.B  #14,D0          * Print a newline and JSR
00001386  4E4F                     573          TRAP    #15
00001388                           574          
00001388  43F9 0000206B            575          LEA     SPACE,A1
0000138E  103C 000E                576          MOVE.B  #14,D0          * Print a newline and JSR
00001392  4E4F                     577          TRAP    #15
00001394                           578          
00001394                           579          * print out where we are jumping to
00001394                           580          
00001394  341A                     581          MOVE.W  (A2)+,D2 * read in the next word of the instruction 
00001396                           582          
00001396  2202                     583          MOVE.L  D2,D1   * save the opcode to print
00001398                           584          
00001398  7410                     585          MOVE.L  #16,D2  * set the base to 16
0000139A                           586          
0000139A  700F                     587          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
0000139C  4E4F                     588          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
0000139E                           589          
0000139E  341A                     590          MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
000013A0                           591          
000013A0  2202                     592          MOVE.L  D2,D1   * save the opcode to print
000013A2                           593          
000013A2  7410                     594          MOVE.L  #16,D2  * set the base to 16
000013A4                           595          
000013A4  700F                     596          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
000013A6  4E4F                     597          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
000013A8                           598          
000013A8  43F9 00001FCA            599          LEA     NEWLINE,A1
000013AE  103C 000E                600          MOVE.B  #14,D0          * Print a newline
000013B2  4E4F                     601          TRAP    #15
000013B4                           602          
000013B4  6000 010A                603          BRA     DONE0100          * we already found instruction, next iteration
000013B8                           604  NOTJSR *RTS
000013B8                           605  
000013B8                           606          * prep values for BITMASK subroutine
000013B8  7C06                     607          MOVE.L  #6,D6
000013BA  7E08                     608          MOVE.L  #8,D7
000013BC                           609          
000013BC  6100 0BC8                610          BSR     BITMASK
000013C0                           611          
000013C0  CC42                     612          AND     D2,D6   * apply bitmask
000013C2                           613          
000013C2  0C46 0040                614          CMPI    #%0000000001000000,D6
000013C6  6600 0012                615          BNE     NOTRTS          * it's not RTS
000013CA                           616          
000013CA  43F9 00001FE9            617          LEA     RTSOP,A1
000013D0  103C 000D                618          MOVE.B  #13,D0          * Print a newline and RTS
000013D4  4E4F                     619          TRAP    #15
000013D6                           620          
000013D6  6000 00E8                621          BRA     DONE0100          * we already found instruction, next iteration
000013DA                           622  NOTRTS  *LEA
000013DA                           623         
000013DA                           624          * prep values for BITMASK subroutine
000013DA  7C06                     625          MOVE.L  #6,D6
000013DC  7E08                     626          MOVE.L  #8,D7
000013DE                           627          
000013DE  6100 0BA6                628          BSR     BITMASK
000013E2                           629          
000013E2  CC42                     630          AND     D2,D6   * apply bitmask
000013E4                           631          
000013E4  0C46 01C0                632          CMPI    #%0000000111000000,D6
000013E8  6600 00D2                633          BNE     UNKNOWN0100          * it's not LEA, we dont know what it is
000013EC                           634          
000013EC                           635          * prep values for BITMASK subroutine
000013EC  7C03                     636          MOVE.L  #3,D6
000013EE  7E05                     637          MOVE.L  #5,D7
000013F0                           638          
000013F0  6100 0B94                639          BSR     BITMASK
000013F4                           640          
000013F4  CC42                     641          AND     D2,D6   * apply bitmask
000013F6                           642          
000013F6  0C46 0008                643          CMPI    #%0000000000001000,D6
000013FA  6700 00C0                644          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000013FE                           645          
000013FE  0C46 0018                646          CMPI    #%0000000000011000,D6
00001402  6700 00B8                647          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001406                           648          
00001406  0C46 0020                649          CMPI    #%0000000000100000,D6
0000140A  6700 00B0                650          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
0000140E                           651          
0000140E  0C46 0028                652          CMPI    #%0000000000101000,D6
00001412  6700 00A8                653          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001416                           654          
00001416  0C46 0030                655          CMPI    #%0000000000110000,D6
0000141A  6700 00A0                656          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
0000141E                           657          
0000141E  0C46 0038                658          CMPI    #%0000000000111000,D6
00001422  6700 0046                659          BEQ     TWOWORDLEA          * it's not LEA, we dont know what it is
00001426                           660          
00001426                           661          * check to make sure it is a supported mode and size
00001426                           662          
00001426  43F9 00001FF2            663          LEA     LEAOP,A1
0000142C  103C 000E                664          MOVE.B  #14,D0          * Print LEA
00001430  4E4F                     665          TRAP    #15
00001432                           666          
00001432  0882 0007                667          BCLR    #7,D2
00001436  0882 0008                668          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
0000143A                           669          
0000143A  43F9 0000206B            670          LEA     SPACE,A1
00001440  103C 000E                671          MOVE.B  #14,D0          * Print SPACE
00001444  4E4F                     672          TRAP    #15
00001446                           673          
00001446  6100 04B8                674          BSR     EAHELPER05
0000144A                           675          
0000144A  43F9 00002071            676          LEA     COMMA,A1
00001450  103C 000E                677          MOVE.B  #14,D0          * Print COMMA
00001454  4E4F                     678          TRAP    #15
00001456                           679          
00001456  6100 0466                680          BSR     EAHELPER611
0000145A                           681          
0000145A  43F9 00001FCA            682          LEA     NEWLINE,A1
00001460  103C 000E                683          MOVE.B  #14,D0          * Start a new line
00001464  4E4F                     684          TRAP    #15
00001466                           685          
00001466                           686          
00001466                           687          * call EA helper
00001466                           688          * MOVE.W  (A2)+,D2        * simply used to advance the pointer, since it is a two word OP
00001466                           689                  
00001466  6000 0058                690          BRA     DONE0100          * we already found instruction, next iteration
0000146A                           691          
0000146A                           692  TWOWORDLEA
0000146A                           693  
0000146A  43F9 00001FF2            694          LEA     LEAOP,A1
00001470  103C 000E                695          MOVE.B  #14,D0   * Print LEA
00001474  4E4F                     696          TRAP    #15
00001476                           697          
00001476  43F9 0000206B            698          LEA     SPACE,A1
0000147C  103C 000E                699          MOVE.B  #14,D0   * Print SPACE
00001480  4E4F                     700          TRAP    #15
00001482                           701  
00001482  321A                     702          MOVE.W  (A2)+,D1
00001484                           703          
00001484  7C00                     704          MOVE.L  #0,D6
00001486  7E0F                     705          MOVE.L  #15,D7
00001488                           706          
00001488  6100 0AFC                707          BSR     BITMASK
0000148C                           708          
0000148C  C286                     709          AND.L   D6,D1   * shave off bad info
0000148E                           710          
0000148E  103C 0003                711          MOVE.B  #3,D0   * Print the address which was the source
00001492  4E4F                     712          TRAP    #15
00001494                           713          
00001494  43F9 00002071            714          LEA     COMMA,A1
0000149A  103C 000E                715          MOVE.B  #14,D0  * Print COMMA
0000149E  4E4F                     716          TRAP    #15
000014A0                           717          
000014A0  0882 0007                718          BCLR    #7,D2
000014A4  0882 0008                719          BCLR    #8,D2 * needed so eahelper recognizes it as the correct mode
000014A8                           720          
000014A8  6100 0414                721          BSR     EAHELPER611
000014AC                           722          
000014AC  43F9 00001FCA            723          LEA     NEWLINE,A1
000014B2  103C 000E                724          MOVE.B  #14,D0          * Start a new line
000014B6  4E4F                     725          TRAP    #15
000014B8                           726          
000014B8  6000 0006                727          BRA     DONE0100
000014BC                           728          
000014BC                           729  UNKNOWN0100 *dont know what it is
000014BC  6100 085E                730          BSR     UNKNOWNOP
000014C0                           731          
000014C0                           732  DONE0100
000014C0  4C9F 0303                733          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000014C4  4E75                     734          RTS
000014C6                           735          
000014C6  6000 FC90                736          BRA     ITERATION
000014CA                           737  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000014CA                           738  *-----------------------------------------------------------------------------        
000014CA                           739          
000014CA                           740          
000014CA                           741  
000014CA                           742  *-----------------------------------------------------------------------------
000014CA                           743  *-----------------------------------------------------------------------------
000014CA                           744  * NAME: OP_0101   (SUBQ)
000014CA                           745  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000014CA                           746  * PRE-CONDITION:  xyz
000014CA                           747  * POST-CONDITION: All registers return to their previous state, and the output
000014CA                           748  *                 goes to the output console for reading the raw data or the
000014CA                           749  *                 actual instruction.
000014CA                           750  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000014CA                           751  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000014CA                           752  OP0101
000014CA  48A7 FFC0                753          MOVEM   D0-D7/A0-A1,-(A7) * Push values to the stack to save
000014CE                           754  
000014CE  CC7C 0100                755          AND     #%0000000100000000, D6  * Baby-Bitmask for the 8th digit.
000014D2  0C46 0100                756          CMPI    #%0000000100000000, D6  * Is the 8th digit a 1?
000014D6  6700 005A                757          BEQ     UNKNOWN0101             * If so, unknown op
000014DA                           758        
000014DA  0C46 0100                759          CMPI    #%0000000100000000, D6  * Is the size 11, an unsupported value?
000014DE  6700 0052                760          BEQ     UNKNOWN0101             * If so, unknown op
000014E2                           761            
000014E2                           762          * Verified SUBQ at this point
000014E2  43F9 00001FED            763          LEA     SUBQOP,A1           * Print out SUBQ
000014E8  103C 000E                764          MOVE.B  #14,D0              * Trap #14 to print out
000014EC  4E4F                     765          TRAP    #15                 * Perform Trap #14
000014EE                           766                          
000014EE  6100 0766                767          BSR     SIZE67              * Print out size
000014F2                           768          
000014F2  43F9 0000206F            769          LEA     IMD,A1              * Formatting
000014F8  103C 000E                770          MOVE.B  #14,D0              * Trap #14 prints out space
000014FC  4E4F                     771          TRAP    #15                 * Perform Trap #14
000014FE                           772          
000014FE  3C3C 0009                773          MOVE.W  #9, D6              * Prep lower value for bitmask
00001502  3E3C 000B                774          MOVE.W  #11,D7              * Prep upper value for bitmask
00001506  6100 0A7E                775          BSR     BITMASK             * Finalize bitmask setup
0000150A  CC42                     776          AND     D2,D6               * Apply bitmask
0000150C                           777          
0000150C  6100 09C6                778          BSR     PRINTDATA911        * Special op for immediate in bits 9->11
00001510                           779            
00001510  43F9 00002071            780          LEA     COMMA,A1            * Formatting
00001516  103C 000E                781          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000151A  4E4F                     782          TRAP    #15                 * Perform Trap #14
0000151C                           783          
0000151C  6100 03E2                784          BSR     EAHELPER05          * Print out the Effective Address
00001520                           785          
00001520  43F9 00001FCA            786          LEA     NEWLINE,A1          * Formatting
00001526  103C 000E                787          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000152A  4E4F                     788          TRAP    #15                 * Perform Trap #14
0000152C                           789          
0000152C  4C9F 03FF                790          MOVEM   (A7)+,D0-D7/A0-A1   * Pop off the stack to return our registers
00001530  4E75                     791          RTS
00001532                           792      
00001532                           793  UNKNOWN0101
00001532  6100 07E8                794          BSR     UNKNOWNOP
00001536  4E75                     795          RTS
00001538                           796  
00001538                           797  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001538                           798  *-----------------------------------------------------------------------------
00001538                           799  
00001538                           800  
00001538                           801  
00001538                           802  *-----------------------------------------------------------------------------
00001538                           803  *-----------------------------------------------------------------------------
00001538                           804  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
00001538                           805  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001538                           806  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
00001538                           807  *                 in the instruction and determines what the bits match to a
00001538                           808  *                 given condition code. If the 8 bit offset is $00, or $FF,
00001538                           809  *                 this signifies a word or long offset (for $00 and $FF
00001538                           810  *                 respectively). The 8 bit offset is in 2's comp. form, and
00001538                           811  *                 should be un-done, then plus or minus to the current
00001538                           812  *                 program counter (PC) to get the actual memory label to
00001538                           813  *                 output to console. The word offset signal eats an
00001538                           814  *                 additional 16 bits and the long offset eats an additional
00001538                           815  *                 32 bits. The word/long offset are for memory alignment.
00001538                           816  * POST-CONDITION: All registers return to their previous state, and the output
00001538                           817  *                 goes to the output console for reading the raw data or the
00001538                           818  *                 actual instruction.
00001538                           819  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001538                           820  *                 A1 (output)
00001538                           821  * CONDITIONS TABLE:
00001538                           822  *                Condition Names  - Mnemonic - Condition Code
00001538                           823  *                --------------------------------------------
00001538                           824  *                True             -    T     - 0000
00001538                           825  *                False            -    F     - 0001
00001538                           826  *                Higher           -    HI    - 0010
00001538                           827  *                Lower or Same    -    LS    - 0011
00001538                           828  *                Carry Clear      -    CC    - 0100
00001538                           829  *                Carry Set        -    CS    - 0101
00001538                           830  *                Not Equal        -    NE    - 0110
00001538                           831  *                Equal            -    EQ    - 0111
00001538                           832  *                Overflow Clear   -    VC    - 1000
00001538                           833  *                Overflow Set     -    VS    - 1001
00001538                           834  *                Plus             -    PL    - 1010
00001538                           835  *                Minus            -    MI    - 1011
00001538                           836  *                Greater or Equal -    GE    - 1100
00001538                           837  *                Less Than        -    LT    - 1101
00001538                           838  *                Greater Than     -    GT    - 1110
00001538                           839  *                Less or Equal    -    LE    - 1111
00001538                           840  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001538                           841  OP0110
00001538  48A7 C0C0                842          MOVEM       D0-D1/A0-A1,-(A7) * Save main method routine vars to stack
0000153C                           843          
0000153C                           844          * Ready four bits to help distinguish op's with the 0110 prefix
0000153C  3C3C 0000                845          MOVE.W  #0,D6                 * Move in 0 to D6 (first arg for the
00001540                           846                                        * BITMASK sub-routine call)
00001540  3E3C 0007                847          MOVE.W  #7,D7                 * Move in 7 to D7 (second arg for the
00001544                           848                                        * BITMASK sub-routine call)
00001544                           849                                        
00001544                           850          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001544  6100 0A40                851          BSR     BITMASK               * Call BITMASK sub-routine
00001548                           852                                        * Returns a bitmask in D6
00001548                           853          
00001548  CC42                     854          AND     D2,D6                 * And the index op, which was pre-loaded
0000154A                           855                                        * in the main memory loop with the bitmask
0000154A                           856                                        * to use to determine what case we need.
0000154A                           857          
0000154A                           858          * Analyze the 8-bit offset in the instruction for a value of $00 or $FF.
0000154A                           859          * $00 == word offset, $FF == long offset
0000154A                           860       ***CMPI    #%0000000000000000,D6
0000154A                           861       ***BEQ     BCC_WORD_OFFSET * or maybe flag a mark to grab when printing...?
0000154A                           862       ***
0000154A                           863       ***CMPI    #%0000000011111111,D6
0000154A                           864       ***BEQ     BCC_LONG_OFFSET * or maybe flag a mark to grab when printing...?
0000154A                           865          
0000154A                           866          * IF PASSED BOTH CMPI CHECKS (ABOVE),
0000154A                           867          * THEN THERE IS A 8-BIT OFFSET (NO EXTRA GRABS FROM MEMORY)
0000154A                           868          
0000154A  3C3C 0009                869          MOVE.W  #9,D6  * Move in 9 to D6 (1st arg for the BITMASK sub-routine call)
0000154E  3E3C 000B                870          MOVE.W  #11,D7 * Move in 11 to D7 (2nd arg for the BITMASK sub-routine call)
00001552                           871                                        
00001552                           872          * The BITMASK call uses D6 as start bit, D7 as ending bit to mask
00001552  6100 0A32                873          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
00001556  CC42                     874          AND     D2,D6   * apply the BITMASK
00001558                           875          
00001558                           876          * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001558  0C46 0400                877          CMPI    #%0000010000000000,D6
0000155C  6700 002A                878          BEQ     OP_BCC
00001560                           879          
00001560                           880          * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
00001560  0C46 0500                881          CMPI    #%0000010100000000,D6
00001564  6700 002C                882          BEQ     OP_BCS
00001568                           883          
00001568                           884          * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001568  0C46 0C00                885          CMPI    #%0000110000000000,D6
0000156C  6700 002E                886          BEQ     OP_BGE
00001570                           887          
00001570                           888          * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
00001570  0C46 0D00                889          CMPI    #%0000110100000000,D6
00001574  6700 0030                890          BEQ     OP_BLT
00001578                           891          
00001578                           892          * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
00001578  0C46 0800                893          CMPI    #%0000100000000000,D6
0000157C  6700 0032                894          BEQ     OP_BVC
00001580                           895          
00001580                           896          * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
00001580                           897          * NOTE: A branch to the immediately following instruction automatically
00001580                           898          *       uses the 16-bit displacement format because the 8-bit displacement
00001580                           899          *       field contains $00 zero offset
00001580                           900          * http://68k.hax.com/BRA
00001580                           901          * NOTE2 ---> Does this mean, there should be no checks when debugging
00001580                           902          *            for word/long offsets?
00001580  0C46 0000                903          CMPI    #%0000000000000000,D6
00001584  6700 0034                904          BEQ     OP_BRA
00001588                           905          
00001588                           906          * CASE OTHER: ADDITIONAL FLAGS ALLOWED TO SIMPLY BE "RAW DATA OPS"
00001588                           907          ; call raw data print out sub routine
00001588                           908  
00001588                           909  OP_BCC
00001588  43F9 0000202D            910          LEA     OP_BCC_MSG,A1
0000158E  6000 0034                911          BRA     OP_BRANCHES_PRINT
00001592                           912  OP_BCS
00001592  43F9 00002032            913          LEA     OP_BCS_MSG,A1
00001598  6000 002A                914          BRA     OP_BRANCHES_PRINT
0000159C                           915  OP_BGE
0000159C  43F9 00002037            916          LEA     OP_BGE_MSG,A1
000015A2  6000 0020                917          BRA     OP_BRANCHES_PRINT
000015A6                           918  OP_BLT
000015A6  43F9 0000203C            919          LEA     OP_BLT_MSG,A1
000015AC  6000 0016                920          BRA     OP_BRANCHES_PRINT
000015B0                           921  OP_BVC
000015B0  43F9 00002041            922          LEA     OP_BVC_MSG,A1
000015B6  6000 000C                923          BRA     OP_BRANCHES_PRINT
000015BA                           924  OP_BRA
000015BA  43F9 00002046            925          LEA     OP_BRA_MSG,A1
000015C0  6000 0002                926          BRA     OP_BRANCHES_PRINT
000015C4                           927  
000015C4                           928  * NEED TO ADD CHECK FOR EATING ANOTHER WORD/LONG
000015C4                           929          * need to take an extra word/long offset, given $00 or $FF read from the 8-bit offset?
000015C4                           930          * assemble output to console
000015C4                           931  OP_BRANCHES_PRINT
000015C4  103C 000E                932          MOVE.B  #14,D0 * print instruction op
000015C8  4E4F                     933          TRAP    #15
000015CA                           934          
000015CA  43F9 00002025            935          LEA     DATA,A1
000015D0  103C 000E                936          MOVE.B  #14,D0 * print raw data hex of the LABEL
000015D4  4E4F                     937          TRAP    #15
000015D6                           938          
000015D6  1A1A                     939          MOVE.B  (A2)+,D5 * move 8 bit label addr into d5 and advance main memory program pointer too
000015D8  2845                     940          MOVE.L  D5,A4 * ready the 8bits into a4
000015DA  43D4                     941          LEA     (A4),A1 * ready the a4 into a1 for print
000015DC  103C 000E                942          MOVE.B  #14,D0 * print the 8bit addr
000015E0  4E4F                     943          TRAP    #15
000015E2                           944  
000015E2  6000 0002                945          BRA     BCC_END
000015E6                           946  
000015E6                           947  BCC_END * reload the memory, call RTS
000015E6  4C9F 0303                948          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000015EA  4E75                     949          RTS
000015EC                           950  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015EC                           951  *-----------------------------------------------------------------------------
000015EC                           952  
000015EC                           953  
000015EC                           954  
000015EC                           955  *-----------------------------------------------------------------------------
000015EC                           956  *-----------------------------------------------------------------------------
000015EC                           957  * NAME: OP_0111   ()
000015EC                           958  * DESCRIPTION:    OP code 0111 is not supported. 
000015EC                           959  * PRE-CONDITION:  
000015EC                           960  * POST-CONDITION: 
000015EC                           961  * REGISTERS:
000015EC                           962  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015EC                           963  OP0111
000015EC  6100 072E                964      BSR     UNKNOWNOP
000015F0  4E75                     965      RTS
000015F2                           966  
000015F2                           967  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000015F2                           968  *-----------------------------------------------------------------------------
000015F2                           969  
000015F2                           970  
000015F2                           971  
000015F2                           972  *-----------------------------------------------------------------------------
000015F2                           973  *-----------------------------------------------------------------------------
000015F2                           974  * NAME: OP_1000   (DIVS, OR)
000015F2                           975  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000015F2                           976  * PRE-CONDITION:  xyz
000015F2                           977  * POST-CONDITION: All registers return to their previous state, and the output
000015F2                           978  *                 goes to the output console for reading the raw data or the
000015F2                           979  *                 actual instruction.
000015F2                           980  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000015F2                           981  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000015F2                           982  OP1000
000015F2                           983          * Saving values to the stack
000015F2  48A7 FFC0                984          MOVEM   D0-D7/A0-A1,-(A7)
000015F6                           985  
000015F6                           986          * Check if the EA Mode is 001 since both DIVS and OR do not support it
000015F6  3C3C 0003                987          MOVE.W  #3, D6              * Prep lower value for bitmask
000015FA  3E3C 0005                988          MOVE.W  #5, D7              * Prep upper value for bitmask
000015FE  6100 0986                989          BSR     BITMASK             * Finalize bitmask setup
00001602  CC42                     990          AND     D2,D6               * Apply bitmask
00001604                           991          
00001604  0C46 0008                992          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
00001608  6700 0712                993          BEQ     UNKNOWNOP                 * If so, the op is not supported
0000160C                           994          
0000160C                           995          * Checking for DIVS
0000160C  3C3C 0006                996          MOVE.W  #6, D6              * Prep lower value for bitmask
00001610  3E3C 0008                997          MOVE.W  #8, D7              * Prep upper value for bitmask
00001614  6100 0970                998          BSR     BITMASK             * Finalize bitmask setup
00001618  CC42                     999          AND     D2,D6               * Apply bitmask
0000161A                          1000          
0000161A  0C46 01C0               1001          CMPI    #%0000000111000000, D6  * Are we DIVS?
0000161E  6600 0050               1002          BNE     NOTDIVS                 * If not, branch to see if it's OR
00001622                          1003          
00001622  43F9 00001FCD           1004          LEA     DIVSOP,A1           * We found DIVS
00001628  103C 000E               1005          MOVE.B  #14,D0              * Trap #14 prints out the data
0000162C  4E4F                    1006          TRAP    #15                 * Perform Trap #14
0000162E                          1007          
0000162E  43F9 0000206B           1008          LEA     SPACE,A1            * formatting
00001634  103C 000E               1009          MOVE.B  #14,D0              * Trap #14 prints out space
00001638  4E4F                    1010          TRAP    #15                 * Perform Trap #14
0000163A                          1011          
0000163A  4243                    1012          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
0000163C  08C3 0000               1013          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
00001640                          1014                                      * to indicate a potential immediate of size word
00001640                          1015          
00001640  6100 02BE               1016          BSR     EAHELPER05          * Print out data. TODO: DOESN'T WORK.
00001644                          1017  
00001644  43F9 00002071           1018          LEA     COMMA,A1            * formatting
0000164A  103C 000E               1019          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000164E  4E4F                    1020          TRAP    #15                 * Perform Trap #14
00001650                          1021          
00001650                          1022          * bit manipulation is needed to make the outlier DIVS work
00001650                          1023          * with the generic EAHELPER611
00001650  0882 0006               1024          BCLR    #6,D2
00001654  0882 0007               1025          BCLR    #7,D2
00001658  0882 0008               1026          BCLR    #8,D2
0000165C                          1027          
0000165C                          1028          * the above bits were cleared so that eahelper05 knows the destination
0000165C                          1029          * is a data register.
0000165C                          1030          
0000165C  6100 0260               1031          BSR     EAHELPER611 
00001660                          1032  
00001660  43F9 00001FCA           1033          LEA     NEWLINE,A1          * We found DIVS
00001666  103C 000E               1034          MOVE.B  #14,D0              * Trap #14 prints out the data
0000166A  4E4F                    1035          TRAP    #15                 * Perform Trap #14
0000166C                          1036          
0000166C  6000 0012               1037          BRA     OP1000END
00001670                          1038          
00001670                          1039  NOTDIVS * It is confirmed OR at this point
00001670  43F9 00002001           1040          LEA     OROP,A1         * We found OR
00001676  103C 000E               1041          MOVE.B  #14,D0          * Trap #14 prints out the data
0000167A  4E4F                    1042          TRAP    #15             * Perform Trap #14
0000167C                          1043          *================================================================
0000167C                          1044          * todo, move the size of the operation into the leading bits of D5
0000167C                          1045          * before subroutine call
0000167C  6100 0240               1046          BSR     EAHELPER611
00001680                          1047  
00001680                          1048  OP1000END
00001680  4C9F 03FF               1049          MOVEM   (A7)+,D0-D7/A0-A1
00001684  4E75                    1050          RTS
00001686                          1051  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001686                          1052  *-----------------------------------------------------------------------------
00001686                          1053  
00001686                          1054  
00001686                          1055  
00001686                          1056  *-----------------------------------------------------------------------------
00001686                          1057  *-----------------------------------------------------------------------------
00001686                          1058  * NAME: OP_1001   (SUB)
00001686                          1059  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001686                          1060  * PRE-CONDITION:  xyz
00001686                          1061  * POST-CONDITION: All registers return to their previous state, and the output
00001686                          1062  *                 goes to the output console for reading the raw data or the
00001686                          1063  *                 actual instruction.
00001686                          1064  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001686                          1065  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001686                          1066  OP1001
00001686                          1067  
00001686                          1068  
00001686                          1069  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001686                          1070  *-----------------------------------------------------------------------------
00001686                          1071  
00001686                          1072  
00001686                          1073  
00001686                          1074  *-----------------------------------------------------------------------------
00001686                          1075  *-----------------------------------------------------------------------------
00001686                          1076  * NAME: OP_1010   ()
00001686                          1077  * DESCRIPTION:    a
00001686                          1078  * PRE-CONDITION:  b
00001686                          1079  * POST-CONDITION: c
00001686                          1080  * REGISTERS:      d
00001686                          1081  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001686                          1082  OP1010
00001686                          1083  
00001686  6100 0694               1084      BSR     UNKNOWNOP
0000168A  4E75                    1085      RTS
0000168C                          1086  
0000168C                          1087  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000168C                          1088  *-----------------------------------------------------------------------------
0000168C                          1089  
0000168C                          1090  
0000168C                          1091  
0000168C                          1092  *-----------------------------------------------------------------------------
0000168C                          1093  *-----------------------------------------------------------------------------
0000168C                          1094  * NAME: OP_1011   (EOR, CMP)
0000168C                          1095  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000168C                          1096  * PRE-CONDITION:  xyz
0000168C                          1097  * POST-CONDITION: All registers return to their previous state, and the output
0000168C                          1098  *                 goes to the output console for reading the raw data or the
0000168C                          1099  *                 actual instruction.
0000168C                          1100  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000168C                          1101  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000168C                          1102  OP1011
0000168C                          1103  
0000168C  6100 068E               1104      BSR     UNKNOWNOP
00001690  4E75                    1105      RTS
00001692                          1106  
00001692                          1107  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001692                          1108  *-----------------------------------------------------------------------------
00001692                          1109  
00001692                          1110  
00001692                          1111  
00001692                          1112  *-----------------------------------------------------------------------------
00001692                          1113  *-----------------------------------------------------------------------------
00001692                          1114  * NAME: OP_1100   (MULS)
00001692                          1115  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001692                          1116  * PRE-CONDITION:  xyz
00001692                          1117  * POST-CONDITION: All registers return to their previous state, and the output
00001692                          1118  *                 goes to the output console for reading the raw data or the
00001692                          1119  *                 actual instruction.
00001692                          1120  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001692                          1121  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001692                          1122  OP1100
00001692  48A7 FFC0               1123          MOVEM   D0-D7/A0-A1,-(A7)   * Saving values to the stack
00001696                          1124  
00001696                          1125          * Check if the EA Mode is 001 since MULS does not support it
00001696  3C3C 0003               1126          MOVE.W  #3, D6              * Prep lower value for bitmask
0000169A  3E3C 0005               1127          MOVE.W  #5, D7              * Prep upper value for bitmask
0000169E  6100 08E6               1128          BSR     BITMASK             * Finalize bitmask setup
000016A2  CC42                    1129          AND     D2,D6               * Apply bitmask
000016A4                          1130          
000016A4  0C46 0008               1131          CMPI    #%0000000000001000, D6    * Is the mode 001, an unsupported mode?
000016A8  6700 0068               1132          BEQ     UNKNOWN1100               * If so, the op is not supported
000016AC                          1133          
000016AC  3C3C 0006               1134          MOVE.W  #6, D6              * Prep lower value for bitmask
000016B0  3E3C 0008               1135          MOVE.W  #8, D7              * Prep upper value for bitmask
000016B4  6100 08D0               1136          BSR     BITMASK             * Finalize bitmask setup
000016B8  CC42                    1137          AND     D2,D6               * Apply bitmask
000016BA                          1138          
000016BA  0C46 01C0               1139          CMPI    #%0000000111000000, D6  * Are we MULS?
000016BE  6600 0052               1140          BNE     UNKNOWN1100             * If not, it is an unknown op
000016C2                          1141          
000016C2  43F9 00001FFC           1142          LEA     MULSOP,A1           * We found MULS
000016C8  103C 000E               1143          MOVE.B  #14,D0              * Trap #14 prints out the data
000016CC  4E4F                    1144          TRAP    #15                 * Perform Trap #14
000016CE                          1145          
000016CE  43F9 0000206B           1146          LEA     SPACE,A1            * formatting
000016D4  103C 000E               1147          MOVE.B  #14,D0              * Trap #14 prints out space
000016D8  4E4F                    1148          TRAP    #15                 * Perform Trap #14
000016DA                          1149          
000016DA  4243                    1150          CLR     D3                  * clear D3, it is a parameter
000016DC  08C3 0000               1151          BSET    #0,D3               * of EAHELPER05 to indicate size
000016E0                          1152          
000016E0  6100 021E               1153          BSR     EAHELPER05          * Print out data
000016E4                          1154  
000016E4  43F9 00002071           1155          LEA     COMMA,A1            * formatting
000016EA  103C 000E               1156          MOVE.B  #14,D0              * Trap #14 prints out a comma
000016EE  4E4F                    1157          TRAP    #15                 * Perform Trap #14
000016F0                          1158          
000016F0  0882 0006               1159          BCLR    #6,D2               * Bit manipulation is 
000016F4  0882 0007               1160          BCLR    #7,D2               * necessary in order to make
000016F8  0882 0008               1161          BCLR    #8,D2               * EAHELPER611 work generically
000016FC                          1162          
000016FC  6100 01C0               1163          BSR     EAHELPER611         * Print out EA
00001700                          1164  
00001700  43F9 00001FCA           1165          LEA     NEWLINE,A1          * Formatting
00001706  103C 000E               1166          MOVE.B  #14,D0              * Trap #14 prints out the data
0000170A  4E4F                    1167          TRAP    #15                 * Perform Trap #14
0000170C                          1168          
0000170C  4C9F 03FF               1169          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
00001710  4E75                    1170          RTS                         * Return to main
00001712                          1171          
00001712                          1172  UNKNOWN1100
00001712  6100 0608               1173          BSR     UNKNOWNOP
00001716                          1174       
00001716  4C9F 03FF               1175          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
0000171A  4E75                    1176          RTS                         * Return to main
0000171C                          1177          
0000171C                          1178  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000171C                          1179  *-----------------------------------------------------------------------------
0000171C                          1180  
0000171C                          1181  
0000171C                          1182  
0000171C                          1183  *-----------------------------------------------------------------------------
0000171C                          1184  *-----------------------------------------------------------------------------
0000171C                          1185  * NAME: OP_1101   (ADD, ADDA)
0000171C                          1186  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000171C                          1187  * PRE-CONDITION:  xyz
0000171C                          1188  * POST-CONDITION: All registers return to their previous state, and the output
0000171C                          1189  *                 goes to the output console for reading the raw data or the
0000171C                          1190  *                 actual instruction.
0000171C                          1191  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000171C                          1192  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000171C                          1193  OP1101
0000171C                          1194  
0000171C  6100 05FE               1195      BSR     UNKNOWNOP
00001720  4E75                    1196      RTS
00001722                          1197  
00001722                          1198  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001722                          1199  *-----------------------------------------------------------------------------
00001722                          1200  
00001722                          1201  
00001722                          1202  
00001722                          1203  *-----------------------------------------------------------------------------
00001722                          1204  *-----------------------------------------------------------------------------
00001722                          1205  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
00001722                          1206  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001722                          1207  * PRE-CONDITION:  xyz
00001722                          1208  * POST-CONDITION: All registers return to their previous state, and the output
00001722                          1209  *                 goes to the output console for reading the raw data or the
00001722                          1210  *                 actual instruction.
00001722                          1211  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001722                          1212  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001722                          1213  OP1110
00001722                          1214  
00001722  48A7 FFC0               1215      MOVEM   D0-D7/A0-A1,-(A7)   * Caller saved
00001726                          1216  
00001726  7C03                    1217      MOVE.L  #3,D6
00001728  7E04                    1218      MOVE.L  #4,D7
0000172A                          1219      
0000172A  6100 085A               1220      BSR     BITMASK * generate a bitmask for the 3 and 4 bits
0000172E                          1221      
0000172E  CC82                    1222      AND.L   D2,D6
00001730                          1223      
00001730  0C46 0008               1224      CMPI    #%0000000000001000,D6 *is it a logical shift
00001734  6700 001A               1225      BEQ     LS
00001738                          1226      
00001738  0C46 0000               1227      CMPI    #%0000000000000000,D6 *is it an arithmatic shift
0000173C  6700 0048               1228      BEQ     AS
00001740                          1229      
00001740  0C46 0018               1230      CMPI    #%0000000000011000,D6 *is it a rorate?
00001744  6700 0076               1231      BEQ     RO
00001748                          1232  
00001748  6100 05D2               1233      BSR     UNKNOWNOP *if nothing above, we don't know what it is
0000174C  6000 0158               1234      BRA     ENDOP1110
00001750                          1235      
00001750                          1236  LS
00001750  7C08                    1237      MOVE.L  #8,D6
00001752  7E08                    1238      MOVE.L  #8,D7
00001754                          1239      
00001754  6100 0830               1240      BSR     BITMASK
00001758                          1241      
00001758  CC82                    1242      AND.L   D2,D6
0000175A                          1243      
0000175A  0C46 0000               1244      CMPI    #0,D6 * is it a left shift?
0000175E  6700 0016               1245      BEQ     LSR
00001762                          1246      
00001762  6000 0002               1247      BRA     LSL * if not a left shift, must be right
00001766                          1248  
00001766                          1249  LSL
00001766                          1250  
00001766  43F9 0000200D           1251      LEA     LSLOP,A1            * formatting
0000176C  103C 000E               1252      MOVE.B  #14,D0              * Trap #14 prints out LSL
00001770  4E4F                    1253      TRAP    #15                 * Perform Trap #14
00001772                          1254      
00001772  6000 007E               1255      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001776                          1256                                  * prints the registers and imm data
00001776                          1257  LSR
00001776                          1258  
00001776  43F9 00002011           1259      LEA     LSROP,A1            * formatting
0000177C  103C 000E               1260      MOVE.B  #14,D0              * Trap #14 prints out LSR
00001780  4E4F                    1261      TRAP    #15                 * Perform Trap #14
00001782                          1262      
00001782  6000 006E               1263      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001786                          1264                                  * prints the registers and imm data
00001786                          1265  
00001786                          1266  AS
00001786  7C08                    1267      MOVE.L  #8,D6
00001788  7E08                    1268      MOVE.L  #8,D7
0000178A                          1269      
0000178A  6100 07FA               1270      BSR     BITMASK
0000178E                          1271      
0000178E  CC82                    1272      AND.L   D2,D6
00001790                          1273      
00001790  0C46 0000               1274      CMPI    #0,D6 * is it a left shift?
00001794  6700 0016               1275      BEQ     ASR
00001798                          1276      
00001798  6000 0002               1277      BRA     ASL * if not a left shift, must be right
0000179C                          1278      
0000179C                          1279  ASL
0000179C                          1280  
0000179C  43F9 00002015           1281      LEA     ASLOP,A1            * formatting
000017A2  103C 000E               1282      MOVE.B  #14,D0              * Trap #14 prints out ASL
000017A6  4E4F                    1283      TRAP    #15                 * Perform Trap #14
000017A8                          1284      
000017A8  6000 0048               1285      BRA     OP1110GENERIC       * a generic part of OP1110 that
000017AC                          1286                                  * prints the registers and imm data
000017AC                          1287  ASR
000017AC                          1288  
000017AC  43F9 00002019           1289      LEA     ASROP,A1            * formatting
000017B2  103C 000E               1290      MOVE.B  #14,D0              * Trap #14 prints out ASR
000017B6  4E4F                    1291      TRAP    #15                 * Perform Trap #14
000017B8                          1292      
000017B8  6000 0038               1293      BRA     OP1110GENERIC       * a generic part of OP1110 that
000017BC                          1294                                  * prints the registers and imm data
000017BC                          1295  RO
000017BC  7C08                    1296      MOVE.L  #8,D6
000017BE  7E08                    1297      MOVE.L  #8,D7
000017C0                          1298      
000017C0  6100 07C4               1299      BSR     BITMASK
000017C4                          1300      
000017C4  CC82                    1301      AND.L   D2,D6
000017C6                          1302      
000017C6  0C46 0000               1303      CMPI    #0,D6 * is it a left shift?
000017CA  6700 0016               1304      BEQ     ROR
000017CE                          1305      
000017CE  6000 0002               1306      BRA     ROL * if not a left shift, must be right
000017D2                          1307  
000017D2                          1308  ROL
000017D2                          1309  
000017D2  43F9 0000201D           1310      LEA     ROLOP,A1            * formatting
000017D8  103C 000E               1311      MOVE.B  #14,D0              * Trap #14 prints out ROL
000017DC  4E4F                    1312      TRAP    #15                 * Perform Trap #14
000017DE                          1313      
000017DE  6000 0012               1314      BRA     OP1110GENERIC       * a generic part of OP1110 that
000017E2                          1315                                  * prints the registers and imm data
000017E2                          1316  ROR
000017E2                          1317  
000017E2  43F9 00002021           1318      LEA     ROROP,A1            * formatting
000017E8  103C 000E               1319      MOVE.B  #14,D0              * Trap #14 prints out ROR
000017EC  4E4F                    1320      TRAP    #15                 * Perform Trap #14
000017EE                          1321      
000017EE  6000 0002               1322      BRA     OP1110GENERIC       * a generic part of OP1110 that
000017F2                          1323                                  * prints the registers and imm data
000017F2                          1324  
000017F2                          1325  OP1110GENERIC
000017F2                          1326  
000017F2  6100 0462               1327      BSR     SIZE67
000017F6                          1328      
000017F6  7C05                    1329      MOVE.L  #5,D6
000017F8  7E05                    1330      MOVE.L  #5,D7
000017FA                          1331      
000017FA  6100 078A               1332      BSR     BITMASK
000017FE                          1333      
000017FE  CC82                    1334      AND.L   D2,D6
00001800                          1335      
00001800  0C46 0020               1336      CMPI    #%0000000000100000,D6   *is it a data reg?
00001804  6700 0074               1337      BEQ     OP1110DATAREG
00001808                          1338      
00001808  43F9 0000206F           1339      LEA     IMD,A1              * formatting
0000180E  103C 000E               1340      MOVE.B  #14,D0              * Trap #14 prints out pound #
00001812  4E4F                    1341      TRAP    #15                 * Perform Trap #14
00001814                          1342      
00001814  7C09                    1343      MOVE.L  #9,D6
00001816  7E0B                    1344      MOVE.L  #11,D7
00001818                          1345      
00001818  6100 076C               1346      BSR     BITMASK
0000181C                          1347      
0000181C  CC82                    1348      AND.L   D2,D6
0000181E                          1349      
0000181E  0C46 0000               1350      CMPI    #0,D6 * special case, if zero print #8 not #0
00001822  6700 002E               1351      BEQ     OP1110IMMEIGHT
00001826                          1352      
00001826  E08E                    1353      LSR.L   #8,D6
00001828  E28E                    1354      LSR.L   #1,D6
0000182A                          1355      
0000182A  2206                    1356      MOVE.L  D6,D1              * formatting
0000182C  103C 0003               1357      MOVE.B  #3,D0              * Trap #14 prints out the number in D1
00001830  4E4F                    1358      TRAP    #15                * Perform Trap #14
00001832                          1359      
00001832  43F9 00002071           1360      LEA     COMMA,A1            * formatting
00001838  103C 000E               1361      MOVE.B  #14,D0              * Trap #14 prints out comma
0000183C  4E4F                    1362      TRAP    #15                 * Perform Trap #1
0000183E                          1363      
0000183E                          1364      * in order to use the eahlpers, we need to do some bit manipulation
0000183E                          1365      * clearing the bits below lets our helper know that the mode is Dn
0000183E  0882 0003               1366      BCLR    #3,D2
00001842  0882 0004               1367      BCLR    #4,D2
00001846  0882 0005               1368      BCLR    #5,D2
0000184A                          1369      
0000184A  6100 00B4               1370      BSR     EAHELPER05
0000184E                          1371      
0000184E  6000 0056               1372      BRA     ENDOP1110
00001852                          1373      
00001852                          1374  OP1110IMMEIGHT
00001852                          1375  
00001852  7208                    1376      MOVE.L  #8,D1              * formatting
00001854  103C 0003               1377      MOVE.B  #3,D0              * Trap #14 prints out the number in D1
00001858  4E4F                    1378      TRAP    #15                * Perform Trap #14
0000185A                          1379      
0000185A  43F9 00002071           1380      LEA     COMMA,A1            * formatting
00001860  103C 000E               1381      MOVE.B  #14,D0              * Trap #14 prints out comma
00001864  4E4F                    1382      TRAP    #15                 * Perform Trap #1
00001866                          1383      
00001866                          1384      * in order to use the eahlpers, we need to do some bit manipulation
00001866                          1385      * clearing the bits below lets our helper know that the mode is Dn
00001866  0882 0003               1386      BCLR    #3,D2
0000186A  0882 0004               1387      BCLR    #4,D2
0000186E  0882 0005               1388      BCLR    #5,D2
00001872                          1389      
00001872  6100 008C               1390      BSR     EAHELPER05
00001876                          1391      
00001876  6000 002E               1392      BRA     ENDOP1110
0000187A                          1393  
0000187A                          1394  OP1110DATAREG
0000187A                          1395  
0000187A                          1396      * in order to use the eahlpers, we need to do some bit manipulation
0000187A                          1397      * clearing the bits below lets our helper know that the mode is Dn
0000187A  0882 0003               1398      BCLR    #3,D2
0000187E  0882 0004               1399      BCLR    #4,D2
00001882  0882 0005               1400      BCLR    #5,D2
00001886  0882 0006               1401      BCLR    #6,D2
0000188A  0882 0007               1402      BCLR    #7,D2
0000188E  0882 0008               1403      BCLR    #8,D2
00001892                          1404      
00001892  6100 002A               1405      BSR     EAHELPER611
00001896                          1406      
00001896  43F9 00002071           1407      LEA     COMMA,A1            * formatting
0000189C  103C 000E               1408      MOVE.B  #14,D0              * Trap #14 prints out comma
000018A0  4E4F                    1409      TRAP    #15                 * Perform Trap #14
000018A2                          1410      
000018A2  6100 005C               1411      BSR     EAHELPER05
000018A6                          1412  
000018A6                          1413  ENDOP1110
000018A6                          1414  
000018A6  43F9 00001FCA           1415      LEA     NEWLINE,A1          * formatting
000018AC  103C 000E               1416      MOVE.B  #14,D0              * Trap #14 prints out a new line
000018B0  4E4F                    1417      TRAP    #15                 * Perform Trap #14
000018B2                          1418      
000018B2  4C9F 03FF               1419      MOVEM   (A7)+,D0-D7/A0-A1   * Caller saved
000018B6  4E75                    1420      RTS
000018B8                          1421  
000018B8                          1422  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018B8                          1423  *-----------------------------------------------------------------------------
000018B8                          1424  
000018B8                          1425  
000018B8                          1426  
000018B8                          1427  *-----------------------------------------------------------------------------
000018B8                          1428  *-----------------------------------------------------------------------------
000018B8                          1429  * NAME: OP_1111   ()
000018B8                          1430  * DESCRIPTION:    a
000018B8                          1431  * PRE-CONDITION:  b
000018B8                          1432  * POST-CONDITION: c
000018B8                          1433  * REGISTERS:      d
000018B8                          1434  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018B8                          1435  OP1111
000018B8                          1436  
000018B8  6100 0462               1437      BSR     UNKNOWNOP
000018BC  4E75                    1438      RTS
000018BE                          1439  
000018BE                          1440  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000018BE                          1441  *-----------------------------------------------------------------------------
000018BE                          1442  
000018BE                          1443  
000018BE                          1444  
000018BE                          1445  *-----------------------------------------------------------------------------
000018BE                          1446  *-----------------------------------------------------------------------------
000018BE                          1447  * NAME:           EAHELPER611
000018BE                          1448  * DESCRIPTION:    a
000018BE                          1449  * PRE-CONDITION:  D2 contains the instruction to print modes for.
000018BE                          1450  *                 D5 contains the size of the data to be printed
000018BE                          1451  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
000018BE                          1452  *                 EAHELPER05 to print.
000018BE                          1453  * REGISTERS:      a
000018BE                          1454  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000018BE                          1455  EAHELPER611
000018BE  48A7 FFC0               1456      MOVEM  D0-D7/A0-A1,-(A7)    * Push values onto stack
000018C2                          1457      
000018C2  3C3C 0006               1458      MOVE.W  #6, D6              * Prep lower value for bitmask
000018C6  3E3C 0008               1459      MOVE.W  #8, D7              * Prep upper value for bitmask
000018CA  6100 06BA               1460      BSR     BITMASK             * Finalize bitmask setup
000018CE  CC42                    1461      AND     D2,D6               * Apply bitmask
000018D0                          1462      
000018D0                          1463      * to move the mode where EAHELPER50 can process it
000018D0  7C06                    1464      MOVE.L  #6,D6       * Prep lower value of bitmask
000018D2  7E08                    1465      MOVE.L  #8,D7       * Prep upper value of bitmask
000018D4  6100 06B0               1466      BSR     BITMASK     * Create bitmask
000018D8  CC42                    1467      AND     D2,D6       * Apply bitmask
000018DA                          1468      
000018DA  4243                    1469      CLR     D3      * prep D3 to store values
000018DC  3606                    1470      MOVE.W  D6,D3   * store bitmasked value in D3
000018DE  E64B                    1471      LSR     #3,D3   * move bits 6-8 to 3-5
000018E0                          1472      
000018E0                          1473      * to move the register where EAHELPER50 can process it
000018E0  7C09                    1474      MOVE.L  #9,D6   * Prep lower value for bitmask
000018E2  7E0B                    1475      MOVE.L  #11,D7  * Prep upper value for bitmask
000018E4  6100 06A0               1476      BSR     BITMASK * create bitmask
000018E8  CC42                    1477      AND     D2,D6   * apply bitmask
000018EA                          1478      
000018EA  4244                    1479      CLR     D4      * prep D3 to store values
000018EC  3806                    1480      MOVE.W  D6,D4   * store bitmasked value in D3
000018EE                          1481      
000018EE  E04C                    1482      LSR     #8,D4   * move bits 9-11 to 0-2
000018F0  E24C                    1483      LSR     #1,D4   * move bits 9-11 to 0-2
000018F2                          1484    
000018F2  8684                    1485      OR.L    D4,D3   * combind the register and mode
000018F4  2403                    1486      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
000018F6                          1487      
000018F6  6100 0008               1488      BSR     EAHELPER05
000018FA                          1489      
000018FA                          1490  ENDEAHELPER611
000018FA                          1491      
000018FA  4C9F 03FF               1492      MOVEM  (A7)+,D0-D7/A0-A1    * Revert back
000018FE  4E75                    1493      RTS
00001900                          1494  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001900                          1495  *-----------------------------------------------------------------------------
00001900                          1496  
00001900                          1497  
00001900                          1498  
00001900                          1499  *-----------------------------------------------------------------------------
00001900                          1500  *-----------------------------------------------------------------------------
00001900                          1501  * NAME:           EAHELPER05
00001900                          1502  * DESCRIPTION:    a
00001900                          1503  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
00001900                          1504  *                 this sub-routine helper for operations that only have one
00001900                          1505  *                 mode register.
00001900                          1506  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
00001900                          1507  * REGISTERS:      a
00001900                          1508  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001900                          1509  EAHELPER05
00001900                          1510      * todo: add code for printing immediate values
00001900                          1511      
00001900  48A7 FFC0               1512      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001904                          1513      
00001904  7C03                    1514      MOVE.L  #3,D6
00001906  7E05                    1515      MOVE.L  #5,D7
00001908                          1516      
00001908  6100 067C               1517      BSR     BITMASK * generate a bitmask to identify the mode
0000190C                          1518      
0000190C  CC42                    1519      AND     D2,D6   * mask off the parts of D2 we don't need
0000190E                          1520      
0000190E  2A06                    1521      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
00001910                          1522      
00001910  0C46 0000               1523      CMPI    #%0000000000000000,D6 * is it data register direct?
00001914  6600 000A               1524      BNE     NOTDATAREG
00001918                          1525      
00001918  6100 013C               1526      BSR     MODE_DN
0000191C                          1527       
0000191C  6000 0132               1528      BRA     ENDEAHELPER05
00001920                          1529      
00001920                          1530  NOTDATAREG * address register direct
00001920                          1531      
00001920  0C46 0008               1532      CMPI    #%0000000000001000,D6 * is it address register direct?
00001924  6600 000A               1533      BNE     NOTADRDIRECT
00001928                          1534      
00001928  6100 022C               1535      BSR     MODE_AN * simply prints out the address register
0000192C                          1536       
0000192C  6000 0122               1537      BRA     ENDEAHELPER05
00001930                          1538      
00001930                          1539  NOTADRDIRECT * address register indirect
00001930                          1540          
00001930  0C46 0010               1541      CMPI    #%0000000000010000,D6 * is it address register indirect?
00001934  6600 0022               1542      BNE     NOTADRINDIRECT
00001938                          1543      
00001938  43F9 00002073           1544      LEA     OBRACK,A1       * Load '('
0000193E  303C 000E               1545      MOVE.W  #14,D0          * Trap #14 to display message
00001942  4E4F                    1546      TRAP    #15             * Perform #14
00001944                          1547          
00001944                          1548  
00001944  6100 0210               1549      BSR     MODE_AN * print out an address register
00001948                          1550      
00001948  43F9 00002075           1551      LEA     CBRACK,A1       * Load ')'
0000194E  303C 000E               1552      MOVE.W  #14,D0          * Trap #14 to display message
00001952  4E4F                    1553      TRAP    #15             * Perform #14
00001954                          1554       
00001954  6000 00FA               1555      BRA     ENDEAHELPER05
00001958                          1556      
00001958                          1557  NOTADRINDIRECT * address register indirect, post increment
00001958                          1558      
00001958  0C46 0018               1559      CMPI    #%0000000000011000,D6 * is it address register indirect post increment?
0000195C  6600 002E               1560      BNE     NOTADRINDIRECTPOST
00001960                          1561      
00001960  43F9 00002073           1562      LEA     OBRACK,A1       * Load '('
00001966  303C 000E               1563      MOVE.W  #14,D0          * Trap #14 to display message
0000196A  4E4F                    1564      TRAP    #15             * Perform #14
0000196C                          1565          
0000196C                          1566  
0000196C  6100 01E8               1567      BSR     MODE_AN * print out an address register
00001970                          1568      
00001970  43F9 00002075           1569      LEA     CBRACK,A1       * Load ')'
00001976  303C 000E               1570      MOVE.W  #14,D0          * Trap #14 to display message
0000197A  4E4F                    1571      TRAP    #15             * Perform #14
0000197C                          1572      
0000197C  43F9 00002077           1573      LEA     PLUS,A1       * Load '+'
00001982  303C 000E               1574      MOVE.W  #14,D0          * Trap #14 to display message
00001986  4E4F                    1575      TRAP    #15             * Perform #14
00001988                          1576       
00001988  6000 00C6               1577      BRA     ENDEAHELPER05
0000198C                          1578      
0000198C                          1579  NOTADRINDIRECTPOST * address register indirect, pre decrement
0000198C                          1580      
0000198C  0C46 0020               1581      CMPI    #%0000000000100000,D6 * is it address register indirect pre decrement?
00001990  6600 002E               1582      BNE     NOTADRINDIRECTPRE
00001994                          1583      
00001994  43F9 00002079           1584      LEA     MINUS,A1       * Load '-'
0000199A  303C 000E               1585      MOVE.W  #14,D0          * Trap #14 to display message
0000199E  4E4F                    1586      TRAP    #15             * Perform #14
000019A0                          1587      
000019A0  43F9 00002073           1588      LEA     OBRACK,A1       * Load '('
000019A6  303C 000E               1589      MOVE.W  #14,D0          * Trap #14 to display message
000019AA  4E4F                    1590      TRAP    #15             * Perform #14
000019AC                          1591          
000019AC                          1592  
000019AC  6100 01A8               1593      BSR     MODE_AN * print out an address register
000019B0                          1594      
000019B0  43F9 00002075           1595      LEA     CBRACK,A1       * Load ')'
000019B6  303C 000E               1596      MOVE.W  #14,D0          * Trap #14 to display message
000019BA  4E4F                    1597      TRAP    #15             * Perform #14
000019BC                          1598       
000019BC  6000 0092               1599      BRA     ENDEAHELPER05
000019C0                          1600  
000019C0                          1601  NOTADRINDIRECTPRE * if none of the previous cases are true, it is a mode not supported by our decompiler
000019C0                          1602  
000019C0  0C46 0038               1603      CMPI    #%0000000000111000,D6 * is it immediate?
000019C4  6600 0086               1604      BNE     NOTIMMEDIATE
000019C8                          1605  
000019C8  0C43 0001               1606      CMPI    #1,D3 * is it a byte?
000019CC  6600 0028               1607      BNE     NOTIMMBYTE
000019D0                          1608      
000019D0  43F9 0000206F           1609      LEA     IMD,A1 *print out the '#' indicating an immediate value
000019D6  103C 000E               1610      MOVE.B  #14,D0
000019DA  4E4F                    1611      TRAP    #15
000019DC                          1612      
000019DC  3C3C 0000               1613      MOVE.W  #0, D6              * Prep lower value for bitmask
000019E0  3E3C 0007               1614      MOVE.W  #7, D7              * Prep upper value for bitmask
000019E4  6100 05A0               1615      BSR     BITMASK             * Finalize bitmask setup
000019E8                          1616          
000019E8  321A                    1617      MOVE.W  (A2)+,D1
000019EA                          1618      
000019EA  C286                    1619      AND.L     D6,D1
000019EC                          1620          
000019EC  103C 0003               1621      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
000019F0  4E4F                    1622      TRAP    #15      * Perform Trap #3
000019F2                          1623      
000019F2  6000 005C               1624      BRA     ENDEAHELPER05
000019F6                          1625  
000019F6                          1626  NOTIMMBYTE
000019F6                          1627      
000019F6  0C43 0002               1628      CMPI    #2,D3 * is it a word?
000019FA  6600 0028               1629      BNE     NOTIMMWORD
000019FE                          1630      
000019FE  43F9 0000206F           1631      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001A04  103C 000E               1632      MOVE.B  #14,D0
00001A08  4E4F                    1633      TRAP    #15
00001A0A                          1634      
00001A0A  3C3C 0000               1635      MOVE.W  #0, D6              * Prep lower value for bitmask
00001A0E  3E3C 000F               1636      MOVE.W  #15, D7             * Prep upper value for bitmask
00001A12  6100 0572               1637      BSR     BITMASK             * Finalize bitmask setup
00001A16                          1638          
00001A16  321A                    1639      MOVE.W  (A2)+,D1
00001A18                          1640      
00001A18  C286                    1641      AND.L     D6,D1               * Apply bitmask
00001A1A                          1642          
00001A1A  103C 0003               1643      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A1E  4E4F                    1644      TRAP    #15      * Perform Trap #3
00001A20                          1645      
00001A20  6000 002E               1646      BRA     ENDEAHELPER05
00001A24                          1647      
00001A24                          1648  NOTIMMWORD
00001A24  0C43 0003               1649      CMPI    #3,D3 * is it a long?
00001A28  6600 0022               1650      BNE     NOTIMMEDIATE
00001A2C                          1651      
00001A2C  43F9 0000206F           1652      LEA     IMD,A1 *print out the '#' indicating an immediate value
00001A32  103C 000E               1653      MOVE.B  #14,D0
00001A36  4E4F                    1654      TRAP    #15
00001A38                          1655          
00001A38  221A                    1656      MOVE.L  (A2)+,D1
00001A3A                          1657          
00001A3A  103C 0003               1658      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A3E  4E4F                    1659      TRAP    #15      * Perform Trap #3
00001A40                          1660      
00001A40  321A                    1661      MOVE.W  (A2)+,D1
00001A42                          1662          
00001A42  103C 0003               1663      MOVE.B  #3,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001A46  4E4F                    1664      TRAP    #15      * Perform Trap #3
00001A48                          1665      
00001A48  6000 0006               1666      BRA     ENDEAHELPER05
00001A4C                          1667  
00001A4C                          1668  NOTIMMEDIATE    
00001A4C                          1669  
00001A4C                          1670  
00001A4C  6100 02CE               1671      BSR     UNKNOWNOP
00001A50                          1672      
00001A50                          1673  ENDEAHELPER05
00001A50  4C9F 03FF               1674      MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001A54  4E75                    1675      RTS
00001A56                          1676  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A56                          1677  *-----------------------------------------------------------------------------
00001A56                          1678  
00001A56                          1679  
00001A56                          1680  
00001A56                          1681  *-----------------------------------------------------------------------------
00001A56                          1682  *-----------------------------------------------------------------------------
00001A56                          1683  * NAME:           MODE_DN
00001A56                          1684  * DESCRIPTION:    Generalize the EA part of the project.
00001A56                          1685  * PRE-CONDITION:  The mode must have been correctly identified. All modes
00001A56                          1686  *                 must be called by RTS.
00001A56                          1687  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
00001A56                          1688  *                 called it.
00001A56                          1689  * REGISTERS:      a
00001A56                          1690  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A56                          1691  * ---> Dn
00001A56                          1692  MODE_DN
00001A56  48A7 FFC0               1693          MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001A5A                          1694  
00001A5A  3C3C 0000               1695          MOVE.W  #0, D6              * Prep lower value for bitmask
00001A5E  3E3C 0002               1696          MOVE.W  #2, D7              * Prep upper value for bitmask
00001A62  6100 0522               1697          BSR     BITMASK             * Finalize bitmask setup
00001A66  CC42                    1698          AND     D2,D6               * Apply bitmask
00001A68                          1699          
00001A68  0C46 0000               1700          CMPI    #%000000000000000, D6   * Data Register D0?
00001A6C  6600 000A               1701          BNE     NOTD0
00001A70                          1702          
00001A70  6100 0074               1703          BSR     PRINTD0
00001A74  6000 006A               1704          BRA     ENDMODE_DN
00001A78                          1705  NOTD0      
00001A78  0C46 0001               1706          CMPI    #%000000000000001, D6   * Data Register D1?
00001A7C  6600 000A               1707          BNE     NOTD1
00001A80                          1708          
00001A80  6100 0072               1709          BSR     PRINTD1
00001A84  6000 005A               1710          BRA     ENDMODE_DN
00001A88                          1711  NOTD1
00001A88  0C46 0002               1712          CMPI    #%000000000000010, D6   * Data Register D2?
00001A8C  6600 000A               1713          BNE     NOTD2
00001A90                          1714          
00001A90  6100 0070               1715          BSR     PRINTD2
00001A94  6000 004A               1716          BRA     ENDMODE_DN
00001A98                          1717  NOTD2
00001A98  0C46 0003               1718          CMPI    #%000000000000011, D6   * Data Register D3?
00001A9C  6600 000A               1719          BNE     NOTD3
00001AA0                          1720          
00001AA0  6100 006E               1721          BSR     PRINTD3
00001AA4  6000 003A               1722          BRA     ENDMODE_DN
00001AA8                          1723  NOTD3
00001AA8  0C46 0004               1724          CMPI    #%000000000000100, D6   * Data Register D4?
00001AAC  6600 000A               1725          BNE     NOTD4
00001AB0                          1726          
00001AB0  6100 006C               1727          BSR     PRINTD4
00001AB4  6000 002A               1728          BRA     ENDMODE_DN
00001AB8                          1729  NOTD4
00001AB8  0C46 0005               1730          CMPI    #%000000000000101, D6   * Data Register D5?
00001ABC  6600 000A               1731          BNE     NOTD5
00001AC0                          1732          
00001AC0  6100 006A               1733          BSR     PRINTD5
00001AC4  6000 001A               1734          BRA     ENDMODE_DN
00001AC8                          1735  NOTD5
00001AC8  0C46 0006               1736          CMPI    #%000000000000110, D6   * Data Register D6?
00001ACC  6600 000A               1737          BNE     NOTD6
00001AD0                          1738          
00001AD0  6100 0068               1739          BSR     PRINTD6
00001AD4  6000 000A               1740          BRA     ENDMODE_DN
00001AD8                          1741  NOTD6
00001AD8  6100 006E               1742          BSR     PRINTD7
00001ADC  6000 0002               1743          BRA     ENDMODE_DN
00001AE0                          1744          
00001AE0                          1745  ENDMODE_DN
00001AE0  4C9F 03FF               1746          MOVEM   (A7)+,D0-D7/A0-A1 * restore stuff
00001AE4  4E75                    1747          RTS
00001AE6                          1748  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AE6                          1749  *-----------------------------------------------------------------------------
00001AE6                          1750  
00001AE6                          1751  
00001AE6                          1752  
00001AE6                          1753  *-----------------------------------------------------------------------------
00001AE6                          1754  *-----------------------------------------------------------------------------
00001AE6                          1755  * NAME:           PRINTD0
00001AE6                          1756  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
00001AE6                          1757  * PRE-CONDITION:  a
00001AE6                          1758  * POST-CONDITION: a
00001AE6                          1759  * REGISTERS:      a
00001AE6                          1760  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AE6                          1761  PRINTD0
00001AE6  43F9 0000209F           1762          LEA     __D0, A1        * Load 'D0'
00001AEC  103C 000E               1763          MOVE.B  #14, D0         * Load Trap #14 to print out
00001AF0  4E4F                    1764          TRAP    #15             * Perform Trap #14
00001AF2  4E75                    1765          RTS
00001AF4                          1766  PRINTD1
00001AF4  43F9 000020A2           1767          LEA     __D1, A1        * Load 'D1'
00001AFA  103C 000E               1768          MOVE.B  #14, D0         * Load Trap #14 to print out
00001AFE  4E4F                    1769          TRAP    #15             * Perform Trap #14
00001B00  4E75                    1770          RTS      
00001B02                          1771  PRINTD2
00001B02  43F9 000020A5           1772          LEA     __D2, A1        * Load 'D2'
00001B08  103C 000E               1773          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B0C  4E4F                    1774          TRAP    #15             * Perform Trap #14
00001B0E  4E75                    1775          RTS      
00001B10                          1776  PRINTD3
00001B10  43F9 000020A8           1777          LEA     __D3, A1        * Load 'D3'
00001B16  103C 000E               1778          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B1A  4E4F                    1779          TRAP    #15             * Perform Trap #14
00001B1C  4E75                    1780          RTS      
00001B1E                          1781  PRINTD4
00001B1E  43F9 000020AB           1782          LEA     __D4, A1        * Load 'D4'
00001B24  103C 000E               1783          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B28  4E4F                    1784          TRAP    #15             * Perform Trap #14
00001B2A  4E75                    1785          RTS       
00001B2C                          1786  PRINTD5
00001B2C  43F9 000020AE           1787          LEA     __D5, A1        * Load 'D5'
00001B32  103C 000E               1788          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B36  4E4F                    1789          TRAP    #15             * Perform Trap #14
00001B38  4E75                    1790          RTS      
00001B3A                          1791  PRINTD6
00001B3A  43F9 000020B1           1792          LEA     __D6, A1        * Load 'D6'
00001B40  103C 000E               1793          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B44  4E4F                    1794          TRAP    #15             * Perform Trap #14
00001B46  4E75                    1795          RTS
00001B48                          1796  PRINTD7
00001B48  43F9 000020B4           1797          LEA     __D7, A1        * Load 'D7'
00001B4E  103C 000E               1798          MOVE.B  #14, D0         * Load Trap #14 to print out
00001B52  4E4F                    1799          TRAP    #15             * Perform Trap #14
00001B54  4E75                    1800          RTS
00001B56                          1801  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B56                          1802  *-----------------------------------------------------------------------------
00001B56                          1803  
00001B56                          1804  
00001B56                          1805  
00001B56                          1806  *-----------------------------------------------------------------------------
00001B56                          1807  *-----------------------------------------------------------------------------
00001B56                          1808  * NAME:           MODE_AN
00001B56                          1809  * DESCRIPTION:    Simply chooses to print A0-A7.
00001B56                          1810  * PRE-CONDITION:  a
00001B56                          1811  * POST-CONDITION: a
00001B56                          1812  * REGISTERS:      a
00001B56                          1813  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B56                          1814  MODE_AN
00001B56  48A7 FFC0               1815          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
00001B5A                          1816  
00001B5A  3C3C 0000               1817          MOVE.W  #0, D6              * Prep lower value for bitmask
00001B5E  3E3C 0002               1818          MOVE.W  #2, D7              * Prep upper value for bitmask
00001B62  6100 0422               1819          BSR     BITMASK             * Finalize bitmask setup
00001B66  CC42                    1820          AND     D2,D6               * Apply bitmask
00001B68                          1821          
00001B68  0C46 0000               1822          CMPI    #%000000000000000, D6   * Address Register A0?
00001B6C  6600 000A               1823          BNE     NOTA0
00001B70                          1824          
00001B70  6100 0074               1825          BSR     PRINTA0
00001B74                          1826          
00001B74  6000 006A               1827          BRA     ENDMODE_AN
00001B78                          1828  NOTA0      
00001B78  0C46 0001               1829          CMPI    #%000000000000001, D6   * Address Register A1?
00001B7C  6600 000A               1830          BNE     NOTA1
00001B80                          1831          
00001B80  6100 0072               1832          BSR     PRINTA1
00001B84                          1833          
00001B84  6000 005A               1834          BRA     ENDMODE_AN
00001B88                          1835  NOTA1
00001B88  0C46 0002               1836          CMPI    #%000000000000010, D6   * Address Register A2?
00001B8C  6600 000A               1837          BNE     NOTA2
00001B90                          1838          
00001B90  6100 0070               1839          BSR     PRINTA2
00001B94                          1840          
00001B94  6000 004A               1841          BRA     ENDMODE_AN
00001B98                          1842  NOTA2
00001B98  0C46 0003               1843          CMPI    #%000000000000011, D6   * Address Register A3?
00001B9C  6600 000A               1844          BNE     NOTA3
00001BA0                          1845          
00001BA0  6100 006E               1846          BSR     PRINTA3
00001BA4                          1847          
00001BA4  6000 003A               1848          BRA     ENDMODE_AN
00001BA8                          1849  NOTA3
00001BA8  0C46 0004               1850          CMPI    #%000000000000100, D6   * Address Register A4?
00001BAC  6600 000A               1851          BNE     NOTA4
00001BB0                          1852          
00001BB0  6100 006C               1853          BSR     PRINTA4
00001BB4                          1854          
00001BB4  6000 002A               1855          BRA     ENDMODE_AN
00001BB8                          1856  NOTA4
00001BB8  0C46 0005               1857          CMPI    #%000000000000101, D6   * Address Register A5?
00001BBC  6600 000A               1858          BNE     NOTA5
00001BC0                          1859          
00001BC0  6100 006A               1860          BSR     PRINTA5
00001BC4                          1861          
00001BC4  6000 001A               1862          BRA     ENDMODE_AN
00001BC8                          1863  NOTA5
00001BC8  0C46 0006               1864          CMPI    #%000000000000110, D6   * Address Register A6?
00001BCC  6600 000A               1865          BNE     NOTA6
00001BD0                          1866          
00001BD0  6100 0068               1867          BSR     PRINTA6
00001BD4                          1868          
00001BD4  6000 000A               1869          BRA     ENDMODE_AN
00001BD8                          1870  NOTA6
00001BD8  6100 006E               1871          BSR     PRINTA7
00001BDC                          1872          
00001BDC  6000 0002               1873          BRA     ENDMODE_AN
00001BE0                          1874  ENDMODE_AN
00001BE0  4C9F 03FF               1875          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
00001BE4  4E75                    1876          RTS
00001BE6                          1877  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001BE6                          1878  *-----------------------------------------------------------------------------
00001BE6                          1879  
00001BE6                          1880  
00001BE6                          1881  
00001BE6                          1882  *-----------------------------------------------------------------------------
00001BE6                          1883  *-----------------------------------------------------------------------------
00001BE6                          1884  * NAME:           PRINTA0
00001BE6                          1885  * DESCRIPTION:    Simply print out the address register.
00001BE6                          1886  * PRE-CONDITION:  a
00001BE6                          1887  * POST-CONDITION: a
00001BE6                          1888  * REGISTERS:      a
00001BE6                          1889  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001BE6                          1890  PRINTA0
00001BE6  43F9 00002087           1891          LEA     __A0, A1        * Load 'A0'
00001BEC  103C 000E               1892          MOVE.B  #14, D0         * Load Trap #14 to print out
00001BF0  4E4F                    1893          TRAP    #15             * Perform Trap #14
00001BF2  4E75                    1894          RTS
00001BF4                          1895  
00001BF4                          1896  PRINTA1
00001BF4  43F9 0000208A           1897          LEA     __A1, A1        * Load 'A1'
00001BFA  103C 000E               1898          MOVE.B  #14, D0         * Load Trap #14 to print out
00001BFE  4E4F                    1899          TRAP    #15             * Perform Trap #14
00001C00  4E75                    1900          RTS
00001C02                          1901          
00001C02                          1902  PRINTA2
00001C02  43F9 0000208D           1903          LEA     __A2, A1        * Load 'A2'
00001C08  103C 000E               1904          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C0C  4E4F                    1905          TRAP    #15             * Perform Trap #14
00001C0E  4E75                    1906          RTS
00001C10                          1907  
00001C10                          1908  PRINTA3
00001C10  43F9 00002090           1909          LEA     __A3, A1        * Load 'A3'
00001C16  103C 000E               1910          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C1A  4E4F                    1911          TRAP    #15             * Perform Trap #14
00001C1C  4E75                    1912          RTS
00001C1E                          1913  
00001C1E                          1914  PRINTA4
00001C1E  43F9 00002093           1915          LEA     __A4, A1        * Load 'A4'
00001C24  103C 000E               1916          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C28  4E4F                    1917          TRAP    #15             * Perform Trap #14
00001C2A  4E75                    1918          RTS
00001C2C                          1919  
00001C2C                          1920  PRINTA5
00001C2C  43F9 00002096           1921          LEA     __A5, A1        * Load 'A5'
00001C32  103C 000E               1922          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C36  4E4F                    1923          TRAP    #15             * Perform Trap #14
00001C38  4E75                    1924          RTS
00001C3A                          1925  
00001C3A                          1926  PRINTA6
00001C3A  43F9 00002099           1927          LEA     __A6, A1        * Load 'A6'
00001C40  103C 000E               1928          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C44  4E4F                    1929          TRAP    #15             * Perform Trap #14
00001C46  4E75                    1930          RTS
00001C48                          1931  
00001C48                          1932  PRINTA7
00001C48  43F9 0000209C           1933          LEA     __A7, A1        * Load 'A7'
00001C4E  103C 000E               1934          MOVE.B  #14, D0         * Load Trap #14 to print out
00001C52  4E4F                    1935          TRAP    #15             * Perform Trap #14
00001C54  4E75                    1936          RTS
00001C56                          1937  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C56                          1938  *-----------------------------------------------------------------------------
00001C56                          1939  
00001C56                          1940  
00001C56                          1941  
00001C56                          1942  *-----------------------------------------------------------------------------
00001C56                          1943  *-----------------------------------------------------------------------------
00001C56                          1944  * NAME:           SIZE67
00001C56                          1945  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
00001C56                          1946  * PRE-CONDITION:  a
00001C56                          1947  * POST-CONDITION: a
00001C56                          1948  * REGISTERS:      a
00001C56                          1949  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C56                          1950  SIZE67
00001C56  48A7 FFFE               1951          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001C5A  3C3C 0006               1952          MOVE.W  #6, D6              * Prep lower value for bitmask
00001C5E  3E3C 0007               1953          MOVE.W  #7, D7              * Prep upper value for bitmask
00001C62  6100 0322               1954          BSR     BITMASK             * Finalize bitmask setup
00001C66  CC42                    1955          AND     D2,D6               * Apply bitmask     
00001C68                          1956  
00001C68  0C46 0000               1957          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001C6C  6600 000A               1958          BNE     NOT67BYTE
00001C70                          1959          
00001C70  6100 0080               1960          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001C74  6000 001E               1961          BRA     END67
00001C78                          1962  NOT67BYTE        
00001C78  0C46 0040               1963          CMPI    #%0000000001000000, D6   * is it a WORD?
00001C7C  6600 000A               1964          BNE     NOT67WORD
00001C80                          1965          
00001C80  6100 007E               1966          BSR     PRINTWORD               * Branch to handle WORD sizes
00001C84  6000 000E               1967          BRA     END67
00001C88                          1968  NOT67WORD
00001C88  0C46 0080               1969          CMPI    #%0000000010000000, D6   * is it a LONG?
00001C8C  6600 0006               1970          BNE     END67
00001C90                          1971          
00001C90  6100 007C               1972          BSR     PRINTLONG               * Branch to handle LONG sizes
00001C94                          1973  END67
00001C94  4C9F 7FFF               1974          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001C98  4E75                    1975          RTS                             * Return. Size handling is finished.
00001C9A                          1976  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C9A                          1977  *-----------------------------------------------------------------------------
00001C9A                          1978  
00001C9A                          1979  
00001C9A                          1980  
00001C9A                          1981  *-----------------------------------------------------------------------------
00001C9A                          1982  *-----------------------------------------------------------------------------
00001C9A                          1983  * NAME:           SIZE68
00001C9A                          1984  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
00001C9A                          1985  * PRE-CONDITION:  a
00001C9A                          1986  * POST-CONDITION: a
00001C9A                          1987  * REGISTERS:      a
00001C9A                          1988  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C9A                          1989  SIZE68
00001C9A                          1990          * finish later, need to follow the same format as SIZE67
00001C9A                          1991          
00001C9A                          1992          
00001C9A  48A7 FFFE               1993          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00001C9E  3C3C 0006               1994          MOVE.W  #6, D6              * Prep lower value for bitmask
00001CA2  3E3C 0008               1995          MOVE.W  #8, D7              * Prep upper value for bitmask
00001CA6  6100 02DE               1996          BSR     BITMASK             * Finalize bitmask setup
00001CAA  CC42                    1997          AND     D2,D6               * Apply bitmask          
00001CAC                          1998          
00001CAC  0C46 0000               1999          CMPI    #%0000000000000000, D6   * is it a BYTE?
00001CB0  6100 0040               2000          BSR     PRINTBYTE               * Branch to handle BYTE sizes
00001CB4  0C46 0100               2001          CMPI    #%0000000100000000, D6   * is it a BYTE?
00001CB8  6100 0038               2002          BSR     PRINTBYTE               * Branch to handle BYTE sizes 
00001CBC                          2003        
00001CBC  0C46 0040               2004          CMPI    #%0000000001000000, D6   * is it a WORD?
00001CC0  6100 003E               2005          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001CC4  0C46 0140               2006          CMPI    #%0000000101000000, D6   * is it a WORD?
00001CC8  6100 0036               2007          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001CCC  0C46 00C0               2008          CMPI    #%0000000011000000, D6   * is it a WORD (ADDA)?
00001CD0  6100 002E               2009          BSR     PRINTWORD               * Branch to handle BYTE sizes
00001CD4                          2010  
00001CD4  0C46 0080               2011          CMPI    #%0000000010000000, D6   * is it a LONG?
00001CD8  6100 0034               2012          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001CDC  0C46 0180               2013          CMPI    #%0000000110000000, D6   * is it a LONG?
00001CE0  6100 002C               2014          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001CE4  0C46 01C0               2015          CMPI    #%0000000111000000, D6   * is it a LONG (ADDA)?
00001CE8  6100 0024               2016          BSR     PRINTLONG               * Branch to handle BYTE sizes
00001CEC                          2017  
00001CEC  4C9F 7FFF               2018          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00001CF0  4E75                    2019          RTS                             * Return. Size handling is finished.
00001CF2                          2020  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001CF2                          2021  *-----------------------------------------------------------------------------
00001CF2                          2022  
00001CF2                          2023  
00001CF2                          2024  
00001CF2                          2025  *-----------------------------------------------------------------------------
00001CF2                          2026  *-----------------------------------------------------------------------------
00001CF2                          2027  * NAME:           PRINTBYTE
00001CF2                          2028  * DESCRIPTION:    a
00001CF2                          2029  * PRE-CONDITION:  a
00001CF2                          2030  * POST-CONDITION: a
00001CF2                          2031  * REGISTERS:      a
00001CF2                          2032  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001CF2                          2033  PRINTBYTE
00001CF2  43F9 0000207B           2034          LEA     __B,A1      * Load '.B ' into A1
00001CF8  103C 000E               2035          MOVE.B  #14,D0      * Trap #14 setup to print
00001CFC  4E4F                    2036          TRAP    #15         * Perform Trap #14
00001CFE  4E75                    2037          RTS                 * Return to SIZE67/SIZE68
00001D00                          2038          
00001D00                          2039  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D00                          2040  *-----------------------------------------------------------------------------
00001D00                          2041  
00001D00                          2042  
00001D00                          2043  
00001D00                          2044  *-----------------------------------------------------------------------------
00001D00                          2045  *-----------------------------------------------------------------------------
00001D00                          2046  * NAME:           PRINTWORD
00001D00                          2047  * DESCRIPTION:    a
00001D00                          2048  * PRE-CONDITION:  a
00001D00                          2049  * POST-CONDITION: a
00001D00                          2050  * REGISTERS:      a
00001D00                          2051  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D00                          2052  PRINTWORD
00001D00  43F9 0000207F           2053          LEA     __W,A1      * Load '.W ' into A1
00001D06  103C 000E               2054          MOVE.B  #14,D0      * Trap #14 setup to print
00001D0A  4E4F                    2055          TRAP    #15         * Perform Trap #14
00001D0C  4E75                    2056          RTS                 * Return to SIZE67/SIZE68
00001D0E                          2057          
00001D0E                          2058  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D0E                          2059  *-----------------------------------------------------------------------------
00001D0E                          2060  
00001D0E                          2061  
00001D0E                          2062  
00001D0E                          2063  *-----------------------------------------------------------------------------
00001D0E                          2064  *-----------------------------------------------------------------------------
00001D0E                          2065  * NAME:           PRINTLONG
00001D0E                          2066  * DESCRIPTION:    a
00001D0E                          2067  * PRE-CONDITION:  a
00001D0E                          2068  * POST-CONDITION: a
00001D0E                          2069  * REGISTERS:      a
00001D0E                          2070  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D0E                          2071  PRINTLONG
00001D0E  43F9 00002083           2072          LEA     __L,A1      * Load '.L ' into A1
00001D14  103C 000E               2073          MOVE.B  #14,D0      * Trap #14 setup to print
00001D18  4E4F                    2074          TRAP    #15         * Perform Trap #14
00001D1A  4E75                    2075          RTS                 * Return to SIZE67/SIZE68
00001D1C                          2076          
00001D1C                          2077  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D1C                          2078  *-----------------------------------------------------------------------------
00001D1C                          2079  
00001D1C                          2080  
00001D1C                          2081  
00001D1C                          2082  *-----------------------------------------------------------------------------
00001D1C                          2083  *-----------------------------------------------------------------------------
00001D1C                          2084  * NAME:           UNKNOWNOP
00001D1C                          2085  * DESCRIPTION:    a
00001D1C                          2086  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00001D1C                          2087  *                 identified as an unknown operation.
00001D1C                          2088  * POST-CONDITION: D2 is no longer the opcode.
00001D1C                          2089  * REGISTERS:      a
00001D1C                          2090  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D1C                          2091  UNKNOWNOP
00001D1C  220A                    2092          MOVE.L  A2,D1   * prep the add to print
00001D1E                          2093          
00001D1E  5581                    2094          SUB.L   #2,D1   * off by two error due to post increment correct
00001D20                          2095          
00001D20  2602                    2096          MOVE.L  D2,D3   * save the opcode to print
00001D22                          2097          
00001D22  7410                    2098          MOVE.L  #16,D2  * set the base to 16
00001D24                          2099          
00001D24  700F                    2100          MOVE.L  #15,D0  * set D0 to 15 to indicate we are converting to a different base
00001D26  4E4F                    2101          TRAP    #15     * Perform Trap #15, 15 to print out mem add in hex
00001D28                          2102          
00001D28  43F9 00002025           2103          LEA     DATA,A1 * load " DATA $" into register A1
00001D2E  700E                    2104          MOVE.L  #14,D0  * print the string stored in A1
00001D30  4E4F                    2105          TRAP    #15
00001D32                          2106          
00001D32  2203                    2107          MOVE.L  D3,D1   * move the opcode from D3 into D1 to print
00001D34                          2108          
00001D34  103C 000F               2109          MOVE.B  #15,D0   * Indicate we are using trap #15, 15 to in a certain #base
00001D38  4E4F                    2110          TRAP    #15      * Perform Trap #3
00001D3A                          2111  
00001D3A  43F9 00001FCA           2112          LEA     NEWLINE,A1 * load newline into register A1
00001D40  700E                    2113          MOVE.L  #14,D0  * print the string stored in A1
00001D42  4E4F                    2114          TRAP    #15
00001D44                          2115  
00001D44  4E75                    2116          RTS
00001D46                          2117  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D46                          2118  *-----------------------------------------------------------------------------
00001D46                          2119  
00001D46                          2120  
00001D46                          2121  
00001D46                          2122  *-----------------------------------------------------------------------------
00001D46                          2123  *-----------------------------------------------------------------------------
00001D46                          2124  * NAME: Print ASCII hex char
00001D46                          2125  * DESCRIPTION:    Prints and address register to console in hex (ASCII chars)
00001D46                          2126  * PRE-CONDITION:  A6 contains the register of memory to print.
00001D46                          2127  *                 This parameter would be pre-loaded by, for example:
00001D46                          2128  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00001D46                          2129  *                 D3 contains the loops to do (number of bytes).
00001D46                          2130  * POST-CONDITION: 
00001D46                          2131  * REGISTERS:      
00001D46                          2132  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D46                          2133  PRINT_ASCII_HEX_CHAR
00001D46  48E7 FFFC               2134      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00001D4A  4285                    2135      CLR.L       D5
00001D4C                          2136      
00001D4C                          2137      * fence post check (if-statement, check if 0 > chars)
00001D4C  0C03 0000               2138      CMPI.B      #0,D3
00001D50  6700 017C               2139      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
00001D54                          2140      
00001D54                          2141  *    MOVE.L      A6,D4
00001D54  2E0E                    2142      MOVE.L      A6,D7
00001D56                          2143  PRINT_ASCII_LOOP
00001D56                          2144  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00001D56                          2145  *    MOVE.L      D4,D7 * make a mutable copy
00001D56  E99F                    2146      ROL.L       #4,D7 * roll to next spot
00001D58  48E7 0100               2147      MOVEM.L     D7,-(A7) * save D7
00001D5C                          2148  
00001D5C  0287 0000000F           2149      ANDI.L      #HEX_VALUE_MASK_LONG,D7
00001D62                          2150      
00001D62  0C87 00000000           2151      CMPI.L      #0,D7
00001D68  6D00 0164               2152      BLT         INVALID_ASCII_INPUT
00001D6C                          2153  
00001D6C  0C87 0000000F           2154      CMPI.L      #15,D7
00001D72  6E00 015A               2155      BGT         INVALID_ASCII_INPUT
00001D76                          2156  
00001D76                          2157      * this might be faster... to do later, after entire assignment done
00001D76                          2158       * CMPI.L      #9,D7
00001D76                          2159       * BLE         PRINT_ASCII_0_TO_9
00001D76                          2160  
00001D76  0C87 00000000           2161      CMPI.L      #0,D7
00001D7C  6700 0098               2162      BEQ         PRINT_ASCII_0
00001D80  0C87 00000001           2163      CMPI.L      #1,D7
00001D86  6700 0098               2164      BEQ         PRINT_ASCII_1
00001D8A  0C87 00000002           2165      CMPI.L      #2,D7
00001D90  6700 0098               2166      BEQ         PRINT_ASCII_2
00001D94  0C87 00000003           2167      CMPI.L      #3,D7
00001D9A  6700 0098               2168      BEQ         PRINT_ASCII_3
00001D9E  0C87 00000004           2169      CMPI.L      #4,D7
00001DA4  6700 0098               2170      BEQ         PRINT_ASCII_4
00001DA8  0C87 00000005           2171      CMPI.L      #5,D7
00001DAE  6700 0098               2172      BEQ         PRINT_ASCII_5
00001DB2  0C87 00000006           2173      CMPI.L      #6,D7
00001DB8  6700 0098               2174      BEQ         PRINT_ASCII_6
00001DBC  0C87 00000007           2175      CMPI.L      #7,D7
00001DC2  6700 0098               2176      BEQ         PRINT_ASCII_7
00001DC6  0C87 00000008           2177      CMPI.L      #8,D7
00001DCC  6700 0098               2178      BEQ         PRINT_ASCII_8
00001DD0  0C87 00000009           2179      CMPI.L      #9,D7
00001DD6  6700 0098               2180      BEQ         PRINT_ASCII_9
00001DDA  0C87 0000000A           2181      CMPI.L      #10,D7
00001DE0  6700 0098               2182      BEQ         PRINT_ASCII_A
00001DE4  0C87 0000000B           2183      CMPI.L      #11,D7
00001DEA  6700 0098               2184      BEQ         PRINT_ASCII_B
00001DEE  0C87 0000000C           2185      CMPI.L      #12,D7
00001DF4  6700 0098               2186      BEQ         PRINT_ASCII_C
00001DF8  0C87 0000000D           2187      CMPI.L      #13,D7
00001DFE  6700 0098               2188      BEQ         PRINT_ASCII_D
00001E02  0C87 0000000E           2189      CMPI.L      #14,D7
00001E08  6700 0098               2190      BEQ         PRINT_ASCII_E
00001E0C  0C87 0000000F           2191      CMPI.L      #15,D7
00001E12  6700 0098               2192      BEQ         PRINT_ASCII_F
00001E16                          2193  PRINT_ASCII_0
00001E16  43F9 0000204B           2194      LEA         ASCII_0,A1
00001E1C  6000 0098               2195      BRA         PRINT_ASCII_CHAR
00001E20                          2196  PRINT_ASCII_1
00001E20  43F9 0000204D           2197      LEA         ASCII_1,A1
00001E26  6000 008E               2198      BRA         PRINT_ASCII_CHAR
00001E2A                          2199  PRINT_ASCII_2
00001E2A  43F9 0000204F           2200      LEA         ASCII_2,A1
00001E30  6000 0084               2201      BRA         PRINT_ASCII_CHAR
00001E34                          2202  PRINT_ASCII_3
00001E34  43F9 00002051           2203      LEA         ASCII_3,A1
00001E3A  6000 007A               2204      BRA         PRINT_ASCII_CHAR
00001E3E                          2205  PRINT_ASCII_4
00001E3E  43F9 00002053           2206      LEA         ASCII_4,A1
00001E44  6000 0070               2207      BRA         PRINT_ASCII_CHAR
00001E48                          2208  PRINT_ASCII_5
00001E48  43F9 00002055           2209      LEA         ASCII_5,A1
00001E4E  6000 0066               2210      BRA         PRINT_ASCII_CHAR
00001E52                          2211  PRINT_ASCII_6
00001E52  43F9 00002057           2212      LEA         ASCII_6,A1
00001E58  6000 005C               2213      BRA         PRINT_ASCII_CHAR
00001E5C                          2214  PRINT_ASCII_7
00001E5C  43F9 00002059           2215      LEA         ASCII_7,A1
00001E62  6000 0052               2216      BRA         PRINT_ASCII_CHAR
00001E66                          2217  PRINT_ASCII_8
00001E66  43F9 0000205B           2218      LEA         ASCII_8,A1
00001E6C  6000 0048               2219      BRA         PRINT_ASCII_CHAR
00001E70                          2220  PRINT_ASCII_9
00001E70  43F9 0000205D           2221      LEA         ASCII_9,A1
00001E76  6000 003E               2222      BRA         PRINT_ASCII_CHAR
00001E7A                          2223  PRINT_ASCII_A
00001E7A  43F9 0000205F           2224      LEA         ASCII_A,A1
00001E80  6000 0034               2225      BRA         PRINT_ASCII_CHAR
00001E84                          2226  PRINT_ASCII_B
00001E84  43F9 00002061           2227      LEA         ASCII_B,A1
00001E8A  6000 002A               2228      BRA         PRINT_ASCII_CHAR
00001E8E                          2229  PRINT_ASCII_C
00001E8E  43F9 00002063           2230      LEA         ASCII_C,A1
00001E94  6000 0020               2231      BRA         PRINT_ASCII_CHAR
00001E98                          2232  PRINT_ASCII_D
00001E98  43F9 00002065           2233      LEA         ASCII_D,A1
00001E9E  6000 0016               2234      BRA         PRINT_ASCII_CHAR
00001EA2                          2235  PRINT_ASCII_E
00001EA2  43F9 00002067           2236      LEA         ASCII_E,A1
00001EA8  6000 000C               2237      BRA         PRINT_ASCII_CHAR
00001EAC                          2238  PRINT_ASCII_F
00001EAC  43F9 00002069           2239      LEA         ASCII_F,A1
00001EB2  6000 0002               2240      BRA         PRINT_ASCII_CHAR
00001EB6                          2241  PRINT_ASCII_CHAR
00001EB6  103C 000E               2242      MOVE.B      #14,D0
00001EBA  4E4F                    2243      TRAP        #15
00001EBC                          2244      
00001EBC                          2245          
00001EBC  4287                    2246      CLR.L       D7
00001EBE  4CDF 0080               2247      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
00001EC2                          2248      
00001EC2  5205                    2249      ADD.B       #1,D5 * loop until counter stops
00001EC4  BA03                    2250      CMP.B       D3,D5
00001EC6  6C00 0006               2251      BGE         PRINT_ASCII_FINISH
00001ECA                          2252      
00001ECA  6000 FE8A               2253      BRA         PRINT_ASCII_LOOP
00001ECE                          2254  INVALID_ASCII_INPUT
00001ECE                          2255  PRINT_ASCII_FINISH
00001ECE  4CDF 3FFF               2256      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
00001ED2  4E75                    2257      RTS
00001ED4                          2258      
00001ED4                          2259  PRINTDATA911
00001ED4  0C46 0E00               2260      CMPI    #%0000111000000000, D6   * Print 7
00001ED8  6700 003C               2261      BEQ     PRINT7   
00001EDC  0C46 0C00               2262      CMPI    #%0000110000000000, D6   * Print 6
00001EE0  6700 0042               2263      BEQ     PRINT6
00001EE4  0C46 0A00               2264      CMPI    #%0000101000000000, D6   * Print 5
00001EE8  6700 0048               2265      BEQ     PRINT5
00001EEC  0C46 0800               2266      CMPI    #%0000100000000000, D6   * Print 4
00001EF0  6700 004E               2267      BEQ     PRINT4 
00001EF4  0C46 0600               2268      CMPI    #%0000011000000000, D6   * Print 3
00001EF8  6700 0054               2269      BEQ     PRINT3    
00001EFC  0C46 0400               2270      CMPI    #%0000010000000000, D6   * Print 2
00001F00  6700 005A               2271      BEQ     PRINT2   
00001F04  0C46 0200               2272      CMPI    #%0000001000000000, D6   * Print 1
00001F08  6700 0060               2273      BEQ     PRINT1     
00001F0C  0C46 0000               2274      CMPI    #%0000000000000000, D6   * Print 0
00001F10  6700 0066               2275      BEQ     PRINT8
00001F14                          2276      
00001F14  4E75                    2277      RTS                             * Fail case  
00001F16                          2278      
00001F16                          2279  PRINT7
00001F16  43F9 00002059           2280      LEA     ASCII_7, A1
00001F1C  103C 000E               2281      MOVE.B      #14,D0
00001F20  4E4F                    2282      TRAP        #15
00001F22  4E75                    2283      RTS
00001F24                          2284      
00001F24                          2285  PRINT6
00001F24  43F9 00002057           2286      LEA     ASCII_6, A1
00001F2A  103C 000E               2287      MOVE.B      #14,D0
00001F2E  4E4F                    2288      TRAP        #15
00001F30  4E75                    2289      RTS
00001F32                          2290      
00001F32                          2291  PRINT5
00001F32  43F9 00002055           2292      LEA     ASCII_5, A1
00001F38  103C 000E               2293      MOVE.B      #14,D0
00001F3C  4E4F                    2294      TRAP        #15
00001F3E  4E75                    2295      RTS
00001F40                          2296      
00001F40                          2297  PRINT4
00001F40  43F9 00002053           2298      LEA     ASCII_4, A1
00001F46  103C 000E               2299      MOVE.B      #14,D0
00001F4A  4E4F                    2300      TRAP        #15
00001F4C  4E75                    2301      RTS
00001F4E                          2302      
00001F4E                          2303  PRINT3
00001F4E  43F9 00002051           2304      LEA     ASCII_3, A1
00001F54  103C 000E               2305      MOVE.B      #14,D0
00001F58  4E4F                    2306      TRAP        #15
00001F5A  4E75                    2307      RTS
00001F5C                          2308      
00001F5C                          2309  PRINT2
00001F5C  43F9 0000204F           2310      LEA     ASCII_2, A1
00001F62  103C 000E               2311      MOVE.B      #14,D0
00001F66  4E4F                    2312      TRAP        #15
00001F68  4E75                    2313      RTS
00001F6A                          2314      
00001F6A                          2315  PRINT1
00001F6A  43F9 0000204D           2316      LEA     ASCII_1, A1
00001F70  103C 000E               2317      MOVE.B      #14,D0
00001F74  4E4F                    2318      TRAP        #15
00001F76  4E75                    2319      RTS
00001F78                          2320          
00001F78                          2321  PRINT8
00001F78  43F9 0000205B           2322      LEA     ASCII_8, A1
00001F7E  103C 000E               2323      MOVE.B      #14,D0
00001F82  4E4F                    2324      TRAP        #15
00001F84  4E75                    2325      RTS
00001F86                          2326  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001F86                          2327  *-----------------------------------------------------------------------------
00001F86                          2328  
00001F86                          2329  
00001F86                          2330  
00001F86                          2331  *-----------------------------------------------------------------------------
00001F86                          2332  *-----------------------------------------------------------------------------
00001F86                          2333  * NAME: Bitmask
00001F86                          2334  * DESCRIPTION:    Masks bits in a data register.
00001F86                          2335  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
00001F86                          2336  *                 the ending bit.  For example, a starting bit of decimal
00001F86                          2337  *                 value 0 and an ending bit of decimal value 3 will mask the
00001F86                          2338  *                 bits 0, 1, 2, and 3.
00001F86                          2339  * POST-CONDITION: D6 contains the bitmask, ready for use.
00001F86                          2340  * REGISTERS:      D5,D6,D7
00001F86                          2341  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001F86                          2342  BITMASK
00001F86  3F05                    2343          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
00001F88  4245                    2344          CLR     D5          * clear D5 so we can use it
00001F8A                          2345  LOOPBIT 
00001F8A  0DC5                    2346          BSET    D6,D5       * set the D6th bit in D5 to 1
00001F8C  5246                    2347          ADD     #1,D6       * increment D6
00001F8E                          2348  
00001F8E  BC47                    2349          CMP     D7,D6       * have we finished?
00001F90  6E00 0004               2350          BGT     BITMASKDONE * yes
00001F94  60F4                    2351          BRA     LOOPBIT     * no, iterate again
00001F96                          2352  
00001F96                          2353  BITMASKDONE
00001F96  2C05                    2354          MOVE.L  D5,D6
00001F98  3A1F                    2355          MOVE    (A7)+,D5    * restore D5
00001F9A  4E75                    2356          RTS
00001F9C                          2357  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001F9C                          2358  *-----------------------------------------------------------------------------
00001F9C                          2359  
00001F9C                          2360  
00001F9C                          2361  
00001F9C                          2362  *-----------------------------------------------------------------------------
00001F9C                          2363  *-----------------------------------------------------------------------------
00001F9C                          2364  * SECTION: Constants/variables used throughout the program.
00001F9C                          2365  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001F9C                          2366  * ---> GENERAL
00001F9C  =0000000D               2367  CR          EQU     $0D
00001F9C  =0000000A               2368  LF          EQU     $0A
00001F9C= 45 4E 54 45 52 20 ...   2369  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
00001FB4= 45 4E 54 45 52 20 ...   2370  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00001FCA= 0D 0A 00                2371  NEWLINE     DC.B    CR,LF,0
00001FCD                          2372  * ---> OPS
00001FCD= 44 49 56 53 00          2373  DIVSOP      DC.B    'DIVS',0
00001FD2= 4E 4F 50 00             2374  NOOPERATION DC.B    'NOP',0
00001FD6= 4E 45 47 00             2375  NEGOP       DC.B    'NEG',0
00001FDA= 4D 4F 56 45 00          2376  MOVEOP      DC.B    'MOVE',0
00001FDF= 4D 4F 56 45 4D 00       2377  MOVEMOP     DC.B    'MOVEM',0
00001FE5= 4A 53 52 00             2378  JSROP       DC.B    'JSR',0
00001FE9= 52 54 53 00             2379  RTSOP       DC.B    'RTS',0
00001FED= 53 55 42 51 00          2380  SUBQOP      DC.B    'SUBQ',0
00001FF2= 4C 45 41 00             2381  LEAOP       DC.B    'LEA',0
00001FF6= 42 43 4C 52 20 00       2382  BCLROP      DC.B    'BCLR ',0
00001FFC= 4D 55 4C 53 00          2383  MULSOP      DC.B    'MULS',0
00002001= 4F 52 00                2384  OROP        DC.B    'OR',0
00002004= 4F 52 49 00             2385  ORIOP       DC.B    'ORI',0
00002008= 43 4D 50 49 00          2386  CMPIOP      DC.B    'CMPI',0
0000200D= 4C 53 4C 00             2387  LSLOP       DC.B    'LSL',0
00002011= 4C 53 52 00             2388  LSROP       DC.B    'LSR',0
00002015= 41 53 4C 00             2389  ASLOP       DC.B    'ASL',0
00002019= 41 53 52 00             2390  ASROP       DC.B    'ASR',0
0000201D= 52 4F 4C 00             2391  ROLOP       DC.B    'ROL',0
00002021= 52 4F 52 00             2392  ROROP       DC.B    'ROR',0
00002025= 20 44 41 54 41 20 ...   2393  DATA        DC.B    ' DATA $',0
0000202D= 42 43 43 20 00          2394  OP_BCC_MSG  DC.B    'BCC ',0
00002032= 42 43 53 20 00          2395  OP_BCS_MSG  DC.B    'BCS ',0
00002037= 42 47 45 20 00          2396  OP_BGE_MSG  DC.B    'BGE ',0
0000203C= 42 4C 54 20 00          2397  OP_BLT_MSG  DC.B    'BLT ',0
00002041= 42 56 43 20 00          2398  OP_BVC_MSG  DC.B    'BVC ',0
00002046= 42 52 41 20 00          2399  OP_BRA_MSG  DC.B    'BRA ',0
0000204B                          2400  * ---> HEX CHARS
0000204B= 30 00                   2401  ASCII_0     DC.B    '0',0
0000204D= 31 00                   2402  ASCII_1     DC.B    '1',0
0000204F= 32 00                   2403  ASCII_2     DC.B    '2',0
00002051= 33 00                   2404  ASCII_3     DC.B    '3',0
00002053= 34 00                   2405  ASCII_4     DC.B    '4',0
00002055= 35 00                   2406  ASCII_5     DC.B    '5',0
00002057= 36 00                   2407  ASCII_6     DC.B    '6',0
00002059= 37 00                   2408  ASCII_7     DC.B    '7',0
0000205B= 38 00                   2409  ASCII_8     DC.B    '8',0
0000205D= 39 00                   2410  ASCII_9     DC.B    '9',0
0000205F= 41 00                   2411  ASCII_A     DC.B    'A',0
00002061= 42 00                   2412  ASCII_B     DC.B    'B',0
00002063= 43 00                   2413  ASCII_C     DC.B    'C',0
00002065= 44 00                   2414  ASCII_D     DC.B    'D',0
00002067= 45 00                   2415  ASCII_E     DC.B    'E',0
00002069= 46 00                   2416  ASCII_F     DC.B    'F',0
0000206B                          2417  * ---> SPECIAL CHARACTERS
0000206B= 20 00                   2418  SPACE       DC.B    ' ',0
0000206D= 24 00                   2419  DOLLAR      DC.B    '$',0
0000206F= 23 00                   2420  IMD         DC.B    '#',0
00002071= 2C 00                   2421  COMMA       DC.B    ',',0
00002073= 28 00                   2422  OBRACK      DC.B    '(',0
00002075= 29 00                   2423  CBRACK      DC.B    ')',0
00002077= 2B 00                   2424  PLUS        DC.B    '+',0
00002079= 2D 00                   2425  MINUS       DC.B    '-',0
0000207B                          2426  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
0000207B= 2E 42 20 00             2427  __B         DC.B    '.B ',0
0000207F= 2E 57 20 00             2428  __W         DC.B    '.W ',0
00002083= 2E 4C 20 00             2429  __L         DC.B    '.L ',0
00002087                          2430  * ---> ADDRESS REGISTERS A0-A7
00002087= 41 30 00                2431  __A0        DC.B   'A0',0
0000208A= 41 31 00                2432  __A1        DC.B   'A1',0    
0000208D= 41 32 00                2433  __A2        DC.B   'A2',0
00002090= 41 33 00                2434  __A3        DC.B   'A3',0
00002093= 41 34 00                2435  __A4        DC.B   'A4',0
00002096= 41 35 00                2436  __A5        DC.B   'A5',0
00002099= 41 36 00                2437  __A6        DC.B   'A6',0
0000209C= 41 37 00                2438  __A7        DC.B   'A7',0
0000209F                          2439  * ---> DATA REGISTERS D0-D7
0000209F= 44 30 00                2440  __D0        DC.B   'D0',0
000020A2= 44 31 00                2441  __D1        DC.B   'D1',0
000020A5= 44 32 00                2442  __D2        DC.B   'D2',0
000020A8= 44 33 00                2443  __D3        DC.B   'D3',0
000020AB= 44 34 00                2444  __D4        DC.B   'D4',0
000020AE= 44 35 00                2445  __D5        DC.B   'D5',0
000020B1= 44 36 00                2446  __D6        DC.B   'D6',0
000020B4= 44 37 00                2447  __D7        DC.B   'D7',0
000020B7                          2448  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000020B7                          2449  *-----------------------------------------------------------------------------
000020B7                          2450  
000020B7                          2451  
000020B7                          2452  
000020B7                          2453  *-----------------------------------------------------------------------------
000020B7                          2454  *-----------------------------------------------------------------------------
000020B7                          2455  * SECTION: Sample program to run, then attempt testing disassembly on.
000020B7                          2456  * STARTING: 16384
000020B7                          2457  * ENDING:   16420
000020B7                          2458  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          2459      ORG $4000
00004000                          2460      
00004000  4E71                    2461      NOP
00004002  103C 009A               2462      MOVE.B   #%10011010, D0
00004006  123C 00A9               2463      MOVE.B   #%10101001, D1
0000400A  D200                    2464      ADD.B    D0,D1
0000400C  48A7 4000               2465      MOVEM    D1,-(A7)
00004010  43F8 1FE5               2466      LEA      JSROP,A1
00004014  4467                    2467      NEG.W    -(A7)
00004016  4EB9 00004046           2468      JSR      END
0000401C  81FC 0001               2469      DIVS    #1, D0
00004020  0181                    2470      BCLR    D0, D1
00004022  CFFC 0003               2471      MULS.W  #3, D7
00004026  CFC0                    2472      MULS    D0, D7
00004028  C5D9                    2473      MULS    (A1)+, D2
0000402A  5146                    2474      SUBQ    #8, D6
0000402C  5F81                    2475      SUBQ.L  #7, D1
0000402E  0041 0004               2476      ORI     #4, D1
00004032  E389                    2477      LSL.L   #1,D1
00004034  E489                    2478      LSR.L   #2,D1
00004036  E781                    2479      ASL.L   #3,D1
00004038  E881                    2480      ASR.L   #4,D1
0000403A  EB99                    2481      ROL.L   #5,D1
0000403C  E099                    2482      ROR.L   #8,D1
0000403E  6000 0006               2483      BRA     END
00004042  6700 0002               2484      BEQ     END
00004046                          2485  
00004046                          2486  END
00004046  4E75                    2487      RTS
00004048                          2488      
00004048                          2489  RLLYEND
00004048                          2490      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AS                  1786
ASCII_0             204B
ASCII_1             204D
ASCII_2             204F
ASCII_3             2051
ASCII_4             2053
ASCII_5             2055
ASCII_6             2057
ASCII_7             2059
ASCII_8             205B
ASCII_9             205D
ASCII_A             205F
ASCII_B             2061
ASCII_C             2063
ASCII_D             2065
ASCII_E             2067
ASCII_F             2069
ASL                 179C
ASLOP               2015
ASR                 17AC
ASROP               2019
BCC_END             15E6
BCLROP              1FF6
BITMASK             1F86
BITMASKDONE         1F96
CBRACK              2075
CMPIOP              2008
COMMA               2071
CR                  D
DATA                2025
DIVSOP              1FCD
DOLLAR              206D
DONE0100            14C0
EAHELPER05          1900
EAHELPER611         18BE
END                 4046
END0000             1254
END67               1C94
ENDEAHELPER05       1A50
ENDEAHELPER611      18FA
ENDMODE_AN          1BE0
ENDMODE_DN          1AE0
ENDOP0001           12BA
ENDOP1110           18A6
HEX_VALUE_MASK_LONG  F
IMD                 206F
INVALID_ASCII_INPUT  1ECE
ITERATION           1158
JSROP               1FE5
LEAOP               1FF2
LF                  A
LOOP                103A
LOOPBIT             1F8A
LOOPUNKNOWNOP       1154
LS                  1750
LSL                 1766
LSLOP               200D
LSR                 1776
LSROP               2011
MINUS               2079
MODE_AN             1B56
MODE_DN             1A56
MOVEMOP             1FDF
MOVEOP              1FDA
MSGEND              1FB4
MSGSTART            1F9C
MULSOP              1FFC
NEGOP               1FD6
NEWLINE             1FCA
NOOPERATION         1FD2
NOT0000             1064
NOT0001             1074
NOT0010             1084
NOT0011             1094
NOT0100             10A4
NOT0101             10B4
NOT0110             10C4
NOT0111             10D4
NOT1000             10E4
NOT1001             10F4
NOT1010             1104
NOT1011             1114
NOT1100             1124
NOT1101             1134
NOT1110             1144
NOT67BYTE           1C78
NOT67WORD           1C88
NOTA0               1B78
NOTA1               1B88
NOTA2               1B98
NOTA3               1BA8
NOTA4               1BB8
NOTA5               1BC8
NOTA6               1BD8
NOTADRDIRECT        1930
NOTADRINDIRECT      1958
NOTADRINDIRECTPOST  198C
NOTADRINDIRECTPRE   19C0
NOTBCLR             11E2
NOTD0               1A78
NOTD1               1A88
NOTD2               1A98
NOTD3               1AA8
NOTD4               1AB8
NOTD5               1AC8
NOTD6               1AD8
NOTDATAREG          1920
NOTDIVS             1670
NOTIMMBYTE          19F6
NOTIMMEDIATE        1A4C
NOTIMMWORD          1A24
NOTJSR              13B8
NOTMOVEM            136A
NOTNEG              1346
NOTNOP              12F0
NOTORI              1248
NOTRTS              13DA
OBRACK              2073
OP0000              1164
OP0001              125A
OP0010              12C0
OP0011              12C6
OP0100              12D4
OP0101              14CA
OP0110              1538
OP0111              15EC
OP1000              15F2
OP1000END           1680
OP1001              1686
OP1010              1686
OP1011              168C
OP1100              1692
OP1101              171C
OP1110              1722
OP1110DATAREG       187A
OP1110GENERIC       17F2
OP1110IMMEIGHT      1852
OP1111              18B8
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_BCC              1588
OP_BCC_MSG          202D
OP_BCS              1592
OP_BCS_MSG          2032
OP_BGE              159C
OP_BGE_MSG          2037
OP_BLT              15A6
OP_BLT_MSG          203C
OP_BRA              15BA
OP_BRANCHES_PRINT   15C4
OP_BRA_MSG          2046
OP_BVC              15B0
OP_BVC_MSG          2041
ORIOP               2004
OROP                2001
PLUS                2077
PRINT1              1F6A
PRINT2              1F5C
PRINT3              1F4E
PRINT4              1F40
PRINT5              1F32
PRINT6              1F24
PRINT7              1F16
PRINT8              1F78
PRINTA0             1BE6
PRINTA1             1BF4
PRINTA2             1C02
PRINTA3             1C10
PRINTA4             1C1E
PRINTA5             1C2C
PRINTA6             1C3A
PRINTA7             1C48
PRINTBYTE           1CF2
PRINTD0             1AE6
PRINTD1             1AF4
PRINTD2             1B02
PRINTD3             1B10
PRINTD4             1B1E
PRINTD5             1B2C
PRINTD6             1B3A
PRINTD7             1B48
PRINTDATA911        1ED4
PRINTLONG           1D0E
PRINTWORD           1D00
PRINT_ASCII_0       1E16
PRINT_ASCII_1       1E20
PRINT_ASCII_2       1E2A
PRINT_ASCII_3       1E34
PRINT_ASCII_4       1E3E
PRINT_ASCII_5       1E48
PRINT_ASCII_6       1E52
PRINT_ASCII_7       1E5C
PRINT_ASCII_8       1E66
PRINT_ASCII_9       1E70
PRINT_ASCII_A       1E7A
PRINT_ASCII_B       1E84
PRINT_ASCII_C       1E8E
PRINT_ASCII_CHAR    1EB6
PRINT_ASCII_D       1E98
PRINT_ASCII_E       1EA2
PRINT_ASCII_F       1EAC
PRINT_ASCII_FINISH  1ECE
PRINT_ASCII_HEX_CHAR  1D46
PRINT_ASCII_LOOP    1D56
RLLYEND             4048
RO                  17BC
ROL                 17D2
ROLOP               201D
ROR                 17E2
ROROP               2021
RTSOP               1FE9
SIZE67              1C56
SIZE68              1C9A
SPACE               206B
START               1000
SUBQOP              1FED
TWOWORDLEA          146A
UNKNOWN0000         1250
UNKNOWN0100         14BC
UNKNOWN0101         1532
UNKNOWN1100         1712
UNKNOWNOP           1D1C
UNKNOWNOP0001       12B6
__A0                2087
__A1                208A
__A2                208D
__A3                2090
__A4                2093
__A5                2096
__A6                2099
__A7                209C
__B                 207B
__D0                209F
__D1                20A2
__D2                20A5
__D3                20A8
__D4                20AB
__D5                20AE
__D6                20B1
__D7                20B4
__L                 2083
__W                 207F
