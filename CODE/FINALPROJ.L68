00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/12/2014 2:37:47 PM

00000000                             1  *    666
00000000                             2  *   66 66
00000000                             3  *  66   66
00000000                             4  *  66   66         8888
00000000                             5  *  66   66       88   kkkk
00000000                             6  *  66  66       8   88   kk      
00000000                             7  *   66  6      8  88  kkk  kk    
00000000                             8  *    66  6    8  88     kk  k
00000000                             9  *     66 66  88 88        kk
00000000                            10  *     6 _______ 8
00000000                            11  *    6    68k    8
00000000                            12  *   6_____PRO_____8
00000000                            13  *  6               8        68k is as easy as
00000000                            14  *  6    0     0    8        6 - 8 - k !
00000000                            15  *  6   /   V   \   8 
00000000                            16  *  6   \__/ \__/   8        Welcome to our Dissasembler, Professor Nash!
00000000                            17  *    6            8         Enjoy your stay!
00000000                            18  *      6        8      
00000000                            19  *        666888
00000000                            20  *  _____                   __    ___  _    
00000000                            21  * | ____|__ _ ___ _   _   / /_  ( _ )| | __
00000000                            22  * |  _| / _` / __| | | | | '_ \ / _ \| |/ /
00000000                            23  * | |__| (_| \__ \ |_| | | (_) | (_) |   < 
00000000                            24  * |_____\__,_|___/\__, |  \___/ \___/|_|\_\
00000000                            25  *                 |___/           
00000000                            26  *-----------------------------------------------------------
00000000                            27  * Title      : 68K Decompiler
00000000                            28  * Written by : Nick Bell, Sammy Nimnuch, Caleb Larson
00000000                            29  * Date       : 11/2014 -> 12/2014
00000000                            30  * Description: This program decompiles other 68K programs
00000000                            31  *              which are loaded into the simulator simultaneously.
00000000                            32  *-----------------------------------------------------------
00000000                            33  
00000000                            34  
00000000  =00000000                 35  OP_0000     EQU     %0000000000000000
00000000  =00001000                 36  OP_0001     EQU     %0001000000000000
00000000  =00002000                 37  OP_0010     EQU     %0010000000000000
00000000  =00003000                 38  OP_0011     EQU     %0011000000000000
00000000  =00004000                 39  OP_0100     EQU     %0100000000000000
00000000  =00005000                 40  OP_0101     EQU     %0101000000000000
00000000  =00006000                 41  OP_0110     EQU     %0110000000000000
00000000  =00007000                 42  OP_0111     EQU     %0111000000000000
00000000  =00008000                 43  OP_1000     EQU     %1000000000000000
00000000  =00009000                 44  OP_1001     EQU     %1001000000000000
00000000  =0000A000                 45  OP_1010     EQU     %1010000000000000
00000000  =0000B000                 46  OP_1011     EQU     %1011000000000000
00000000  =0000C000                 47  OP_1100     EQU     %1100000000000000
00000000  =0000D000                 48  OP_1101     EQU     %1101000000000000
00000000  =0000E000                 49  OP_1110     EQU     %1110000000000000
00000000  =0000F000                 50  OP_1111     EQU     %1111000000000000
00000000  =0000000F                 51  HEX_VALUE_MASK_LONG EQU     $0000000F  * mask a hex value in 32-bits
00000000                            52  
00001000                            53  START:  ORG    $1000            * first instruction of program
00001000                            54  
00001000                            55  * -----------------------------------
00001000                            56  * Starting and Ending Addresses
00001000                            57  * -----------------------------------
00001000                            58  *-----------------------------------------------------------------------------
00001000                            59  *-----------------------------------------------------------------------------
00001000                            60  * NAME: START OF PROGRAM
00001000                            61  * DESCRIPTION:    Grab the starting and ending address for the program
00001000                            62  * PRE-CONDITION:  
00001000                            63  * POST-CONDITION: 
00001000                            64  * REGISTERS:      
00001000                            65  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001000                            66  
00001000                            67  * THINK ABOUT ASKING FOR VALID START/END NO NEGATIVE ADDR
00001000                            68  
00001000  43F9 000027D6             69          LEA     MSGSTART,A1     * Load MESSAGE START, asking for input
00001006  103C 000E                 70          MOVE.B  #14,D0          * Trap #14 to display message
0000100A  4E4F                      71          TRAP    #15             * Perform #14
0000100C                            72          
0000100C  103C 0004                 73          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001010  4E4F                      74          TRAP    #15             * Perform Trap #15
00001012  2441                      75          MOVEA.L D1,A2           * Move the user input into A2. This is the starting address.
00001014                            76  
00001014  43F9 000027EE             77          LEA     MSGEND,A1       * Load MESSAGE END, asking for input
0000101A  303C 000E                 78          MOVE.W  #14,D0          * Trap #14 to display MESGEND
0000101E  4E4F                      79          TRAP    #15             * Perform #14
00001020                            80          
00001020  103C 0004                 81          MOVE.B  #4,D0           * Trap #4 gets an input and stores in D1
00001024  4E4F                      82          TRAP    #15             * Perform Trap #4 to get the ending address
00001026  2A01                      83          MOVE.L  D1,D5           * Move the ending address into D5
00001028  43F9 00002829             84          LEA     NEWLINE,A1      * Store newline variable for seperate opcodes
0000102E                            85          
0000102E  3E3C 000F                 86          MOVE.W  #15,D7          * prep D7 for bitmask subroutine
00001032  3C3C 000C                 87          MOVE.W  #12,D6          * prep D6 for bitmask subroutine
00001036  6100 1788                 88          BSR     BITMASK         * obtain a bitmask that goes from 12-15 (inclusive)
0000103A                            89          
0000103A  4279 0000292F             90          CLR     (__COUNTER)     * setup for the counter which controlls # of output
00001040  33FC 0000 0000292F        91          MOVE    #0,(__COUNTER)  * lines
00001048                            92          
00001048  6100 0164                 93          BSR     CLEAR_SCREEN    * clear the prompt for start/end ADDR's
0000104C                            94  
0000104C                            95  LOOP    
0000104C  2C4A                      96          MOVE.L  A2,A6           * Copy the starting address into A6   
0000104E  7608                      97          MOVE.L  #8,D3           * Move #8 into D3 to indicate the size
00001050  6100 152E                 98          BSR     PRINT_ASCII_HEX_CHAR    * Subroutine to print out hex without Trap Task #15
00001054                            99          
00001054  43F9 000028DF            100          LEA     SPACE,A1        * print a space to seperate the address from the data
0000105A  303C 000E                101          MOVE.W  #14,D0          * Trap #14 to display the SPACE
0000105E  4E4F                     102          TRAP    #15             * Perform Trap #15
00001060                           103  
00001060  3F06                     104          MOVE    D6,-(A7)        * save the bitmask on the stack
00001062  341A                     105          MOVE.W  (A2)+,D2        * Read an operation into D2
00001064  CC42                     106          AND.W   D2,D6           * Apply this bitmask
00001066                           107          
00001066  BC7C 0000                108          CMP     #OP_0000,D6     * Does the operation start with 0000?
0000106A  6600 000A                109          BNE     NOT0000         * No, check next case
0000106E  6100 014A                110          BSR     OP0000          * Branch to subroutine 0000
00001072  6000 00F6                111          BRA     ITERATION       * Move to next iteration of the loop
00001076                           112  NOT0000        
00001076  BC7C 1000                113          CMP     #OP_0001,D6     * Does the operation start with 0001?
0000107A  6600 000A                114          BNE     NOT0001         * No, check next case
0000107E  6100 02C4                115          BSR     OP0001          * Branch to subroutine 0001
00001082  6000 00E6                116          BRA     ITERATION       * Move to next iteration of the loop
00001086                           117  NOT0001
00001086  BC7C 2000                118          CMP     #OP_0010,D6     * Does the operation start with 0010?
0000108A  6600 000A                119          BNE     NOT0010         * No, check next case
0000108E  6100 031A                120          BSR     OP0010          * Branch to subroutine 0010
00001092  6000 00D6                121          BRA     ITERATION       * Move to next iteration of the loop
00001096                           122  NOT0010
00001096  BC7C 3000                123          CMP     #OP_0011,D6     * Does the operation start with 0011?
0000109A  6600 000A                124          BNE     NOT0011         * No, check next case
0000109E  6100 037C                125          BSR     OP0011          * Branch to subroutine 0011
000010A2  6000 00C6                126          BRA     ITERATION       * Move to next iteration of the loop
000010A6                           127  NOT0011
000010A6  BC7C 4000                128          CMP     #OP_0100,D6     * Does the operation start with 0100?
000010AA  6600 000A                129          BNE     NOT0100         * No, check next case
000010AE  6100 03DE                130          BSR     OP0100          * Branch to subroutine 0100
000010B2  6000 00B6                131          BRA     ITERATION       * Move to next iteration of the loop
000010B6                           132  NOT0100
000010B6  BC7C 5000                133          CMP     #OP_0101,D6     * Does the operation start with 0101?
000010BA  6600 000A                134          BNE     NOT0101         * No, check next case
000010BE  6100 06FE                135          BSR     OP0101          * Branch to subroutine 0101
000010C2  6000 00A6                136          BRA     ITERATION       * Move to next iteration of the loop
000010C6                           137  NOT0101
000010C6  BC7C 6000                138          CMP     #OP_0110,D6     * Does the operation start with 0110?
000010CA  6600 000A                139          BNE     NOT0110         * No, check next case
000010CE  6100 075C                140          BSR     OP0110          * Branch to subroutine 0110
000010D2  6000 0096                141          BRA     ITERATION       * Move to next iteration of the loop
000010D6                           142  NOT0110
000010D6  BC7C 7000                143          CMP     #OP_0111,D6     * Does the operation start with 0111?
000010DA  6600 000A                144          BNE     NOT0111         * No, check next case
000010DE  6100 085E                145          BSR     OP0111          * Branch to subroutine 0111
000010E2  6000 0086                146          BRA     ITERATION       * Move to next iteration of the loop
000010E6                           147  NOT0111
000010E6  BC7C 8000                148          CMP     #OP_1000,D6     * Does the operation start with 1000?
000010EA  6600 000A                149          BNE     NOT1000         * No, check next case
000010EE  6100 0854                150          BSR     OP1000          * Branch to subroutine 1000
000010F2  6000 0076                151          BRA     ITERATION       * Move to next iteration of the loop
000010F6                           152  NOT1000
000010F6  BC7C 9000                153          CMP     #OP_1001,D6     * Does the operation start with 1001?
000010FA  6600 000A                154          BNE     NOT1001         * No, check next case
000010FE  6100 091C                155          BSR     OP1001          * Branch to subroutine 1001
00001102  6000 0066                156          BRA     ITERATION       * Move to next iteration of the loop
00001106                           157  NOT1001
00001106  BC7C A000                158          CMP     #OP_1010,D6     * Does the operation start with 1010?
0000110A  6600 000A                159          BNE     NOT1010         * No, check next case
0000110E  6100 09C6                160          BSR     OP1010          * Branch to subroutine 1010
00001112  6000 0056                161          BRA     ITERATION       * Move to next iteration of the loop
00001116                           162  NOT1010
00001116  BC7C B000                163          CMP     #OP_1011,D6     * Does the operation start with 1011?
0000111A  6600 000A                164          BNE     NOT1011         * No, check next case
0000111E  6100 09BC                165          BSR     OP1011          * Branch to subroutine 1011
00001122  6000 0046                166          BRA     ITERATION       * Move to next iteration of the loop
00001126                           167  NOT1011
00001126  BC7C C000                168          CMP     #OP_1100,D6     * Does the operation start with 1100?
0000112A  6600 000A                169          BNE     NOT1100         * No, check next case
0000112E  6100 0A56                170          BSR     OP1100          * Branch to subroutine 1100
00001132  6000 0036                171          BRA     ITERATION       * Move to next iteration of the loop
00001136                           172  NOT1100
00001136  BC7C D000                173          CMP     #OP_1101,D6     * Does the operation start with 1101?
0000113A  6600 000A                174          BNE     NOT1101         * No, check next case
0000113E  6100 0AD0                175          BSR     OP1101          * Branch to subroutine 1101
00001142  6000 0026                176          BRA     ITERATION       * Move to next iteration of the loop
00001146                           177  NOT1101
00001146  BC7C E000                178          CMP     #OP_1110,D6     * Does the operation start with 1110?
0000114A  6600 000A                179          BNE     NOT1110         * No, check next case
0000114E  6100 0C46                180          BSR     OP1110          * Branch to subroutine 1110
00001152  6000 0016                181          BRA     ITERATION       * Move to next iteration of the loop
00001156                           182  NOT1110
00001156  BC7C F000                183          CMP     #OP_1111,D6     * Does the operation start with 1111?
0000115A  6600 000A                184          BNE     LOOPUNKNOWNOP   * No, check next case
0000115E  6100 0DCC                185          BSR     OP1111          * Branch to subroutine 1111
00001162  6000 0006                186          BRA     ITERATION       * Move to next iteration of the loop
00001166                           187          
00001166                           188  LOOPUNKNOWNOP
00001166  6100 13EE                189          BSR     UNKNOWNOP       * Fail case
0000116A                           190          
0000116A                           191  ITERATION
0000116A  3C1F                     192          MOVE    (A7)+,D6        * restore the bitmask to its previous state
0000116C                           193      
0000116C  5279 0000292F            194          ADDI    #1,(__COUNTER)  * Track the lines on screen
00001172  0C79 001E 0000292F       195          CMPI    #30,(__COUNTER) * Has the counter reached 30?
0000117A  6600 0006                196          BNE     END_OF_LOOP     * Not at 30, go loop more
0000117E  6100 000C                197          BSR     IDLE_STATE      * Break to idle, ask to clear screen
00001182                           198  
00001182                           199  END_OF_LOOP
00001182  BA4A                     200          CMP     A2,D5           * Compare the starting address to ending address
00001184  6700 2F10                201          BEQ     END             * If they are equal, branch 
00001188  6000 FEC2                202          BRA     LOOP            * Otherwise, branch back to LOOP
0000118C                           203          
0000118C                           204  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000118C                           205  *-----------------------------------------------------------------------------
0000118C                           206  
0000118C                           207  IDLE_STATE
0000118C  43F9 00002804            208      LEA     CONT_MSG,A1     * show msg to hit enter in order to continue
00001192  103C 000E                209      MOVE.B  #14,D0          * Trap #14 to show CONT_MSG
00001196  4E4F                     210      TRAP    #15             * Perform Trap #14
00001198                           211      
00001198  103C 0004                212      MOVE.B  #4,D0           * trap task 4 for input
0000119C  4E4F                     213      TRAP    #15             * Perform Trap #15
0000119E  0C41 000D                214      CMPI    #$D,D1          * Compare 13 (Enter) to D1
000011A2                           215      
000011A2  6100 000A                216      BSR     CLEAR_SCREEN    * Clear everything, so ready to output another 30
000011A6  42B9 0000292F            217      CLR.L   (__COUNTER)     * Reset the counter
000011AC  4E75                     218      RTS                     * Done with IDLE State
000011AE                           219      
000011AE                           220  CLEAR_SCREEN
000011AE  103C 000B                221      MOVE.B  #11,D0          * Move #11 into D0 for Trap Task #11
000011B2  323C FF00                222      MOVE.W  #$FF00,D1       * To clear screen, set D1.W to $FF00
000011B6  4E4F                     223      TRAP    #15             * Perform Trap #11
000011B8  4E75                     224      RTS                     * Return to IDLE_STATE
000011BA                           225  
000011BA                           226  *-----------------------------------------------------------------------------
000011BA                           227  *-----------------------------------------------------------------------------
000011BA                           228  * NAME: OP_0000   (BCLR, ORI, CMPI)
000011BA                           229  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000011BA                           230  * PRE-CONDITION:  D2 contains the OPcode to be processed
000011BA                           231  * POST-CONDITION: All registers return to their previous state, and the output
000011BA                           232  *                 goes to the output console for reading the raw data or the
000011BA                           233  *                 actual instruction.
000011BA                           234  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000011BA                           235  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000011BA                           236  OP0000
000011BA  48A7 FFC0                237          MOVEM   D0-D7/A0-A1,-(A7)   * Push values to the stack to save
000011BE                           238                        
000011BE                           239          * Checking for unsupported mode (An) for BCLR, ORI, and CMPI
000011BE  3C3C 0003                240          MOVE.W  #3, D6              * Prep lower value for bitmask
000011C2  3E3C 0005                241          MOVE.W  #5, D7              * Prep upper value for bitmask
000011C6  6100 15F8                242          BSR     BITMASK             * Finalize bitmask setup
000011CA  CC42                     243          AND     D2,D6               * Apply bitmask
000011CC                           244          
000011CC  0C46 0008                245          CMPI    #%0000000000001000, D6  * Is the mode An, an unsupported mode?
000011D0  6700 0168                246          BEQ     UNKNOWN0000             * If so, the op is unknown
000011D4                           247          
000011D4                           248          * Checking for BCLR Dynamic
000011D4  3C3C 0006                249          MOVE.W  #6, D6              * Prep lower value for bitmask
000011D8  3E3C 0008                250          MOVE.W  #8, D7              * Prep upper value for bitmask
000011DC  6100 15E2                251          BSR     BITMASK             * Finalize bitmask setup
000011E0  CC42                     252          AND     D2,D6               * Apply bitmask
000011E2                           253          
000011E2  0C46 0180                254          CMPI    #%0000000110000000, D6  * Are we BCLR Dynamic?
000011E6  6600 0050                255          BNE     NOTBCLRDYNA             * If not, branch to BCLR Static or other ops
000011EA                           256  
000011EA                           257          * Confirmed BCLR Dynamic at this point
000011EA  43F9 00002863            258          LEA     BCLROP,A1           * We found BCLR
000011F0  103C 000E                259          MOVE.B  #14,D0              * Trap #14 prints out the data
000011F4  4E4F                     260          TRAP    #15                 * Perform Trap #14
000011F6                           261  
000011F6  43F9 000028DF            262          LEA     SPACE,A1            * Formatting
000011FC  103C 000E                263          MOVE.B  #14,D0              * Trap #14 prints out space
00001200  4E4F                     264          TRAP    #15                 * Perform Trap #14
00001202                           265          
00001202                           266          * Set up for printing out the Register
00001202  0882 0006                267          BCLR    #6,D2               * Clear bit 6
00001206  0882 0007                268          BCLR    #7,D2               * Clear bit 7
0000120A  0882 0008                269          BCLR    #8,D2               * Clear bit 8
0000120E                           270          
0000120E  6100 0D22                271          BSR     EAHELPER611         * Print out Register
00001212                           272  
00001212  43F9 000028E5            273          LEA     COMMA,A1            * formatting
00001218  103C 000E                274          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000121C  4E4F                     275          TRAP    #15                 * Perform Trap #14
0000121E                           276          
0000121E  4243                     277          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
00001220  08C3 0000                278          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
00001224                           279      
00001224  6100 0D4E                280          BSR     EAHELPER05          * Print out data.
00001228                           281          
00001228  43F9 00002829            282          LEA     NEWLINE,A1          * Formatting
0000122E  103C 000E                283          MOVE.B  #14,D0              * Trap #14 prints out the data
00001232  4E4F                     284          TRAP    #15                 * Perform Trap #14
00001234                           285          
00001234  6000 0108                286          BRA     END0000             * Found the op, move to next iteration
00001238                           287          
00001238                           288  NOTBCLRDYNA     * Possible options left are BCLR Static, ORI, and CMPI
00001238  3C3C 0006                289          MOVE.W  #6, D6              * Prep lower value for bitmask
0000123C  3E3C 000B                290          MOVE.W  #11, D7             * Prep upper value for bitmask
00001240  6100 157E                291          BSR     BITMASK             * Finalize bitmask setup
00001244  CC42                     292          AND     D2,D6               * Apply bitmask
00001246                           293          
00001246  0C46 0880                294          CMPI    #%0000100010000000, D6  * Are we BCLR Static?
0000124A  6600 003A                295          BNE     NOTBCLR                 * If not, branch to other functions
0000124E                           296          
0000124E                           297          * Confirmed BCLR Static at this point
0000124E  43F9 00002863            298          LEA     BCLROP,A1           * We found BCLR
00001254  103C 000E                299          MOVE.B  #14,D0              * Trap #14 prints out the data
00001258  4E4F                     300          TRAP    #15                 * Perform Trap #14
0000125A                           301  
0000125A  43F9 000028DF            302          LEA     SPACE,A1            * Formatting
00001260  103C 000E                303          MOVE.B  #14,D0              * Trap #14 prints out space
00001264  4E4F                     304          TRAP    #15                 * Perform Trap #14
00001266                           305          
00001266  2802                     306          MOVE.L  D2, D4              * Saving values
00001268                           307                  
00001268  43F9 000028E3            308          LEA     IMD, A1             * Formatting
0000126E  103C 000E                309          MOVE.B  #14,D0              * Trap #14 prints out the data
00001272  4E4F                     310          TRAP    #15                 * Perform Trap #14
00001274                           311          
00001274                           312          * Grab next word
00001274  3A1A                     313          MOVE.W (A2)+, D5            * Move the pointer, and store it in D3
00001276  E18D                     314          LSL.L   #8, D5              * LSL for first nibble of the word
00001278  E18D                     315          LSL.L   #8, D5              * LSL for second nibble of the word
0000127A  2C45                     316          MOVE.L  D5, A6              * Store D5 into A6, to be used as parameter
0000127C  7604                     317          MOVE.L  #4, D3              * Four most significant bits in D3
0000127E  6100 1300                318          BSR     PRINT_ASCII_HEX_CHAR    * Perform number print out
00001282                           319  
00001282  6000 007E                320          BRA     SKIPLONG            * Formatting, returning saved values, etc.
00001286                           321          
00001286                           322  NOTBCLR * Possible options left are ORI or CMPI
00001286  3C3C 0009                323          MOVE.W  #9, D6              * Prep lower value for bitmask
0000128A  3E3C 000B                324          MOVE.W  #11, D7             * Prep upper value for bitmask
0000128E  6100 1530                325          BSR     BITMASK             * Finalize bitmask setup
00001292  CC42                     326          AND     D2,D6               * Apply bitmask
00001294                           327          
00001294  0C46 0000                328          CMPI    #%0000000000000000, D6   * Are we possibly ORI?
00001298  6600 008A                329          BNE     NOTORI                   * If not, branch to NOTORI
0000129C                           330          
0000129C                           331          * Size check to see if unsupported ORI mode
0000129C  3C3C 0006                332          MOVE.W  #6, D6              * Prep lower value for bitmask
000012A0  3E3C 0007                333          MOVE.W  #7, D7              * Prep upper value for bitmask
000012A4  6100 151A                334          BSR     BITMASK             * Finalize bitmask setup
000012A8  CC42                     335          AND     D2,D6               * Apply bitmask
000012AA                           336          
000012AA  0C46 00C0                337          CMPI    #%0000000011000000, D6  * Are bits 6,7 == 1,1?
000012AE  6700 008A                338          BEQ     UNKNOWN0000             * If so, unknown op. 
000012B2                           339          
000012B2                           340          * Confirmed ORI at this point
000012B2  43F9 00002871            341          LEA     ORIOP, A1           * Load 'ORI' into the output window
000012B8  103C 000E                342          MOVE.B  #14,D0              * Trap #14 prints out the data in D0
000012BC  4E4F                     343          TRAP    #15                 * Perform Trap #14
000012BE                           344  
000012BE                           345  IMD_SIZE_0000        
000012BE  6100 0FFA                346          BSR     SIZE67              * Print the size
000012C2                           347  
000012C2                           348          * Mode check to see the size
000012C2  3C3C 0006                349          MOVE.W  #6, D6              * Prep lower value for bitmask
000012C6  3E3C 0007                350          MOVE.W  #7, D7              * Prep upper value for bitmask
000012CA  6100 14F4                351          BSR     BITMASK             * Finalize bitmask setup
000012CE  CC42                     352          AND     D2,D6               * Apply bitmask
000012D0                           353          
000012D0  2802                     354          MOVE.L  D2, D4              * Saving value
000012D2                           355                  
000012D2  43F9 000028E3            356          LEA     IMD, A1             * Formatting
000012D8  103C 000E                357          MOVE.B  #14,D0              * Trap #14 prints out the data
000012DC  4E4F                     358          TRAP    #15                 * Perform Trap #14
000012DE                           359                 
000012DE                           360          * Grab immediate data
000012DE  3A1A                     361          MOVE.W (A2)+, D5            * Move the pointer, and store it in D3
000012E0  E18D                     362          LSL.L   #8, D5              * LSL to get one nibble 
000012E2  E18D                     363          LSL.L   #8, D5              * LSL to get the next nibble
000012E4  2C45                     364          MOVE.L  D5, A6              * Store D5 into A6 for PRINT_ASCII_HEX_CHAR
000012E6  7604                     365          MOVE.L  #4, D3              * Move #4 into D3 to display four bits
000012E8  6100 1296                366          BSR     PRINT_ASCII_HEX_CHAR
000012EC                           367  
000012EC  0C46 0080                368          CMPI    #%0000000010000000, D6   * See if the size is a LONG
000012F0  6600 0010                369          BNE     SKIPLONG    
000012F4                           370          
000012F4                           371          * Grab next word, if necessary
000012F4  3A1A                     372          MOVE.W (A2)+, D5            * Move the pointer, and store it in D3
000012F6  E18D                     373          LSL.L   #8, D5              * LSL to get first nibble of the word
000012F8  E18D                     374          LSL.L   #8, D5              * LSL to get second nibble of the word
000012FA  2C45                     375          MOVE.L  D5, A6              * Store D5 into A6 as a parameter
000012FC  7604                     376          MOVE.L  #4, D3              * Move #4 into D3 to show four bits
000012FE  6100 1280                377          BSR     PRINT_ASCII_HEX_CHAR    * Perform number output
00001302                           378  
00001302                           379  SKIPLONG
00001302  43F9 000028E5            380          LEA     COMMA, A1           * Formatting
00001308  103C 000E                381          MOVE.B  #14,D0              * Trap #14 prints out the data
0000130C  4E4F                     382          TRAP    #15                 * Perform Trap #14
0000130E                           383          
0000130E  2404                     384          MOVE.L  D4, D2              * Return saved value
00001310                           385          
00001310  6100 0C62                386          BSR     EAHELPER05          * Print out the EA
00001314                           387          
00001314  43F9 00002829            388          LEA     NEWLINE,A1          * Formatting
0000131A  103C 000E                389          MOVE.B  #14,D0              * Trap #14 prints out the data
0000131E  4E4F                     390          TRAP    #15                 * Perform Trap #14
00001320                           391          
00001320  6000 001C                392          BRA     END0000             * Done with op. Move to next iteration
00001324                           393  
00001324                           394  NOTORI  * Possible option left is CMPI
00001324                           395  
00001324  0C46 0C00                396          CMPI    #%0000110000000000, D6  * Are we CMPI?
00001328  6600 0010                397          BNE     UNKNOWN0000             * If not, unknown op
0000132C                           398          
0000132C                           399          * Confirmed CMPI at this point
0000132C  43F9 00002875            400          LEA     CMPIOP, A1          * Formatting
00001332  103C 000E                401          MOVE.B  #14,D0              * Trap #14 prints out the data
00001336  4E4F                     402          TRAP    #15                 * Perform Trap #14
00001338                           403          
00001338  6084                     404          BRA     IMD_SIZE_0000       * Get immediate value and end opcode 0000
0000133A                           405          
0000133A                           406  UNKNOWN0000
0000133A  6100 121A                407          BSR     UNKNOWNOP           * Unknown op
0000133E                           408  
0000133E                           409  END0000          
0000133E  4C9F 03FF                410          MOVEM   (A7)+,D0-D7/A0-A1   * Pop values back of the stack, restore registers
00001342  4E75                     411          RTS
00001344                           412  
00001344                           413  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001344                           414  *-----------------------------------------------------------------------------
00001344                           415  
00001344                           416  
00001344                           417  
00001344                           418  *-----------------------------------------------------------------------------
00001344                           419  *-----------------------------------------------------------------------------
00001344                           420  * NAME: OP_0001   (MOVE.B)
00001344                           421  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001344                           422  * PRE-CONDITION:  D2 contains the opcode to be processed
00001344                           423  * POST-CONDITION: All registers return to their previous state, and the output
00001344                           424  *                 goes to the output console for reading the raw data or the
00001344                           425  *                 actual instruction.
00001344                           426  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001344                           427  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001344                           428  OP0001  
00001344  48A7 FFC0                429          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
00001348                           430          
00001348  3C3C 0006                431          MOVE.W  #6, D6              * Prep lower value for bitmask
0000134C  3E3C 0008                432          MOVE.W  #8, D7              * Prep upper value for bitmask
00001350  6100 146E                433          BSR     BITMASK             * Finalize bitmask setup
00001354  CC42                     434          AND     D2,D6               * Apply bitmask
00001356                           435          
00001356  0C46 0040                436          CMPI    #%0000000001000000,D6   * Is it an unsupported mode?
0000135A  6600 0006                437          BNE     OP0001MOVE              * If not, branch to only print out MOVE
0000135E                           438          
0000135E  6000 0040                439          BRA     UNKNOWNOP0001 * it was an unpermitted mode, jump to unknownop
00001362                           440  OP0001MOVE
00001362  43F9 00002841            441          LEA     MOVEOP,A1   * Put 'MOVE' into the window
00001368  103C 000E                442          MOVE.B  #14,D0      * Trap #14 to print out
0000136C  4E4F                     443          TRAP    #15         * Perform Trap #14
0000136E                           444          
0000136E                           445  OP0001MOVEA
0000136E                           446  
0000136E  43F9 000028F3            447          LEA     __B,A1      * Put '.B' into the window
00001374  103C 000E                448          MOVE.B  #14,D0      * Trap #14 to print out
00001378  4E4F                     449          TRAP    #15         * Perform Trap #14
0000137A                           450          
0000137A  7601                     451          MOVE.L  #1,D3       * Move #1 into D3 as a size parameter
0000137C  6100 0BF6                452          BSR     EAHELPER05  * Perform EAHELPER05
00001380                           453          
00001380  43F9 000028E5            454          LEA     COMMA,A1    * Load ',' into the window
00001386  103C 000E                455          MOVE.B  #14,D0      * Trap #14 to print out
0000138A  4E4F                     456          TRAP    #15         * Perform Trap #14
0000138C                           457          
0000138C  6100 0BA4                458          BSR     EAHELPER611 * Perform EAHELPER611 for Destination Reg and Mode
00001390                           459          
00001390  43F9 00002829            460          LEA     NEWLINE,A1  * Load a newline into the window
00001396  103C 000E                461          MOVE.B  #14,D0      * Trap #14 to print it out
0000139A  4E4F                     462          TRAP    #15         * Perform trap #14
0000139C                           463          
0000139C  6000 0006                464          BRA     ENDOP0001   * Move to next iteration
000013A0                           465          
000013A0                           466  UNKNOWNOP0001
000013A0  6100 11B4                467          BSR     UNKNOWNOP   * Op is unknown
000013A4                           468          
000013A4                           469  ENDOP0001
000013A4  4C9F 03FF                470          MOVEM (A7)+,D0-D7/A0-A1 * Pop values back
000013A8  4E75                     471          RTS                     * Move to next iteration
000013AA                           472          
000013AA                           473  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000013AA                           474  *-----------------------------------------------------------------------------
000013AA                           475  
000013AA                           476  
000013AA                           477  
000013AA                           478  *-----------------------------------------------------------------------------
000013AA                           479  *-----------------------------------------------------------------------------
000013AA                           480  * NAME: OP_0010   (MOVE.L, MOVEA.L)
000013AA                           481  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000013AA                           482  * PRE-CONDITION:  D2 contains the opcode to be processed
000013AA                           483  * POST-CONDITION: All registers return to their previous state, and the output
000013AA                           484  *                 goes to the output console for reading the raw data or the
000013AA                           485  *                 actual instruction.
000013AA                           486  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000013AA                           487  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000013AA                           488  OP0010  
000013AA  48A7 FFC0                489          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
000013AE                           490          
000013AE  3C3C 0006                491          MOVE.W  #6, D6              * Prep lower value for bitmask
000013B2  3E3C 0008                492          MOVE.W  #8, D7              * Prep upper value for bitmask
000013B6  6100 1408                493          BSR     BITMASK             * Finalize bitmask setup
000013BA                           494          
000013BA  CC42                     495          AND     D2,D6               * Apply bitmask
000013BC                           496          
000013BC  0C46 0040                497          CMPI    #%0000000001000000,D6
000013C0  6600 0012                498          BNE     OP0010MOVE
000013C4                           499          
000013C4  43F9 00002846            500          LEA     MOVEAOP,A1   * Put 'MOVE' into the window
000013CA  103C 000E                501          MOVE.B  #14,D0      * Trap #14 to print out
000013CE  4E4F                     502          TRAP    #15         * Perform Trap #14
000013D0                           503          
000013D0  6000 000E                504          BRA     OP0010MOVEA
000013D4                           505          
000013D4                           506  OP0010MOVE
000013D4                           507  
000013D4  43F9 00002841            508          LEA     MOVEOP,A1   * Put 'MOVE' into the window
000013DA  103C 000E                509          MOVE.B  #14,D0      * Trap #14 to print out
000013DE  4E4F                     510          TRAP    #15         * Perform Trap #14
000013E0                           511          
000013E0                           512  OP0010MOVEA
000013E0                           513  
000013E0  43F9 000028FB            514          LEA     __L,A1   * Put '.L ' into the window
000013E6  103C 000E                515          MOVE.B  #14,D0   * Trap #14 to print out
000013EA  4E4F                     516          TRAP    #15      * Perform Trap #14
000013EC                           517          
000013EC  7603                     518          MOVE.L  #3,D3    * indicate the size of a potential
000013EE                           519                           * immediate is long
000013EE                           520          
000013EE  6100 0B84                521          BSR     EAHELPER05  * branch to ea helper to print the source
000013F2                           522          
000013F2  43F9 000028E5            523          LEA     COMMA,A1    * Put ',' into the window
000013F8  103C 000E                524          MOVE.B  #14,D0      * Trap #14 to print out
000013FC  4E4F                     525          TRAP    #15         * Perform Trap #14
000013FE                           526          
000013FE  6100 0B32                527          BSR     EAHELPER611 * branch to ea helper to print the destination
00001402                           528          
00001402  43F9 00002829            529          LEA     NEWLINE,A1  * Put a newline into the window
00001408  103C 000E                530          MOVE.B  #14,D0      * Trap #14 to print out
0000140C  4E4F                     531          TRAP    #15         * Peerform Trap task #14
0000140E                           532          
0000140E  6000 0006                533          BRA     ENDOP0010
00001412                           534          
00001412                           535  UNKNOWNOP0010
00001412  6100 1142                536          BSR     UNKNOWNOP   * OP is not recognized by our compiler
00001416                           537          
00001416                           538  ENDOP0010
00001416  4C9F 03FF                539          MOVEM (A7)+,D0-D7/A0-A1 * restore registers we saved
0000141A  4E75                     540          RTS        
0000141C                           541  
0000141C                           542  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000141C                           543  *-----------------------------------------------------------------------------
0000141C                           544  
0000141C                           545  
0000141C                           546  
0000141C                           547  *-----------------------------------------------------------------------------
0000141C                           548  *-----------------------------------------------------------------------------
0000141C                           549  * NAME: OP_0011   (MOVE.W, MOVEA.W)
0000141C                           550  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000141C                           551  * PRE-CONDITION:  D2 contains the opcode to be processed
0000141C                           552  * POST-CONDITION: All registers return to their previous state, and the output
0000141C                           553  *                 goes to the output console for reading the raw data or the
0000141C                           554  *                 actual instruction.
0000141C                           555  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000141C                           556  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000141C                           557  OP0011  
0000141C  48A7 FFC0                558          MOVEM   D0-D7/A0-A1,-(A7)   * Push vales onto stack
00001420                           559          
00001420  3C3C 0006                560          MOVE.W  #6, D6              * Prep lower value for bitmask
00001424  3E3C 0008                561          MOVE.W  #8, D7              * Prep upper value for bitmask
00001428  6100 1396                562          BSR     BITMASK             * Finalize bitmask setup
0000142C                           563          
0000142C  CC42                     564          AND     D2,D6               * Apply bitmask
0000142E                           565          
0000142E  0C46 0040                566          CMPI    #%0000000001000000,D6
00001432  6600 0012                567          BNE     OP0011MOVE
00001436                           568          
00001436  43F9 00002846            569          LEA     MOVEAOP,A1   * Put 'MOVE' into the window
0000143C  103C 000E                570          MOVE.B  #14,D0      * Trap #14 to print out
00001440  4E4F                     571          TRAP    #15         * Perform Trap #14
00001442                           572          
00001442  6000 000E                573          BRA     OP0011MOVEA * Skip printing MOVE
00001446                           574          
00001446                           575  OP0011MOVE
00001446                           576  
00001446  43F9 00002841            577          LEA     MOVEOP,A1   * Put 'MOVE' into the window
0000144C  103C 000E                578          MOVE.B  #14,D0      * Trap #14 to print out
00001450  4E4F                     579          TRAP    #15         * Perform Trap #14
00001452                           580          
00001452                           581  OP0011MOVEA
00001452                           582  
00001452  43F9 000028F7            583          LEA     __W,A1   * Put 'MOVE' into the window
00001458  103C 000E                584          MOVE.B  #14,D0   * Trap #14 to print out
0000145C  4E4F                     585          TRAP    #15      * Perform Trap #14
0000145E                           586          
0000145E  7602                     587          MOVE.L  #2,D3   * indicate to eahlper that an
00001460                           588                          * immediate could be
00001460                           589          
00001460  6100 0B12                590          BSR     EAHELPER05 * used to print the source reg
00001464                           591          
00001464  43F9 000028E5            592          LEA     COMMA,A1 * Put ',' into the window
0000146A  103C 000E                593          MOVE.B  #14,D0   * Trap #14 to print out
0000146E  4E4F                     594          TRAP    #15      * Perform Trap task #14
00001470                           595          
00001470  6100 0AC0                596          BSR     EAHELPER611 * used to print the destination reg
00001474                           597          
00001474  43F9 00002829            598          LEA     NEWLINE,A1 * Print a newline
0000147A  103C 000E                599          MOVE.B  #14,D0     * Trap #14 to print out
0000147E  4E4F                     600          TRAP    #15        * Perform Trap task #14
00001480                           601          
00001480  6000 0006                602          BRA     ENDOP0011 * we are done, head to end of subroutine
00001484                           603          
00001484                           604  UNKNOWNOP0011
00001484  6100 10D0                605          BSR     UNKNOWNOP * print out an unrecognized OP
00001488                           606          
00001488                           607  ENDOP0011
00001488  4C9F 03FF                608          MOVEM (A7)+,D0-D7/A0-A1 * restore registers we saved
0000148C  4E75                     609          RTS        
0000148E                           610  
0000148E                           611  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000148E                           612  *-----------------------------------------------------------------------------
0000148E                           613  
0000148E                           614  *-----------------------------------------------------------------------------
0000148E                           615  *-----------------------------------------------------------------------------
0000148E                           616  * NAME: OP_0100   (NOP, MOVEM, LEA, NEG, JSR, RTS)
0000148E                           617  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000148E                           618  * PRE-CONDITION:  D2 contains the opcode to be processed
0000148E                           619  * POST-CONDITION: All registers return to their previous state, and the output
0000148E                           620  *                 goes to the output console for reading the raw data or the
0000148E                           621  *                 actual instruction.
0000148E                           622  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000148E                           623  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000148E                           624  OP0100  
0000148E                           625  
0000148E  48A7 C0C0                626          MOVEM   D0-D1/A0-A1,-(A7) * Push values to the stack to save
00001492                           627          
00001492                           628          *NOP
00001492  0C42 4E71                629          CMPI    #%0100111001110001,D2   * Check the bits to see if we are NOP
00001496  6600 0012                630          BNE     NOTNOP                  * Not NOP, check the next possiblity
0000149A                           631          
0000149A  43F9 00002839            632          LEA     NOOPERATION,A1  * Display 'NOP'
000014A0  103C 000D                633          MOVE.B  #13,D0          * Load trap task #13
000014A4  4E4F                     634          TRAP    #15             * Perform trap task #13
000014A6                           635          
000014A6  6000 0310                636          BRA     DONE0100 * OP identified, move out of the subroutine
000014AA                           637  NOTNOP * This label processes NEG
000014AA                           638          
000014AA                           639          * prep values for BITMASK subroutine
000014AA  7C08                     640          MOVE.L  #8,D6   * Load 8 into D6, indicating the starting bit
000014AC  7E0B                     641          MOVE.L  #11,D7  * Load 11 into D7, indicating the ending bit
000014AE                           642          
000014AE  6100 1310                643          BSR     BITMASK * Create the bitmask, stored in D6
000014B2                           644          
000014B2  CC42                     645          AND     D2,D6                   * Apply bitmask to the OP
000014B4                           646          
000014B4  0C46 0400                647          CMPI    #%0000010000000000,D6   * Is the OP NEG?
000014B8  6600 0046                648          BNE     NOTNEG                  * The Op is not NEG, check next case
000014BC                           649          
000014BC  7C03                     650          MOVE.L  #3,D6   * Load 3 into D6, indicating the starting bit
000014BE  7E05                     651          MOVE.L  #5,D7   * Load 11 into D7, indicating the ending bit
000014C0                           652          
000014C0  6100 12FE                653          BSR     BITMASK * generate a bitmask to be used to check mode
000014C4                           654          
000014C4  0C46 0008                655          CMPI    #%0000000000001000,D6 * check to see if it is unsupported mode
000014C8  6700 02EA                656          BEQ     UNKNOWN0100 * print print out as hex indicating bad op
000014CC                           657          
000014CC  0C46 0028                658          CMPI    #%0000000000101000,D6 * check to see if it is unsupported mode
000014D0  6700 02E2                659          BEQ     UNKNOWN0100 * print print out as hex indicating bad op
000014D4                           660          
000014D4  0C46 0030                661          CMPI    #%0000000000110000,D6 * check to see if it is unsupported mode
000014D8  6700 02DA                662          BEQ     UNKNOWN0100 * print print out as hex indicating bad op
000014DC                           663        
000014DC                           664          * it is NEG, print
000014DC  43F9 0000283D            665          LEA     NEGOP,A1    * Display 'NEG'
000014E2  103C 000E                666          MOVE.B  #14,D0      * Load trap task #14
000014E6  4E4F                     667          TRAP    #15         * Perform trap task #14
000014E8                           668          
000014E8  6100 0DD0                669          BSR     SIZE67      * call size67 to print the size of the OP
000014EC                           670          
000014EC  6100 0A86                671          BSR     EAHELPER05  * call eahelper05 to print the destination of op
000014F0                           672          
000014F0  43F9 00002829            673          LEA     NEWLINE,A1  * Display a newline
000014F6  103C 000E                674          MOVE.B  #14,D0      * Load trap task #14
000014FA  4E4F                     675          TRAP    #15         * Perform trap task #14
000014FC                           676          
000014FC  6000 02BA                677          BRA     DONE0100 * we found the op, move to next iteration
00001500                           678          
00001500                           679  NOTNEG * This label processes MOVEM
00001500                           680  
00001500                           681          * prep values for BITMASK subroutine
00001500  7C07                     682          MOVE.L  #7,D6   * Load 7 into D6, indicating the starting bit
00001502  7E09                     683          MOVE.L  #9,D7   * Load 9 into D7, indicating the ending bit
00001504                           684          
00001504  6100 12BA                685          BSR     BITMASK * Generate the bitmask
00001508                           686          
00001508  CC82                     687          AND.L   D2,D6   * apply bitmask
0000150A                           688          
0000150A  0C46 0080                689          CMPI    #%0000000010000000,D6 * is it MOVEM?
0000150E  6600 0148                690          BNE     NOTMOVEM          * it is not MOVEM
00001512                           691          
00001512  7C0A                     692          MOVE.L  #10,D6  * Load 10 into D6, indicating the starting bit
00001514  7E0A                     693          MOVE.L  #10,D7  * Load 10 into D7, indicating the ending bit
00001516                           694          
00001516  6100 12A8                695          BSR     BITMASK * Generate the bitmask
0000151A                           696          
0000151A  CC82                     697          AND.L   D2,D6   * Apply the bitmask to the OP
0000151C                           698          
0000151C  0C46 0000                699          CMPI    #%0000000000000000,D6 * is it register to memory?
00001520  6700 009C                700          BEQ     MOVEMTOMEM * it is, branch to the label that processes it
00001524                           701          
00001524                           702  MOVEMTOREG * This label processes MOVEM from memory to register
00001524                           703  
00001524  7C03                     704          MOVE.L  #3,D6   * Load 3 into D6, indicating the starting bit
00001526  7E05                     705          MOVE.L  #5,D7   * Load 5 into D7, indicating the ending bit
00001528                           706          
00001528  6100 1296                707          BSR     BITMASK * Generate the bitmask
0000152C                           708          
0000152C  CC82                     709          AND.L   D2,D6   * Apply the bitmask to the OP
0000152E                           710          
0000152E  0C46 0000                711          CMPI    #%0000000000000000,D6 * is it an unsupported mode?
00001532  6700 0280                712          BEQ     UNKNOWN0100           * yes, branch to unknown
00001536                           713          
00001536  0C46 0008                714          CMPI    #%0000000000001000,D6 * is it an unsupported mode?
0000153A  6700 0278                715          BEQ     UNKNOWN0100           * yes, branch to unknown
0000153E                           716          
0000153E  0C46 0020                717          CMPI    #%0000000000100000,D6 * is it an unsupported mode?
00001542  6700 0270                718          BEQ     UNKNOWN0100           * yes, branch to unknown
00001546                           719          
00001546  0C46 0028                720          CMPI    #%0000000000101000,D6 * is it an unsupported mode?
0000154A  6700 0268                721          BEQ     UNKNOWN0100           * yes, branch to unknown
0000154E                           722          
0000154E  0C46 0030                723          CMPI    #%0000000000110000,D6 * is it an unsupported mode?
00001552  6700 0260                724          BEQ     UNKNOWN0100           * yes, branch to unknown
00001556                           725          
00001556  0C46 0038                726          CMPI    #%0000000000111000,D6 * is it an unsupported mode?
0000155A  6700 0258                727          BEQ     UNKNOWN0100           * yes, branch to unknown
0000155E                           728          
0000155E  43F9 0000284C            729          LEA     MOVEMOP,A1  * Print MOVEM to the window
00001564  103C 000E                730          MOVE.B  #14,D0      * Indicate task #14
00001568  4E4F                     731          TRAP    #15         * Perform trap task #14
0000156A                           732          
0000156A  7C06                     733          MOVE.L  #6,D6   * Load 6 into D6, indicating the starting bit
0000156C  7E06                     734          MOVE.L  #6,D7   * Load 6 into D7, indicating the ending bit
0000156E                           735          
0000156E  6100 1250                736          BSR     BITMASK * Generate the bitmask
00001572                           737          
00001572  CC82                     738          AND.L   D2,D6   * Apply the bitmask to the OP
00001574                           739          
00001574  0C46 0040                740          CMPI    #%0000000001000000,D6 * is it a long op?
00001578  6600 0012                741          BNE     NOTLONGMOVEM1       * no, it is a word
0000157C                           742          
0000157C  43F9 000028FB            743          LEA     __L,A1  * Load '.L ' to the window
00001582  103C 000E                744          MOVE.B  #14,D0  * Indicate task #14
00001586  4E4F                     745          TRAP    #15     * Perform trap task #14
00001588                           746          
00001588  6000 000E                747          BRA     SKIPNOTLONG1 * The OP was a long, skip the long portion
0000158C                           748          
0000158C                           749  NOTLONGMOVEM1 * this label prints out '.W ' for MOVEM
0000158C                           750  
0000158C  43F9 000028F7            751          LEA     __W,A1  * Load '.W ' to the window
00001592  103C 000E                752          MOVE.B  #14,D0  * Indicate we are using task #14
00001596  4E4F                     753          TRAP    #15     * Perform trap task #15
00001598                           754                  
00001598                           755  SKIPNOTLONG1 * this label handles printing the source and dest regs of MOVEM
00001598                           756  
00001598  6100 09DA                757          BSR     EAHELPER05 * print out the register we are moving from
0000159C                           758          
0000159C  43F9 000028E5            759          LEA     COMMA,A1    * Load ',' to the window
000015A2  103C 000E                760          MOVE.B  #14,D0      * Indicate trap task #14
000015A6  4E4F                     761          TRAP    #15         * Perform trap task #14
000015A8                           762          
000015A8  6100 0DF2                763          BSR     MOVEMHELPERPOST * Call the helper function
000015AC                           764          
000015AC  341A                     765          MOVE.W  (A2)+,D2    * Read the next OP into D2
000015AE                           766          
000015AE  43F9 00002829            767          LEA     NEWLINE,A1  * Load newline to the window
000015B4  103C 000E                768          MOVE.B  #14,D0      * Indicate task #14
000015B8  4E4F                     769          TRAP    #15         * Perform trap task #14
000015BA                           770      
000015BA  6000 01FC                771          BRA     DONE0100 * Operation processed, move out of the subroutine
000015BE                           772          
000015BE                           773  MOVEMTOMEM * this label handles MOVEM from register to memory
000015BE                           774  
000015BE  7C03                     775          MOVE.L  #3,D6   * Load 3 into D6, indicating the starting bit
000015C0  7E05                     776          MOVE.L  #5,D7   * Load 5 into D7, indicating the ending bit
000015C2                           777          
000015C2  6100 11FC                778          BSR     BITMASK * Generate the bitmask
000015C6                           779          
000015C6  CC82                     780          AND.L   D2,D6   * apply the bitmask to the OP
000015C8                           781          
000015C8  0C46 0000                782          CMPI    #%0000000000000000,D6 * is it an unsopported mode?
000015CC  6700 01E6                783          BEQ     UNKNOWN0100 * if yes, branch to print unknown
000015D0                           784          
000015D0  0C46 0008                785          CMPI    #%0000000000001000,D6 * is it an unsopported mode?
000015D4  6700 01DE                786          BEQ     UNKNOWN0100 * if yes, branch to print unknown
000015D8                           787          
000015D8  0C46 0018                788          CMPI    #%0000000000011000,D6 * is it an unsopported mode?
000015DC  6700 01D6                789          BEQ     UNKNOWN0100 * if yes, branch to print unknown
000015E0                           790          
000015E0  0C46 0028                791          CMPI    #%0000000000101000,D6 * is it an unsopported mode?
000015E4  6700 01CE                792          BEQ     UNKNOWN0100 * if yes, branch to print unknown
000015E8                           793          
000015E8  0C46 0030                794          CMPI    #%0000000000110000,D6 * is it an unsopported mode?
000015EC  6700 01C6                795          BEQ     UNKNOWN0100 * if yes, branch to print unknown
000015F0                           796          
000015F0  0C46 0070                797          CMPI    #%0000000001110000,D6 * is it an unsopported mode?
000015F4  6700 01BE                798          BEQ     UNKNOWN0100 * if yes, branch to print unknown
000015F8                           799          
000015F8  43F9 0000284C            800          LEA     MOVEMOP,A1  * Load 'MOVEM' to the window
000015FE  103C 000E                801          MOVE.B  #14,D0      * Indicate task #14
00001602  4E4F                     802          TRAP    #15         * Perform trap task #15
00001604                           803          
00001604  7C06                     804          MOVE.L  #6,D6   * Load 6 into D6, indicating the starting bit
00001606  7E06                     805          MOVE.L  #6,D7   * Load 6 into D7, indicating the ending bit
00001608                           806          
00001608  6100 11B6                807          BSR     BITMASK * Generate the bitmask
0000160C                           808          
0000160C  CC82                     809          AND.L   D2,D6   * Apply the bitmask to the OP
0000160E                           810          
0000160E  0C46 0040                811          CMPI    #%0000000001000000,D6 * is it a long op?
00001612  6600 0012                812          BNE     NOTLONGMOVEM2  * no, it is a word
00001616                           813          
00001616  43F9 000028FB            814          LEA     __L,A1  * Load '.L ' to the window
0000161C  103C 000E                815          MOVE.B  #14,D0  * Indicate task #14
00001620  4E4F                     816          TRAP    #15     * Perform trap task #14
00001622                           817          
00001622  6000 000E                818          BRA     SKIPNOTLONG2 * It was a long, so skip label for word
00001626                           819          
00001626                           820  NOTLONGMOVEM2 * This label handles printing .W for MOVEM
00001626                           821  
00001626  43F9 000028F7            822          LEA     __W,A1  * Load ',W ' to the window
0000162C  103C 000E                823          MOVE.B  #14,D0  * Indicate task #14
00001630  4E4F                     824          TRAP    #15     * Perform trap task #14
00001632                           825                  
00001632                           826  SKIPNOTLONG2 * This label handles printing the source and dest regs of MOVEM
00001632                           827  
00001632  6100 0EF4                828          BSR     MOVEMHELPERPRE  * Branch to a helper function that prints
00001636                           829                                  * multiple source registers
00001636                           830                                  
00001636  43F9 000028E5            831          LEA     COMMA,A1    * Load ',' to the window
0000163C  103C 000E                832          MOVE.B  #14,D0      * Indicate task #14
00001640  4E4F                     833          TRAP    #15         * Perform trap task #14
00001642                           834          
00001642  6100 0930                835          BSR     EAHELPER05 * Print out the register we are moving to
00001646                           836          
00001646  341A                     837          MOVE.W  (A2)+,D2    * Walk the pointer forward, move data into D2
00001648                           838          
00001648  43F9 00002829            839          LEA     NEWLINE,A1  * Load a newline to the window
0000164E  103C 000E                840          MOVE.B  #14,D0      * Indicate task #14
00001652  4E4F                     841          TRAP    #15         * Perform trap task #14
00001654                           842      
00001654  6000 0162                843          BRA     DONE0100    * Found and printed the OP, move on to the next iteration
00001658                           844  
00001658                           845  NOTMOVEM * This label processes JSR
00001658                           846  
00001658                           847          * prep values for BITMASK subroutine
00001658  7C06                     848          MOVE.L  #6,D6   * Load 6 into D6, indicating the starting bit
0000165A  7E08                     849          MOVE.L  #8,D7   * Load 8 into D7, indicating the ending bit
0000165C                           850          
0000165C  6100 1162                851          BSR     BITMASK * Generate a bitmask
00001660                           852          
00001660  CC42                     853          AND     D2,D6   * Apply bitmask to OPcode
00001662                           854          
00001662  0C46 0080                855          CMPI    #%0000000010000000,D6   * Check the masked bits to see if JSR
00001666  6600 0046                856          BNE     NOTJSR          * It's not JSR
0000166A                           857          
0000166A  43F9 00002852            858          LEA     JSROP,A1    * Load 'JSR' to the window
00001670  103C 000E                859          MOVE.B  #14,D0      * Indicate task #14
00001674  4E4F                     860          TRAP    #15         * Perform trap task #14
00001676                           861          
00001676  43F9 000028DF            862          LEA     SPACE,A1    * Load ' ' to the window
0000167C  103C 000E                863          MOVE.B  #14,D0      * Indicate task #14
00001680  4E4F                     864          TRAP    #15         * Perform trap task #14
00001682                           865          
00001682  43F9 000028E1            866          LEA     DOLLAR,A1   * Load '$' to the window
00001688  103C 000E                867          MOVE.B  #14,D0      * Indicate task #14
0000168C  4E4F                     868          TRAP    #15         * Perform trap task #14
0000168E                           869          
0000168E                           870          * print out where we are jumping to
0000168E                           871          
0000168E  241A                     872          MOVE.L  (A2)+,D2 * read in the next word of the instruction
00001690                           873  
00001690  2E02                     874          MOVE.L  D2,D7   * Move the second word of the OP into D7
00001692                           875  
00001692  2C47                     876          MOVE.L  D7,A6   * Move the second word of the OP into A6
00001694                           877          
00001694  4283                     878          CLR.L   D3      * Clear D3, it is to be used as a parameter
00001696                           879          
00001696  163C 0008                880          MOVE.B  #8,D3   * Indicate the number of nibbles we wish to print
0000169A                           881          
0000169A  6100 0EE4                882          BSR     PRINT_ASCII_HEX_CHAR * Call helper for printing hex
0000169E                           883          
0000169E  43F9 00002829            884          LEA     NEWLINE,A1  * Load a newline to the window
000016A4  103C 000E                885          MOVE.B  #14,D0      * Indicate task #14
000016A8  4E4F                     886          TRAP    #15         * Perform trap task #14
000016AA                           887          
000016AA  6000 010C                888          BRA     DONE0100 * found instruction, move out of subroutine
000016AE                           889          
000016AE                           890  NOTJSR * This label processes RTS
000016AE                           891  
000016AE                           892          * prep values for BITMASK subroutine
000016AE  7C06                     893          MOVE.L  #6,D6   * Load 6 into D6, indicating the starting bit
000016B0  7E08                     894          MOVE.L  #8,D7   * Load 8 into D7, indicating the ending bit
000016B2                           895          
000016B2  6100 110C                896          BSR     BITMASK * Generate a bitmask
000016B6                           897          
000016B6  CC42                     898          AND     D2,D6   * Apply the bitmask to the OPcode
000016B8                           899          
000016B8  0C46 0040                900          CMPI    #%0000000001000000,D6 * Check to see if it is RTS
000016BC  6600 0012                901          BNE     NOTRTS          * it's not RTS
000016C0                           902          
000016C0  43F9 00002856            903          LEA     RTSOP,A1    * Load 'RTS' to the window
000016C6  103C 000D                904          MOVE.B  #13,D0      * Indicate task #13
000016CA  4E4F                     905          TRAP    #15         * Perform trap task #13
000016CC                           906          
000016CC  6000 00EA                907          BRA     DONE0100 * found instruction, move out of subroutine
000016D0                           908          
000016D0                           909  NOTRTS * This label processes LEA
000016D0                           910         
000016D0                           911          * prep values for BITMASK subroutine
000016D0  7C06                     912          MOVE.L  #6,D6   * Load 6 into D6, indicating the starting bit
000016D2  7E08                     913          MOVE.L  #8,D7   * Load 8 into D7, indicating the ending bit
000016D4                           914          
000016D4  6100 10EA                915          BSR     BITMASK * Generate the bitmask
000016D8                           916          
000016D8  CC42                     917          AND     D2,D6   * Apply bitmask to the OPcode
000016DA                           918          
000016DA  0C46 01C0                919          CMPI    #%0000000111000000,D6 * Is it LEA?
000016DE  6600 00D4                920          BNE     UNKNOWN0100          * It's not LEA, we dont know what it is
000016E2                           921          
000016E2                           922          * prep values for BITMASK subroutine
000016E2  7C03                     923          MOVE.L  #3,D6   * Load 3 into D6, indicating the starting bit
000016E4  7E05                     924          MOVE.L  #5,D7   * Load 5 into D7, indicating the ending bit
000016E6                           925          
000016E6  6100 10D8                926          BSR     BITMASK * Generate bitmask
000016EA                           927          
000016EA  CC42                     928          AND     D2,D6   * Apply bitmask to the OPcode
000016EC                           929          
000016EC  0C46 0008                930          CMPI    #%0000000000001000,D6 * Check for invalid mode
000016F0  6700 00C2                931          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000016F4                           932          
000016F4  0C46 0018                933          CMPI    #%0000000000011000,D6 * Check for invalid mode
000016F8  6700 00BA                934          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
000016FC                           935          
000016FC  0C46 0020                936          CMPI    #%0000000000100000,D6 * Check for invalid mode
00001700  6700 00B2                937          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001704                           938          
00001704  0C46 0028                939          CMPI    #%0000000000101000,D6 * Check for invalid mode
00001708  6700 00AA                940          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
0000170C                           941          
0000170C  0C46 0030                942          CMPI    #%0000000000110000,D6 * Check for invalid mode
00001710  6700 00A2                943          BEQ     UNKNOWN0100          * it's not LEA, we dont know what it is
00001714                           944          
00001714  0C46 0038                945          CMPI    #%0000000000111000,D6 * Check to see if two word LEA
00001718  6700 0048                946          BEQ     TWOWORDLEA          * it's a two word LEA
0000171C                           947          
0000171C  43F9 0000285F            948          LEA     LEAOP,A1    * Load 'LEA' to the window
00001722  103C 000E                949          MOVE.B  #14,D0      * Indicate task #14
00001726  4E4F                     950          TRAP    #15         * Perform trap task #14
00001728                           951          
00001728  0882 0007                952          BCLR    #7,D2   * Clear this bit so that the EA helper knows the mode
0000172C  0882 0008                953          BCLR    #8,D2   * Clear this bit so that the EA helper knows the mode
00001730                           954          
00001730  43F9 000028DF            955          LEA     SPACE,A1    * Load ' ' to the window
00001736  103C 000E                956          MOVE.B  #14,D0      * Indicate task #14
0000173A  4E4F                     957          TRAP    #15         * Perform trap task #14
0000173C                           958          
0000173C  7602                     959          MOVE.L  #2,D3       * Indicate the size of a potential immediate
0000173E                           960          
0000173E  6100 0834                961          BSR     EAHELPER05  * Call eahelper to print the source
00001742                           962          
00001742  43F9 000028E5            963          LEA     COMMA,A1    * Load ',' to the window
00001748  103C 000E                964          MOVE.B  #14,D0      * Indicate task #14
0000174C  4E4F                     965          TRAP    #15         * Perform trap task #14
0000174E                           966          
0000174E  6100 07E2                967          BSR     EAHELPER611 * Call eahelper to print the destination
00001752                           968          
00001752  43F9 00002829            969          LEA     NEWLINE,A1  * Load newline to the window
00001758  103C 000E                970          MOVE.B  #14,D0      * Indicate task #14
0000175C  4E4F                     971          TRAP    #15         * Perform trap task #14
0000175E                           972                  
0000175E  6000 0058                973          BRA     DONE0100 * instruction identified, move on to next iteration
00001762                           974          
00001762                           975  TWOWORDLEA * This label processes two word LEA
00001762                           976  
00001762  43F9 0000285F            977          LEA     LEAOP,A1    * Load ',' to the window
00001768  103C 000E                978          MOVE.B  #14,D0      * Indicate task #14
0000176C  4E4F                     979          TRAP    #15         * Perform trap task #14
0000176E                           980          
0000176E  43F9 000028DF            981          LEA     SPACE,A1    * Load ',' to the window
00001774  103C 000E                982          MOVE.B  #14,D0      * Indicate task #14
00001778  4E4F                     983          TRAP    #15         * Perform trap task #14
0000177A                           984  
0000177A  321A                     985          MOVE.W  (A2)+,D1    * Move the next word of the instruction into D1
0000177C                           986          
0000177C  7C00                     987          MOVE.L  #0,D6   * Load 0 into D6, indicating the starting bit
0000177E  7E0F                     988          MOVE.L  #15,D7  * Load 15 into D6, indicating the ending bit
00001780                           989          
00001780  6100 103E                990          BSR     BITMASK * Generate bitmask
00001784                           991          
00001784  C286                     992          AND.L   D6,D1   * Shave off any bad info
00001786                           993          
00001786  103C 0003                994          MOVE.B  #3,D0   * Print the address which was the source
0000178A  4E4F                     995          TRAP    #15     * Perform trap task #3
0000178C                           996          
0000178C  43F9 000028E5            997          LEA     COMMA,A1    * Load ',' to the window
00001792  103C 000E                998          MOVE.B  #14,D0      * Indicate task #14
00001796  4E4F                     999          TRAP    #15         * Perform trap task #14
00001798                          1000          
00001798  0882 0007               1001          BCLR    #7,D2   * Clear this bit so that the EA helper knows the mode
0000179C  0882 0008               1002          BCLR    #8,D2   * Clear this bit so that the EA helper knows the mode
000017A0                          1003          
000017A0  6100 0790               1004          BSR     EAHELPER611 * print out the destination
000017A4                          1005          
000017A4  43F9 00002829           1006          LEA     NEWLINE,A1  * Load ',' to the window
000017AA  103C 000E               1007          MOVE.B  #14,D0      * Indicate task #14
000017AE  4E4F                    1008          TRAP    #15         * Perform trap task #14
000017B0                          1009          
000017B0  6000 0006               1010          BRA     DONE0100    * We ID'd the OP, leave subroutine
000017B4                          1011          
000017B4                          1012  UNKNOWN0100 * If we didn't identify the OP, branch here
000017B4                          1013  
000017B4  6100 0DA0               1014          BSR     UNKNOWNOP * prints out unknown operations
000017B8                          1015          
000017B8                          1016  DONE0100
000017B8  4C9F 0303               1017          MOVEM   (A7)+,D0-D1/A0-A1 * Pop off the stack to return our registers
000017BC  4E75                    1018          RTS
000017BE                          1019          
000017BE                          1020  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000017BE                          1021  *-----------------------------------------------------------------------------
000017BE                          1022        
000017BE                          1023          
000017BE                          1024          
000017BE                          1025  
000017BE                          1026  *-----------------------------------------------------------------------------
000017BE                          1027  *-----------------------------------------------------------------------------
000017BE                          1028  * NAME: OP_0101   (SUBQ)
000017BE                          1029  * DESCRIPTION:    Determines the instruction by using bit-level logic.
000017BE                          1030  * PRE-CONDITION:  xyz
000017BE                          1031  * POST-CONDITION: All registers return to their previous state, and the output
000017BE                          1032  *                 goes to the output console for reading the raw data or the
000017BE                          1033  *                 actual instruction.
000017BE                          1034  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
000017BE                          1035  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000017BE                          1036  OP0101
000017BE  48A7 FFC0               1037          MOVEM   D0-D7/A0-A1,-(A7)       * Push values to the stack to save
000017C2                          1038  
000017C2  CC7C 0100               1039          AND     #%0000000100000000, D6  * Baby-Bitmask for the 8th digit.
000017C6  0C46 0100               1040          CMPI    #%0000000100000000, D6  * Is the 8th digit a 1?
000017CA  6700 005A               1041          BEQ     UNKNOWN0101             * If so, unknown op
000017CE                          1042        
000017CE  0C46 0100               1043          CMPI    #%0000000100000000, D6  * Is the size 11, an unsupported value?
000017D2  6700 0052               1044          BEQ     UNKNOWN0101             * If so, unknown op
000017D6                          1045            
000017D6                          1046          * Verified SUBQ at this point
000017D6  43F9 0000285A           1047          LEA     SUBQOP,A1           * Print out SUBQ
000017DC  103C 000E               1048          MOVE.B  #14,D0              * Trap #14 to print out
000017E0  4E4F                    1049          TRAP    #15                 * Perform Trap #14
000017E2                          1050                          
000017E2  6100 0AD6               1051          BSR     SIZE67              * Print out size
000017E6                          1052          
000017E6  43F9 000028E3           1053          LEA     IMD,A1              * Formatting
000017EC  103C 000E               1054          MOVE.B  #14,D0              * Trap #14 prints out space
000017F0  4E4F                    1055          TRAP    #15                 * Perform Trap #14
000017F2                          1056          
000017F2  3C3C 0009               1057          MOVE.W  #9, D6              * Prep lower value for bitmask
000017F6  3E3C 000B               1058          MOVE.W  #11,D7              * Prep upper value for bitmask
000017FA  6100 0FC4               1059          BSR     BITMASK             * Finalize bitmask setup
000017FE  CC42                    1060          AND     D2,D6               * Apply bitmask
00001800                          1061          
00001800  6100 0F0C               1062          BSR     PRINTDATA911        * Special op for immediate in bits 9->11
00001804                          1063            
00001804  43F9 000028E5           1064          LEA     COMMA,A1            * Formatting
0000180A  103C 000E               1065          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000180E  4E4F                    1066          TRAP    #15                 * Perform Trap #14
00001810                          1067          
00001810  6100 0762               1068          BSR     EAHELPER05          * Print out the Effective Address
00001814                          1069          
00001814  43F9 00002829           1070          LEA     NEWLINE,A1          * Formatting
0000181A  103C 000E               1071          MOVE.B  #14,D0              * Trap #14 prints out a comma
0000181E  4E4F                    1072          TRAP    #15                 * Perform Trap #14
00001820                          1073          
00001820  4C9F 03FF               1074          MOVEM   (A7)+,D0-D7/A0-A1   * Pop off the stack to return our registers
00001824  4E75                    1075          RTS
00001826                          1076      
00001826                          1077  UNKNOWN0101
00001826  6100 0D2E               1078          BSR     UNKNOWNOP
0000182A  4E75                    1079          RTS
0000182C                          1080  
0000182C                          1081  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000182C                          1082  *-----------------------------------------------------------------------------
0000182C                          1083  
0000182C                          1084  
0000182C                          1085  
0000182C                          1086  *-----------------------------------------------------------------------------
0000182C                          1087  *-----------------------------------------------------------------------------
0000182C                          1088  * NAME: OP_0110   (BCC, BCS, BGE, BLT, BVC, BRA)
0000182C                          1089  * DESCRIPTION:    Determines the instruction by using bit-level logic.
0000182C                          1090  * PRE-CONDITION:  Given the possibilties for 0110, masks the next 4 bits
0000182C                          1091  *                 in the instruction and determines what the bits match to a
0000182C                          1092  *                 given condition code. If the 8 bit offset is $00, or $FF,
0000182C                          1093  *                 this signifies a word or long offset (for $00 and $FF
0000182C                          1094  *                 respectively). The 8 bit offset is in 2's comp. form, and
0000182C                          1095  *                 should be un-done, then plus or minus to the current
0000182C                          1096  *                 program counter (PC) to get the actual memory label to
0000182C                          1097  *                 output to console. The word offset signal eats an
0000182C                          1098  *                 additional 16 bits and the long offset eats an additional
0000182C                          1099  *                 32 bits. The word/long offset are for memory alignment.
0000182C                          1100  * POST-CONDITION: All registers return to their previous state, and the output
0000182C                          1101  *                 goes to the output console for reading the raw data or the
0000182C                          1102  *                 actual instruction.
0000182C                          1103  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
0000182C                          1104  *                 A1 (output)
0000182C                          1105  * CONDITIONS TABLE:
0000182C                          1106  *                Condition Names  - Mnemonic - Condition Code
0000182C                          1107  *                --------------------------------------------
0000182C                          1108  *                True             -    T     - 0000
0000182C                          1109  *                False            -    F     - 0001
0000182C                          1110  *                Higher           -    HI    - 0010
0000182C                          1111  *                Lower or Same    -    LS    - 0011
0000182C                          1112  *                Carry Clear      -    CC    - 0100
0000182C                          1113  *                Carry Set        -    CS    - 0101
0000182C                          1114  *                Not Equal        -    NE    - 0110
0000182C                          1115  *                Equal            -    EQ    - 0111
0000182C                          1116  *                Overflow Clear   -    VC    - 1000
0000182C                          1117  *                Overflow Set     -    VS    - 1001
0000182C                          1118  *                Plus             -    PL    - 1010
0000182C                          1119  *                Minus            -    MI    - 1011
0000182C                          1120  *                Greater or Equal -    GE    - 1100
0000182C                          1121  *                Less Than        -    LT    - 1101
0000182C                          1122  *                Greater Than     -    GT    - 1110
0000182C                          1123  *                Less or Equal    -    LE    - 1111
0000182C                          1124  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000182C  48E7 FFC2               1125  OP0110  MOVEM.L D0-D7/A0-A1/A6,-(A7) * Save main method routine vars to stack
00001830                          1126                          
00001830  3C3C 0009               1127          MOVE.W  #9,D6  * Move in 9 to D6
00001834  3E3C 000B               1128          MOVE.W  #11,D7 * Move in 11 to D7
00001838                          1129                                        
00001838  6100 0F86               1130          BSR     BITMASK * Call BITMASK sub-routine, Returns a bitmask in D6
0000183C  CC42                    1131          AND     D2,D6   * apply the BITMASK
0000183E                          1132          
0000183E  0C46 0400               1133          CMPI    #%0000010000000000,D6 * CASE 1: BCC - BINARY FOR "CARRY CLEAR" FLAG
00001842  6700 0032               1134          BEQ     OP_BCC
00001846  0C46 0500               1135          CMPI    #%0000010100000000,D6 * CASE 2: BCS - BINARY FOR "CARRY SET" FLAG
0000184A  6700 0034               1136          BEQ     OP_BCS
0000184E  0C46 0C00               1137          CMPI    #%0000110000000000,D6 * CASE 3: BGE - BINARY FOR "GREATER OR EQUAL" FLAG
00001852  6700 0036               1138          BEQ     OP_BGE
00001856  0C46 0D00               1139          CMPI    #%0000110100000000,D6 * CASE 4: BLT - BINARY FOR "LESS THAN" FLAG
0000185A  6700 0038               1140          BEQ     OP_BLT
0000185E  0C46 0800               1141          CMPI    #%0000100000000000,D6 * CASE 5: BVC - BINARY FOR "OVERFLOW CLEAR" FLAG
00001862  6700 003A               1142          BEQ     OP_BVC
00001866  0C46 0000               1143          CMPI    #%0000000000000000,D6 * CASE 6: BRA - BINARY FOR "BRANCH ALWAYS" FLAG
0000186A  6700 003C               1144          BEQ     OP_BRA
0000186E  6100 0CE6               1145          BSR     UNKNOWNOP             * don't know what it is, print it out, skip to end
00001872  6000 00C4               1146          BRA     BCC_END
00001876                          1147  
00001876  43F9 0000289D           1148  OP_BCC  LEA     OP_BCC_MSG,A1
0000187C  6000 0034               1149          BRA     OP_BRANCHES_PRINT
00001880  43F9 000028A2           1150  OP_BCS  LEA     OP_BCS_MSG,A1
00001886  6000 002A               1151          BRA     OP_BRANCHES_PRINT
0000188A  43F9 000028A7           1152  OP_BGE  LEA     OP_BGE_MSG,A1
00001890  6000 0020               1153          BRA     OP_BRANCHES_PRINT
00001894  43F9 000028AC           1154  OP_BLT  LEA     OP_BLT_MSG,A1
0000189A  6000 0016               1155          BRA     OP_BRANCHES_PRINT
0000189E  43F9 000028B1           1156  OP_BVC  LEA     OP_BVC_MSG,A1
000018A4  6000 000C               1157          BRA     OP_BRANCHES_PRINT
000018A8  43F9 000028B6           1158  OP_BRA  LEA     OP_BRA_MSG,A1
000018AE  6000 0002               1159          BRA     OP_BRANCHES_PRINT
000018B2                          1160  OP_BRANCHES_PRINT
000018B2  103C 000E               1161          MOVE.B  #14,D0 * print instruction op, chosen from cases directly above
000018B6  4E4F                    1162          TRAP    #15
000018B8                          1163          
000018B8  43F9 000028E1           1164          LEA     DOLLAR,A1
000018BE  103C 000E               1165          MOVE.B  #14,D0 * print raw data hex of the LABEL
000018C2  4E4F                    1166          TRAP    #15
000018C4                          1167          
000018C4  3C3C 0000               1168          MOVE.W  #0,D6                 * Move in 0 to D6 - prep mask
000018C8  3E3C 0007               1169          MOVE.W  #7,D7                 * Move in 7 to D7
000018CC  6100 0EF2               1170          BSR     BITMASK               * Call BITMASK sub-routine, return in D6
000018D0  CC42                    1171          AND     D2,D6                 * AND mask with op bits, get last 8 bits in D6
000018D2                          1172          
000018D2  0C46 0000               1173          CMPI    #%00000000,D6         * all 0's == word offset
000018D6  6700 0028               1174          BEQ     BCC_WORD_OFFSET
000018DA                          1175          
000018DA  0C46 00FF               1176          CMPI    #%11111111,D6         * all F's == long offset
000018DE  6700 003E               1177          BEQ     BCC_LONG_OFFSET
000018E2                          1178  BCC_BYTE_OFFSET
000018E2  E18E                    1179          LSL.L   #8,D6
000018E4  E18E                    1180          LSL.L   #8,D6
000018E6  E18E                    1181          LSL.L   #8,D6
000018E8                          1182          
000018E8  2C46                    1183          MOVE.L  D6,A6
000018EA  7602                    1184          MOVE.L  #2,D3
000018EC                          1185          
000018EC  6100 0C92               1186          BSR     PRINT_ASCII_HEX_CHAR
000018F0                          1187          
000018F0  43F9 00002829           1188          LEA     NEWLINE,A1
000018F6  103C 000E               1189          MOVE.B  #14,D0
000018FA  4E4F                    1190          TRAP    #15
000018FC                          1191          
000018FC  6000 003A               1192          BRA     BCC_END
00001900                          1193  BCC_WORD_OFFSET
00001900                          1194  
00001900  3C1A                    1195          MOVE.W  (A2)+,D6
00001902                          1196  
00001902  E18E                    1197          LSL.L   #8,D6
00001904  E18E                    1198          LSL.L   #8,D6
00001906                          1199          
00001906  2C46                    1200          MOVE.L  D6,A6
00001908  7604                    1201          MOVE.L  #4,D3
0000190A                          1202          
0000190A  6100 0C74               1203          BSR     PRINT_ASCII_HEX_CHAR
0000190E                          1204          
0000190E  43F9 00002829           1205          LEA     NEWLINE,A1
00001914  103C 000E               1206          MOVE.B  #14,D0
00001918  4E4F                    1207          TRAP    #15
0000191A                          1208          
0000191A  6000 001C               1209          BRA     BCC_END
0000191E                          1210  BCC_LONG_OFFSET
0000191E                          1211  
0000191E  2C1A                    1212          MOVE.L  (A2)+,D6
00001920                          1213  
00001920  2C46                    1214          MOVE.L  D6,A6
00001922  7608                    1215          MOVE.L  #8,D3
00001924                          1216          
00001924  6100 0C5A               1217          BSR     PRINT_ASCII_HEX_CHAR
00001928                          1218          
00001928  43F9 00002829           1219          LEA     NEWLINE,A1
0000192E  103C 000E               1220          MOVE.B  #14,D0
00001932  4E4F                    1221          TRAP    #15
00001934                          1222          
00001934  6000 0002               1223          BRA     BCC_END
00001938                          1224  BCC_END * reload the memory, call RTS
00001938  4CDF 43FF               1225          MOVEM.L (A7)+,D0-D7/A0-A1/A6 * Pop off the stack to return our registers
0000193C  4E75                    1226          RTS
0000193E                          1227  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000193E                          1228  *-----------------------------------------------------------------------------
0000193E                          1229  
0000193E                          1230  
0000193E                          1231  
0000193E                          1232  *-----------------------------------------------------------------------------
0000193E                          1233  *-----------------------------------------------------------------------------
0000193E                          1234  * NAME: OP_0111   ()
0000193E                          1235  * DESCRIPTION:    OP code 0111 is not supported. 
0000193E                          1236  * PRE-CONDITION:  
0000193E                          1237  * POST-CONDITION: 
0000193E                          1238  * REGISTERS:
0000193E                          1239  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000193E                          1240  OP0111
0000193E  6100 0C16               1241      BSR     UNKNOWNOP
00001942  4E75                    1242      RTS
00001944                          1243  
00001944                          1244  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001944                          1245  *-----------------------------------------------------------------------------
00001944                          1246  
00001944                          1247  
00001944                          1248  
00001944                          1249  *-----------------------------------------------------------------------------
00001944                          1250  *-----------------------------------------------------------------------------
00001944                          1251  * NAME: OP_1000   (DIVS, OR)
00001944                          1252  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001944                          1253  * PRE-CONDITION:  xyz
00001944                          1254  * POST-CONDITION: All registers return to their previous state, and the output
00001944                          1255  *                 goes to the output console for reading the raw data or the
00001944                          1256  *                 actual instruction.
00001944                          1257  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001944                          1258  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001944                          1259  OP1000
00001944  48A7 FFC0               1260          MOVEM   D0-D7/A0-A1,-(A7)   * Saving values to the stack
00001948                          1261  
00001948                          1262          * Check if the EA Mode is 001 since both DIVS and OR do not support it
00001948  3C3C 0003               1263          MOVE.W  #3, D6              * Prep lower value for bitmask
0000194C  3E3C 0005               1264          MOVE.W  #5, D7              * Prep upper value for bitmask
00001950  6100 0E6E               1265          BSR     BITMASK             * Finalize bitmask setup
00001954  CC42                    1266          AND     D2,D6               * Apply bitmask
00001956                          1267          
00001956  0C46 0008               1268          CMPI    #%0000000000001000, D6  * Is the mode 001, an unsupported mode?
0000195A  6700 0BFA               1269          BEQ     UNKNOWNOP                 * If so, the op is not supported
0000195E                          1270          
0000195E                          1271          * Checking for DIVS
0000195E  3C3C 0006               1272          MOVE.W  #6, D6              * Prep lower value for bitmask
00001962  3E3C 0008               1273          MOVE.W  #8, D7              * Prep upper value for bitmask
00001966  6100 0E58               1274          BSR     BITMASK             * Finalize bitmask setup
0000196A  CC42                    1275          AND     D2,D6               * Apply bitmask
0000196C                          1276          
0000196C  0C46 01C0               1277          CMPI    #%0000000111000000, D6  * Are we DIVS?
00001970  6600 0050               1278          BNE     NOTDIVS                 * If not, branch to see if it's OR
00001974                          1279          
00001974  43F9 0000282C           1280          LEA     DIVSOP,A1           * We found DIVS
0000197A  103C 000E               1281          MOVE.B  #14,D0              * Trap #14 prints out the data
0000197E  4E4F                    1282          TRAP    #15                 * Perform Trap #14
00001980                          1283          
00001980  43F9 000028DF           1284          LEA     SPACE,A1            * formatting
00001986  103C 000E               1285          MOVE.B  #14,D0              * Trap #14 prints out space
0000198A  4E4F                    1286          TRAP    #15                 * Perform Trap #14
0000198C                          1287          
0000198C  4243                    1288          CLR     D3                  * clear D3, it is a parameter of ea05 to indicate size
0000198E  08C3 0000               1289          BSET    #0,D3               * in this case it is always word, so set the first bit of D3
00001992                          1290                                      * to indicate a potential immediate of size word
00001992                          1291          
00001992  6100 05E0               1292          BSR     EAHELPER05          * Print out data
00001996                          1293  
00001996  43F9 000028E5           1294          LEA     COMMA,A1            * formatting
0000199C  103C 000E               1295          MOVE.B  #14,D0              * Trap #14 prints out a comma
000019A0  4E4F                    1296          TRAP    #15                 * Perform Trap #14
000019A2                          1297          
000019A2                          1298          * bit manipulation is needed to make DIVS work
000019A2                          1299          * with the generic EAHELPER611
000019A2  0882 0006               1300          BCLR    #6,D2               * This signifies that
000019A6  0882 0007               1301          BCLR    #7,D2               * we are dealing with
000019AA  0882 0008               1302          BCLR    #8,D2               * a data register
000019AE                          1303       
000019AE  6100 0582               1304          BSR     EAHELPER611 
000019B2                          1305  
000019B2  43F9 00002829           1306          LEA     NEWLINE,A1          * We found DIVS
000019B8  103C 000E               1307          MOVE.B  #14,D0              * Trap #14 prints out the data
000019BC  4E4F                    1308          TRAP    #15                 * Perform Trap #14
000019BE                          1309          
000019BE  6000 0056               1310          BRA     OP1000END           * Move onto next iteration
000019C2                          1311          
000019C2                          1312  NOTDIVS 
000019C2                          1313          * Checking for invalid OPMODEs 011 and 111
000019C2  0C46 00C0               1314          CMPI    #%0000000011000000, D6      * Is the OPMODE 011, unsupported by OR?
000019C6  6700 004A               1315          BEQ     UNKNOWN1000                 * If so, the OP is unknown
000019CA  0C46 01C0               1316          CMPI    #%0000000111000000, D6      * Is the OPMODE 111, unsupported by OR?
000019CE  6700 0042               1317          BEQ     UNKNOWN1000                 * If so, the OP is unknown
000019D2                          1318  
000019D2                          1319          * It is confirmed OR at this point
000019D2  43F9 0000286E           1320          LEA     OROP,A1         * We found OR
000019D8  103C 000E               1321          MOVE.B  #14,D0          * Trap #14 prints out the data
000019DC  4E4F                    1322          TRAP    #15             * Perform Trap #14
000019DE                          1323  
000019DE  6100 091E               1324          BSR     SIZE68          * print out the size
000019E2                          1325          
000019E2  6100 0590               1326          BSR     EAHELPER05      * print out the EA
000019E6                          1327          
000019E6  43F9 000028E5           1328          LEA     COMMA,A1        * formatting
000019EC  103C 000E               1329          MOVE.B  #14,D0          * Trap #14 prints out comma
000019F0  4E4F                    1330          TRAP    #15             * Perform Trap #1
000019F2                          1331          
000019F2                          1332          * bit manipulation is needed to make EAHELPER611 work
000019F2  0882 0006               1333          BCLR    #6,D2           
000019F6  0882 0007               1334          BCLR    #7,D2
000019FA  0882 0008               1335          BCLR    #8,D2
000019FE                          1336               
000019FE  6100 0532               1337          BSR     EAHELPER611      * Print out register  
00001A02                          1338          
00001A02  43F9 00002829           1339          LEA     NEWLINE,A1       * formatting
00001A08  103C 000E               1340          MOVE.B  #14,D0           * Trap #14 prints out comma
00001A0C  4E4F                    1341          TRAP    #15              * Perform Trap #1
00001A0E                          1342          
00001A0E  6000 00C0               1343          BRA     DONE1001         * pop values back
00001A12                          1344          
00001A12                          1345  UNKNOWN1000
00001A12  6100 0B42               1346          BSR     UNKNOWNOP       * Op is unknown
00001A16                          1347  
00001A16                          1348  OP1000END
00001A16  4C9F 03FF               1349          MOVEM   (A7)+,D0-D7/A0-A1   * pop values back
00001A1A  4E75                    1350          RTS                         * return to main
00001A1C                          1351  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001A1C                          1352  *-----------------------------------------------------------------------------
00001A1C                          1353  
00001A1C                          1354  
00001A1C                          1355  
00001A1C                          1356  *-----------------------------------------------------------------------------
00001A1C                          1357  *-----------------------------------------------------------------------------
00001A1C                          1358  * NAME: OP_1001   (SUB)
00001A1C                          1359  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001A1C                          1360  * PRE-CONDITION:  xyz
00001A1C                          1361  * POST-COND        BSR     SIZE68      * pr    int out the sizesizeate, and the output
00001A1C                          1362  *                 goes to the output console for reading the raw data or the
00001A1C                          1363  *                 actual instruction.
00001A1C                          1364  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001A1C                          1365  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001A1C                          1366  OP1001
00001A1C  48A7 FFC0               1367          MOVEM   D0-D7/A0-A1,-(A7)   * Saving values to the stack
00001A20                          1368          
00001A20  3C3C 0006               1369          MOVE.W  #6, D6              * Prep lower value for bitmask
00001A24  3E3C 0008               1370          MOVE.W  #8, D7              * Prep upper value for bitmask
00001A28  6100 0D96               1371          BSR     BITMASK             * Finalize bitmask setup
00001A2C  CC42                    1372          AND     D2,D6               * Apply bitmask
00001A2E                          1373          
00001A2E                          1374          * Check to see if opmode is unsupported for both EOR and CMP
00001A2E  0C46 00C0               1375          CMPI    #%0000000011000000, D6      * Is the OPMODE 011, unsupported by SUB?
00001A32  6700 0098               1376          BEQ     UNKNOWN1001                 * If so, the OP is unknown
00001A36  0C46 01C0               1377          CMPI    #%0000000111000000, D6      * Is the OPMODE 111, unsupported by SUB?
00001A3A  6700 0090               1378          BEQ     UNKNOWN1001                 * If so, the OP is unknown
00001A3E                          1379            
00001A3E                          1380          * Check to see if the opmode is EA v Dn -> Dn
00001A3E  0C46 0000               1381          CMPI    #%0000000000000000, D6      * Is the OPMODE 000, a BYTE for EA v DN?
00001A42  6700 0070               1382          BEQ     SUB_EA_DN                   * If so, branch to SUB_EA_DN
00001A46  0C46 0040               1383          CMPI    #%0000000001000000, D6      * Is the OPMODE 001, a WORD for EA v DN?
00001A4A  6700 0068               1384          BEQ     SUB_EA_DN                   * If so, branch to SUB_EA_DN
00001A4E  0C46 0080               1385          CMPI    #%0000000010000000, D6      * Is the OPMODE 010, a LONG for EA v DN?
00001A52  6700 0060               1386          BEQ     SUB_EA_DN                   * If so, branch to SUB_EA_DN
00001A56                          1387          
00001A56                          1388          * Need to see if the size is a BYTE and the mode is An direct
00001A56                          1389          * Since this is not supported
00001A56  3C3C 0003               1390          MOVE.W  #3, D6              * Prep lower value for bitmask
00001A5A  3E3C 0008               1391          MOVE.W  #8, D7              * Prep upper value for bitmask
00001A5E  6100 0D60               1392          BSR     BITMASK             * Finalize bitmask setup
00001A62  CC42                    1393          AND     D2,D6               * Apply bitmask
00001A64                          1394          
00001A64  0C46 0108               1395          CMPI    #%0000000100001000, D6      * Is the mode 001 and is a byte?
00001A68  6700 0062               1396          BEQ     UNKNOWN1001                 * If so, unsupported op
00001A6C                          1397          
00001A6C                          1398          * Verified to be SUB_DN_EA here
00001A6C  0C46 0000               1399          CMPI    #%0000000000000000, D6      * Is the  000, a BYTE for EA v DN?
00001A70  6700 0042               1400          BEQ     SUB_EA_DN                   * If so, branch to SUB_EA_DN
00001A74                          1401  
00001A74                          1402  PRINT1001   
00001A74  43F9 00002892           1403          LEA     SUBOP,A1    * We found SUB
00001A7A  103C 000E               1404          MOVE.B  #14,D0      * Trap #14 prints out a comma
00001A7E  4E4F                    1405          TRAP    #15         * Perform Trap #14
00001A80                          1406          
00001A80  6100 087C               1407          BSR     SIZE68      * print out the size
00001A84                          1408          
00001A84  6100 04EE               1409          BSR     EAHELPER05
00001A88                          1410          
00001A88                          1411          * bit manipulation is needed to make EAHELPER611 work
00001A88  0882 0006               1412          BCLR    #6,D2
00001A8C  0882 0007               1413          BCLR    #7,D2
00001A90  0882 0008               1414          BCLR    #8,D2
00001A94                          1415               
00001A94  43F9 000028E5           1416          LEA     COMMA,A1            * formatting
00001A9A  103C 000E               1417          MOVE.B  #14,D0              * Trap #14 prints out comma
00001A9E  4E4F                    1418          TRAP    #15                 * Perform Trap #1
00001AA0                          1419          
00001AA0  6100 0490               1420          BSR     EAHELPER611 
00001AA4                          1421          
00001AA4  43F9 00002829           1422          LEA     NEWLINE,A1          * formatting
00001AAA  103C 000E               1423          MOVE.B  #14,D0              * Trap #14 prints out comma
00001AAE  4E4F                    1424          TRAP    #15                 * Perform Trap #1
00001AB0                          1425          
00001AB0  6000 001E               1426          BRA     DONE1001
00001AB4                          1427          
00001AB4                          1428  SUB_EA_DN
00001AB4                          1429          * SUBA is not supported and must be checked
00001AB4  3C3C 0003               1430          MOVE.W  #3, D6              * Prep lower value for bitmask
00001AB8  3E3C 0005               1431          MOVE.W  #5, D7              * Prep upper value for bitmask
00001ABC  6100 0D02               1432          BSR     BITMASK             * Finalize bitmask setup
00001AC0  CC42                    1433          AND     D2,D6               * Apply bitmask
00001AC2                          1434          
00001AC2  0C46 0008               1435          CMPI    #%0000000000001000, D6      * Is the mode 001, an unsupported mode for SUB?
00001AC6  6700 0004               1436          BEQ     UNKNOWN1001                 * If so, branch to UNKNOWN100
00001ACA                          1437          
00001ACA  60A8                    1438          BRA     PRINT1001           * Verified to be valid at this point
00001ACC                          1439          
00001ACC                          1440  UNKNOWN1001
00001ACC  6100 0A88               1441          BSR     UNKNOWNOP           * Unknown op
00001AD0                          1442          
00001AD0                          1443  DONE1001
00001AD0  4C9F 03FF               1444          MOVEM   (A7)+,D0-D7/A0-A1   * Return vales
00001AD4  4E75                    1445          RTS                         * Return to main
00001AD6                          1446  
00001AD6                          1447  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001AD6                          1448  *-----------------------------------------------------------------------------
00001AD6                          1449  
00001AD6                          1450  
00001AD6                          1451  
00001AD6                          1452  *-----------------------------------------------------------------------------
00001AD6                          1453  *-----------------------------------------------------------------------------
00001AD6                          1454  * NAME: OP_1010   ()
00001AD6                          1455  * DESCRIPTION:    a
00001AD6                          1456  * PRE-CONDITION:  b
00001AD6                          1457  * POST-CONDITION: c
00001AD6                          1458  * REGISTERS:      d
00001AD6                          1459  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001AD6                          1460  OP1010
00001AD6                          1461  
00001AD6  6100 0A7E               1462      BSR     UNKNOWNOP
00001ADA  4E75                    1463      RTS
00001ADC                          1464  
00001ADC                          1465  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001ADC                          1466  *-----------------------------------------------------------------------------
00001ADC                          1467  
00001ADC                          1468  
00001ADC                          1469  
00001ADC                          1470  *-----------------------------------------------------------------------------
00001ADC                          1471  *-----------------------------------------------------------------------------
00001ADC                          1472  * NAME: OP_1011   (EOR, CMP)
00001ADC                          1473  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001ADC                          1474  * PRE-CONDITION:  xyz
00001ADC                          1475  * POST-CONDITION: All registers return to their previous state, and the output
00001ADC                          1476  *                 goes to the output console for reading the raw data or the
00001ADC                          1477  *                 actual instruction.
00001ADC                          1478  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001ADC                          1479  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001ADC                          1480  OP1011
00001ADC                          1481  
00001ADC  48A7 FFC0               1482          MOVEM   D0-D7/A0-A1,-(A7)   * Saving values to the stack
00001AE0                          1483  
00001AE0  3C3C 0006               1484          MOVE.W  #6, D6              * Prep lower value for bitmask
00001AE4  3E3C 0008               1485          MOVE.W  #8, D7              * Prep upper value for bitmask
00001AE8  6100 0CD6               1486          BSR     BITMASK             * Finalize bitmask setup
00001AEC  CC42                    1487          AND     D2,D6               * Apply bitmask
00001AEE                          1488          
00001AEE                          1489          * Check to see if opmode is unsupported for both EOR and CMP
00001AEE  0C46 00C0               1490          CMPI    #%0000000011000000, D6      * Is the OPMODE 011, unsupported by EOR/CMP?
00001AF2  6700 0088               1491          BEQ     UNKNOWN1011                 * If so, the OP is unknown
00001AF6  0C46 01C0               1492          CMPI    #%0000000111000000, D6      * Is the OPMODE 111, unsupported by EOR/CMP?
00001AFA  6700 0080               1493          BEQ     UNKNOWN1011                 * If so, the OP is unknown
00001AFE                          1494          
00001AFE                          1495          * Check to see if it is CMP
00001AFE  0C46 0000               1496          CMPI    #%0000000000000000, D6      * Is the OPMODE 000, a BYTE for CMP?
00001B02  6700 0038               1497          BEQ     NOTEOR                      * If so, the OP is CMP
00001B06  0C46 0040               1498          CMPI    #%0000000001000000, D6      * Is the OPMODE 000, a WORD for CMP?
00001B0A  6700 0030               1499          BEQ     NOTEOR                      * If so, the OP is CMP
00001B0E  0C46 0080               1500          CMPI    #%0000000010000000, D6      * Is the OPMODE 000, a LONG for CMP?
00001B12  6700 0028               1501          BEQ     NOTEOR                      * If so, the OP is CMP
00001B16                          1502  
00001B16                          1503          * Check to see EA mode is 001, unsupported by EOR
00001B16  3C3C 0003               1504          MOVE.W  #3, D6              * Prep lower value for bitmask
00001B1A  3E3C 0005               1505          MOVE.W  #5, D7              * Prep upper value for bitmask
00001B1E  6100 0CA0               1506          BSR     BITMASK             * Finalize bitmask setup
00001B22  CC42                    1507          AND     D2,D6               * Apply bitmask
00001B24                          1508          
00001B24  0C46 0040               1509          CMPI    #%0000000001000000, D6      * Is the mode 001, unsupported for EOR?
00001B28  6700 0052               1510          BEQ     UNKNOWN1011                 * If so, the op is unknown
00001B2C                          1511          
00001B2C                          1512          * Verified to be EOR at this point
00001B2C  43F9 00002835           1513          LEA     EOROP,A1            * We found EOR
00001B32  103C 000E               1514          MOVE.B  #14,D0              * Trap #14 prints out the data
00001B36  4E4F                    1515          TRAP    #15                 * Perform Trap #14
00001B38                          1516          
00001B38  6000 000E               1517          BRA     DISPLAY1011         * Branch to the end of 1011       
00001B3C                          1518  
00001B3C                          1519  NOTEOR
00001B3C  43F9 00002831           1520          LEA     CMPOP,A1            * We found CMP
00001B42  103C 000E               1521          MOVE.B  #14,D0              * Trap #14 prints out the data
00001B46  4E4F                    1522          TRAP    #15                 * Perform Trap #14
00001B48                          1523          
00001B48                          1524  DISPLAY1011
00001B48  6100 07B4               1525          BSR     SIZE68
00001B4C                          1526          
00001B4C  6100 0426               1527          BSR     EAHELPER05
00001B50                          1528          
00001B50  43F9 000028E5           1529          LEA     COMMA,A1            * Formatting
00001B56  103C 000E               1530          MOVE.B  #14,D0              * Trap #14 prints out the data
00001B5A  4E4F                    1531          TRAP    #15                 * Perform Trap #14
00001B5C                          1532          
00001B5C  0882 0006               1533          BCLR    #6,D2               * Bit manipulation is 
00001B60  0882 0007               1534          BCLR    #7,D2               * necessary in order to make
00001B64  0882 0008               1535          BCLR    #8,D2               * EAHELPER611 work generically
00001B68                          1536          
00001B68  6100 03C8               1537          BSR     EAHELPER611         * Print out EA
00001B6C                          1538          
00001B6C  43F9 00002829           1539          LEA     NEWLINE,A1          * Formatting
00001B72  103C 000E               1540          MOVE.B  #14,D0              * Trap #14 prints out the data
00001B76  4E4F                    1541          TRAP    #15                 * Perform Trap #14
00001B78                          1542          
00001B78  6000 0006               1543          BRA     DONE1011            * Branch to end 1011 and move to next op
00001B7C                          1544          
00001B7C                          1545  UNKNOWN1011
00001B7C  6100 09D8               1546          BSR     UNKNOWNOP           * Unknown op
00001B80                          1547                   
00001B80                          1548  DONE1011
00001B80  4C9F 03FF               1549          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
00001B84  4E75                    1550          RTS                         * Return to main
00001B86                          1551  
00001B86                          1552  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001B86                          1553  *-----------------------------------------------------------------------------
00001B86                          1554  
00001B86                          1555  
00001B86                          1556  
00001B86                          1557  *-----------------------------------------------------------------------------
00001B86                          1558  *-----------------------------------------------------------------------------
00001B86                          1559  * NAME: OP_1100   (MULS)
00001B86                          1560  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001B86                          1561  * PRE-CONDITION:  xyz
00001B86                          1562  * POST-CONDITION: All registers return to their previous state, and the output
00001B86                          1563  *                 goes to the output console for reading the raw data or the
00001B86                          1564  *                 actual instruction.
00001B86                          1565  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001B86                          1566  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001B86                          1567  OP1100
00001B86  48A7 FFC0               1568          MOVEM   D0-D7/A0-A1,-(A7)   * Saving values to the stack
00001B8A                          1569  
00001B8A                          1570          * Check if the EA Mode is 001 since MULS does not support it
00001B8A  3C3C 0003               1571          MOVE.W  #3, D6              * Prep lower value for bitmask
00001B8E  3E3C 0005               1572          MOVE.W  #5, D7              * Prep upper value for bitmask
00001B92  6100 0C2C               1573          BSR     BITMASK             * Finalize bitmask setup
00001B96  CC42                    1574          AND     D2,D6               * Apply bitmask
00001B98                          1575          
00001B98  0C46 0008               1576          CMPI    #%0000000000001000, D6    * Is the mode 001, an unsupported mode?
00001B9C  6700 0068               1577          BEQ     UNKNOWN1100               * If so, the op is not supported
00001BA0                          1578          
00001BA0  3C3C 0006               1579          MOVE.W  #6, D6              * Prep lower value for bitmask
00001BA4  3E3C 0008               1580          MOVE.W  #8, D7              * Prep upper value for bitmask
00001BA8  6100 0C16               1581          BSR     BITMASK             * Finalize bitmask setup
00001BAC  CC42                    1582          AND     D2,D6               * Apply bitmask
00001BAE                          1583          
00001BAE  0C46 01C0               1584          CMPI    #%0000000111000000, D6  * Are we MULS?
00001BB2  6600 0052               1585          BNE     UNKNOWN1100             * If not, it is an unknown op
00001BB6                          1586          
00001BB6  43F9 00002869           1587          LEA     MULSOP,A1           * We found MULS
00001BBC  103C 000E               1588          MOVE.B  #14,D0              * Trap #14 prints out the data
00001BC0  4E4F                    1589          TRAP    #15                 * Perform Trap #14
00001BC2                          1590          
00001BC2  43F9 000028DF           1591          LEA     SPACE,A1            * formatting
00001BC8  103C 000E               1592          MOVE.B  #14,D0              * Trap #14 prints out space
00001BCC  4E4F                    1593          TRAP    #15                 * Perform Trap #14
00001BCE                          1594          
00001BCE  4243                    1595          CLR     D3                  * clear D3, it is a parameter
00001BD0  08C3 0000               1596          BSET    #0,D3               * of EAHELPER05 to indicate size
00001BD4                          1597          
00001BD4  6100 039E               1598          BSR     EAHELPER05          * Print out data
00001BD8                          1599  
00001BD8  43F9 000028E5           1600          LEA     COMMA,A1            * formatting
00001BDE  103C 000E               1601          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001BE2  4E4F                    1602          TRAP    #15                 * Perform Trap #14
00001BE4                          1603          
00001BE4  0882 0006               1604          BCLR    #6,D2               * Bit manipulation is 
00001BE8  0882 0007               1605          BCLR    #7,D2               * necessary in order to make
00001BEC  0882 0008               1606          BCLR    #8,D2               * EAHELPER611 work generically
00001BF0                          1607          
00001BF0  6100 0340               1608          BSR     EAHELPER611         * Print out EA
00001BF4                          1609  
00001BF4  43F9 00002829           1610          LEA     NEWLINE,A1          * Formatting
00001BFA  103C 000E               1611          MOVE.B  #14,D0              * Trap #14 prints out the data
00001BFE  4E4F                    1612          TRAP    #15                 * Perform Trap #14
00001C00                          1613          
00001C00  4C9F 03FF               1614          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
00001C04  4E75                    1615          RTS                         * Return to main
00001C06                          1616          
00001C06                          1617  UNKNOWN1100
00001C06  6100 094E               1618          BSR     UNKNOWNOP
00001C0A                          1619       
00001C0A  4C9F 03FF               1620          MOVEM   (A7)+,D0-D7/A0-A1   * Done identifying op
00001C0E  4E75                    1621          RTS                         * Return to main
00001C10                          1622          
00001C10                          1623  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001C10                          1624  *-----------------------------------------------------------------------------
00001C10                          1625  
00001C10                          1626  
00001C10                          1627  
00001C10                          1628  
00001C10                          1629  
00001C10                          1630  
00001C10                          1631  *-----------------------------------------------------------------------------
00001C10                          1632  *-----------------------------------------------------------------------------
00001C10                          1633  * NAME: OP_1101   (ADD, ADDA)
00001C10                          1634  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001C10                          1635  * PRE-CONDITION:  xyz
00001C10                          1636  * POST-CONDITION: All registers return to their previous state, and the output
00001C10                          1637  *                 goes to the output console for reading the raw data or the
00001C10                          1638  *                 actual instruction.
00001C10                          1639  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001C10                          1640  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001C10                          1641  OP1101
00001C10  48E7 FFFE               1642          MOVEM.L A0-A6/D0-D7,-(A7)
00001C14                          1643          
00001C14  3C3C 0006               1644          MOVE.W  #6, D6              * Prep lower value for bitmask
00001C18  3E3C 0008               1645          MOVE.W  #8, D7              * Prep upper value for bitmask
00001C1C  6100 0BA2               1646          BSR     BITMASK             * Finalize bitmask setup
00001C20  CC42                    1647          AND     D2,D6               * Apply bitmask
00001C22  EC4E                    1648          LSR     #6,D6               * LSR by 6 to get the necessary bits
00001C24                          1649  
00001C24  0C06 0000               1650          CMPI.B  #%0000000000000000,D6   * Compare bits for 000 (base 2)
00001C28  6700 003E               1651          BEQ     BYTE_EA_DN
00001C2C                          1652  
00001C2C  0C06 0001               1653          CMPI.B  #%0000000000000001,D6   * Compare bits for 001 (base 2)    
00001C30  6700 004E               1654          BEQ     WORD_EA_DN
00001C34                          1655  
00001C34  0C06 0002               1656          CMPI.B  #%0000000000000010,D6   * Compare bits for 010 (base 2)
00001C38  6700 005E               1657          BEQ     LONG_EA_DN
00001C3C                          1658  
00001C3C  0C06 0003               1659          CMPI.B  #%0000000000000011,D6   * Compare bits for 011 (base 2)
00001C40  6700 006E               1660          BEQ     ADDA_WORD_OP
00001C44                          1661  
00001C44  0C06 0004               1662          CMPI.B  #%0000000000000100,D6   * Compare bits for 100 (base 2)
00001C48  6700 0086               1663          BEQ     BYTE_DN_EA
00001C4C                          1664  
00001C4C  0C06 0005               1665          CMPI.B  #%0000000000000101,D6   * Compare bits for 101 (base 2)
00001C50  6700 0096               1666          BEQ     WORD_DN_EA
00001C54                          1667  
00001C54  0C06 0006               1668          CMPI.B  #%0000000000000110,D6   * Compare bits for 110 (base 2)
00001C58  6700 00A6               1669          BEQ     LONG_DN_EA
00001C5C                          1670  
00001C5C  0C06 0007               1671          CMPI.B  #%0000000000000111,D6   * Compare bits for 111 (base 2)    
00001C60  6700 00B6               1672          BEQ     ADDA_LONG_OP
00001C64                          1673  
00001C64  6000 011E               1674          BRA     ADD_ADDA_END            * Unknown, break to end of routine/exit
00001C68                          1675          
00001C68                          1676  BYTE_EA_DN
00001C68  6100 00CE               1677          BSR     ADD_EA_DN_GENERIC       * print out 'ADD' base op name for ADDA too
00001C6C                          1678  
00001C6C  43F9 000028F3           1679          LEA     __B,A1                  * print out size (BYTE)
00001C72  103C 000E               1680          MOVE.B  #14,D0                  * trap #14 to print it out
00001C76  4E4F                    1681          TRAP    #15                     * perform trap #14
00001C78                          1682  
00001C78  6100 00CC               1683          BSR     ADD_ADDA_SPACE          * print out space
00001C7C  6000 00EE               1684          BRA     ADD_ADDA_PRINT          * Go to specific printing now
00001C80                          1685  
00001C80                          1686  WORD_EA_DN
00001C80  6100 00B6               1687          BSR     ADD_EA_DN_GENERIC       * print out 'ADD' base op name for ADDA too
00001C84                          1688  
00001C84  43F9 000028F7           1689          LEA     __W,A1                  * print out size (WORD)
00001C8A  103C 000E               1690          MOVE.B  #14,D0                  * Trap #14 to print it out
00001C8E  4E4F                    1691          TRAP    #15                     * perform Trap #14
00001C90                          1692          
00001C90  6100 00B4               1693          BSR     ADD_ADDA_SPACE          * print out space
00001C94  6000 00D6               1694          BRA     ADD_ADDA_PRINT          * perform trap #14
00001C98                          1695          
00001C98                          1696  LONG_EA_DN
00001C98  6100 009E               1697          BSR     ADD_EA_DN_GENERIC       * print out 'ADD' base op name for ADDA too
00001C9C                          1698  
00001C9C  43F9 000028FB           1699          LEA     __L,A1                  * print out size (LONG)
00001CA2  103C 000E               1700          MOVE.B  #14,D0                  * Trap #14 to print it out
00001CA6  4E4F                    1701          TRAP    #15                     * Perform trap #14
00001CA8                          1702  
00001CA8  6100 009C               1703          BSR     ADD_ADDA_SPACE          * print out space
00001CAC  6000 00BE               1704          BRA     ADD_ADDA_PRINT          * go to specific printing
00001CB0                          1705          
00001CB0                          1706  ADDA_WORD_OP
00001CB0  6100 0086               1707          BSR     ADD_EA_DN_GENERIC       * print out 'ADD' base op name for ADDA too
00001CB4                          1708  
00001CB4  43F9 000028D3           1709          LEA     ASCII_A,A1              * print out 'A'
00001CBA  103C 000E               1710          MOVE.B  #14,D0                  * Trap #14 to print it out
00001CBE  4E4F                    1711          TRAP    #15                     * Perform Trap #14
00001CC0                          1712  
00001CC0  43F9 000028F7           1713          LEA     __W,A1                  * Load '.W'
00001CC6  103C 000E               1714          MOVE.B  #14,D0                  * Trap #14 to print it out
00001CCA  4E4F                    1715          TRAP    #15                     * Perform trap #15
00001CCC                          1716          
00001CCC  6000 0086               1717          BRA     ADDA_PRT                * Specific printing for ADDA
00001CD0                          1718          
00001CD0                          1719  BYTE_DN_EA
00001CD0  6100 0066               1720          BSR     ADD_EA_DN_GENERIC       * print out 'ADD' base op name for ADDA too
00001CD4                          1721          
00001CD4  43F9 000028F3           1722          LEA     __B,A1                  * Load '.B' 
00001CDA  103C 000E               1723          MOVE.B  #14,D0                  * Trap #14 to print it out
00001CDE  4E4F                    1724          TRAP    #15                     * Perform Trap #14
00001CE0                          1725          
00001CE0  6100 0064               1726          BSR     ADD_ADDA_SPACE          * print out a SPACE
00001CE4  6000 0086               1727          BRA     ADD_ADDA_PRINT          * print out PRINT
00001CE8                          1728  
00001CE8                          1729  WORD_DN_EA
00001CE8  6100 004E               1730          BSR     ADD_EA_DN_GENERIC       * Print out ADD
00001CEC                          1731  
00001CEC  43F9 000028F7           1732          LEA     __W,A1                  * Print out .W
00001CF2  103C 000E               1733          MOVE.B  #14,D0                  * Trap #14 to print it out
00001CF6  4E4F                    1734          TRAP    #15                     * Perform Trap #14
00001CF8                          1735  
00001CF8  6100 004C               1736          BSR     ADD_ADDA_SPACE          * Print SPACE
00001CFC  6000 006E               1737          BRA     ADD_ADDA_PRINT          * Specific Printing
00001D00                          1738  
00001D00                          1739  LONG_DN_EA
00001D00  6100 0036               1740          BSR     ADD_EA_DN_GENERIC       * Print out ADD base
00001D04                          1741          
00001D04  43F9 000028FB           1742          LEA     __L,A1                  * Print out Long
00001D0A  103C 000E               1743          MOVE.B  #14,D0                  * Trap #14 to print it out
00001D0E  4E4F                    1744          TRAP    #15                     * Perform Trap #14
00001D10                          1745          
00001D10  6100 0034               1746          BSR     ADD_ADDA_SPACE          * Print out a space
00001D14  6000 0056               1747          BRA     ADD_ADDA_PRINT          * Specific printing
00001D18                          1748  
00001D18                          1749  ADDA_LONG_OP
00001D18  6100 001E               1750          BSR     ADD_EA_DN_GENERIC       * Print out 'ADD' base
00001D1C                          1751          
00001D1C  43F9 000028D3           1752          LEA     ASCII_A,A1              * Print out 'A'
00001D22  103C 000E               1753          MOVE.B  #14,D0                  * Trap #14 to print it out
00001D26  4E4F                    1754          TRAP    #15                     * Perform Trap #14
00001D28                          1755          
00001D28  43F9 000028FB           1756          LEA     __L,A1                  * Print out a .L
00001D2E  103C 000E               1757          MOVE.B  #14,D0                  * Trap #14 to print it out
00001D32  4E4F                    1758          TRAP    #15                     * Perform Trap #14
00001D34                          1759          
00001D34  6000 001E               1760          BRA     ADDA_PRT                * Go to specific printing
00001D38                          1761          
00001D38                          1762  ADD_EA_DN_GENERIC
00001D38  43F9 000028BB           1763          LEA     OP_ADD_MSG,A1           * print out 'ADD'
00001D3E  103C 000E               1764          MOVE.B  #14,D0                  * Trap #14 to print it out
00001D42  4E4F                    1765          TRAP    #15                     * Perform Trap #14
00001D44  4E75                    1766          RTS                             * Return to whatever called this
00001D46                          1767          
00001D46                          1768  ADD_ADDA_SPACE
00001D46  43F9 000028DF           1769          LEA     SPACE,A1                * Print out a space
00001D4C  103C 000E               1770          MOVE.B  #14,D0                  * Trap #14 to print it out
00001D50  4E4F                    1771          TRAP    #15                     * Perform Trap #14
00001D52  4E75                    1772          RTS                             * Return.
00001D54                          1773  
00001D54                          1774  ADDA_PRT
00001D54  6100 0364               1775          BSR     MODE_DN                 * Break to print out Dn register
00001D58  43F9 000028E5           1776          LEA     COMMA,A1                * Print out comma
00001D5E  103C 000E               1777          MOVE.B  #14,D0                  * Trap #14 to print it out
00001D62  4E4F                    1778          TRAP    #15                     * Perform Trap #14
00001D64  6100 0454               1779          BSR     MODE_AN                 * Break to print out An Register
00001D68  6000 001A               1780          BRA     ADD_ADDA_END            * Go to end of routine
00001D6C                          1781  
00001D6C                          1782  ADD_ADDA_PRINT
00001D6C                          1783  
00001D6C  6100 0206               1784          BSR     EAHELPER05          * Use EA Helper subroutine for printing out ADDA
00001D70                          1785  
00001D70  43F9 000028E5           1786          LEA     COMMA,A1            * formatting
00001D76  103C 000E               1787          MOVE.B  #14,D0              * Trap #14 prints out a comma
00001D7A  4E4F                    1788          TRAP    #15                 * Perform Trap #14
00001D7C                          1789          
00001D7C  6100 01B4               1790          BSR     EAHELPER611         * Use EA Helper subroutine for printing out ADDA
00001D80  6000 0002               1791          BRA     ADD_ADDA_END        * Go to end of subroutine
00001D84                          1792          
00001D84                          1793  ADD_ADDA_END
00001D84  43F9 00002829           1794          LEA     NEWLINE,A1          * Print out a new line
00001D8A  103C 000E               1795          MOVE.B  #14,D0              * Trap #14 to print it out
00001D8E  4E4F                    1796          TRAP    #15                 * Perform Trap #14
00001D90                          1797          
00001D90  4CDF 7FFF               1798          MOVEM.L (A7)+,A0-A6/D0-D7   * Pop back saved values
00001D94  4E75                    1799          RTS                         * Return to main
00001D96                          1800  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001D96                          1801  *-----------------------------------------------------------------------------
00001D96                          1802  
00001D96                          1803  
00001D96                          1804  
00001D96                          1805  *-----------------------------------------------------------------------------
00001D96                          1806  *-----------------------------------------------------------------------------
00001D96                          1807  * NAME: OP_1110   (LSL, LSR, ASL, ASR, ROL, ROR)
00001D96                          1808  * DESCRIPTION:    Determines the instruction by using bit-level logic.
00001D96                          1809  * PRE-CONDITION:  xyz
00001D96                          1810  * POST-CONDITION: All registers return to their previous state, and the output
00001D96                          1811  *                 goes to the output console for reading the raw data or the
00001D96                          1812  *                 actual instruction.
00001D96                          1813  * REGISTERS:      D0, D1 (output), D2 (op-code), D6 (bitmask)
00001D96                          1814  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001D96                          1815  OP1110
00001D96                          1816  
00001D96  48A7 FFC0               1817      MOVEM   D0-D7/A0-A1,-(A7)   * Caller saved
00001D9A                          1818  
00001D9A  7C03                    1819      MOVE.L  #3,D6   * Load 3 into D6, indicating the starting bit for bitmask
00001D9C  7E04                    1820      MOVE.L  #4,D7   * Load 4 into D7, indicating the ending bit for bitmask
00001D9E                          1821      
00001D9E  6100 0A20               1822      BSR     BITMASK * Generate a bitmask for the 3 and 4 bits
00001DA2                          1823      
00001DA2  CC82                    1824      AND.L   D2,D6   * Apply the bitmask to the OPcode
00001DA4                          1825      
00001DA4  0C46 0008               1826      CMPI    #%0000000000001000,D6 * Is it a logical shift?
00001DA8  6700 001A               1827      BEQ     LS
00001DAC                          1828      
00001DAC  0C46 0000               1829      CMPI    #%0000000000000000,D6 * Is it an arithmatic shift?
00001DB0  6700 0048               1830      BEQ     AS
00001DB4                          1831      
00001DB4  0C46 0018               1832      CMPI    #%0000000000011000,D6 * Is it a rotate?
00001DB8  6700 0076               1833      BEQ     RO
00001DBC                          1834  
00001DBC  6100 0798               1835      BSR     UNKNOWNOP * If none of the above, it's not an OP we identify
00001DC0                          1836      
00001DC0  6000 0158               1837      BRA     ENDOP1110 * Branch to the unknownop part of the subroutine
00001DC4                          1838      
00001DC4                          1839  LS * This label handles LS
00001DC4                          1840  
00001DC4  7C08                    1841      MOVE.L  #8,D6   * Load 8 into D6, indicating the starting bit for bitmask
00001DC6  7E08                    1842      MOVE.L  #8,D7   * Load 8 into D7, indicating the ending bit for bitmask
00001DC8                          1843      
00001DC8  6100 09F6               1844      BSR     BITMASK * Generate bitmask
00001DCC                          1845      
00001DCC  CC82                    1846      AND.L   D2,D6 * Apply the bitmask
00001DCE                          1847      
00001DCE  0C46 0000               1848      CMPI    #0,D6 * Is it a left shift?
00001DD2  6700 0016               1849      BEQ     LSR
00001DD6                          1850      
00001DD6  6000 0002               1851      BRA     LSL * If not a left shift, must be right
00001DDA                          1852  
00001DDA                          1853  LSL * This label handles LSL
00001DDA                          1854  
00001DDA  43F9 0000287A           1855      LEA     LSLOP,A1            * Load 'LSL' to the window
00001DE0  103C 000E               1856      MOVE.B  #14,D0              * Trap #14 prints out LSL
00001DE4  4E4F                    1857      TRAP    #15                 * Perform Trap #14
00001DE6                          1858      
00001DE6  6000 007E               1859      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001DEA                          1860                                  * prints registers and imm data
00001DEA                          1861  LSR * This label handles LSR
00001DEA                          1862  
00001DEA  43F9 0000287E           1863      LEA     LSROP,A1            * Load 'LSR' to the window
00001DF0  103C 000E               1864      MOVE.B  #14,D0              * Trap #14 prints out LSR
00001DF4  4E4F                    1865      TRAP    #15                 * Perform Trap #14
00001DF6                          1866      
00001DF6  6000 006E               1867      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001DFA                          1868                                  * prints the registers and imm data
00001DFA                          1869  
00001DFA                          1870  AS * This label handles AS
00001DFA                          1871  
00001DFA  7C08                    1872      MOVE.L  #8,D6   * Load 8 into D6, indicating the starting bit for bitmask
00001DFC  7E08                    1873      MOVE.L  #8,D7   * Load 8 into D7, indicating the ending bit for bitmask
00001DFE                          1874      
00001DFE  6100 09C0               1875      BSR     BITMASK * Generate bitmask
00001E02                          1876      
00001E02  CC82                    1877      AND.L   D2,D6   * Apply bitmask to OPcode
00001E04                          1878      
00001E04  0C46 0000               1879      CMPI    #0,D6 * Is it a left shift?
00001E08  6700 0016               1880      BEQ     ASR
00001E0C                          1881      
00001E0C  6000 0002               1882      BRA     ASL * If not a left shift, must be right
00001E10                          1883      
00001E10                          1884  ASL * This label handles ASL
00001E10                          1885  
00001E10  43F9 00002882           1886      LEA     ASLOP,A1            * Load 'ASL' to the window
00001E16  103C 000E               1887      MOVE.B  #14,D0              * Trap #14 prints out ASL
00001E1A  4E4F                    1888      TRAP    #15                 * Perform Trap #14
00001E1C                          1889      
00001E1C  6000 0048               1890      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001E20                          1891                                  * prints the registers and imm data
00001E20                          1892  ASR * This label handles ASR
00001E20                          1893  
00001E20  43F9 00002886           1894      LEA     ASROP,A1            * Load 'ASR' to the window
00001E26  103C 000E               1895      MOVE.B  #14,D0              * Trap #14 prints out ASR
00001E2A  4E4F                    1896      TRAP    #15                 * Perform Trap #14
00001E2C                          1897      
00001E2C  6000 0038               1898      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001E30                          1899                                  * prints the registers and imm data
00001E30                          1900  RO * This label handles RO
00001E30                          1901  
00001E30  7C08                    1902      MOVE.L  #8,D6   * Load 8 into D6, indicating the starting bit for bitmask
00001E32  7E08                    1903      MOVE.L  #8,D7   * Load 8 into D7, indicating the ending bit for bitmask
00001E34                          1904      
00001E34  6100 098A               1905      BSR     BITMASK * Generate bitmask
00001E38                          1906      
00001E38  CC82                    1907      AND.L   D2,D6   Apply bitmask to OPcode
00001E3A                          1908      
00001E3A  0C46 0000               1909      CMPI    #0,D6 * Is it a left shift?
00001E3E  6700 0016               1910      BEQ     ROR
00001E42                          1911      
00001E42  6000 0002               1912      BRA     ROL * If not a left shift, must be right
00001E46                          1913  
00001E46                          1914  ROL * This label handles ROL
00001E46                          1915  
00001E46  43F9 0000288A           1916      LEA     ROLOP,A1            * Load 'ROL' to the window
00001E4C  103C 000E               1917      MOVE.B  #14,D0              * Trap #14 prints out ROL
00001E50  4E4F                    1918      TRAP    #15                 * Perform Trap #14
00001E52                          1919      
00001E52  6000 0012               1920      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001E56                          1921                                  * prints the registers and imm data
00001E56                          1922  ROR * This label handles ROR
00001E56                          1923  
00001E56  43F9 0000288E           1924      LEA     ROROP,A1            * Load 'ROR' to the window
00001E5C  103C 000E               1925      MOVE.B  #14,D0              * Trap #14 prints out ROR
00001E60  4E4F                    1926      TRAP    #15                 * Perform Trap #14
00001E62                          1927      
00001E62  6000 0002               1928      BRA     OP1110GENERIC       * a generic part of OP1110 that
00001E66                          1929                                  * prints the registers and imm data
00001E66                          1930  
00001E66                          1931  OP1110GENERIC * This label handles the parts of OP1110 that are common
00001E66                          1932  
00001E66  6100 0452               1933      BSR     SIZE67  * Print the size of the operation
00001E6A                          1934      
00001E6A  7C05                    1935      MOVE.L  #5,D6   * Load 5 into D6, indicating the starting bit for bitmask
00001E6C  7E05                    1936      MOVE.L  #5,D7   * Load 5 into D7, indicating the ending bit for bitmask
00001E6E                          1937      
00001E6E  6100 0950               1938      BSR     BITMASK * Genereate bitmask
00001E72                          1939      
00001E72  CC82                    1940      AND.L   D2,D6   * Apply bitmask
00001E74                          1941      
00001E74  0C46 0020               1942      CMPI    #%0000000000100000,D6   * Is it a data reg?
00001E78  6700 0074               1943      BEQ     OP1110DATAREG
00001E7C                          1944      
00001E7C  43F9 000028E3           1945      LEA     IMD,A1  * Load '#' to the window
00001E82  103C 000E               1946      MOVE.B  #14,D0  * Trap #14 prints out pound #
00001E86  4E4F                    1947      TRAP    #15     * Perform Trap #14
00001E88                          1948      
00001E88  7C09                    1949      MOVE.L  #9,D6   * Load 9 into D6, indicating the starting bit for bitmask
00001E8A  7E0B                    1950      MOVE.L  #11,D7  * Load 11 into D7, indicating the ending bit for bitmask
00001E8C                          1951      
00001E8C  6100 0932               1952      BSR     BITMASK * Generate bitmask
00001E90                          1953      
00001E90  CC82                    1954      AND.L   D2,D6   * Apply bitmask to the OPcode
00001E92                          1955      
00001E92  0C46 0000               1956      CMPI    #0,D6 * special case, if zero print #8 not #0
00001E96  6700 002E               1957      BEQ     OP1110IMMEIGHT
00001E9A                          1958      
00001E9A  E08E                    1959      LSR.L   #8,D6   * Shift the size over for easy printing
00001E9C  E28E                    1960      LSR.L   #1,D6   * Shift the size over for easy printing
00001E9E                          1961      
00001E9E  2206                    1962      MOVE.L  D6,D1   * Load the size of the immediate into D1
00001EA0  103C 0003               1963      MOVE.B  #3,D0   * Trap #14 prints out the number in D1
00001EA4  4E4F                    1964      TRAP    #15     * Perform Trap #14
00001EA6                          1965      
00001EA6  43F9 000028E5           1966      LEA     COMMA,A1    * Load ',' to the window
00001EAC  103C 000E               1967      MOVE.B  #14,D0      * Trap #14 prints out comma
00001EB0  4E4F                    1968      TRAP    #15         * Perform Trap #1
00001EB2                          1969      
00001EB2                          1970      * in order to use the eahlpers, we need to do some bit manipulation
00001EB2                          1971      * clearing the bits below lets our helper know that the mode is Dn
00001EB2  0882 0003               1972      BCLR    #3,D2
00001EB6  0882 0004               1973      BCLR    #4,D2
00001EBA  0882 0005               1974      BCLR    #5,D2
00001EBE                          1975      
00001EBE  6100 00B4               1976      BSR     EAHELPER05 * Print out the destination REG
00001EC2                          1977      
00001EC2  6000 0056               1978      BRA     ENDOP1110 * We have identified and printed the OP, leave subroutine
00001EC6                          1979      
00001EC6                          1980  OP1110IMMEIGHT * This label processes the special case where immediate == 0
00001EC6                          1981  
00001EC6  7208                    1982      MOVE.L  #8,D1              * Load 8 into D1 to be printed
00001EC8  103C 0003               1983      MOVE.B  #3,D0              * Trap #3 prints out the number in D1
00001ECC  4E4F                    1984      TRAP    #15                * Perform Trap #14
00001ECE                          1985      
00001ECE  43F9 000028E5           1986      LEA     COMMA,A1            * Load ',' to the window
00001ED4  103C 000E               1987      MOVE.B  #14,D0              * Trap #14 prints out comma
00001ED8  4E4F                    1988      TRAP    #15                 * Perform Trap #1
00001EDA                          1989      
00001EDA                          1990      * in order to use the eahlpers, we need to do some bit manipulation
00001EDA                          1991      * clearing the bits below lets our helper know that the mode is Dn
00001EDA  0882 0003               1992      BCLR    #3,D2
00001EDE  0882 0004               1993      BCLR    #4,D2
00001EE2  0882 0005               1994      BCLR    #5,D2
00001EE6                          1995      
00001EE6  6100 008C               1996      BSR     EAHELPER05 * Print out the destination reg
00001EEA                          1997      
00001EEA  6000 002E               1998      BRA     ENDOP1110 * Op is ID'ed and printed, move out of subroutine
00001EEE                          1999  
00001EEE                          2000  OP1110DATAREG * This label handles printing REG to REG operations
00001EEE                          2001  
00001EEE                          2002      * in order to use the eahlpers, we need to do some bit manipulation
00001EEE                          2003      * clearing the bits below lets our helper know that the mode is Dn
00001EEE  0882 0003               2004      BCLR    #3,D2
00001EF2  0882 0004               2005      BCLR    #4,D2
00001EF6  0882 0005               2006      BCLR    #5,D2
00001EFA  0882 0006               2007      BCLR    #6,D2
00001EFE  0882 0007               2008      BCLR    #7,D2
00001F02  0882 0008               2009      BCLR    #8,D2
00001F06                          2010      
00001F06  6100 002A               2011      BSR     EAHELPER611 * Print out the source register
00001F0A                          2012      
00001F0A  43F9 000028E5           2013      LEA     COMMA,A1            * Load ',' to the window
00001F10  103C 000E               2014      MOVE.B  #14,D0              * Trap #14 prints out comma
00001F14  4E4F                    2015      TRAP    #15                 * Perform Trap #14
00001F16                          2016      
00001F16  6100 005C               2017      BSR     EAHELPER05  * Op is ID'ed and printed, move out of subroutine
00001F1A                          2018  
00001F1A                          2019  ENDOP1110 * This label is jumped to after the Opcode has been processed
00001F1A                          2020  
00001F1A  43F9 00002829           2021      LEA     NEWLINE,A1          * Load a newline to the window
00001F20  103C 000E               2022      MOVE.B  #14,D0              * Trap #14 prints out a new line
00001F24  4E4F                    2023      TRAP    #15                 * Perform Trap #14
00001F26                          2024      
00001F26  4C9F 03FF               2025      MOVEM   (A7)+,D0-D7/A0-A1   * Caller saved
00001F2A  4E75                    2026      RTS
00001F2C                          2027  
00001F2C                          2028  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001F2C                          2029  *-----------------------------------------------------------------------------
00001F2C                          2030  
00001F2C                          2031  
00001F2C                          2032  
00001F2C                          2033  *-----------------------------------------------------------------------------
00001F2C                          2034  *-----------------------------------------------------------------------------
00001F2C                          2035  * NAME: OP_1111   ()
00001F2C                          2036  * DESCRIPTION:    a
00001F2C                          2037  * PRE-CONDITION:  b
00001F2C                          2038  * POST-CONDITION: c
00001F2C                          2039  * REGISTERS:      d
00001F2C                          2040  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001F2C                          2041  OP1111
00001F2C                          2042  
00001F2C  6100 0628               2043      BSR     UNKNOWNOP
00001F30  4E75                    2044      RTS
00001F32                          2045  
00001F32                          2046  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001F32                          2047  *-----------------------------------------------------------------------------
00001F32                          2048  
00001F32                          2049  
00001F32                          2050  
00001F32                          2051  *-----------------------------------------------------------------------------
00001F32                          2052  *-----------------------------------------------------------------------------
00001F32                          2053  * NAME:           EAHELPER611
00001F32                          2054  * DESCRIPTION:    a
00001F32                          2055  * PRE-CONDITION:  D2 contains the instruction to print modes for.
00001F32                          2056  *                 D5 contains the size of the data to be printed
00001F32                          2057  * POST-CONDITION: Determines if mode is direct, if it's not, passes D2 to 
00001F32                          2058  *                 EAHELPER05 to print.
00001F32                          2059  * REGISTERS:      a
00001F32                          2060  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001F32                          2061  EAHELPER611
00001F32  48A7 FFC0               2062      MOVEM  D0-D7/A0-A1,-(A7)    * Push values onto stack
00001F36                          2063      
00001F36  3C3C 0006               2064      MOVE.W  #6, D6              * Prep lower value for bitmask
00001F3A  3E3C 0008               2065      MOVE.W  #8, D7              * Prep upper value for bitmask
00001F3E                          2066      
00001F3E  6100 0880               2067      BSR     BITMASK             * Finalize bitmask setup
00001F42                          2068      
00001F42  CC42                    2069      AND     D2,D6               * Apply bitmask
00001F44                          2070      
00001F44                          2071      * to move the mode where EAHELPER50 can process it
00001F44  7C06                    2072      MOVE.L  #6,D6       * Prep lower value of bitmask
00001F46  7E08                    2073      MOVE.L  #8,D7       * Prep upper value of bitmask
00001F48  6100 0876               2074      BSR     BITMASK     * Create bitmask
00001F4C  CC42                    2075      AND     D2,D6       * Apply bitmask
00001F4E                          2076      
00001F4E  4243                    2077      CLR     D3      * prep D3 to store values
00001F50  3606                    2078      MOVE.W  D6,D3   * store bitmasked value in D3
00001F52  E64B                    2079      LSR     #3,D3   * move bits 6-8 to 3-5
00001F54                          2080      
00001F54                          2081      * to move the register where EAHELPER50 can process it
00001F54  7C09                    2082      MOVE.L  #9,D6   * Prep lower value for bitmask
00001F56  7E0B                    2083      MOVE.L  #11,D7  * Prep upper value for bitmask
00001F58  6100 0866               2084      BSR     BITMASK * create bitmask
00001F5C  CC42                    2085      AND     D2,D6   * apply bitmask
00001F5E                          2086      
00001F5E  4244                    2087      CLR     D4      * prep D3 to store values
00001F60  3806                    2088      MOVE.W  D6,D4   * store bitmasked value in D3
00001F62                          2089      
00001F62  E04C                    2090      LSR     #8,D4   * move bits 9-11 to 0-2
00001F64  E24C                    2091      LSR     #1,D4   * move bits 9-11 to 0-2
00001F66                          2092    
00001F66  8684                    2093      OR.L    D4,D3   * combind the register and mode
00001F68  2403                    2094      MOVE.L  D3,D2   * put the result in D2 so EAHELPER05 can process it
00001F6A                          2095      
00001F6A  6100 0008               2096      BSR     EAHELPER05 * the bits have been shifted to where EAHELPER05
00001F6E                          2097                         * can interperate them
00001F6E                          2098  ENDEAHELPER611
00001F6E                          2099      
00001F6E  4C9F 03FF               2100      MOVEM  (A7)+,D0-D7/A0-A1    * Restore registers
00001F72  4E75                    2101      RTS
00001F74                          2102  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00001F74                          2103  *-----------------------------------------------------------------------------
00001F74                          2104  
00001F74                          2105  
00001F74                          2106  
00001F74                          2107  *-----------------------------------------------------------------------------
00001F74                          2108  *-----------------------------------------------------------------------------
00001F74                          2109  * NAME:           EAHELPER05
00001F74                          2110  * DESCRIPTION:    a
00001F74                          2111  * PRE-CONDITION:  D2 contains the instruction to print modes for. Only call
00001F74                          2112  *                 this sub-routine helper for operations that only have one
00001F74                          2113  *                 mode register.
00001F74                          2114  *                 D3 contains the size of immediate it could be, 1 = byte
00001F74                          2115  *                 2 = word, 3 = long
00001F74                          2116  * POST-CONDITION: Determines mode, passes D2 to REGHELPER to print.
00001F74                          2117  * REGISTERS:      a
00001F74                          2118  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00001F74                          2119  EAHELPER05
00001F74                          2120      
00001F74  48A7 FFC0               2121      MOVEM   D0-D7/A0-A1,-(A7) * save stuff
00001F78                          2122      
00001F78  7C03                    2123      MOVE.L  #3,D6   * Load 3 into D6 indicating the starting bit of the bitmask
00001F7A  7E05                    2124      MOVE.L  #5,D7   * Load 5 into D7 indicating the ending bit of the bitmask
00001F7C                          2125      
00001F7C  6100 0842               2126      BSR     BITMASK * generate a bitmask to identify the mode
00001F80                          2127      
00001F80  CC42                    2128      AND     D2,D6   * mask off the parts of D2 we don't need
00001F82                          2129      
00001F82  2A06                    2130      MOVE.L  D6,D5   * store the 3-5 bitmask for later use
00001F84                          2131      
00001F84  0C46 0000               2132      CMPI    #%0000000000000000,D6 * is it data register direct?
00001F88  6600 000A               2133      BNE     NOTDATAREG
00001F8C                          2134      
00001F8C  6100 012C               2135      BSR     MODE_DN * It is data register direct, BSR to print data regs
00001F90                          2136       
00001F90  6000 0122               2137      BRA     ENDEAHELPER05 * Sucessfully printed, move out of subroutine
00001F94                          2138      
00001F94                          2139  NOTDATAREG * This label handles address register direct
00001F94                          2140      
00001F94  0C46 0008               2141      CMPI    #%0000000000001000,D6 * is it address register direct?
00001F98  6600 000A               2142      BNE     NOTADRDIRECT
00001F9C                          2143      
00001F9C  6100 021C               2144      BSR     MODE_AN * simply prints out the address register
00001FA0                          2145       
00001FA0  6000 0112               2146      BRA     ENDEAHELPER05   * Sucessfully printed, move out of subroutine
00001FA4                          2147      
00001FA4                          2148  NOTADRDIRECT * This label handles address register indirect
00001FA4                          2149          
00001FA4  0C46 0010               2150      CMPI    #%0000000000010000,D6 * is it address register indirect?
00001FA8  6600 0022               2151      BNE     NOTADRINDIRECT
00001FAC                          2152      
00001FAC  43F9 000028E7           2153      LEA     OBRACK,A1       * Load '('
00001FB2  303C 000E               2154      MOVE.W  #14,D0          * Trap #14 to display message
00001FB6  4E4F                    2155      TRAP    #15             * Perform #14
00001FB8                          2156          
00001FB8                          2157  
00001FB8  6100 0200               2158      BSR     MODE_AN * print out an address register
00001FBC                          2159      
00001FBC  43F9 000028E9           2160      LEA     CBRACK,A1       * Load ')'
00001FC2  303C 000E               2161      MOVE.W  #14,D0          * Trap #14 to display message
00001FC6  4E4F                    2162      TRAP    #15             * Perform #14
00001FC8                          2163       
00001FC8  6000 00EA               2164      BRA     ENDEAHELPER05   * Sucessfully printed, move out of subroutine
00001FCC                          2165      
00001FCC                          2166  NOTADRINDIRECT * This label handles address register indirect, post increment
00001FCC                          2167      
00001FCC  0C46 0018               2168      CMPI    #%0000000000011000,D6 * is it address register indirect post inc?
00001FD0  6600 002E               2169      BNE     NOTADRINDIRECTPOST
00001FD4                          2170      
00001FD4  43F9 000028E7           2171      LEA     OBRACK,A1       * Load '('
00001FDA  303C 000E               2172      MOVE.W  #14,D0          * Trap #14 to display message
00001FDE  4E4F                    2173      TRAP    #15             * Perform #14
00001FE0                          2174          
00001FE0                          2175  
00001FE0  6100 01D8               2176      BSR     MODE_AN * Print out an address register
00001FE4                          2177      
00001FE4  43F9 000028E9           2178      LEA     CBRACK,A1       * Load ')'
00001FEA  303C 000E               2179      MOVE.W  #14,D0          * Trap #14 to display message
00001FEE  4E4F                    2180      TRAP    #15             * Perform #14
00001FF0                          2181      
00001FF0  43F9 000028EB           2182      LEA     PLUS,A1       * Load '+'
00001FF6  303C 000E               2183      MOVE.W  #14,D0        * Trap #14 to display message
00001FFA  4E4F                    2184      TRAP    #15           * Perform #14
00001FFC                          2185       
00001FFC  6000 00B6               2186      BRA     ENDEAHELPER05   * Sucessfully printed, move out of subroutine
00002000                          2187      
00002000                          2188  NOTADRINDIRECTPOST * This label handles address register indirect, pre decrement
00002000                          2189      
00002000  0C46 0020               2190      CMPI    #%0000000000100000,D6 * is it address register indirect pre dec?
00002004  6600 002E               2191      BNE     NOTADRINDIRECTPRE
00002008                          2192      
00002008  43F9 000028ED           2193      LEA     MINUS,A1       * Load '-'
0000200E  303C 000E               2194      MOVE.W  #14,D0         * Trap #14 to display message
00002012  4E4F                    2195      TRAP    #15            * Perform #14
00002014                          2196      
00002014  43F9 000028E7           2197      LEA     OBRACK,A1       * Load '('
0000201A  303C 000E               2198      MOVE.W  #14,D0          * Trap #14 to display message
0000201E  4E4F                    2199      TRAP    #15             * Perform #14
00002020                          2200          
00002020                          2201  
00002020  6100 0198               2202      BSR     MODE_AN * Print out an address register
00002024                          2203      
00002024  43F9 000028E9           2204      LEA     CBRACK,A1       * Load ')'
0000202A  303C 000E               2205      MOVE.W  #14,D0          * Trap #14 to display message
0000202E  4E4F                    2206      TRAP    #15             * Perform #14
00002030                          2207       
00002030  6000 0082               2208      BRA     ENDEAHELPER05   * Sucessfully printed, move out of subroutine
00002034                          2209  
00002034                          2210  NOTADRINDIRECTPRE * This label handles immediate mode
00002034                          2211  
00002034  0C46 0038               2212      CMPI    #%0000000000111000,D6 * Is it immediate?
00002038  6600 0076               2213      BNE     NOTIMMEDIATE
0000203C                          2214  
0000203C  0C43 0001               2215      CMPI    #1,D3 * Is it a byte?
00002040  6600 0024               2216      BNE     NOTIMMBYTE
00002044                          2217      
00002044  43F9 000028E3           2218      LEA     IMD,A1  * Load '#'
0000204A  103C 000E               2219      MOVE.B  #14,D0  * Trap #14 to display message
0000204E  4E4F                    2220      TRAP    #15     * Perform #14
00002050                          2221      
00002050  7C00                    2222      MOVE.L  #0, D6  * Prep lower value for bitmask
00002052  7E07                    2223      MOVE.L  #7, D7  * Prep upper value for bitmask
00002054                          2224      
00002054  6100 076A               2225      BSR     BITMASK * Generate bitmask
00002058                          2226          
00002058  321A                    2227      MOVE.W  (A2)+,D1 * Read next word of instruction into D1
0000205A                          2228      
0000205A  C286                    2229      AND.L   D6,D1   * Apply bitmask to newly read word
0000205C                          2230          
0000205C  103C 0003               2231      MOVE.B  #3,D0   * Indicate trap #3
00002060  4E4F                    2232      TRAP    #15     * Perform Trap #3
00002062                          2233      
00002062  6000 0050               2234      BRA     ENDEAHELPER05   * Sucessfully printed, move out of subroutine
00002066                          2235  
00002066                          2236  NOTIMMBYTE
00002066                          2237      
00002066  0C43 0002               2238      CMPI    #2,D3 * is it a word?
0000206A  6600 0024               2239      BNE     NOTIMMWORD
0000206E                          2240      
0000206E  43F9 000028E3           2241      LEA     IMD,A1  * Load '#'    
00002074  103C 000E               2242      MOVE.B  #14,D0  * Trap #14 to display message
00002078  4E4F                    2243      TRAP    #15     * Perform #14
0000207A                          2244      
0000207A  7C00                    2245      MOVE.L  #0, D6  * Prep lower value for bitmask
0000207C  7E0F                    2246      MOVE.L  #15, D7 * Prep upper value for bitmask
0000207E                          2247      
0000207E  6100 0740               2248      BSR     BITMASK * Generate bitmask
00002082                          2249          
00002082  321A                    2250      MOVE.W  (A2)+,D1 * Read next word of operation
00002084                          2251      
00002084  C286                    2252      AND.L    D6,D1  * Apply bitmask
00002086                          2253          
00002086  103C 0003               2254      MOVE.B  #3,D0   * Indicate trap #3 
0000208A  4E4F                    2255      TRAP    #15     * Perform Trap #3
0000208C                          2256      
0000208C  6000 0026               2257      BRA     ENDEAHELPER05   * Sucessfully printed, move out of subroutine
00002090                          2258      
00002090                          2259  NOTIMMWORD
00002090  0C43 0003               2260      CMPI    #3,D3 * is it a long?
00002094  6600 001A               2261      BNE     NOTIMMEDIATE
00002098                          2262      
00002098  43F9 000028E3           2263      LEA     IMD,A1  * Load '#'
0000209E  103C 000E               2264      MOVE.B  #14,D0  * Trap #14 to display message
000020A2  4E4F                    2265      TRAP    #15     * Perform #14
000020A4                          2266          
000020A4  221A                    2267      MOVE.L  (A2)+,D1 * Read the next word of the operation into D1
000020A6                          2268          
000020A6  103C 0003               2269      MOVE.B  #3,D0   * Indicate trap #3
000020AA  4E4F                    2270      TRAP    #15     * Perform Trap #3
000020AC                          2271      
000020AC  6000 0006               2272      BRA     ENDEAHELPER05   * Sucessfully printed, move out of subroutine
000020B0                          2273  
000020B0                          2274  NOTIMMEDIATE
000020B0  6100 04A4               2275      BSR     UNKNOWNOP * Could not identify mode, BSR UNKNOWNOP
000020B4                          2276      
000020B4                          2277  ENDEAHELPER05
000020B4  4C9F 03FF               2278      MOVEM   (A7)+,D0-D7/A0-A1 * Restore Registers
000020B8  4E75                    2279      RTS
000020BA                          2280  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000020BA                          2281  *-----------------------------------------------------------------------------
000020BA                          2282  
000020BA                          2283  
000020BA                          2284  
000020BA                          2285  *-----------------------------------------------------------------------------
000020BA                          2286  *-----------------------------------------------------------------------------
000020BA                          2287  * NAME:           MODE_DN
000020BA                          2288  * DESCRIPTION:    Generalize the EA part of the project.
000020BA                          2289  * PRE-CONDITION:  The mode must have been correctly identified. All modes
000020BA                          2290  *                 must be called by RTS.
000020BA                          2291  * POST-CONDITION: After the EA, the entire op will head back to the BSR that
000020BA                          2292  *                 called it.
000020BA                          2293  * REGISTERS:      a
000020BA                          2294  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000020BA                          2295  * ---> Dn
000020BA                          2296  MODE_DN
000020BA  48A7 FFC0               2297          MOVEM   D0-D7/A0-A1,-(A7) * Save Registers
000020BE                          2298  
000020BE  3C3C 0000               2299          MOVE.W  #0, D6  * Prep lower value for bitmask
000020C2  3E3C 0002               2300          MOVE.W  #2, D7  * Prep upper value for bitmask
000020C6                          2301          
000020C6  6100 06F8               2302          BSR     BITMASK * Generate bitmask
000020CA                          2303          
000020CA  CC42                    2304          AND     D2,D6   * Apply bitmask
000020CC                          2305          
000020CC  0C46 0000               2306          CMPI    #%000000000000000, D6   * Data Register D0?
000020D0  6600 000A               2307          BNE     NOTD0
000020D4                          2308          
000020D4  6100 0074               2309          BSR     PRINTD0
000020D8  6000 006A               2310          BRA     ENDMODE_DN
000020DC                          2311  NOTD0      
000020DC  0C46 0001               2312          CMPI    #%000000000000001, D6   * Data Register D1?
000020E0  6600 000A               2313          BNE     NOTD1
000020E4                          2314          
000020E4  6100 0072               2315          BSR     PRINTD1
000020E8  6000 005A               2316          BRA     ENDMODE_DN
000020EC                          2317  NOTD1
000020EC  0C46 0002               2318          CMPI    #%000000000000010, D6   * Data Register D2?
000020F0  6600 000A               2319          BNE     NOTD2
000020F4                          2320          
000020F4  6100 0070               2321          BSR     PRINTD2
000020F8  6000 004A               2322          BRA     ENDMODE_DN
000020FC                          2323  NOTD2
000020FC  0C46 0003               2324          CMPI    #%000000000000011, D6   * Data Register D3?
00002100  6600 000A               2325          BNE     NOTD3
00002104                          2326          
00002104  6100 006E               2327          BSR     PRINTD3
00002108  6000 003A               2328          BRA     ENDMODE_DN
0000210C                          2329  NOTD3
0000210C  0C46 0004               2330          CMPI    #%000000000000100, D6   * Data Register D4?
00002110  6600 000A               2331          BNE     NOTD4
00002114                          2332          
00002114  6100 006C               2333          BSR     PRINTD4
00002118  6000 002A               2334          BRA     ENDMODE_DN
0000211C                          2335  NOTD4
0000211C  0C46 0005               2336          CMPI    #%000000000000101, D6   * Data Register D5?
00002120  6600 000A               2337          BNE     NOTD5
00002124                          2338          
00002124  6100 006A               2339          BSR     PRINTD5
00002128  6000 001A               2340          BRA     ENDMODE_DN
0000212C                          2341  NOTD5
0000212C  0C46 0006               2342          CMPI    #%000000000000110, D6   * Data Register D6?
00002130  6600 000A               2343          BNE     NOTD6
00002134                          2344          
00002134  6100 0068               2345          BSR     PRINTD6
00002138  6000 000A               2346          BRA     ENDMODE_DN
0000213C                          2347  NOTD6
0000213C  6100 006E               2348          BSR     PRINTD7
00002140  6000 0002               2349          BRA     ENDMODE_DN
00002144                          2350          
00002144                          2351  ENDMODE_DN
00002144  4C9F 03FF               2352          MOVEM   (A7)+,D0-D7/A0-A1 * Restore registers
00002148  4E75                    2353          RTS
0000214A                          2354  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000214A                          2355  *-----------------------------------------------------------------------------
0000214A                          2356  
0000214A                          2357  
0000214A                          2358  
0000214A                          2359  *-----------------------------------------------------------------------------
0000214A                          2360  *-----------------------------------------------------------------------------
0000214A                          2361  * NAME:           PRINTD0
0000214A                          2362  * DESCRIPTION:    Simply prints D0, D1, ..., up to D7.
0000214A                          2363  * PRE-CONDITION:  a
0000214A                          2364  * POST-CONDITION: a
0000214A                          2365  * REGISTERS:      a
0000214A                          2366  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000214A                          2367  PRINTD0
0000214A  43F9 00002917           2368          LEA     __D0, A1        * Load 'D0'
00002150  103C 000E               2369          MOVE.B  #14, D0         * Load Trap #14 to print out
00002154  4E4F                    2370          TRAP    #15             * Perform Trap #14
00002156  4E75                    2371          RTS
00002158                          2372  PRINTD1
00002158  43F9 0000291A           2373          LEA     __D1, A1        * Load 'D1'
0000215E  103C 000E               2374          MOVE.B  #14, D0         * Load Trap #14 to print out
00002162  4E4F                    2375          TRAP    #15             * Perform Trap #14
00002164  4E75                    2376          RTS      
00002166                          2377  PRINTD2
00002166  43F9 0000291D           2378          LEA     __D2, A1        * Load 'D2'
0000216C  103C 000E               2379          MOVE.B  #14, D0         * Load Trap #14 to print out
00002170  4E4F                    2380          TRAP    #15             * Perform Trap #14
00002172  4E75                    2381          RTS      
00002174                          2382  PRINTD3
00002174  43F9 00002920           2383          LEA     __D3, A1        * Load 'D3'
0000217A  103C 000E               2384          MOVE.B  #14, D0         * Load Trap #14 to print out
0000217E  4E4F                    2385          TRAP    #15             * Perform Trap #14
00002180  4E75                    2386          RTS      
00002182                          2387  PRINTD4
00002182  43F9 00002923           2388          LEA     __D4, A1        * Load 'D4'
00002188  103C 000E               2389          MOVE.B  #14, D0         * Load Trap #14 to print out
0000218C  4E4F                    2390          TRAP    #15             * Perform Trap #14
0000218E  4E75                    2391          RTS       
00002190                          2392  PRINTD5
00002190  43F9 00002926           2393          LEA     __D5, A1        * Load 'D5'
00002196  103C 000E               2394          MOVE.B  #14, D0         * Load Trap #14 to print out
0000219A  4E4F                    2395          TRAP    #15             * Perform Trap #14
0000219C  4E75                    2396          RTS      
0000219E                          2397  PRINTD6
0000219E  43F9 00002929           2398          LEA     __D6, A1        * Load 'D6'
000021A4  103C 000E               2399          MOVE.B  #14, D0         * Load Trap #14 to print out
000021A8  4E4F                    2400          TRAP    #15             * Perform Trap #14
000021AA  4E75                    2401          RTS
000021AC                          2402  PRINTD7
000021AC  43F9 0000292C           2403          LEA     __D7, A1        * Load 'D7'
000021B2  103C 000E               2404          MOVE.B  #14, D0         * Load Trap #14 to print out
000021B6  4E4F                    2405          TRAP    #15             * Perform Trap #14
000021B8  4E75                    2406          RTS
000021BA                          2407  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000021BA                          2408  *-----------------------------------------------------------------------------
000021BA                          2409  
000021BA                          2410  
000021BA                          2411  
000021BA                          2412  *-----------------------------------------------------------------------------
000021BA                          2413  *-----------------------------------------------------------------------------
000021BA                          2414  * NAME:           MODE_AN
000021BA                          2415  * DESCRIPTION:    Simply chooses to print A0-A7.
000021BA                          2416  * PRE-CONDITION:  a
000021BA                          2417  * POST-CONDITION: a
000021BA                          2418  * REGISTERS:      a
000021BA                          2419  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000021BA                          2420  MODE_AN
000021BA  48A7 FFC0               2421          MOVEM   D0-D7/A0-A1,-(A7)   * Save information
000021BE                          2422  
000021BE  3C3C 0000               2423          MOVE.W  #0, D6              * Prep lower value for bitmask
000021C2  3E3C 0002               2424          MOVE.W  #2, D7              * Prep upper value for bitmask
000021C6  6100 05F8               2425          BSR     BITMASK             * Finalize bitmask setup
000021CA  CC42                    2426          AND     D2,D6               * Apply bitmask
000021CC                          2427          
000021CC  0C46 0000               2428          CMPI    #%000000000000000, D6   * Address Register A0?
000021D0  6600 000A               2429          BNE     NOTA0
000021D4                          2430          
000021D4  6100 0074               2431          BSR     PRINTA0
000021D8                          2432          
000021D8  6000 006A               2433          BRA     ENDMODE_AN
000021DC                          2434  NOTA0      
000021DC  0C46 0001               2435          CMPI    #%000000000000001, D6   * Address Register A1?
000021E0  6600 000A               2436          BNE     NOTA1
000021E4                          2437          
000021E4  6100 0072               2438          BSR     PRINTA1
000021E8                          2439          
000021E8  6000 005A               2440          BRA     ENDMODE_AN
000021EC                          2441  NOTA1
000021EC  0C46 0002               2442          CMPI    #%000000000000010, D6   * Address Register A2?
000021F0  6600 000A               2443          BNE     NOTA2
000021F4                          2444          
000021F4  6100 0070               2445          BSR     PRINTA2
000021F8                          2446          
000021F8  6000 004A               2447          BRA     ENDMODE_AN
000021FC                          2448  NOTA2
000021FC  0C46 0003               2449          CMPI    #%000000000000011, D6   * Address Register A3?
00002200  6600 000A               2450          BNE     NOTA3
00002204                          2451          
00002204  6100 006E               2452          BSR     PRINTA3
00002208                          2453          
00002208  6000 003A               2454          BRA     ENDMODE_AN
0000220C                          2455  NOTA3
0000220C  0C46 0004               2456          CMPI    #%000000000000100, D6   * Address Register A4?
00002210  6600 000A               2457          BNE     NOTA4
00002214                          2458          
00002214  6100 006C               2459          BSR     PRINTA4
00002218                          2460          
00002218  6000 002A               2461          BRA     ENDMODE_AN
0000221C                          2462  NOTA4
0000221C  0C46 0005               2463          CMPI    #%000000000000101, D6   * Address Register A5?
00002220  6600 000A               2464          BNE     NOTA5
00002224                          2465          
00002224  6100 006A               2466          BSR     PRINTA5
00002228                          2467          
00002228  6000 001A               2468          BRA     ENDMODE_AN
0000222C                          2469  NOTA5
0000222C  0C46 0006               2470          CMPI    #%000000000000110, D6   * Address Register A6?
00002230  6600 000A               2471          BNE     NOTA6
00002234                          2472          
00002234  6100 0068               2473          BSR     PRINTA6
00002238                          2474          
00002238  6000 000A               2475          BRA     ENDMODE_AN
0000223C                          2476  NOTA6
0000223C  6100 006E               2477          BSR     PRINTA7
00002240                          2478          
00002240  6000 0002               2479          BRA     ENDMODE_AN
00002244                          2480  ENDMODE_AN
00002244  4C9F 03FF               2481          MOVEM   (A7)+,D0-D7/A0-A1   * Restore registers
00002248  4E75                    2482          RTS
0000224A                          2483  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000224A                          2484  *-----------------------------------------------------------------------------
0000224A                          2485  
0000224A                          2486  
0000224A                          2487  
0000224A                          2488  *-----------------------------------------------------------------------------
0000224A                          2489  *-----------------------------------------------------------------------------
0000224A                          2490  * NAME:           PRINTA0
0000224A                          2491  * DESCRIPTION:    Simply print out the address register.
0000224A                          2492  * PRE-CONDITION:  a
0000224A                          2493  * POST-CONDITION: a
0000224A                          2494  * REGISTERS:      a
0000224A                          2495  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000224A                          2496  PRINTA0
0000224A  43F9 000028FF           2497          LEA     __A0, A1        * Load 'A0'
00002250  103C 000E               2498          MOVE.B  #14, D0         * Load Trap #14 to print out
00002254  4E4F                    2499          TRAP    #15             * Perform Trap #14
00002256  4E75                    2500          RTS
00002258                          2501  
00002258                          2502  PRINTA1
00002258  43F9 00002902           2503          LEA     __A1, A1        * Load 'A1'
0000225E  103C 000E               2504          MOVE.B  #14, D0         * Load Trap #14 to print out
00002262  4E4F                    2505          TRAP    #15             * Perform Trap #14
00002264  4E75                    2506          RTS
00002266                          2507          
00002266                          2508  PRINTA2
00002266  43F9 00002905           2509          LEA     __A2, A1        * Load 'A2'
0000226C  103C 000E               2510          MOVE.B  #14, D0         * Load Trap #14 to print out
00002270  4E4F                    2511          TRAP    #15             * Perform Trap #14
00002272  4E75                    2512          RTS
00002274                          2513  
00002274                          2514  PRINTA3
00002274  43F9 00002908           2515          LEA     __A3, A1        * Load 'A3'
0000227A  103C 000E               2516          MOVE.B  #14, D0         * Load Trap #14 to print out
0000227E  4E4F                    2517          TRAP    #15             * Perform Trap #14
00002280  4E75                    2518          RTS
00002282                          2519  
00002282                          2520  PRINTA4
00002282  43F9 0000290B           2521          LEA     __A4, A1        * Load 'A4'
00002288  103C 000E               2522          MOVE.B  #14, D0         * Load Trap #14 to print out
0000228C  4E4F                    2523          TRAP    #15             * Perform Trap #14
0000228E  4E75                    2524          RTS
00002290                          2525  
00002290                          2526  PRINTA5
00002290  43F9 0000290E           2527          LEA     __A5, A1        * Load 'A5'
00002296  103C 000E               2528          MOVE.B  #14, D0         * Load Trap #14 to print out
0000229A  4E4F                    2529          TRAP    #15             * Perform Trap #14
0000229C  4E75                    2530          RTS
0000229E                          2531  
0000229E                          2532  PRINTA6
0000229E  43F9 00002911           2533          LEA     __A6, A1        * Load 'A6'
000022A4  103C 000E               2534          MOVE.B  #14, D0         * Load Trap #14 to print out
000022A8  4E4F                    2535          TRAP    #15             * Perform Trap #14
000022AA  4E75                    2536          RTS
000022AC                          2537  
000022AC                          2538  PRINTA7
000022AC  43F9 00002914           2539          LEA     __A7, A1        * Load 'A7'
000022B2  103C 000E               2540          MOVE.B  #14, D0         * Load Trap #14 to print out
000022B6  4E4F                    2541          TRAP    #15             * Perform Trap #14
000022B8  4E75                    2542          RTS
000022BA                          2543  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000022BA                          2544  *-----------------------------------------------------------------------------
000022BA                          2545  
000022BA                          2546  
000022BA                          2547  
000022BA                          2548  *-----------------------------------------------------------------------------
000022BA                          2549  *-----------------------------------------------------------------------------
000022BA                          2550  * NAME:           SIZE67
000022BA                          2551  * DESCRIPTION:    Called if the size is stored in bits 6 to 7.
000022BA                          2552  * PRE-CONDITION:  a
000022BA                          2553  * POST-CONDITION: a
000022BA                          2554  * REGISTERS:      a
000022BA                          2555  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000022BA                          2556  SIZE67
000022BA  48A7 FFFE               2557          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
000022BE  3C3C 0006               2558          MOVE.W  #6, D6              * Prep lower value for bitmask
000022C2  3E3C 0007               2559          MOVE.W  #7, D7              * Prep upper value for bitmask
000022C6  6100 04F8               2560          BSR     BITMASK             * Finalize bitmask setup
000022CA  CC42                    2561          AND     D2,D6               * Apply bitmask     
000022CC                          2562  
000022CC  0C46 0000               2563          CMPI    #%0000000000000000, D6   * is it a BYTE?
000022D0  6600 000A               2564          BNE     NOT67BYTE
000022D4                          2565          
000022D4  6100 009C               2566          BSR     PRINTBYTE               * Branch to handle BYTE sizes
000022D8  6000 001E               2567          BRA     END67
000022DC                          2568  NOT67BYTE        
000022DC  0C46 0040               2569          CMPI    #%0000000001000000, D6   * is it a WORD?
000022E0  6600 000A               2570          BNE     NOT67WORD
000022E4                          2571          
000022E4  6100 009A               2572          BSR     PRINTWORD               * Branch to handle WORD sizes
000022E8  6000 000E               2573          BRA     END67
000022EC                          2574  NOT67WORD
000022EC  0C46 0080               2575          CMPI    #%0000000010000000, D6   * is it a LONG?
000022F0  6600 0006               2576          BNE     END67
000022F4                          2577          
000022F4  6100 0098               2578          BSR     PRINTLONG               * Branch to handle LONG sizes
000022F8                          2579  END67
000022F8  4C9F 7FFF               2580          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
000022FC  4E75                    2581          RTS                             * Return. Size handling is finished.
000022FE                          2582  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000022FE                          2583  *-----------------------------------------------------------------------------
000022FE                          2584  
000022FE                          2585  
000022FE                          2586  
000022FE                          2587  *-----------------------------------------------------------------------------
000022FE                          2588  *-----------------------------------------------------------------------------
000022FE                          2589  * NAME:           SIZE68
000022FE                          2590  * DESCRIPTION:    Called if the size is stored in bits 6 to 8.
000022FE                          2591  * PRE-CONDITION:  a
000022FE                          2592  * POST-CONDITION: a
000022FE                          2593  * REGISTERS:      a
000022FE                          2594  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000022FE                          2595  SIZE68
000022FE                          2596  
000022FE  48A7 FFFE               2597          MOVEM   D0-D7/A0-A6, -(A7)  * Save values to return to original when done
00002302  3C3C 0006               2598          MOVE.W  #6, D6              * Prep lower value for bitmask
00002306  3E3C 0008               2599          MOVE.W  #8, D7              * Prep upper value for bitmask
0000230A  6100 04B4               2600          BSR     BITMASK             * Finalize bitmask setup
0000230E  CC42                    2601          AND     D2,D6               * Apply bitmask       
00002310                          2602  
00002310  0C46 0000               2603          CMPI    #%0000000000000000, D6  * is it a BYTE?
00002314  6700 003E               2604          BEQ     PRINTBYTE68               * Branch to handle BYTE sizes
00002318  0C46 0100               2605          CMPI    #%0000000100000000, D6  * is it a BYTE?
0000231C  6700 0036               2606          BEQ     PRINTBYTE68               * Branch to handle BYTE sizes 
00002320                          2607        
00002320  0C46 0040               2608          CMPI    #%0000000001000000, D6  * is it a WORD?
00002324  6700 0036               2609          BEQ     PRINTWORD68               * Branch to handle BYTE sizes
00002328  0C46 0140               2610          CMPI    #%0000000101000000, D6  * is it a WORD?
0000232C  6700 002E               2611          BEQ     PRINTWORD68               * Branch to handle BYTE sizes
00002330  0C46 00C0               2612          CMPI    #%0000000011000000, D6  * is it a WORD (ADDA)?
00002334  6700 0026               2613          BEQ     PRINTWORD68               * Branch to handle BYTE sizes
00002338                          2614  
00002338  0C46 0080               2615          CMPI    #%0000000010000000, D6  * is it a LONG?
0000233C  6700 0026               2616          BEQ     PRINTLONG68               * Branch to handle BYTE sizes
00002340  0C46 0180               2617          CMPI    #%0000000110000000, D6  * is it a LONG?
00002344  6700 001E               2618          BEQ     PRINTLONG68               * Branch to handle BYTE sizes
00002348  0C46 01C0               2619          CMPI    #%0000000111000000, D6  * is it a LONG (ADDA)?
0000234C  6700 0016               2620          BEQ     PRINTLONG68               * Branch to handle BYTE sizes
00002350                          2621  
00002350  6000 001A               2622          BRA     END68
00002354                          2623          
00002354                          2624  PRINTBYTE68
00002354  6100 001C               2625          BSR     PRINTBYTE
00002358  6000 0012               2626          BRA     END68
0000235C                          2627  
0000235C                          2628  PRINTWORD68
0000235C  6100 0022               2629          BSR     PRINTWORD
00002360  6000 000A               2630          BRA     END68
00002364                          2631          
00002364                          2632  PRINTLONG68
00002364  6100 0028               2633          BSR     PRINTLONG
00002368  6000 0002               2634          BRA     END68
0000236C                          2635  
0000236C                          2636  END68
0000236C  4C9F 7FFF               2637          MOVEM   (A7)+,D0-D7/A0-A6       * Pop off the stack to return our registers
00002370  4E75                    2638          RTS                             * Return. Size handling is finished.
00002372                          2639  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00002372                          2640  *-----------------------------------------------------------------------------
00002372                          2641  
00002372                          2642  
00002372                          2643  
00002372                          2644  *-----------------------------------------------------------------------------
00002372                          2645  *-----------------------------------------------------------------------------
00002372                          2646  * NAME:           PRINTBYTE
00002372                          2647  * DESCRIPTION:    a
00002372                          2648  * PRE-CONDITION:  a
00002372                          2649  * POST-CONDITION: a
00002372                          2650  * REGISTERS:      a
00002372                          2651  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00002372                          2652  PRINTBYTE
00002372  43F9 000028F3           2653          LEA     __B,A1      * Load '.B ' into A1
00002378  103C 000E               2654          MOVE.B  #14,D0      * Trap #14 setup to print
0000237C  4E4F                    2655          TRAP    #15         * Perform Trap #14
0000237E  4E75                    2656          RTS                 * Return to SIZE67/SIZE68
00002380                          2657          
00002380                          2658  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00002380                          2659  *-----------------------------------------------------------------------------
00002380                          2660  
00002380                          2661  
00002380                          2662  
00002380                          2663  *-----------------------------------------------------------------------------
00002380                          2664  *-----------------------------------------------------------------------------
00002380                          2665  * NAME:           PRINTWORD
00002380                          2666  * DESCRIPTION:    a
00002380                          2667  * PRE-CONDITION:  a
00002380                          2668  * POST-CONDITION: a
00002380                          2669  * REGISTERS:      a
00002380                          2670  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00002380                          2671  PRINTWORD
00002380  43F9 000028F7           2672          LEA     __W,A1      * Load '.W ' into A1
00002386  103C 000E               2673          MOVE.B  #14,D0      * Trap #14 setup to print
0000238A  4E4F                    2674          TRAP    #15         * Perform Trap #14
0000238C  4E75                    2675          RTS                 * Return to SIZE67/SIZE68
0000238E                          2676          
0000238E                          2677  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000238E                          2678  *-----------------------------------------------------------------------------
0000238E                          2679  
0000238E                          2680  
0000238E                          2681  
0000238E                          2682  *-----------------------------------------------------------------------------
0000238E                          2683  *-----------------------------------------------------------------------------
0000238E                          2684  * NAME:           PRINTLONG
0000238E                          2685  * DESCRIPTION:    a
0000238E                          2686  * PRE-CONDITION:  a
0000238E                          2687  * POST-CONDITION: a
0000238E                          2688  * REGISTERS:      a
0000238E                          2689  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000238E                          2690  PRINTLONG
0000238E  43F9 000028FB           2691          LEA     __L,A1      * Load '.L ' into A1
00002394  103C 000E               2692          MOVE.B  #14,D0      * Trap #14 setup to print
00002398  4E4F                    2693          TRAP    #15         * Perform Trap #14
0000239A  4E75                    2694          RTS                 * Return to SIZE67/SIZE68
0000239C                          2695          
0000239C                          2696  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
0000239C                          2697  *-----------------------------------------------------------------------------
0000239C                          2698  
0000239C                          2699  
0000239C                          2700  
0000239C                          2701  *-----------------------------------------------------------------------------
0000239C                          2702  *-----------------------------------------------------------------------------
0000239C                          2703  * NAME:           MOVEMHELPERPOST
0000239C                          2704  * DESCRIPTION:    Deciphers the myriad of combinations possible for MOVEM
0000239C                          2705  * PRE-CONDITION:  A2 points to the second word of the MOVEM op
0000239C                          2706  * POST-CONDITION: The registers being saved are printed
0000239C                          2707  * REGISTERS:      A2
0000239C                          2708  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
0000239C                          2709  MOVEMHELPERPOST
0000239C  48A7 FFFE               2710          MOVEM  D0-D7/A0-A6,-(A7)
000023A0                          2711          
000023A0  4285                    2712          CLR.L   D5  * to be used as a loop counter
000023A2  4284                    2713          CLR.L   D4  * == 1 if we have printed any registers (for fencepost issue)
000023A4  4283                    2714          CLR.L   D3  * == 1 if we are in a range
000023A6  4286                    2715          CLR.L   D6  * == 1 if we have already printed the slash or dash
000023A8  4287                    2716          CLR.L   D7  * == counts the number of registers in a range
000023AA  1C3C 0001               2717          MOVE.B  #1,D6 * to fix fencepost issue
000023AE  4282                    2718          CLR.L   D2
000023B0  3412                    2719          MOVE.W  (A2),D2 * move the next word of the OP into D2
000023B2                          2720          
000023B2                          2721  DLOOP * Loop to print out the data register portion of the addresses being saved
000023B2                          2722  
000023B2  E25A                    2723          ROR     #1,D2 * Rotate one bit out of D2
000023B4  6500 0006               2724          BCS     DVALID  * Was the bit set?
000023B8                          2725          
000023B8  6000 0064               2726          BRA     DINVALID * No it was not
000023BC                          2727          
000023BC                          2728  DVALID * This lable handles cases where the bit rotated out was true
000023BC                          2729  
000023BC  0C43 0000               2730          CMPI    #0,D3   * Check to see if in a range
000023C0  6700 0020               2731          BEQ     DFORWARDVALID * Not in a range
000023C4                          2732          
000023C4  5247                    2733          ADDI    #1,D7 * Increment number of regs in range
000023C6                          2734          
000023C6  0C46 0001               2735          CMPI    #1,D6   * Check to see if a symbol has been printed
000023CA  6700 0086               2736          BEQ     DLOOPITER * If one has, move on to the next iteration
000023CE                          2737          
000023CE  43F9 000028F1           2738          LEA     DASH,A1 * Load '-'
000023D4  103C 000E               2739          MOVE.B  #14,D0  * Indicate task #14
000023D8  4E4F                    2740          TRAP    #15     * Perform trap task #14
000023DA                          2741          
000023DA  1C3C 0001               2742          MOVE.B  #1,D6 * Indicate a symbol has been printed
000023DE                          2743          
000023DE  6000 0072               2744          BRA     DLOOPITER * Move to next iteration
000023E2                          2745          
000023E2                          2746  DFORWARDVALID * This label handles the case where the bit rotated out was true
000023E2                          2747          
000023E2  0C44 0000               2748          CMPI    #0,D4 * Check to see if a slash should be printed
000023E6  6700 000E               2749          BEQ     DNOSLASH * It does not, move to label that doesn't print slash
000023EA                          2750                  
000023EA  43F9 000028EF           2751          LEA     SLASH,A1 * Load '/'
000023F0  103C 000E               2752          MOVE.B  #14,D0   * Indicate task #14
000023F4  4E4F                    2753          TRAP    #15      * Perform trap task #14
000023F6                          2754          
000023F6                          2755  DNOSLASH * This label handles the true case without printing a slash
000023F6                          2756  
000023F6  183C 0001               2757          MOVE.B  #1,D4 * We have printed something, now slashes are fair game
000023FA                          2758          
000023FA  1C3C 0001               2759          MOVE.B  #1,D6 * Indicate a symbol has been printed
000023FE                          2760          
000023FE  43F9 000028D9           2761          LEA     ASCII_D,A1  * Load 'D'
00002404  103C 000E               2762          MOVE.B  #14,D0      * Indicate task #14
00002408  4E4F                    2763          TRAP    #15         * Perform trap task #14
0000240A                          2764          
0000240A  2205                    2765          MOVE.L  D5,D1   * Load the number of the data register
0000240C  103C 0003               2766          MOVE.B  #3,D0   * Indicate task #14
00002410  4E4F                    2767          TRAP    #15     * Perform trap task #14
00002412                          2768  
00002412  163C 0001               2769          MOVE.B  #1,D3   * Set to 1 to indicate we are in a range
00002416  1C3C 0000               2770          MOVE.B  #0,D6   * Set to 0 to indicate we have not printed a symbol
0000241A                          2771          
0000241A  6000 0036               2772          BRA     DLOOPITER   * Move on to next iteration
0000241E                          2773  
0000241E                          2774  
0000241E                          2775  DINVALID * This label handles the case where the bit rotated out was invalid
0000241E                          2776          
0000241E  0C43 0001               2777          CMPI    #1,D3   * Were we in a range?
00002422  6600 002E               2778          BNE     DLOOPITER * If not, next iteration
00002426                          2779          
00002426  163C 0000               2780          MOVE.B  #0,D3   * If we were, we are not anymore
0000242A                          2781          
0000242A  0C47 0001               2782          CMPI    #1,D7   * Was the # of registers in the range greater than one?
0000242E  6D00 0020               2783          BLT     DLOOPITERCLR * No, different case
00002432                          2784          
00002432  43F9 000028D9           2785          LEA     ASCII_D,A1  * Load 'D'
00002438  103C 000E               2786          MOVE.B  #14,D0      * Indicate task #14
0000243C  4E4F                    2787          TRAP    #15         * Perform trap task #14
0000243E                          2788          
0000243E  2205                    2789          MOVE.L  D5,D1   * Move the register to print
00002440                          2790          
00002440  0641 FFFF               2791          ADDI    #-1,D1  * Print out previous reg, it was the last in the range
00002444                          2792          
00002444  103C 0003               2793          MOVE.B  #3,D0   * Indicate task #3
00002448  4E4F                    2794          TRAP    #15     * Perform trap task #3
0000244A                          2795          
0000244A  4287                    2796          CLR.L   D7  * Clear the number in range counter
0000244C                          2797          
0000244C  6000 0004               2798          BRA     DLOOPITER * Move on to the next iteration
00002450                          2799          
00002450                          2800  DLOOPITERCLR * This label handles ranges of size == 1
00002450                          2801         
00002450  4287                    2802          CLR.L   D7 * Simply clear the # in range counter
00002452                          2803  
00002452                          2804  DLOOPITER * This label is the next iteration of the loop
00002452                          2805          
00002452  0C45 0008               2806          CMPI    #8,D5 * Are we done with the data registers yet?
00002456  6700 0008               2807          BEQ     DLOOPDONE * Yes
0000245A                          2808  
0000245A  5245                    2809          ADDI    #1,D5   * No, incriment counter
0000245C  6000 FF54               2810          BRA     DLOOP   * Back to start of loop
00002460                          2811  
00002460                          2812  DLOOPDONE
00002460                          2813  
00002460  7A09                    2814          MOVE.L  #9,D5  * to be used as a loop counter
00002462  4283                    2815          CLR.L   D3  * == 1 if we are in a range
00002464  4286                    2816          CLR.L   D6  * == 1 if we have already printed the slash or dash
00002466  4287                    2817          CLR.L   D7  * count of registers in a range
00002468  1C3C 0001               2818          MOVE.B  #1,D6 * to fix fencepost issue     
0000246C                          2819  
0000246C                          2820  ALOOP * loop to print out the address register portion of data regs being saved
0000246C                          2821  
0000246C  E25A                    2822          ROR     #1,D2   * Rotate one bit out of D2
0000246E  6500 0006               2823          BCS     AVALID  * Was the bit set?
00002472                          2824          
00002472  6000 0068               2825          BRA     AINVALID  * No it was not
00002476                          2826          
00002476                          2827  AVALID * This lable handles cases where the bit rotated out was true
00002476                          2828  
00002476  0C43 0000               2829          CMPI    #0,D3   * Are we in a range?
0000247A  6700 0020               2830          BEQ     AFORWARDVALID * We are not in a range
0000247E                          2831          
0000247E  5247                    2832          ADDI    #1,D7 * Increment number of regs in range
00002480                          2833          
00002480  0C46 0001               2834          CMPI    #1,D6   * Have we already printed a symbol?
00002484  6700 008E               2835          BEQ     ALOOPITER * If so, next iteration
00002488                          2836          
00002488  43F9 000028F1           2837          LEA     DASH,A1 * Load '-'
0000248E  103C 000E               2838          MOVE.B  #14,D0  * Indicate task #14
00002492  4E4F                    2839          TRAP    #15     * Perform trap task #14
00002494                          2840          
00002494  1C3C 0001               2841          MOVE.B  #1,D6 * Indicate a symbol has been printed
00002498                          2842          
00002498  6000 007A               2843          BRA     ALOOPITER * Move to next iteration of the loop
0000249C                          2844          
0000249C                          2845  AFORWARDVALID * This label handles the case where the bit rotated out was true
0000249C                          2846                  
0000249C  0C44 0000               2847          CMPI    #0,D4   * Have we printed anything?
000024A0  6700 000E               2848          BEQ     ANOSLASH * If not, don't print a slash
000024A4                          2849                  
000024A4  43F9 000028EF           2850          LEA     SLASH,A1    * Load '/'
000024AA  103C 000E               2851          MOVE.B  #14,D0      * Indicate task #14
000024AE  4E4F                    2852          TRAP    #15         * Perform trap task #14
000024B0                          2853          
000024B0                          2854  ANOSLASH * This label handles the true case without printing a slash
000024B0                          2855  
000024B0  183C 0001               2856          MOVE.B  #1,D4   * We have printed a register, now we can print slash
000024B4                          2857          
000024B4  1C3C 0001               2858          MOVE.B  #1,D6   * Indicate a symbol has been printed
000024B8                          2859          
000024B8  43F9 000028D3           2860          LEA     ASCII_A,A1  * Load 'A'
000024BE  103C 000E               2861          MOVE.B  #14,D0      * Indicate task #14
000024C2  4E4F                    2862          TRAP    #15         * Perform trap task #14
000024C4                          2863          
000024C4  2205                    2864          MOVE.L  D5,D1  * Load the loop counter into D1 to print
000024C6                          2865          
000024C6  0641 FFF8               2866          ADDI    #-8,D1 * For A, need to adjust by 8
000024CA                          2867          
000024CA  103C 0003               2868          MOVE.B  #3,D0   * Indicate task #3
000024CE  4E4F                    2869          TRAP    #15     * Perform trap task #3
000024D0                          2870  
000024D0  163C 0001               2871          MOVE.B  #1,D3   * Set to 1 to indicate we are in a range
000024D4  1C3C 0000               2872          MOVE.B  #0,D6   * Set to 0 to indicate we have not printed a symbol
000024D8                          2873          
000024D8  6000 003A               2874          BRA     ALOOPITER * MOve on to the next iteration of the loop
000024DC                          2875  
000024DC                          2876  
000024DC                          2877  AINVALID * This label handles the case where the bit rotated out was invalid
000024DC                          2878          
000024DC  0C43 0001               2879          CMPI    #1,D3   * Were we in a range?
000024E0  6600 0032               2880          BNE     ALOOPITER * If not, move on to the next iteration
000024E4                          2881          
000024E4  163C 0000               2882          MOVE.B  #0,D3   * If we were, we are not anymore
000024E8                          2883          
000024E8  0C47 0001               2884          CMPI    #1,D7   * Was there more than one value in the range?
000024EC  6D00 0024               2885          BLT     ALOOPITERCLR * No, just clear the count and move to next iter
000024F0                          2886          
000024F0  43F9 000028D3           2887          LEA     ASCII_A,A1  * Load 'A'
000024F6  103C 000E               2888          MOVE.B  #14,D0      * Indicate task #14
000024FA  4E4F                    2889          TRAP    #15         * Perform trap task #14
000024FC                          2890          
000024FC  2205                    2891          MOVE.L  D5,D1  * Move the loop counter into D1
000024FE                          2892          
000024FE  0641 FFFF               2893          ADDI    #-1,D1 * print out previous reg #, it was the last in the range
00002502  0641 FFF8               2894          ADDI    #-8,D1 * it's A, need to adjust by 8
00002506                          2895          
00002506  103C 0003               2896          MOVE.B  #3,D0   * Indicate task #3
0000250A  4E4F                    2897          TRAP    #15     * Perform trap task #3
0000250C                          2898          
0000250C  4287                    2899          CLR.L   D7  * Clear the count of registers in the range
0000250E                          2900          
0000250E  6000 0004               2901          BRA     ALOOPITER * Move on to the next loop iteration
00002512                          2902          
00002512                          2903  ALOOPITERCLR * This label handles the case the range was less than 2
00002512                          2904          
00002512  4287                    2905          CLR.L   D7 * Simply clear the number of registers in range
00002514                          2906  
00002514                          2907  ALOOPITER * This label is the next iteration of the loop
00002514                          2908          
00002514  0C45 0010               2909          CMPI    #16,D5  * Are we done yet?
00002518  6700 0008               2910          BEQ     ALOOPDONE * If yes, branch to ALOOPDONE
0000251C                          2911  
0000251C  5245                    2912          ADDI    #1,D5 * Increment loop counter
0000251E  6000 FF4C               2913          BRA     ALOOP * Start the loop over again
00002522                          2914  
00002522                          2915  ALOOPDONE *Branch to this label when we are done
00002522                          2916          
00002522  4C9F 7FFF               2917          MOVEM    (A7)+,D0-D7/A0-A6 * Restore registers
00002526  4E75                    2918          RTS
00002528                          2919  
00002528                          2920          
00002528                          2921  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00002528                          2922  *-----------------------------------------------------------------------------
00002528                          2923  
00002528                          2924  
00002528                          2925  
00002528                          2926  
00002528                          2927  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00002528                          2928  *-----------------------------------------------------------------------------
00002528                          2929  *-----------------------------------------------------------------------------
00002528                          2930  * NAME:           MOVEMHELPERPRE
00002528                          2931  * DESCRIPTION:    Deciphers the myriad of combinations possible for MOVEM
00002528                          2932  * PRE-CONDITION:  A2 points to the second word of the MOVEM op
00002528                          2933  * POST-CONDITION: The registers being saved are printed
00002528                          2934  * REGISTERS:      A2
00002528                          2935  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00002528                          2936  MOVEMHELPERPRE
00002528                          2937  
00002528  48A7 7F00               2938      MOVEM   D1-D7,-(A7) * Save registers
0000252C                          2939  
0000252C  3412                    2940      MOVE.W  (A2),D2 * move the data we need to proccess into D2
0000252E                          2941      
0000252E  7800                    2942      MOVE.L  #0,D4   * To be used as a loop counter
00002530                          2943      
00002530  4287                    2944      CLR.L   D7 * put the flipped bits here
00002532                          2945      
00002532                          2946  PRELOOP * The start of the loop
00002532                          2947  
00002532  E35A                    2948      ROL.W   #1,D2 * Rotate one bit out of the OP
00002534                          2949      
00002534  6500 0006               2950      BCS     PRESETBIT * If set, branch here
00002538                          2951      
00002538  6000 0004               2952      BRA     PRELOOPITER * If we hit this, it was not set
0000253C                          2953      
0000253C                          2954  PRESETBIT * This label handles the case if the bit rotated out was set
0000253C                          2955  
0000253C  09C7                    2956      BSET    D4,D7 * set the bit in the result
0000253E                          2957  
0000253E                          2958  PRELOOPITER * This label handles the case if the bit rotated out was not set
0000253E                          2959  
0000253E  0C44 000F               2960      CMPI    #15,D4 * Are we done manipulating bits?
00002542  6700 0006               2961      BEQ     PRELOOPDONE * If yes, branch here
00002546                          2962      
00002546  5244                    2963      ADDI    #1,D4 * If not, incriment
00002548  60E8                    2964      BRA     PRELOOP * and start the loop again
0000254A                          2965  
0000254A                          2966  PRELOOPDONE * This label is branched to when the loop is finished
0000254A                          2967  
0000254A  3487                    2968      MOVE.W  D7,(A2) * Move the result of our bit manipulation into (A2)
0000254C                          2969      
0000254C  4C9F 00FE               2970      MOVEM   (A7)+,D1-D7 * Restore registers
00002550                          2971  
00002550  6100 FE4A               2972      BSR MOVEMHELPERPOST * Now the bits are in the same format as if were post
00002554                          2973  
00002554  4E75                    2974      RTS
00002556                          2975  
00002556                          2976  
00002556                          2977  
00002556                          2978          
00002556                          2979  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00002556                          2980  *-----------------------------------------------------------------------------
00002556                          2981  
00002556                          2982  
00002556                          2983  
00002556                          2984  *-----------------------------------------------------------------------------
00002556                          2985  *-----------------------------------------------------------------------------
00002556                          2986  * NAME:           UNKNOWNOP
00002556                          2987  * DESCRIPTION:    a
00002556                          2988  * PRE-CONDITION:  D2 contains the instruction to print. D2 has already been
00002556                          2989  *                 identified as an unknown operation.
00002556                          2990  * POST-CONDITION: D2 is no longer the opcode.
00002556                          2991  * REGISTERS:      a
00002556                          2992  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00002556                          2993  UNKNOWNOP
00002556  48A7 FFC0               2994          MOVEM   D0-D7/A0-A1,-(A7) * Save registers
0000255A                          2995          
0000255A  43F9 00002896           2996          LEA     DATA,A1 * load " DATA $" into register A1
00002560  700E                    2997          MOVE.L  #14,D0  * print the string stored in A1
00002562  4E4F                    2998          TRAP    #15
00002564                          2999          
00002564  E18A                    3000          LSL.L   #8,D2   * Shift out un-needed info
00002566  E18A                    3001          LSL.L   #8,D2   * Shift out un-needed info
00002568                          3002          
00002568  2C42                    3003          MOVE.L  D2,A6   * Move the opcode to A6 to be printed
0000256A                          3004          
0000256A  7604                    3005          MOVE.L  #4,D3   * Indicate number of nibbles to print
0000256C                          3006          
0000256C  6100 0012               3007          BSR     PRINT_ASCII_HEX_CHAR * Print the hex
00002570                          3008  
00002570  43F9 00002829           3009          LEA     NEWLINE,A1 * load newline into register A1
00002576  700E                    3010          MOVE.L  #14,D0  * print the string stored in A1
00002578  4E4F                    3011          TRAP    #15
0000257A                          3012  
0000257A  4C9F 03FF               3013          MOVEM   (A7)+,D0-D7/A0-A1 * Restore registers
0000257E  4E75                    3014          RTS
00002580                          3015  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00002580                          3016  *-----------------------------------------------------------------------------
00002580                          3017  
00002580                          3018  
00002580                          3019  
00002580                          3020  *-----------------------------------------------------------------------------
00002580                          3021  *-----------------------------------------------------------------------------
00002580                          3022  * NAME: Print ASCII hex char
00002580                          3023  * DESCRIPTION:    Prints and address register to console in hex (ASCII chars)
00002580                          3024  * PRE-CONDITION:  A6 contains the register of memory to print.
00002580                          3025  *                 This parameter would be pre-loaded by, for example:
00002580                          3026  *                 "LEA FOO_BAR_ADDR,A6" or "LEA $1234FEED,A6"
00002580                          3027  *                 D3 contains the loops to do (number of nibbles).
00002580                          3028  * POST-CONDITION: 
00002580                          3029  * REGISTERS:      
00002580                          3030  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00002580                          3031  PRINT_ASCII_HEX_CHAR
00002580  48E7 FFFC               3032      MOVEM.L     D0-D7/A0-A5,-(A7) * push data to save
00002584  4285                    3033      CLR.L       D5
00002586                          3034      
00002586                          3035      * fence post check (if-statement, check if 0 > chars)
00002586  0C03 0000               3036      CMPI.B      #0,D3
0000258A  6700 017C               3037      BEQ         INVALID_ASCII_INPUT * go to very last part if invalid
0000258E                          3038      
0000258E                          3039  *    MOVE.L      A6,D4
0000258E  2E0E                    3040      MOVE.L      A6,D7
00002590                          3041  PRINT_ASCII_LOOP
00002590                          3042  *    MOVE.L      A6,D7 * increase a6's pointer position ea. loop
00002590                          3043  *    MOVE.L      D4,D7 * make a mutable copy
00002590  E99F                    3044      ROL.L       #4,D7 * roll to next spot
00002592  48E7 0100               3045      MOVEM.L     D7,-(A7) * save D7
00002596                          3046  
00002596  0287 0000000F           3047      ANDI.L      #HEX_VALUE_MASK_LONG,D7
0000259C                          3048      
0000259C  0C87 00000000           3049      CMPI.L      #0,D7
000025A2  6D00 0164               3050      BLT         INVALID_ASCII_INPUT
000025A6                          3051  
000025A6  0C87 0000000F           3052      CMPI.L      #15,D7
000025AC  6E00 015A               3053      BGT         INVALID_ASCII_INPUT
000025B0                          3054  
000025B0                          3055      * this might be faster... to do later, after entire assignment done
000025B0                          3056       * CMPI.L      #9,D7
000025B0                          3057       * BLE         PRINT_ASCII_0_TO_9
000025B0                          3058  
000025B0  0C87 00000000           3059      CMPI.L      #0,D7
000025B6  6700 0098               3060      BEQ         PRINT_ASCII_0
000025BA  0C87 00000001           3061      CMPI.L      #1,D7
000025C0  6700 0098               3062      BEQ         PRINT_ASCII_1
000025C4  0C87 00000002           3063      CMPI.L      #2,D7
000025CA  6700 0098               3064      BEQ         PRINT_ASCII_2
000025CE  0C87 00000003           3065      CMPI.L      #3,D7
000025D4  6700 0098               3066      BEQ         PRINT_ASCII_3
000025D8  0C87 00000004           3067      CMPI.L      #4,D7
000025DE  6700 0098               3068      BEQ         PRINT_ASCII_4
000025E2  0C87 00000005           3069      CMPI.L      #5,D7
000025E8  6700 0098               3070      BEQ         PRINT_ASCII_5
000025EC  0C87 00000006           3071      CMPI.L      #6,D7
000025F2  6700 0098               3072      BEQ         PRINT_ASCII_6
000025F6  0C87 00000007           3073      CMPI.L      #7,D7
000025FC  6700 0098               3074      BEQ         PRINT_ASCII_7
00002600  0C87 00000008           3075      CMPI.L      #8,D7
00002606  6700 0098               3076      BEQ         PRINT_ASCII_8
0000260A  0C87 00000009           3077      CMPI.L      #9,D7
00002610  6700 0098               3078      BEQ         PRINT_ASCII_9
00002614  0C87 0000000A           3079      CMPI.L      #10,D7
0000261A  6700 0098               3080      BEQ         PRINT_ASCII_A
0000261E  0C87 0000000B           3081      CMPI.L      #11,D7
00002624  6700 0098               3082      BEQ         PRINT_ASCII_B
00002628  0C87 0000000C           3083      CMPI.L      #12,D7
0000262E  6700 0098               3084      BEQ         PRINT_ASCII_C
00002632  0C87 0000000D           3085      CMPI.L      #13,D7
00002638  6700 0098               3086      BEQ         PRINT_ASCII_D
0000263C  0C87 0000000E           3087      CMPI.L      #14,D7
00002642  6700 0098               3088      BEQ         PRINT_ASCII_E
00002646  0C87 0000000F           3089      CMPI.L      #15,D7
0000264C  6700 0098               3090      BEQ         PRINT_ASCII_F
00002650                          3091  PRINT_ASCII_0
00002650  43F9 000028BF           3092      LEA         ASCII_0,A1
00002656  6000 0098               3093      BRA         PRINT_ASCII_CHAR
0000265A                          3094  PRINT_ASCII_1
0000265A  43F9 000028C1           3095      LEA         ASCII_1,A1
00002660  6000 008E               3096      BRA         PRINT_ASCII_CHAR
00002664                          3097  PRINT_ASCII_2
00002664  43F9 000028C3           3098      LEA         ASCII_2,A1
0000266A  6000 0084               3099      BRA         PRINT_ASCII_CHAR
0000266E                          3100  PRINT_ASCII_3
0000266E  43F9 000028C5           3101      LEA         ASCII_3,A1
00002674  6000 007A               3102      BRA         PRINT_ASCII_CHAR
00002678                          3103  PRINT_ASCII_4
00002678  43F9 000028C7           3104      LEA         ASCII_4,A1
0000267E  6000 0070               3105      BRA         PRINT_ASCII_CHAR
00002682                          3106  PRINT_ASCII_5
00002682  43F9 000028C9           3107      LEA         ASCII_5,A1
00002688  6000 0066               3108      BRA         PRINT_ASCII_CHAR
0000268C                          3109  PRINT_ASCII_6
0000268C  43F9 000028CB           3110      LEA         ASCII_6,A1
00002692  6000 005C               3111      BRA         PRINT_ASCII_CHAR
00002696                          3112  PRINT_ASCII_7
00002696  43F9 000028CD           3113      LEA         ASCII_7,A1
0000269C  6000 0052               3114      BRA         PRINT_ASCII_CHAR
000026A0                          3115  PRINT_ASCII_8
000026A0  43F9 000028CF           3116      LEA         ASCII_8,A1
000026A6  6000 0048               3117      BRA         PRINT_ASCII_CHAR
000026AA                          3118  PRINT_ASCII_9
000026AA  43F9 000028D1           3119      LEA         ASCII_9,A1
000026B0  6000 003E               3120      BRA         PRINT_ASCII_CHAR
000026B4                          3121  PRINT_ASCII_A
000026B4  43F9 000028D3           3122      LEA         ASCII_A,A1
000026BA  6000 0034               3123      BRA         PRINT_ASCII_CHAR
000026BE                          3124  PRINT_ASCII_B
000026BE  43F9 000028D5           3125      LEA         ASCII_B,A1
000026C4  6000 002A               3126      BRA         PRINT_ASCII_CHAR
000026C8                          3127  PRINT_ASCII_C
000026C8  43F9 000028D7           3128      LEA         ASCII_C,A1
000026CE  6000 0020               3129      BRA         PRINT_ASCII_CHAR
000026D2                          3130  PRINT_ASCII_D
000026D2  43F9 000028D9           3131      LEA         ASCII_D,A1
000026D8  6000 0016               3132      BRA         PRINT_ASCII_CHAR
000026DC                          3133  PRINT_ASCII_E
000026DC  43F9 000028DB           3134      LEA         ASCII_E,A1
000026E2  6000 000C               3135      BRA         PRINT_ASCII_CHAR
000026E6                          3136  PRINT_ASCII_F
000026E6  43F9 000028DD           3137      LEA         ASCII_F,A1
000026EC  6000 0002               3138      BRA         PRINT_ASCII_CHAR
000026F0                          3139  PRINT_ASCII_CHAR
000026F0  103C 000E               3140      MOVE.B      #14,D0
000026F4  4E4F                    3141      TRAP        #15
000026F6                          3142      
000026F6                          3143          
000026F6  4287                    3144      CLR.L       D7
000026F8  4CDF 0080               3145      MOVEM.L     (A7)+,D7 * copy back D7 from stack, to mutate its' bits
000026FC                          3146      
000026FC  5205                    3147      ADD.B       #1,D5 * loop until counter stops
000026FE  BA03                    3148      CMP.B       D3,D5
00002700  6C00 0006               3149      BGE         PRINT_ASCII_FINISH
00002704                          3150      
00002704  6000 FE8A               3151      BRA         PRINT_ASCII_LOOP
00002708                          3152  INVALID_ASCII_INPUT
00002708                          3153  PRINT_ASCII_FINISH
00002708  4CDF 3FFF               3154      MOVEM.L     (A7)+,D0-D7/A0-A5 * pop saved memory
0000270C  4E75                    3155      RTS
0000270E                          3156      
0000270E                          3157  PRINTDATA911
0000270E  0C46 0E00               3158      CMPI    #%0000111000000000, D6   * Print 7
00002712  6700 003C               3159      BEQ     PRINT7   
00002716  0C46 0C00               3160      CMPI    #%0000110000000000, D6   * Print 6
0000271A  6700 0042               3161      BEQ     PRINT6
0000271E  0C46 0A00               3162      CMPI    #%0000101000000000, D6   * Print 5
00002722  6700 0048               3163      BEQ     PRINT5
00002726  0C46 0800               3164      CMPI    #%0000100000000000, D6   * Print 4
0000272A  6700 004E               3165      BEQ     PRINT4 
0000272E  0C46 0600               3166      CMPI    #%0000011000000000, D6   * Print 3
00002732  6700 0054               3167      BEQ     PRINT3    
00002736  0C46 0400               3168      CMPI    #%0000010000000000, D6   * Print 2
0000273A  6700 005A               3169      BEQ     PRINT2   
0000273E  0C46 0200               3170      CMPI    #%0000001000000000, D6   * Print 1
00002742  6700 0060               3171      BEQ     PRINT1     
00002746  0C46 0000               3172      CMPI    #%0000000000000000, D6   * Print 0
0000274A  6700 0066               3173      BEQ     PRINT8
0000274E                          3174      
0000274E  4E75                    3175      RTS                             * Fail case  
00002750                          3176      
00002750                          3177  PRINT7
00002750  43F9 000028CD           3178      LEA     ASCII_7, A1
00002756  103C 000E               3179      MOVE.B      #14,D0
0000275A  4E4F                    3180      TRAP        #15
0000275C  4E75                    3181      RTS
0000275E                          3182      
0000275E                          3183  PRINT6
0000275E  43F9 000028CB           3184      LEA     ASCII_6, A1
00002764  103C 000E               3185      MOVE.B      #14,D0
00002768  4E4F                    3186      TRAP        #15
0000276A  4E75                    3187      RTS
0000276C                          3188      
0000276C                          3189  PRINT5
0000276C  43F9 000028C9           3190      LEA     ASCII_5, A1
00002772  103C 000E               3191      MOVE.B      #14,D0
00002776  4E4F                    3192      TRAP        #15
00002778  4E75                    3193      RTS
0000277A                          3194      
0000277A                          3195  PRINT4
0000277A  43F9 000028C7           3196      LEA     ASCII_4, A1
00002780  103C 000E               3197      MOVE.B      #14,D0
00002784  4E4F                    3198      TRAP        #15
00002786  4E75                    3199      RTS
00002788                          3200      
00002788                          3201  PRINT3
00002788  43F9 000028C5           3202      LEA     ASCII_3, A1
0000278E  103C 000E               3203      MOVE.B      #14,D0
00002792  4E4F                    3204      TRAP        #15
00002794  4E75                    3205      RTS
00002796                          3206      
00002796                          3207  PRINT2
00002796  43F9 000028C3           3208      LEA     ASCII_2, A1
0000279C  103C 000E               3209      MOVE.B      #14,D0
000027A0  4E4F                    3210      TRAP        #15
000027A2  4E75                    3211      RTS
000027A4                          3212      
000027A4                          3213  PRINT1
000027A4  43F9 000028C1           3214      LEA     ASCII_1, A1
000027AA  103C 000E               3215      MOVE.B      #14,D0
000027AE  4E4F                    3216      TRAP        #15
000027B0  4E75                    3217      RTS
000027B2                          3218          
000027B2                          3219  PRINT8
000027B2  43F9 000028CF           3220      LEA     ASCII_8, A1
000027B8  103C 000E               3221      MOVE.B      #14,D0
000027BC  4E4F                    3222      TRAP        #15
000027BE  4E75                    3223      RTS
000027C0                          3224  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000027C0                          3225  *-----------------------------------------------------------------------------
000027C0                          3226  
000027C0                          3227  
000027C0                          3228  
000027C0                          3229  *-----------------------------------------------------------------------------
000027C0                          3230  *-----------------------------------------------------------------------------
000027C0                          3231  * NAME: Bitmask
000027C0                          3232  * DESCRIPTION:    Masks bits in a data register.
000027C0                          3233  * PRE-CONDITION:  D6 contains the starting bit to be masked, and D7 contains
000027C0                          3234  *                 the ending bit.  For example, a starting bit of decimal
000027C0                          3235  *                 value 0 and an ending bit of decimal value 3 will mask the
000027C0                          3236  *                 bits 0, 1, 2, and 3.
000027C0                          3237  * POST-CONDITION: D6 contains the bitmask, ready for use.
000027C0                          3238  * REGISTERS:      D5,D6,D7
000027C0                          3239  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000027C0                          3240  BITMASK
000027C0  3F05                    3241          MOVE    D5,-(A7)    * push D5 onto the stack so we can use it to
000027C2  4245                    3242          CLR     D5          * clear D5 so we can use it
000027C4                          3243  LOOPBIT 
000027C4  0DC5                    3244          BSET    D6,D5       * set the D6th bit in D5 to 1
000027C6  5246                    3245          ADD     #1,D6       * increment D6
000027C8                          3246  
000027C8  BC47                    3247          CMP     D7,D6       * have we finished?
000027CA  6E00 0004               3248          BGT     BITMASKDONE * yes
000027CE  60F4                    3249          BRA     LOOPBIT     * no, iterate again
000027D0                          3250  
000027D0                          3251  BITMASKDONE
000027D0  2C05                    3252          MOVE.L  D5,D6
000027D2  3A1F                    3253          MOVE    (A7)+,D5    * restore D5
000027D4  4E75                    3254          RTS
000027D6                          3255  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
000027D6                          3256  *-----------------------------------------------------------------------------
000027D6                          3257  
000027D6                          3258  
000027D6                          3259  
000027D6                          3260  *-----------------------------------------------------------------------------
000027D6                          3261  *-----------------------------------------------------------------------------
000027D6                          3262  * SECTION: Constants/variables used throughout the program.
000027D6                          3263  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
000027D6                          3264  
000027D6                          3265  * ---> GENERAL
000027D6  =0000000D               3266  CR          EQU     $0D
000027D6  =0000000A               3267  LF          EQU     $0A
000027D6= 45 4E 54 45 52 20 ...   3268  MSGSTART    DC.B    'ENTER START ADDRESS: ',CR,LF,0
000027EE= 45 4E 54 45 52 20 ...   3269  MSGEND      DC.B    'ENTER END ADDRESS: ',CR,LF,0
00002804= 48 69 74 20 74 68 ...   3270  CONT_MSG    DC.B    'Hit the [ENTER] key to continue...',CR,LF,0
00002829= 0D 0A 00                3271  NEWLINE     DC.B    CR,LF,0
0000282C                          3272  
0000282C                          3273  * ---> OPS
0000282C= 44 49 56 53 00          3274  DIVSOP      DC.B    'DIVS',0
00002831= 43 4D 50 00             3275  CMPOP       DC.B    'CMP',0
00002835= 45 4F 52 00             3276  EOROP       DC.B    'EOR',0
00002839= 4E 4F 50 00             3277  NOOPERATION DC.B    'NOP',0
0000283D= 4E 45 47 00             3278  NEGOP       DC.B    'NEG',0
00002841= 4D 4F 56 45 00          3279  MOVEOP      DC.B    'MOVE',0
00002846= 4D 4F 56 45 41 00       3280  MOVEAOP      DC.B   'MOVEA',0
0000284C= 4D 4F 56 45 4D 00       3281  MOVEMOP     DC.B    'MOVEM',0
00002852= 4A 53 52 00             3282  JSROP       DC.B    'JSR',0
00002856= 52 54 53 00             3283  RTSOP       DC.B    'RTS',0
0000285A= 53 55 42 51 00          3284  SUBQOP      DC.B    'SUBQ',0
0000285F= 4C 45 41 00             3285  LEAOP       DC.B    'LEA',0
00002863= 42 43 4C 52 20 00       3286  BCLROP      DC.B    'BCLR ',0
00002869= 4D 55 4C 53 00          3287  MULSOP      DC.B    'MULS',0
0000286E= 4F 52 00                3288  OROP        DC.B    'OR',0
00002871= 4F 52 49 00             3289  ORIOP       DC.B    'ORI',0
00002875= 43 4D 50 49 00          3290  CMPIOP      DC.B    'CMPI',0
0000287A= 4C 53 4C 00             3291  LSLOP       DC.B    'LSL',0
0000287E= 4C 53 52 00             3292  LSROP       DC.B    'LSR',0
00002882= 41 53 4C 00             3293  ASLOP       DC.B    'ASL',0
00002886= 41 53 52 00             3294  ASROP       DC.B    'ASR',0
0000288A= 52 4F 4C 00             3295  ROLOP       DC.B    'ROL',0
0000288E= 52 4F 52 00             3296  ROROP       DC.B    'ROR',0
00002892= 53 55 42 00             3297  SUBOP       DC.B    'SUB',0
00002896= 44 41 54 41 20 24 00    3298  DATA        DC.B    'DATA $',0
0000289D= 42 43 43 20 00          3299  OP_BCC_MSG  DC.B    'BCC ',0
000028A2= 42 43 53 20 00          3300  OP_BCS_MSG  DC.B    'BCS ',0
000028A7= 42 47 45 20 00          3301  OP_BGE_MSG  DC.B    'BGE ',0
000028AC= 42 4C 54 20 00          3302  OP_BLT_MSG  DC.B    'BLT ',0
000028B1= 42 56 43 20 00          3303  OP_BVC_MSG  DC.B    'BVC ',0
000028B6= 42 52 41 20 00          3304  OP_BRA_MSG  DC.B    'BRA ',0
000028BB= 41 44 44 00             3305  OP_ADD_MSG  DC.B    'ADD',0
000028BF                          3306  
000028BF                          3307  * ---> HEX CHARS
000028BF= 30 00                   3308  ASCII_0     DC.B    '0',0
000028C1= 31 00                   3309  ASCII_1     DC.B    '1',0
000028C3= 32 00                   3310  ASCII_2     DC.B    '2',0
000028C5= 33 00                   3311  ASCII_3     DC.B    '3',0
000028C7= 34 00                   3312  ASCII_4     DC.B    '4',0
000028C9= 35 00                   3313  ASCII_5     DC.B    '5',0
000028CB= 36 00                   3314  ASCII_6     DC.B    '6',0
000028CD= 37 00                   3315  ASCII_7     DC.B    '7',0
000028CF= 38 00                   3316  ASCII_8     DC.B    '8',0
000028D1= 39 00                   3317  ASCII_9     DC.B    '9',0
000028D3= 41 00                   3318  ASCII_A     DC.B    'A',0
000028D5= 42 00                   3319  ASCII_B     DC.B    'B',0
000028D7= 43 00                   3320  ASCII_C     DC.B    'C',0
000028D9= 44 00                   3321  ASCII_D     DC.B    'D',0
000028DB= 45 00                   3322  ASCII_E     DC.B    'E',0
000028DD= 46 00                   3323  ASCII_F     DC.B    'F',0
000028DF                          3324  
000028DF                          3325  * ---> SPECIAL CHARACTERS
000028DF= 20 00                   3326  SPACE       DC.B    ' ',0
000028E1= 24 00                   3327  DOLLAR      DC.B    '$',0
000028E3= 23 00                   3328  IMD         DC.B    '#',0
000028E5= 2C 00                   3329  COMMA       DC.B    ',',0
000028E7= 28 00                   3330  OBRACK      DC.B    '(',0
000028E9= 29 00                   3331  CBRACK      DC.B    ')',0
000028EB= 2B 00                   3332  PLUS        DC.B    '+',0
000028ED= 2D 00                   3333  MINUS       DC.B    '-',0
000028EF= 2F 00                   3334  SLASH       DC.B    '/',0
000028F1= 2D 00                   3335  DASH        DC.B    '-',0
000028F3                          3336  
000028F3                          3337  * ---> B/W/L (BYTE, WORD, LONG, RESPECTIVELY)
000028F3= 2E 42 20 00             3338  __B         DC.B    '.B ',0
000028F7= 2E 57 20 00             3339  __W         DC.B    '.W ',0
000028FB= 2E 4C 20 00             3340  __L         DC.B    '.L ',0
000028FF                          3341  
000028FF                          3342  * ---> ADDRESS REGISTERS A0-A7
000028FF= 41 30 00                3343  __A0        DC.B   'A0',0
00002902= 41 31 00                3344  __A1        DC.B   'A1',0    
00002905= 41 32 00                3345  __A2        DC.B   'A2',0
00002908= 41 33 00                3346  __A3        DC.B   'A3',0
0000290B= 41 34 00                3347  __A4        DC.B   'A4',0
0000290E= 41 35 00                3348  __A5        DC.B   'A5',0
00002911= 41 36 00                3349  __A6        DC.B   'A6',0
00002914= 41 37 00                3350  __A7        DC.B   'A7',0
00002917                          3351  
00002917                          3352  * ---> DATA REGISTERS D0-D7
00002917= 44 30 00                3353  __D0        DC.B   'D0',0
0000291A= 44 31 00                3354  __D1        DC.B   'D1',0
0000291D= 44 32 00                3355  __D2        DC.B   'D2',0
00002920= 44 33 00                3356  __D3        DC.B   'D3',0
00002923= 44 34 00                3357  __D4        DC.B   'D4',0
00002926= 44 35 00                3358  __D5        DC.B   'D5',0
00002929= 44 36 00                3359  __D6        DC.B   'D6',0
0000292C= 44 37 00                3360  __D7        DC.B   'D7',0
0000292F                          3361  
0000292F                          3362  __COUNTER   DS.B    1       * main loop counter
00002930                          3363  
00002930                          3364  *------------------------[+]END CODE BLOCK SEGMENT[+]-------------------------
00002930                          3365  *-----------------------------------------------------------------------------
00002930                          3366  
00002930                          3367  
00002930                          3368  
00002930                          3369  *-----------------------------------------------------------------------------
00002930                          3370  *-----------------------------------------------------------------------------
00002930                          3371  * SECTION: Sample program to run, then attempt testing disassembly on.
00002930                          3372  * STARTING: 16384
00002930                          3373  * ENDING:   Any even number before 16384 to continue FOREVER
00002930                          3374  *-----------------------[+]START CODE BLOCK SEGMENT[+]------------------------
00004000                          3375      ORG $4000
00004000                          3376      
00004000  D242                    3377      ADD     D2,D1
00004002  D2CA                    3378      ADDA    A2,A1
00004004  9240                    3379      SUB     D0,D1
00004006  944A                    3380      SUB     A2,D2   * Should be invalid since this is SUBA
00004008  8642                    3381      OR      D2,D3
0000400A  8492                    3382      OR.L    (A2),D2
0000400C  B200                    3383      CMP.B   D0,D1
0000400E  B441                    3384      CMP.W   D1,D2
00004010  B682                    3385      CMP.L   D2,D3
00004012  B248                    3386      CMP     A0,D1
00004014  B25A                    3387      CMP     (A2)+,D1
00004016  B101                    3388      EOR.B   D0,D1
00004018  B342                    3389      EOR.W   D1,D2
0000401A  B583                    3390      EOR.L   D2,D3
0000401C  B150                    3391      EOR     D0,(A0)
0000401E  B359                    3392      EOR     D1,(A1)+
00004020  0000 0003               3393      ORI.B   #3,D0 
00004024  0042 0290               3394      ORI.W   #$290,D2
00004028  0087 0000000A           3395      ORI.L   #%1010,D7   * $1010 == A
0000402E  0043 0002               3396      ORI     #2,D3
00004032  4E71                    3397      NOP
00004034  103C 009A               3398      MOVE.B   #%10011010, D0
00004038  123C 00A9               3399      MOVE.B   #%10101001, D1
0000403C  303C 009A               3400      MOVE.W   #%10011010, D0
00004040  323C 00A9               3401      MOVE.W   #%10101001, D1
00004044  203C 00011170           3402      MOVE.L   #70000, D0
0000404A  223C 00011170           3403      MOVE.L   #70000, D1
00004050  81FC 0001               3404      DIVS     #1, D0
00004054  D200                    3405      ADD.B    D0,D1
00004056  4C9F 3C1A               3406      MOVEM    (A7)+,A2-A5/D1/D3-D4
0000405A  43F8 2852               3407      LEA      JSROP,A1
0000405E  4467                    3408      NEG.W    -(A7)
00004060  4EB9 00004096           3409      JSR      END
00004066  CFFC 0003               3410      MULS.W  #3, D7
0000406A  CFC0                    3411      MULS    D0, D7
0000406C  C5D9                    3412      MULS    (A1)+, D2
0000406E  C682                    3413      AND.L   D2,D3
00004070  5146                    3414      SUBQ    #8, D6
00004072  5F81                    3415      SUBQ.L  #7, D1
00004074  0041 0004               3416      ORI     #4, D1
00004078  E389                    3417      LSL.L   #1,D1
0000407A  E489                    3418      LSR.L   #2,D1
0000407C  E781                    3419      ASL.L   #3,D1
0000407E  E881                    3420      ASR.L   #4,D1
00004080  EB99                    3421      ROL.L   #5,D1
00004082  E099                    3422      ROR.L   #8,D1
00004084  0881 0002               3423      BCLR    #2,D1
00004088                          3424  
00004088                          3425  SOMELABLE
00004088  DAC1                    3426      ADDA.W  D1,A5
0000408A  4E71                    3427      NOP
0000408C  D803                    3428      ADD.B   D3,D4
0000408E  4E71                    3429      NOP
00004090  6000 0006               3430      BRA     RLLYEND
00004094  65F2                    3431      BCS     SOMELABLE
00004096                          3432  
00004096                          3433  END
00004096  4E75                    3434      RTS
00004098                          3435      
00004098                          3436  RLLYEND
00004098                          3437      END    START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_LONG_OP        1D18
ADDA_PRT            1D54
ADDA_WORD_OP        1CB0
ADD_ADDA_END        1D84
ADD_ADDA_PRINT      1D6C
ADD_ADDA_SPACE      1D46
ADD_EA_DN_GENERIC   1D38
AFORWARDVALID       249C
AINVALID            24DC
ALOOP               246C
ALOOPDONE           2522
ALOOPITER           2514
ALOOPITERCLR        2512
ANOSLASH            24B0
AS                  1DFA
ASCII_0             28BF
ASCII_1             28C1
ASCII_2             28C3
ASCII_3             28C5
ASCII_4             28C7
ASCII_5             28C9
ASCII_6             28CB
ASCII_7             28CD
ASCII_8             28CF
ASCII_9             28D1
ASCII_A             28D3
ASCII_B             28D5
ASCII_C             28D7
ASCII_D             28D9
ASCII_E             28DB
ASCII_F             28DD
ASL                 1E10
ASLOP               2882
ASR                 1E20
ASROP               2886
AVALID              2476
BCC_BYTE_OFFSET     18E2
BCC_END             1938
BCC_LONG_OFFSET     191E
BCC_WORD_OFFSET     1900
BCLROP              2863
BITMASK             27C0
BITMASKDONE         27D0
BYTE_DN_EA          1CD0
BYTE_EA_DN          1C68
CBRACK              28E9
CLEAR_SCREEN        11AE
CMPIOP              2875
CMPOP               2831
COMMA               28E5
CONT_MSG            2804
CR                  D
DASH                28F1
DATA                2896
DFORWARDVALID       23E2
DINVALID            241E
DISPLAY1011         1B48
DIVSOP              282C
DLOOP               23B2
DLOOPDONE           2460
DLOOPITER           2452
DLOOPITERCLR        2450
DNOSLASH            23F6
DOLLAR              28E1
DONE0100            17B8
DONE1001            1AD0
DONE1011            1B80
DVALID              23BC
EAHELPER05          1F74
EAHELPER611         1F32
END                 4096
END0000             133E
END67               22F8
END68               236C
ENDEAHELPER05       20B4
ENDEAHELPER611      1F6E
ENDMODE_AN          2244
ENDMODE_DN          2144
ENDOP0001           13A4
ENDOP0010           1416
ENDOP0011           1488
ENDOP1110           1F1A
END_OF_LOOP         1182
EOROP               2835
HEX_VALUE_MASK_LONG  F
IDLE_STATE          118C
IMD                 28E3
IMD_SIZE_0000       12BE
INVALID_ASCII_INPUT  2708
ITERATION           116A
JSROP               2852
LEAOP               285F
LF                  A
LONG_DN_EA          1D00
LONG_EA_DN          1C98
LOOP                104C
LOOPBIT             27C4
LOOPUNKNOWNOP       1166
LS                  1DC4
LSL                 1DDA
LSLOP               287A
LSR                 1DEA
LSROP               287E
MINUS               28ED
MODE_AN             21BA
MODE_DN             20BA
MOVEAOP             2846
MOVEMHELPERPOST     239C
MOVEMHELPERPRE      2528
MOVEMOP             284C
MOVEMTOMEM          15BE
MOVEMTOREG          1524
MOVEOP              2841
MSGEND              27EE
MSGSTART            27D6
MULSOP              2869
NEGOP               283D
NEWLINE             2829
NOOPERATION         2839
NOT0000             1076
NOT0001             1086
NOT0010             1096
NOT0011             10A6
NOT0100             10B6
NOT0101             10C6
NOT0110             10D6
NOT0111             10E6
NOT1000             10F6
NOT1001             1106
NOT1010             1116
NOT1011             1126
NOT1100             1136
NOT1101             1146
NOT1110             1156
NOT67BYTE           22DC
NOT67WORD           22EC
NOTA0               21DC
NOTA1               21EC
NOTA2               21FC
NOTA3               220C
NOTA4               221C
NOTA5               222C
NOTA6               223C
NOTADRDIRECT        1FA4
NOTADRINDIRECT      1FCC
NOTADRINDIRECTPOST  2000
NOTADRINDIRECTPRE   2034
NOTBCLR             1286
NOTBCLRDYNA         1238
NOTD0               20DC
NOTD1               20EC
NOTD2               20FC
NOTD3               210C
NOTD4               211C
NOTD5               212C
NOTD6               213C
NOTDATAREG          1F94
NOTDIVS             19C2
NOTEOR              1B3C
NOTIMMBYTE          2066
NOTIMMEDIATE        20B0
NOTIMMWORD          2090
NOTJSR              16AE
NOTLONGMOVEM1       158C
NOTLONGMOVEM2       1626
NOTMOVEM            1658
NOTNEG              1500
NOTNOP              14AA
NOTORI              1324
NOTRTS              16D0
OBRACK              28E7
OP0000              11BA
OP0001              1344
OP0001MOVE          1362
OP0001MOVEA         136E
OP0010              13AA
OP0010MOVE          13D4
OP0010MOVEA         13E0
OP0011              141C
OP0011MOVE          1446
OP0011MOVEA         1452
OP0100              148E
OP0101              17BE
OP0110              182C
OP0111              193E
OP1000              1944
OP1000END           1A16
OP1001              1A1C
OP1010              1AD6
OP1011              1ADC
OP1100              1B86
OP1101              1C10
OP1110              1D96
OP1110DATAREG       1EEE
OP1110GENERIC       1E66
OP1110IMMEIGHT      1EC6
OP1111              1F2C
OP_0000             0
OP_0001             1000
OP_0010             2000
OP_0011             3000
OP_0100             4000
OP_0101             5000
OP_0110             6000
OP_0111             7000
OP_1000             8000
OP_1001             9000
OP_1010             A000
OP_1011             B000
OP_1100             C000
OP_1101             D000
OP_1110             E000
OP_1111             F000
OP_ADD_MSG          28BB
OP_BCC              1876
OP_BCC_MSG          289D
OP_BCS              1880
OP_BCS_MSG          28A2
OP_BGE              188A
OP_BGE_MSG          28A7
OP_BLT              1894
OP_BLT_MSG          28AC
OP_BRA              18A8
OP_BRANCHES_PRINT   18B2
OP_BRA_MSG          28B6
OP_BVC              189E
OP_BVC_MSG          28B1
ORIOP               2871
OROP                286E
PLUS                28EB
PRELOOP             2532
PRELOOPDONE         254A
PRELOOPITER         253E
PRESETBIT           253C
PRINT1              27A4
PRINT1001           1A74
PRINT2              2796
PRINT3              2788
PRINT4              277A
PRINT5              276C
PRINT6              275E
PRINT7              2750
PRINT8              27B2
PRINTA0             224A
PRINTA1             2258
PRINTA2             2266
PRINTA3             2274
PRINTA4             2282
PRINTA5             2290
PRINTA6             229E
PRINTA7             22AC
PRINTBYTE           2372
PRINTBYTE68         2354
PRINTD0             214A
PRINTD1             2158
PRINTD2             2166
PRINTD3             2174
PRINTD4             2182
PRINTD5             2190
PRINTD6             219E
PRINTD7             21AC
PRINTDATA911        270E
PRINTLONG           238E
PRINTLONG68         2364
PRINTWORD           2380
PRINTWORD68         235C
PRINT_ASCII_0       2650
PRINT_ASCII_1       265A
PRINT_ASCII_2       2664
PRINT_ASCII_3       266E
PRINT_ASCII_4       2678
PRINT_ASCII_5       2682
PRINT_ASCII_6       268C
PRINT_ASCII_7       2696
PRINT_ASCII_8       26A0
PRINT_ASCII_9       26AA
PRINT_ASCII_A       26B4
PRINT_ASCII_B       26BE
PRINT_ASCII_C       26C8
PRINT_ASCII_CHAR    26F0
PRINT_ASCII_D       26D2
PRINT_ASCII_E       26DC
PRINT_ASCII_F       26E6
PRINT_ASCII_FINISH  2708
PRINT_ASCII_HEX_CHAR  2580
PRINT_ASCII_LOOP    2590
RLLYEND             4098
RO                  1E30
ROL                 1E46
ROLOP               288A
ROR                 1E56
ROROP               288E
RTSOP               2856
SIZE67              22BA
SIZE68              22FE
SKIPLONG            1302
SKIPNOTLONG1        1598
SKIPNOTLONG2        1632
SLASH               28EF
SOMELABLE           4088
SPACE               28DF
START               1000
SUBOP               2892
SUBQOP              285A
SUB_EA_DN           1AB4
TWOWORDLEA          1762
UNKNOWN0000         133A
UNKNOWN0100         17B4
UNKNOWN0101         1826
UNKNOWN1000         1A12
UNKNOWN1001         1ACC
UNKNOWN1011         1B7C
UNKNOWN1100         1C06
UNKNOWNOP           2556
UNKNOWNOP0001       13A0
UNKNOWNOP0010       1412
UNKNOWNOP0011       1484
WORD_DN_EA          1CE8
WORD_EA_DN          1C80
__A0                28FF
__A1                2902
__A2                2905
__A3                2908
__A4                290B
__A5                290E
__A6                2911
__A7                2914
__B                 28F3
__COUNTER           292F
__D0                2917
__D1                291A
__D2                291D
__D3                2920
__D4                2923
__D5                2926
__D6                2929
__D7                292C
__L                 28FB
__W                 28F7
